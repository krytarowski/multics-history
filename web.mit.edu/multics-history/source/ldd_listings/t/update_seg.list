	COMPILATION LISTING OF SEGMENT update_seg
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 08/19/86  2159.5 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 update_seg:  us:	procedure
       11 		options ( rename (( alloc_, smart_alloc_ )) );
       12 
       13 
       14 /*
       15*
       16*	This procedure is the first-generation user interface to the Multics
       17*	Online Updater.  Facilities are provided for batching several segments
       18*	which must be installed together into a single operation, for error
       19*	recovery (consisting of restoring the affected libraries to a consistent
       20*	state), and for deinstallation.  Flexible options are provided for
       21*	setting names and acl's on installed segments.
       22*
       23*	All calls to update_seg are of the form:
       24*
       25*		update_seg function args options
       26*
       27*
       28*	"function" may be: set_defaults (sd), print_defaults (pd), init (in),
       29*	print (pr), add, replace (rp), move (mv), delete (dl), install,
       30*	de_install, clear, and list (ls).  All installation requests
       31*	are placed in a list of updater tasks;  these tasks are then
       32*	compiled into a list of installation operations in which the
       33*	most sensitive operations (adding names to target segments)
       34*	come last in the list, and are processed nearly simultaneously.
       35*	Error recovery during processing may be inhibited if desired.  Actions
       36*	performed may be logged on the console (before or after processing)
       37*	via the "print" function.  
       38*
       39*	P. Bos, June 1972
       40*	G. Dixon, February 1973
       41*	P. Kelley, May 1973
       42*	P. Kelley, March 1980
       43*	  1) Added optional pathname specification to the "-log"
       44*	     control argument with the "initiate" function.
       45*	  2) Added the "-initial_acl" & "-iacl" control arguments for
       46*	     the add, replace, move operations.
       47*	     MIS version number changed to 1.5
       48*	E. N. Kittlitz, March 1981
       49*	  Changed MIS version number to 1.6 for entry_bound support
       50*	  in upd_install_task_ and upd_copy_seg_task_.
       51*            Modified 1984-12-05 BIM to pass signal_io_ conditions.
       52**/
       53 
       54 /****^  HISTORY COMMENTS:
       55*  1) change(86-07-17,GDixon), approve(86-08-18,MCR7494),
       56*     audit(86-08-18,Martinson), install(86-08-19,MR12.0-1129):
       57*     Add -fill and -no_fill control arguments to control filling of the
       58*     -log description.
       59*                                                   END HISTORY COMMENTS */
       60 
       61 /**/
       62 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       63 
       64      dcl	com_err_			entry options (variable),
       65 	command_query_		entry options (variable),
       66 	condition_		entry (char(*), entry),
       67 	condition_interpreter_	entry (ptr, ptr, fixed bin, fixed bin, ptr, char(*), ptr, ptr),
       68 	continue_to_signal_		entry (fixed bin(35)),
       69 	cu_$arg_count		entry (fixed bin),
       70 	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin, fixed bin(35)),
       71 	cu_$cl			entry,
       72 	cu_$level_get		entry returns (fixed bin),
       73 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35)),
       74 	cv_mode_			entry (char(*), bit(36) aligned, fixed bin(35)),  
       75 	cv_userid_		entry (char(*)) returns (char(32)),
       76 	date_time_		entry (fixed bin(71), char(*) aligned),
       77 	date_time_$fstime		entry (fixed bin(35), char(*) aligned),
       78 	equal_			entry (ptr, ptr, ptr, fixed bin(35)),
       79 	expand_path_		entry (ptr, fixed bin, ptr, ptr, fixed bin(35)),
       80 	find_condition_info_	entry (ptr, ptr, fixed bin(35)),
       81 	get_group_id_$tag_star	entry returns (char(32) aligned),
       82 	get_process_id_		entry returns (bit(36) aligned),
       83 	get_wdir_			entry returns (char(168) aligned),
       84 	hcs_$delentry_file		entry (char(*), char(*), fixed bin(35)),
       85 	ioa_$ioa_stream		entry options (variable),
       86 	ios_$attach		entry (char(*), char(*), char(*), char(*), bit(72) aligned),
       87 	ios_$detach		entry (char(*), char(*), char(*), bit(72) aligned),
       88 	msa_manager_$area_handler	entry (ptr, char(*), ptr, ptr, bit(1) aligned),
       89 	msa_manager_$make_special	entry (fixed bin, char(*), char(*), ptr, fixed bin, ptr, fixed bin(35)),
       90 	msa_manager_$initiate	entry (char(*), char(*), ptr, fixed bin, ptr, fixed bin(35)),
       91 	msa_manager_$terminate	entry (ptr, fixed bin(35)),
       92 	msf_manager_$adjust		entry (ptr, fixed bin, fixed bin(24), bit(3), fixed bin(35)),
       93 	msf_manager_$close		entry (ptr),
       94 	msf_manager_$open		entry (char(*), char(*), ptr, fixed bin(35)),
       95 	upd_print_acl_		entry (ptr, fixed bin, bit(*)),
       96 	reversion_		entry (char(*)),
       97 	set_lock_$lock		entry (bit(36) aligned, fixed bin, fixed bin(35)),
       98 	set_lock_$unlock		entry (bit(36) aligned, fixed bin(35)),
       99 	suffixed_name_$find		entry (char(*), char(*), char(*), char(*), fixed bin(2), fixed bin(5),
      100 				fixed bin(35)),
      101 	suffixed_name_$new_suffix	entry (char(*), char(*), char(*), char(*), fixed bin(35)),
      102 	upd_add_task_$init		entry (ptr, ptr),
      103 	upd_add_task_$reset		entry (ptr),
      104 	upd_gen_call_		entry (ptr, ptr),
      105 	upd_print_err_		entry options (variable),
      106 	upd_task_			entry (bit(1), ptr, entry, ptr),
      107 	upd_thread_task_		entry (ptr, ptr);
      108 
      109      dcl	upd_install_task_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
      110 				(3) char(168), (3) char(32), (3) fixed bin(5), (3) ptr, (3) fixed bin, (3) ptr, 
      111 				(3) fixed bin, bit(36) aligned, ptr, fixed bin(18), bit(1), char(168) aligned,
      112 				fixed bin(35), fixed bin(35)),
      113 	upd_install_task_$init	entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
      114 				bit(1), bit(1), ptr, char(32) aligned),
      115 	upd_describe_task_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
      116 				ptr, char (168) aligned, ptr, fixed bin(35) ),
      117 	upd_subtask_		entry (bit(36) aligned, ptr, ptr, fixed bin(35), fixed bin, ptr, fixed bin,
      118 				ptr, ptr);
      119 
      120      dcl (addr, baseno, clock, dim, fixed, index, length, max, mod, null, size, substr)
      121 				builtin;
      122 
      123      dcl (error_table_$bad_conversion,
      124 	error_table_$bad_ring_brackets,
      125 	error_table_$badcall,
      126 	error_table_$badopt,
      127 	error_table_$dirseg,
      128 	error_table_$fatal_error,
      129 	error_table_$improper_data_format,
      130 	error_table_$invalid_lock_reset,
      131 	error_table_$segno_in_use,
      132 	error_table_$locked_by_this_process,
      133 	error_table_$lock_wait_time_exceeded,
      134 	error_table_$moderr,
      135 	error_table_$namedup,
      136 	error_table_$noentry,
      137 	error_table_$not_done,
      138 	error_table_$out_of_bounds,
      139 	error_table_$out_of_sequence,
      140 	error_table_$seg_not_found,
      141 	error_table_$seglock,
      142 	error_table_$too_many_names,
      143 	error_table_$too_many_acl_entries,
      144 	error_table_$wrong_no_of_args)
      145 				fixed bin(35) ext static;
      146 
      147      dcl  (sys_info$default_max_length,
      148 	 sys_info$max_seg_size)	fixed bin ext static;
      149 
      150      dcl	area			area based (Pmsa_ptr);	/* all allocations will be within log segment */
      151 
      152      dcl (argp, fp, p, q, inp, rqp, desp)	 ptr;
      153 
      154      dcl	(logp, msa_ptr)		ptr int static init (null);	/* log segment pointer */
      155 
      156      dcl  Pmsa_ptr			ptr based (msa_ptr);
      157 
      158      dcl	a			fixed bin,	/* used by acl, name options */
      159 	argi			fixed bin,	/* argument index */
      160 	argl			fixed bin,	/* argument length */
      161 	code			fixed bin(35),	/* status code */
      162 	f			fixed bin,	/* updater function called */
      163 	fail			fixed bin,	/* from -severity option */
      164 	fl			fixed bin,	/* length of function arg */
      165          (i, j)			fixed bin,	/* random */
      166 	mode			fixed bin(5),	/* argument to suffixed_name_$find */
      167 	n			fixed bin,	/* used by acl, ringbracket, name options */
      168 	nargs			fixed bin,	/* argument count */
      169 	npath			fixed bin,	/* number of non-control (i.e. pathname) args */
      170 	option			fixed bin,	/* code for control arg being processed */
      171 	r			fixed bin,	/* temp used by ringbracket option */
      172 	state			fixed bin,	/* used in decoding acl option */
      173 	status			bit(72) aligned,	/* an I/O system status code. */
      174 	type			fixed bin(2);	/* argument to suffixed_name_$find */
      175 
      176      dcl	arg			char(argl) based (argp);	/* argument */
      177 
      178      dcl	answer			char(3) aligned,	/* answer to a query */
      179 	date			char(24) aligned,	/* a date-time string */
      180 	dir (3)			char(168),	/* dirname array */
      181 	doc_dir			char(168) aligned,	/* documentation directory */
      182 	docsw			bit(1) init ("0"b),	/* ON if documentation directory being changed */
      183 	dummy			char(1),		/* dummy char string */
      184 	eqseg			char(32),		/* entryname to match = */
      185 	fcbp			ptr,	/* ptr to _file _control _block used by msf_manager_ */
      186 	function			char(fl) based (fp),/* updater function invoked */
      187 	init_log_segment		char(168) aligned,		/* pathname of opt. "init" log segment */
      188 	listdir			char(168),		/* dirname of installation list segment */
      189 	Llistdir			fixed bin,		/* length of non-blank part of listdir */
      190 	listseg			char(32), 		/* entryname of installation list segment */
      191 	logdir			char(168) int static,	/* dirname of current installation log */
      192 	logseg			char(32) int static,/* entryname of log */
      193 	maxl			fixed bin(18) init (0), /* max seg length */
      194 	proc			char(10) aligned int static init ("update_seg"),	/* for com_err_ */
      195 	seg (3)			char(32),		/* entryname array */
      196 	tseg			char(32),		/* temp. entryname */
      197 	Version_No		char(4) aligned int static init ("1.6"), /* MIS Version No. */
      198 	xxx			char(16);		/* part of com_err_ comment */
      199 
      200      dcl	ctlw			bit(36) aligned,	/* control word for task procedures */
      201 	eqsw			bit(1) aligned,	/* non-zero if = may be decoded */
      202 	nofillsw			bit(1) aligned,	/* non-zero for "-no_fill" */
      203 	rstrtsw			bit(1) aligned,	/* non-zero for "-restart" option */
      204 	stopsw			bit(1) aligned,	/* non-zero for "-stop" option */
      205 	sws			bit(36) aligned;	/* option word for segment request */
      206 
      207      dcl  owp ptr;					/* ptr to option switches		*/
      208 						/* meaning of switches depends upon	*/
      209 						/* function being performed, so...	*/
      210      dcl	1 request_option_word	aligned based (owp),/* breakdown of sws by "request" actions */
      211 	 (2 archivesw		bit (1),		/* "-archive" */
      212 	  2 old_namesw		bit (1),		/* "-old_name" */
      213 	  2 spec_segsw		bit (1),		/* "-special_seg" */
      214 	  2 logsw			bit (1),		/* "-log" */
      215 	  2 defersw		bit (1),		/* "-defer" */
      216 	  2 mlsw			bit (1),		/* "-max_length" */
      217 	  2 pad			bit (30)) unal;
      218 
      219      dcl	1 print_option_word		aligned based (owp),/* breakdown of sws by "print"/"list" actions */
      220 	 (2 errorsw		bit (1),		/* "-error" */
      221 	  2 briefsw		bit (1),		/* "-brief" */
      222 	  2 longsw		bit (1),		/* "-long" */
      223 	  2 log_sw		bit (1),		/* "-log" */
      224 	  2 pad			bit (32)) unal;
      225 
      226      dcl	1 clear_option_word		aligned based (owp),/* breakdown of sws by "clear" actions */
      227 	 (2 cerrorsw		bit (1),		/* "-error" */
      228 	  2 uidsw			bit (1),		/* "-uid" */
      229 	  2 pad			bit (34)) unal;
      230 
      231      dcl	1 install_option_word	aligned based (owp),/* breakdown of sws by "install" actions */
      232 	 (2 stopsw		bit (1),		/* "-stop" */
      233 	  2 pad			bit (35)) unal;
      234 
      235      dcl	1 init_option_word		aligned based (owp),/* breakdown of sws by "init" actions */
      236 	 (2 restartsw		bit (1),		/* "-restart" */
      237 	  2 padd			bit (2),
      238 	  2 log_sw		bit (1),		/* "-log" */
      239 	  2 pad			bit (32)) unal;
      240 
      241      dcl (endlabel, errlabel)		label local;	/* used for install/de_install functions */
      242 
      243      dcl	faultlabel		label local init (logerr);
      244 						/* used to recover from seg_fault errors during */
      245 						/* installation object segment initialization. */
      246 
      247      dcl	1 stat			based (addr (status)),/* overlay for I/O status code */
      248 	  2 code			fixed bin(35);	/* a system status code */
      249 
      250 
      251      dcl	1 global_default		aligned int static,	/* per-process default acl, rb's */
      252 	  2 log_directory		char (168) aligned init (""),/* default is "working_dir" */
      253 	  2 rb (3)		fixed bin init (1,5,5), /* default is " 1,5,5 " */
      254 	  2 acl,					/* n.b. not same as "acl" array */
      255 	    3 n			fixed bin init (1),	/* 1 entry to start with */
      256 	    3 a1,					/* default is "re *.*.*" */
      257 	      4 userid		char(32) init ("*.*.*"),
      258 	      4 mode		bit(36) init ("1100"b),
      259 	      4 bits		bit(36) init ("0"b),
      260 	      4 code		fixed bin(35) init (0),
      261 	    3 a2 (29),				/* leave room for 30 entries in default acl */
      262 	      4 userid		char(32),
      263 	      4 mode		bit(36),
      264 	      4 pad		bit(36),
      265 	      4 code		fixed bin(35);
      266 
      267      dcl	1 t			aligned,		/* all acl, rb, name args fill in here */
      268 	  2 log_directory		char (168) aligned, /* -sld */
      269 	  2 rb (3)		fixed bin,	/* -rb */
      270 	  2 acl (3),				/* -acl, -deleteacl, -setacl */
      271 	    3 n			fixed bin,	/* acl count */
      272 	    3 a (30),				/* acl array */
      273 	      4 userid		char(32),		/* user name */
      274 	      4 mode		bit(36),		/* mode (rew) */
      275 	      4 pad		bit(36),		/* padding     */
      276 	      4 code		fixed bin(35),	/* error code   */
      277 	  2 names (3),				/* -names, -deletenames, -addnames */
      278 	    3 n			fixed bin,	/* name count */
      279 	    3 a (30),				/* name array */
      280 	      4 name		char(32),		/* name */
      281 	      4 pcode		fixed bin(35),	/* installation code */
      282 	      4 rcode		fixed bin(35);	/* de_installation code */
      283 
      284      dcl	1 default			aligned based,	/* overlay for "t", "global_default" */
      285 	  2 log_directory		char (168) aligned, /* documentation dir */
      286 	  2 rb (3)		fixed bin,	/* ring brackets */
      287 	  2 acl,					/* default acl */
      288 	    3 n			fixed bin,	/* acl count */
      289 	    3 a (30),				/* acl array */
      290 	      4 userid		char(32),		/* user name */
      291 	      4 mode		bit(36),		/* mode	         */
      292 	      4 pad		bit(36),		/* padding */
      293 	      4 code		fixed bin(35);	/* error code */
      294 
      295      dcl	1 acl (n)			aligned based,	/* single acl array */
      296 	  2 userid		char(32),		/* .. used for allocations */
      297 	  2 mode			bit(36),
      298 	  2 pad			bit(36),
      299 	  2 code			fixed bin(35);
      300 
      301      dcl	1 names (n)		aligned based,	/* single names array */
      302 	  2 name			char(32),		/* .. also for allocations */
      303 	  2 pcode			fixed bin(35),	/* installation status code */
      304 	  2 rcode			fixed bin(35);	/* de_installation status code */
      305 
      306      dcl	1 in			aligned based(inp),	/* args for upd_install_task_$init call */
      307 	  2 temp			ptr init (null),	/* pointer to its internal temps */
      308 	  2 taskp			ptr init (null),	/* its task pointer */
      309 	  2 code			fixed bin(35) init (0), /* status code */
      310 	  2 sev			fixed bin init (0),	/* severity code */
      311 	  2 seqno			fixed bin init (0),	/* sequence no (no special task ordering) */
      312 	  2 io_name		char (32) aligned init (""); /* name of io seg */
      313 
      314      dcl	1 desc			aligned based (desp), /* args for upd_describe_task_ task call */
      315 	  2 taskp			ptr init (null),	/* its task pointer */
      316 	  2 code			fixed bin(35) init (0), /* status code */
      317 	  2 sev			fixed bin init (0),	/* severity code */
      318 	  2 seqno			fixed bin init (1),	/* sequence no. */
      319 	  2 temp			ptr init (null);	/* ptr to temps */
      320 
      321      dcl	1 rq			aligned based(rqp),	/* args for upd_install_task_ call */
      322 	  2 temp			ptr init (null),	/* pointer to his internal temps */
      323 	  2 taskp			ptr init (null),	/* his task pointer */
      324 	  2 ap (3)		ptr init ((3) null),/* acl array pointers */
      325 	  2 np (3)		ptr init ((3) null),/* name array pointers */
      326 	  2 an (3)		fixed bin init ((3) 0),	/* acl counts */
      327 	  2 nn (3)		fixed bin init ((3) 0),	/* name counts */
      328 	  2 code			fixed bin(35) init (0),	/* status code */
      329 	  2 sev			fixed bin init (0),	/* severity code */
      330 	  2 seqno			fixed bin init (0),	/* sequence no. (no ordering) */
      331 	  2 dir (3)		char(168) unal,	/* dirname array */
      332 	  2 seg (3)		char(32) unal,	/* entryname array */
      333 	  2 rb (3)		fixed bin(5),	/* ring brackets for target seg */
      334 	  2 maxlen		fixed bin(18),	/* max length attribute */
      335 	  2 options		bit(36);		/* installation options (-archive, -oldnames, etc.) */
      336 
      337      dcl	1 log			aligned based (logp),	/* installation log */
      338 	  2 version		char(4) aligned,	/* updater version number */
      339 	  2 init_id		bit(36),		/* process id of process which initialized it last */
      340 	  2 selfp			ptr,		/* pointer to self, to remember segment no. */
      341 	  2 areap			ptr,		/* addr (log.area) */
      342 	  2 linkp			ptr,		/* task linkage table root pointer */
      343 	  2 listp			ptr,		/* task list root pointer */
      344 	  2 processp		ptr,		/* copy of listp, modified by upd_subtask_ */
      345 	  2 nullp			ptr,		/* static null pointer */
      346 	  2 lock,					/* items related to locking io seg while its in use */
      347 	    3 word		bit(36) aligned,	/* lock word */
      348 	    3 group_id		char(32) aligned,	/* process group id of user who locked log */
      349 	  2 fcn (4),				/* items related to groups of update_seg functions */
      350 	    3 group_id		char(32) aligned,	/* process group id of last user to perform one */
      351 						/* of the functions in this group on this log. */
      352 	    3 date		fixed bin(35),	/* date on which function was performed. */
      353 	  2 sw			aligned,		/* random switches */
      354 	   (3 full_recovery		bit(1),		/* on if segs can be deleted in de_installation 	*/
      355 	    3 special_segs		bit(1),		/* on if special segs are being installed */
      356 	    3 error		bit(1),		/* on if errors occurred in install/de_install */
      357 	    3 logging_sw		bit(1)) unal,	/* on if any documentation is being performed */
      358 	  2 d,					/* defaults for this installation */
      359 	    3 log_directory		char (168) aligned, /* default documentation dir */
      360 	    3 rb (3)		fixed bin,	/* default ring brackets */
      361 	    3 acl,				/* default access control list for new segments */
      362 	      4 n			fixed bin,	/* number of entries in default acl */
      363 	      4 a (30),				/* out of a maximum of 30 */
      364 	        5 userid		char(32),		/* user name for this entry */
      365 	        5 mode		bit(36),		/* mode */
      366 	        5 bits		bit(36),		/* padding */
      367 	        5 code		fixed bin(35),	/* error code */
      368 	  2 description		ptr,		/* ptr to documentation reason description */
      369 	  2 t,					/* args for task call to upd_subtask_ */
      370 	    3 taskp		ptr,		/* his task pointer */
      371 	    3 temp		ptr,		/* pointer to his internal temps */
      372 	    3 code		fixed bin(35),	/* status code for him */
      373 	    3 sev			fixed bin,	/* severity code */
      374 	    3 seqno		fixed bin,	/* task sequence number (=32767) */
      375 	  2 area			area;		/* rest of segment */
      376 
      377      dcl	function_table (20)		char(16) aligned int static init (
      378 				"set_defaults",	/*  (1) */
      379 				"print_defaults",	/*  (2) */
      380 				"initiate",	/*  (3) */
      381 				"print",		/*  (4) */
      382 				"add",		/*  (5) */
      383 				"replace",	/*  (6) */
      384 				"move",		/*  (7) */
      385 				"delete",		/*  (8) */
      386 				"install",	/*  (9) */
      387 				"de_install",	/* (10) */
      388 				"clear",		/* (11) */
      389 				"list",		/* (12) */
      390 				"sd",		/* (13) (1) */
      391 				"pd",		/* (14) (2) */
      392 				"in",		/* (15) (3) */
      393 				"pr",		/* (16) (4) */
      394 				"rp",		/* (17) (6) */
      395 				"mv",		/* (18) (7) */
      396 				"dl",		/* (19) (8) */
      397 				"ls");		/* (20)(12) */
      398 
      399      dcl	function_index (20)		fixed bin int static init (
      400 				1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12,
      401 				1, 2, 3, 4,    6, 7, 8,            12);
      402 
      403      dcl	option_table (44)		char(16) aligned int static init (
      404 				"-acl",		/* (1) */
      405 				"-delete_acl",	/* (2) */
      406 				"-set_acl",	/* (3) */
      407 				"-ring_brackets",	/* (4) */
      408 				"-name",		/* (5) */
      409 				"-delete_name",	/* (6) */
      410 				"-add_name",	/* (7) */
      411 				"-old_name",	/* (8) */
      412 				"-archive",	/* (9) */
      413 				"-severity",	/* (10) */
      414 				"-restart",	/* (11) */
      415 				"-stop",		/* (12) */
      416 				"-error",		/* (13) */
      417 				"-brief",		/* (14) */
      418 				"-long",		/* (15) */
      419 				"-special_seg",	/* (16) */
      420 				"-log",		/* (17) */
      421 				"-defer",		/* (18) */
      422 				"-uid",		/* (19) */
      423 				"-set_log_dir",	/* (20) */
      424 				"-max_length",	/* (21) */
      425 				"-da",		/* (22) (2) */
      426 				"-sa",		/* (23) (3) */
      427 				"-rb",	 	/* (24) (4) */
      428 				"-nm",		/* (25) (5) */
      429 				"-dn",		/* (26) (6) */
      430 				"-an",		/* (27) (7) */
      431 				"-onm",		/* (28) (8) */
      432 				"-ac",		/* (29) (9) */
      433 				"-sv",		/* (30) (10) */
      434 				"-rt",		/* (31) (11) */
      435 				"-er",		/* (32) (13) */
      436 				"-bf",		/* (33) (14) */
      437 				"-lg",		/* (34) (15) */
      438 				"-ss",		/* (35) (16) */
      439 				"-df",		/* (36) (18) */
      440 				"-sld",		/* (37) (20) */
      441 				"-ml",		/* (38) (21) */
      442 	/* The next 6 control arguments don't follow the above ordering. */
      443 	/* Too many unecessary changes would have been required.         */
      444 				"-initial_acl",	/* (39) (22) */
      445 				"-iacl",		/* (40) (22) */
      446 				"-fill",		/* (41) (23) */
      447 				"-fi",		/* (42) (23) */
      448 				"-no_fill",	/* (43) (24) */
      449 				"-nfi");		/* (44) (24) */
      450 
      451      dcl	option_index (44)		fixed bin int static init (
      452 	1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21,
      453 	   2, 3, 4, 5, 6, 7, 8, 9, 10, 11,     13, 14, 15, 16,     18,     20, 21, 
      454 	22, 22, 23, 23, 24, 24);
      455 
      456      dcl	option_matrix (24, 12)	fixed bin int static init (
      457 				1,  0,  1,  0,  1,  1,  1,  0,  0,  0,	0,  0,  /*  (1) -acl */
      458 				0,  0,  0,  0,  2,  2,  2,  0,  0,  0,	0,  0,  /*  (2) -deleteacl */
      459 				0,  0,  0,  0,  3,  3,  3,  0,  0,  0,	0,  0,  /*  (3) -setacl */
      460 				4,  0,  4,  0,  4,  4,  4,  0,  0,  0,	0,  0,  /*  (4) -ring_brackets */
      461 				0,  0,  0,  0,  5,  5,  5,  0,  0,  0,	0,  0,  /*  (5) -names */
      462 				0,  0,  0,  0,  6,  6,  6,  0,  0,  0,	0,  0,  /*  (6) -deletenames */
      463 				0,  0,  0,  0,  7,  7,  7,  0,  0,  0,	0,  0,  /*  (7) -addnames */
      464 				0,  0,  0,  0,  0,  8,  0,  0,  0,  0,	0,  0,  /*  (8) -oldnames */
      465 				0,  0,  0,  0,  9,  9,  9,  0,  0,  0,	0,  0,  /*  (9) -archive */
      466 				0,  0,  0,  0,  0,  0,  0,  0, 10, 10,	0,  0,  /* (10) -severity */
      467 				0,  0, 11,  0,  0,  0,  0,  0,  0,  0,	0,  0,  /* (11) -restart */
      468 				0,  0,  0,  0,  0,  0,  0,  0, 12, 12,	0,  0,  /* (12) -stop */
      469 				0,  0,  0, 13,  0,  0,  0,  0,  0,  0, 13,  0,  /* (13) -error */
      470 				0,  0,  0, 14,  0,  0,  0,  0,  0,  0,	0, 14,  /* (14) -brief */
      471 				0,  0,  0, 15,  0,  0,  0,  0,  0,  0,	0, 15,  /* (15) -long */
      472 				0,  0,  0,  0, 16, 16, 16, 16,  0,  0,	0,  0,  /* (16) -special_seg */
      473 				0,  0, 17, 17, 17, 17, 17, 17,  0,  0,	0,  0,  /* (17) -log */
      474 				0,  0,  0,  0, 18, 18, 18, 18,  0,  0, 	0,  0,  /* (18) -defer */
      475 				0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 19,  0,  /* (19) -uid */
      476 			         20,  0, 20,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* (20) -set_log_dir */
      477 				0,  0,  0,  0, 21, 21, 21,  0,  0,  0,  0,  0,  /* (21) -max_length */
      478 			          0,  0,  0,  0, 22, 22, 22,  0,  0,  0,  0,  0,  /* (22) -initial_acl */
      479 			          0,  0, 23,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* (23) -fill */
      480 			          0,  0, 24,  0,  0,  0,  0,  0,  0,  0,  0,  0); /* (24) -no_fill */
      481 
      482      dcl	path_matrix (12, 3)		fixed bin int static init (
      483 				0, 0, 0,		/* set_defaults */
      484 				1, 0, 0,		/* print_defaults */
      485 				1, 0, 0,		/* init */
      486 				1, 0, 0,		/* print */
      487 				1, 3, 0,		/* add */
      488 				1, 2, 3,		/* replace */
      489 				2, 3, 0,		/* move */
      490 				2, 0, 0,		/* delete */
      491 				1, 0, 0,		/* install */
      492 				1, 0, 0, 		/* de_install */
      493 				1, 0, 0,		/* clear */
      494 				1, 0, 0);		/* list */
      495 
      496      dcl	pmax (12)			fixed bin int static init (0, 1, 1, 1, 2, 3, 2, 1, 1, 1, 1, 1),
      497 	pmin (12)			fixed bin int static init (0, 0, 0, 0, 2, 2, 2, 1, 0, 0, 0, 0);
      498 
      499      dcl	fail_max			fixed bin(35) int static init (5),
      500 	fail_min			fixed bin(35) int static init (1);
      501 
      502      dcl	1 query_info		aligned int static,	/* command_query_ info structure. */
      503 	  2 version		fixed bin init (2),
      504 	  2 yes_no_sw		bit(1) unal init ("1"b),
      505 	  2 suppress_name		bit(1) unal init ("0"b),
      506 	  2 status		fixed bin(35) init (0),
      507 	  2 code			fixed bin(35) init (0);
      508 
      509      dcl	cleanup			condition;	/* capture this condition */
      510 
      511 /**/
      512 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      513 
      514 	owp = addr(sws);
      515 
      516 	call cu_$arg_count (nargs);			/* get number of arguments */
      517 	if nargs = 0 then do;			/* no arguments, tell user format */
      518 	     call com_err_ (error_table_$wrong_no_of_args, (proc),
      519 		"^/Calling sequence is:^-^a <function> <args> <options>",
      520 		(proc));
      521 	     return;				/* exit to user */
      522 	     end;
      523 	argi = 1;					/* first arg */
      524 	call cu_$arg_ptr (argi, fp, fl, code);		/* get pointer and length */
      525 	if code ^= 0 then				/* unlikely */
      526 	     go to argerr;				/* but check anyway */
      527 	do i = 1 to dim (function_table, 1);		/* first arg is updater function */
      528 	     if function = function_table(i) then do;	/* search table for a match */
      529 		f = function_index(i);		/* found; get function code; */
      530 		on cleanup begin;			/* set up handler to unlock log and detach streams */
      531 		     call ios_$detach ( "installation_list_", "", "", status);
      532 		     call ios_$detach ( "installation_error_", "", "", status);
      533 		     call unlock_log;
      534 		     end;
      535 		go to init(f);			/* and go process call */
      536 		end;
      537 	     end;
      538 	call com_err_(error_table_$badcall, (proc), "Unknown updater function specified. ""^a""", function);
      539 	return;					/* return to user */
      540 
      541 
      542 init(1):     					/* "set_defaults" function */
      543 join0:	p = addr (t);				/* will be used to overlay "default" */
      544 	q = addr (global_default);			/* copy current defaults for this process */
      545 	p -> default = q -> default;			/* .. so arg processor can update them */
      546 	go to join1;				/* go look at args */
      547 
      548 
      549 init(2):	npath = 0;				/* "print_defaults" function, allow log pathname */
      550 	go to join1;				/* go get args */
      551 
      552 
      553 init(3):	npath = 0;				/* "initiate" function, we expect a pathname */
      554 	rstrtsw = "0"b;				/* reset "-restart" switch */
      555 	sws = "0"b;				/* reset switches */
      556 	nofillsw = "0"b;				/* -log -fill is the default.			*/
      557 	go to join0;				/* go get global defaults */
      558 
      559 init(11):	endlabel = return;				/* "clear" function; return to user after processing */
      560 init(4):						/* "print" function */
      561 init(12):	sws = "0"b;				/* "list" function; reset option switches */
      562 	npath = 0;				/* assume no log pathname supplied */
      563 	go to join1;				/* skip to argument processor */
      564 
      565 
      566 init(5):						/* "add" function */
      567 init(6):						/* "replace" function */
      568 init(7):						/* "move" function */
      569 init(8):	npath = 0;				/* "delete" function */
      570 	fail = 1;					/* make any error a fatal error. */
      571 	call init_log ("1"b);			/* make sure there is an installation object segment. */
      572 	do i = 1 to 3;				/* three of everything, by sheer coincidence */
      573 	     dir(i), seg(i) = "";			/* blank out all pathname args */
      574 	     t.acl(i).n, t.names(i).n = 0;		/* no names or acls yet */
      575 	     end;
      576 	p = addr (t);				/* first part overlaid by "default" */
      577 	q = addr (log.d);				/* will use installation defaults */
      578 	p -> default = q -> default;			/* copies default ringbrackets and acl */
      579 	if f ^= 5 then				/* want acl only for add function */
      580 	     t.acl(1).n = 0;			/* zero acl count for any other */
      581 	if (f = 6) | (f = 7) then do i = 1 to 3;	/* if "replace" or "move", then we'll  */
      582 	     t.rb(i) = 0;				/* determine default rings via upd_ring_task_$list   */
      583 	     end;					/* for the "old" segment, unless "-rb" option appears later */
      584 	npath = 0;				/* no pathnames yet */
      585 	sws = "0"b;				/* no options either */
      586 	maxl = sys_info$default_max_length;		/* default  */
      587 	go to join1;				/* skip to arg processor */
      588 
      589 
      590 init(9):	stopsw = "0"b;				/* "install" function; reset "-stop" switch */
      591 init(10):	npath = 0;				/* "de_install" function. */
      592 	fail = 1;					/* any error is fatal, by default. */
      593 
      594 
      595 join1:	option = 0;				/* here to process argument list; zero option code */
      596 	eqsw = "0"b;				/* first pathname can't have "=" */
      597 nxtarg:	argi = argi + 1;				/* increment arg counter */
      598 	if argi > nargs then			/* that's all there are */
      599 	     go to aend(option);			/* go finish up current option if any */
      600 	call cu_$arg_ptr (argi, argp, argl, code);	/* get pointer, length for this arg */
      601 	if code ^= 0 then do;			/* unlikely error */
      602 	     argp = addr (dummy);			/* avoid null pointer reference */
      603 	     argl = 0;				/* didn't get nothin' */
      604 argerr:	     call com_err_(code, (proc), """^a"" (arg ^d)", arg, argi);	/* complain to user */
      605 	     go to return;				/* and let him figure it out */
      606 	     end;
      607 	if substr (arg, 1, 1) = "-" then		/* argument is option specifier */
      608 	     go to aend(option);			/* go finish up last option */
      609 	else					/* not a control arg, */
      610 	     go to aarg(option);			/* go process normal arg */
      611 
      612 ckopt:	if argi > nargs then			/* reenter here after aend(i), check arg count again */
      613 	     go to start(f);			/* exit from arg processor if done */
      614 	do i = 1 to dim (option_table, 1);		/* search option table for this control arg */
      615 	     if arg = option_table(i) then do;		/* found it */
      616 		option = option_matrix(option_index(i), f);/* very table-driven program */
      617 		if option = 0 then			/* option not permitted for this function */
      618 		     go to badopt;			/* pretend we never heard of it */
      619 		go to abgn(option);			/* ok option, go process */
      620 		end;
      621 	     end;
      622 badopt:	call com_err_(error_table_$badopt, (proc), "^a", arg);/* unknown updater option */
      623 	go to return;				/* go unlock log segment, if its locked */
      624 
      625 logerr:	call com_err_(error_table_$out_of_sequence, (proc), "^/^a.^/^a^a ^a.", 
      626 	     "No installation object (io) segment is active", "Type:  """,
      627 	     (proc), "initiate <io_path_name>""  to initiate an io segment");
      628 						/* error return after log initiation failure */
      629 return:	call unlock_log;				/* standard return point from update_seg; unlock log */
      630 return_without_unlocking:
      631 	return;
      632 /**/
      633 
      634 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      635 
      636 
      637 aarg(0):	npath = npath + 1;				/* here for pathname argument */
      638 	if npath > pmax(f) then			/* is that too many? */
      639 	     go to path_err;			/* then tell user. */
      640 	if arg ^= "" then do;			/* leave hooks for funny functions */
      641 	     j = path_matrix (f, npath);		/* find out where to put it */
      642 	     dir(j), seg(j) = "";			/* clear the place, cause expand_path_ doesn't */
      643 	     call expand_path_(argp, argl, addr (dir(j)), addr (seg(j)), code);
      644 	     if code ^= 0 then			/* bad pathname syntax */
      645 		go to argerr;			/* go tell user */
      646 	     i = index (seg(j), "=");			/* see if entryname includes "=" components */
      647 	     if i ^= 0 then if eqsw then do;		/* ahaa! */
      648 		tseg = seg(j);			/* copy entryname (equal_ blows it otherwise) */
      649 		call equal_(addr (eqseg), addr (tseg), addr (seg(j)), code);
      650 		if code ^= 0 then			/* bad "=" syntax */
      651 		     go to argerr;			/* go complain */
      652 		end;
      653 	     eqseg = seg(j);			/* following args may use "=" option, if not already */
      654 	     eqsw = "1"b;				/* cheaper to test than eqseg ^= "" */
      655 	     end;
      656 	go to nxtarg;				/* go process next argument */
      657 
      658 aend(0):	go to ckopt;				/* no deferrred processing, go check new arg */
      659 
      660 
      661 abgn(1):						/* "-acl" option */
      662 abgn(2):						/* "-deleteacl" option */
      663 abgn(3):	a = option;				/* "-setacl" option; get index for which acl (1, 2, 3) */
      664 	state = 0;				/* first arg to option is mode */
      665 	n = 0;					/* nothing yet */
      666 	go to nxtarg;				/* and jump back in again */
      667 
      668 aarg(1):						/* "-acl" option arg */
      669 aarg(2):						/* "-deleteacl" option arg */
      670 aarg(3):	if state = 0 then do;			/* "-setacl" option arg */
      671 	     n = n + 1;				/* starts a new acl entry */
      672 	     if n > dim (t.acl.a, 2) then do;		/* limit number of ACLe's to max we can store */
      673 		call com_err_(error_table_$too_many_acl_entries, (proc),
      674 		     "^/Only  ^d  acl entries may be specified after the  ^a  control argument.",
      675 		     dim (t.acl.a, 2), (option_table(option)));
      676 		go to return;			/* unlock log, if necessary, and return to user */
      677 		end;
      678 	     t.acl(a).a(n).code = 0;			/* reset status code */
      679 	     if a = 2 then do;			/* is this "-deleteacl"? */
      680 		t.acl(a).a(n).mode = "0"b;		/* yes, no mode arg */
      681 		go to aarg2a;			/* arg is userid each time */
      682 		end;
      683 	     call cv_mode_(arg, t.acl(a).a(n).mode, code);/* go convert mode to binary */
      684 	     if code ^= 0 then			/* bad mode specification */
      685 		go to argerr;			/* go complain */
      686 	     t.acl(a).a(n).userid = "*.*.*";		/* assume *.*.* in case no userid specified */
      687 	     state = 1;				/* next arg should be userid */
      688 	     end;
      689 	else do;					/* arg is userid */
      690 aarg2a:	     t.acl(a).a(n).userid = cv_userid_(arg);	/* get userid in standard format */
      691 	     state = 0;				/* next arg will be mode again */
      692 	     end;
      693 	go to nxtarg;				/* go get next argument */
      694 
      695 aend(1):						/* "-acl" option terminated */
      696 aend(2):						/* "-deleteacl" option terminated */
      697 aend(3):	t.acl(a).n = n;				/* "-setacl" option terminated; record acl size */
      698 	go to ckopt;				/* and go check new option */
      699 
      700 
      701 abgn(4):	n = 0;					/* "-ring_brackets", tell the rest */
      702 	go to nxtarg;				/* go get next argument */
      703 
      704 aarg(4):	n = n + 1;				/* should be a ring bracket */
      705 	r = cv_dec_check_(arg, code);			/* go convert to binary */
      706 	if code ^= 0 then do;			/* conversion error */
      707 	     code = error_table_$bad_conversion;
      708 	     go to argerr;				/* gripe bitch complain */
      709 	     end;
      710 	if r <= 0 then				/* we don't allow ring brackets of 0 or less */
      711 	     go to rberr;				/* save hardcore the trouble */
      712 	if r > 7 then				/* and nobody allows ringbrackets bigger than 7 */
      713 	     go to rberr;				/* gripe */
      714 	if n ^= 1 then if r < t.rb(n-1) then do;	/* better not be smaller than last one */
      715 rberr:	     code = error_table_$bad_ring_brackets;	/* set error code */
      716 	     go to argerr;				/* and go tell user what he can do with them */
      717 	     end;
      718 	t.rb(n) = r;				/* record ring bracket */
      719 	if n = 3 then 				/* -rb option is self-terminating */
      720 	     option = 0;				/* pathname may follow */
      721 	go to nxtarg;				/* go get next argument */
      722 
      723 aend(4):	if n = 0					/* "-ring_bracket" option terminated */
      724 	     then do;				/* bit he didn't give us any rings! */
      725 		n = 1;				/* start him off at ring 1 */
      726 		t.rb(n) = max((cu_$level_get()), 5);	/* default him to highest he can handle */
      727 		end;
      728 	if n < 3					/* finish up the three rings */
      729 	     then do i = n+1 to 3;
      730 		t.rb(i) = max((cu_$level_get()), t.rb(i-1), 5);/* default him to highest */
      731 		end;
      732 	option = 0;				/* finished with the rings */
      733 	go to ckopt;				/* go check next option */
      734 
      735 
      736 abgn(5):						/* "-names" option */
      737 abgn(6):						/* "-deletenames" option */
      738 abgn(7):	a = option - 4;				/* "-addnames" option; get array index (1, 2, 3) */
      739 	n = 0;					/* nobody home yet */
      740 	go to nxtarg;				/* go get next arg */
      741 
      742 aarg(5):						/* "-names" option arg */
      743 aarg(6):						/* "-deletenames" option arg */
      744 aarg(7):	n = n + 1;				/* "-addnames" option arg; increment count */
      745 	if n > dim (t.names.a, 2) then do;		/* limit number of names to max we can store */
      746 	     call com_err_(error_table_$too_many_names, (proc),
      747 		"^/Only  ^d  names may be specified after the  ^a  control argument.",
      748 		dim (t.names.a, 2), (option_table (option)));
      749 	     go to return;				/* unlock log and return to user */
      750 	     end;
      751 	t.names(a).a(n).name = arg;			/* put name in array */
      752 	t.names(a).a(n).pcode = error_table_$not_done;	/* initialize install code */
      753 	t.names(a).a(n).rcode = 0;			/* and de_install code */
      754 	go to nxtarg;				/* go process next argument */
      755 
      756 aend(5):						/* "-names" option terminated */
      757 aend(6):						/* "-deletenames" option terminated */
      758 aend(7):	t.names(a).n = n;				/* "-addnames" option terminated; record array size */
      759 	go to ckopt;				/* and go check up on new option */
      760 
      761 
      762 abgn(8):	old_namesw = "1"b;				/* "-oldnames" */
      763 	go to endopt;				/* skip */
      764 
      765 
      766 abgn(9):	archivesw = "1"b;				/* "-archive" */
      767 	go to endopt;
      768 
      769 
      770 abgn(10):	go to nxtarg;				/* "-severity"; no initialization necessary */
      771 
      772 aarg(10):	fail = cv_dec_check_ (arg, code);		/* convert severity to a number */
      773 	if code ^= 0 then do;			/* conversion failed? Tell user. */
      774 	     call com_err_(error_table_$bad_conversion, (proc), "Argument  ^a  ^a.",
      775 		arg, "could not be converted to a severity number");
      776 	     go to return;				/* unlock log and return to user */
      777 	     end;
      778 	go to nxtarg;
      779 
      780 aend(10):	if (fail < fail_min) | (fail > fail_max) then do;	/* Severity outside allowable bounds. */
      781 	     call com_err_(error_table_$out_of_bounds, (proc), "^d^/^a  ^d  to  ^d.", fail,
      782 		"Failure severity must be a number from", (fail_min), (fail_max));
      783 	     return;
      784 	     end;
      785 	go to ckopt;
      786 
      787 
      788 abgn(11):	rstrtsw = "1"b;				/* "-restart" */
      789 	substr (sws, 1, 1) = "1"b;
      790 	go to endopt;
      791 
      792 
      793 abgn(12):	stopsw = "1"b;				/* "-stop" */
      794 	go to endopt;
      795 
      796 
      797 abgn(13):	substr (sws, 1, 1) = "1"b;			/* "-error" */
      798 	go to endopt;
      799 
      800 
      801 abgn(14):	briefsw = "1"b;				/* "-brief" */
      802 	go to endopt;
      803 
      804 
      805 abgn(15):	longsw = "1"b;				/* "-long" */
      806 	go to endopt;
      807 
      808 
      809 abgn(16):	spec_segsw = "1"b;				/* "-special_seg" */
      810 	go to endopt;
      811 
      812 
      813 abgn(17):	substr (sws, 4, 1) = "1"b;			/* "-log" */
      814 	if f = 3					/* if "initiate" function, then possible pathname follows*/
      815 	     then go to nxtarg;			/* optional pathname argument may follow */
      816 	     else go to endopt;			/* else no pathname is allowed */
      817 
      818 						/* opt. pathname of "initiate" function*/
      819 aarg(17):	init_log_segment = "";			/* set 1st to null */
      820 	call expand_path_ ( argp, argl, addr(init_log_segment), null, code);
      821 	if code ^= 0
      822 	     then go to argerr;
      823 	go to endopt;				/* terminate this option */
      824 
      825 aend(17):	init_log_segment = "";			/* no pathname was supplied */
      826 	go to ckopt;				/* find out what arg really is */
      827 	     
      828 abgn(18):	defersw = "1"b;				/* "-defer" */
      829 	go to endopt;
      830 
      831 
      832 abgn(19):	uidsw = "1"b;				/* "-uid" */
      833 	go to endopt;
      834 
      835 
      836 abgn(20):	goto nxtarg;				/* "-set_log_dir" option */
      837 						/* go pick up pathname of documentation dir. */
      838 
      839 aarg(20): doc_dir = "";				/* get ready to test expected path */
      840 	if arg ^= "" then
      841 	     call expand_path_(argp, argl, addr(doc_dir), null, code);
      842 	if code ^= 0
      843 	     then goto argerr;			/* bad pathname syntax */
      844 	t.log_directory = doc_dir;			/* update our temporary */
      845 	docsw = "1"b;
      846 	goto endopt;
      847 
      848 
      849 aend(20):	code = error_table_$wrong_no_of_args;		/* means we didn't get expected arg */
      850 	goto argerr;
      851 
      852 
      853 abgn(21):	mlsw = "1"b;				/* "-max_length" */
      854 	go to nxtarg;
      855 
      856 
      857 aarg(21):	maxl = cv_dec_check_ (arg, code);		/* check for numeric arg */
      858 	if code ^= 0 then do;
      859 	     call com_err_ (error_table_$bad_conversion, (proc), "Argument  ^a  ^a.",
      860 		arg,  "could not be converted to a proper length" );
      861 	     go to return;
      862 	     end;
      863 	go to endopt;				/* self terminating */
      864 
      865 
      866 aend(21):	maxl = sys_info$max_seg_size;			/* default to highest */
      867 	go to ckopt;				/* check new option */
      868 
      869 
      870 abgn(22):	substr(sws, 7, 1) = "1"b;			/* "-initial_acl" */
      871 	if f = 5					/* if "add" function then */
      872 	     then t.acl(1).n = 0;			/* reset default acl */
      873 	go to endopt;				/* self-terminating option */
      874 
      875 
      876 abgn(23): nofillsw = "0"b;				/* "-fill" */
      877 	go to endopt;
      878 	
      879 
      880 abgn(24): nofillsw = "1"b;				/* "-no_fill" */
      881 	go to endopt;
      882 
      883 
      884 endopt:	option = 0;				/* self-terminating options */
      885 	go to nxtarg;				/* go get next argument if any */
      886 
      887 /**/
      888 
      889 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      890 
      891 
      892 start(1):	p = addr (global_default);			/* "set_defaults" function */
      893 	q = addr (t);				/* copy updated defaults back to static storage */
      894 	p -> default = q -> default;			/* quick copy */
      895 	return;					/* done */
      896 
      897 
      898 						/* "print_defaults" function */
      899 start(2):	call ios_$attach ("installation_list_", "syn", "user_output", "w", status);
      900 	faultlabel = start2a;			/* recover from a segment fault error in case */
      901 						/* someone deleted the "current" installation */
      902 						/* object segment from under our noses. */
      903 	call init_log ((npath > 0));			/* validate current log pointer, unless user specified */
      904 						/* his own object seg as an option. */
      905 	if logp = null then				/* if no log is "current", then */
      906 	     go to start2a;				/* we can't very well print its defaults. */
      907 	p = addr (log.d);				/* otherwise, print its path name and defaults */
      908 	call ioa_$ioa_stream ("installation_list_",
      909 	     "^/Defaults for  ^a>^a^/^5xring brackets:^/^-^d,^d,^d^/^5xACL:",
      910 	     logdir, logseg, p->default.rb(1), p->default.rb(2), p->default.rb(3));
      911 	call upd_print_acl_ (addr (p->default.acl.a), p->default.acl.n, "100"b);
      912 	if p->default.log_directory ^= ""		/* if default log dir was set */
      913 	     then call ioa_$ioa_stream ("installation_list_", /* then tell the user */
      914 		"^5xdocumentation directory:^/^-^a", p->default.log_directory);
      915 start2a:	p = addr (global_default);			/* print the global defaults, at the very least */
      916 	call ioa_$ioa_stream ("installation_list_",
      917 	     "^/Global defaults^/^5xring brackets:^/^-^d,^d,^d^/^5xACL:",
      918 	     p->default.rb(1), p->default.rb(2), p->default.rb(3));
      919 	call upd_print_acl_ (addr (p->default.acl.a), p->default.acl.n, "100"b);
      920 	if p->default.log_directory ^= ""		/* if global default log dir was set */
      921 	     then call ioa_$ioa_stream ("installation_list_", /* then tell the user */
      922 		"^5xdocumentation directory:^/^-^a", p->default.log_directory);
      923 	call ioa_$ioa_stream ("installation_list_", "");	/* space up paper */
      924 	go to clean_up;				/* detach streams, and quit. */
      925 
      926 
      927 start(3):	call init_log (rstrtsw);			/* "init" function, see about log */
      928 	p = addr (log.d);				/* copy acl, rb defaults into log segment */
      929 	q = addr (t);				/* consist of global defaults updated by args */
      930 	p -> default = q -> default;			/* quick copy */
      931 	log.fcn(1).date = fs_date();			/* record date that log was changed. */
      932 	log.fcn(1).group_id = log.lock.group_id;	/* record installer's name in create-log slot */
      933 	if docsw then				/* we're going to change the documentation dir */
      934 	     if log.processp ^= null then		/* if we've already "installed" then */
      935 						/* we can't change it.		*/
      936 		call com_err_ (error_table_$out_of_sequence, (proc), "^/^a ^a>^a^/^a.^/^a.",
      937 		     "Installation object (io) segment", logdir, logseg, "has previously been installed",
      938 		     "The documentation directory has not be changed");
      939 	if logsw then do;				/* there's a description coming... */
      940 	     if log.processp ^= null then 		/* if desc. task already allocated, then can't change it */
      941 		call com_err_ (error_table_$out_of_sequence, (proc), "^/^a ^a>^a^/^a.^/^a^/^a",
      942 		     "Installation object (io) segment", logdir, logseg, "has previously been installed",
      943 		     "The installation description cannot be changed.",
      944 		     "As a result, the ""-log"" argument has been ignored.");
      945 	     else 
      946 		call get_reason(Pmsa_ptr, nofillsw, log.description);
      947 						/* pick up the typed lines */
      948 						/* we'll allocate the task at "install" time */
      949 	     end;
      950 	go to return;				/* unlock log and return to installer */
      951 
      952 
      953 start(4):	call init_log ("1"b);			/* "print" function, see about log */
      954 	call ios_$attach ("installation_list_", "syn", "user_output", "w", status);
      955 	call ios_$attach ("installation_error_", "syn", "error_output", "w", status);
      956 						/* attach the installation output streams 	*/
      957 	if logsw then do;				/* print the documentation description only */
      958 	     if log.description ^= null then		/* looks like something's there */
      959 						/* pass only minimum args */
      960 		call upd_describe_task_ ( "000001"b, log.nullp, log.nullp, 0, 0, log.nullp, 0,
      961 		     log.nullp, log.d.log_directory, log.description, log.fcn(3).date);
      962 	     goto skip_print;			/* skip other print functions */
      963 	     end;
      964 	ctlw = substr("000001"b || sws,1, length(ctlw));	/* form print control word */
      965 	call condition_("task_linkage_err_", linkage_err);/* set up handler for linkage errors */
      966 	call upd_task_("0"b, (log.listp), upd_gen_call_, addr (ctlw));
      967 						/* go process task list */
      968 skip_print:
      969 	call ioa_$ioa_stream ("installation_list_", "");	/* insert a blank line after the output. */
      970 	go to clean_up;
      971 
      972 
      973 start(5):						/* "add" function */
      974 start(6):						/* "replace" function */
      975 start(7):						/* "move" function */
      976 start(8):	if log.processp ^= null then do;		/* "delete" function; make sure installation */
      977 						/* requests can still be added to log */
      978 	     call com_err_ (error_table_$out_of_sequence, (proc), "^/^a ^a>^a^/^a.^/^a.",
      979 		"Installation object (io) segment", logdir, logseg, "has previously been installed",
      980 		"No more installation requests may be added to the segment");
      981 	     go to return;				/* unlock log and return to installer */
      982 	     end;
      983 	if npath < pmin(f) then do;			/* check minimum pathname count */
      984 path_err:	     if pmin(f) = pmax(f) then		/* specialize form of error msg. */
      985 		eqseg = "^/^a^/^a  ""^a""  ^a:  ^d.";	/* min # of paths = max # */
      986 	     else
      987 		eqseg = "^/^a^/^a  ""^a""  ^a:  ^d  or  ^d.";	/* min # of paths < max # paths */
      988 	     call com_err_(error_table_$wrong_no_of_args, (proc), eqseg,
      989 		"The number of path names which must be specified",
      990 		"with the", (function_table(f)), "function is", (pmin(f)), (pmax(f)));
      991 	     go to return;				/* unlock log and return to installer */
      992 	     end;
      993 	if f = 6 then if npath = 2 then do;		/* third arg is optional for replace */
      994 	     dir(3) = dir(2);			/* if omitted, third path becomes directory part	*/
      995 	     seg(3) = seg(1);			/* of second path, and entryname part of first	*/
      996 	         					/* path, meaning put new seg in old directory.	*/
      997 	     end;
      998 	if ( f = 5 | f = 6) then if npath = 2 then	/* if we're adding/replacing and only 2 paths given,	*/
      999 	     if t.names(1).n ^= 0 then		/* and  "-name" option was issued,		*/
     1000 		seg(3) = t.names(1).a(1).name;	/* then entryname part of third path becomes	*/
     1001 						/* first name in "-name" array"		*/
     1002 	call condition_ ("area", msa_manager_$area_handler );
     1003 						/* set up handler for "area" condition	*/
     1004 	allocate rq in (area);			/* get some space to put things for this call */
     1005 	do i = 1 to 3;				/* three of everything (coincidence?) */
     1006 	     rq.dir(i) = dir(i);			/* dirname */
     1007 	     rq.seg(i) = seg(i);			/* entryname */
     1008 	     rq.rb(i) = t.rb(i);			/* ring brackets */
     1009 	     n = t.acl(i).n;			/* get count for this acl entry */
     1010 	     if n ^= 0 then do;			/* anything there? */
     1011 		allocate acl in (area) set (p);	/* yes, make us an acl */
     1012 		q = addr (t.acl(i).a(1));		/* get pointer to temporary one */
     1013 		p -> acl = q -> acl;		/* copy acl into log segment */
     1014 		rq.ap(i) = p;			/* set pointer and length in request block */
     1015 		rq.an(i) = n;			/* for call to upd_install_task_ */
     1016 		end;
     1017 	     n = t.names(i).n;			/* get count for name array entry */
     1018 	     if n ^= 0 then do;			/* same as for acl */
     1019 		allocate names in (area) set (p);	/* we got one, allocate space in log */
     1020 		q = addr (t.names(i).a(1));		/* get pointer to names array */
     1021 		p -> names = q -> names;		/* copy names */
     1022 		rq.np(i) = p;			/* set pointer */
     1023 		rq.nn(i) = n;			/* and size */
     1024 		end;
     1025 	     end;
     1026 	rq.options = sws;				/* copy option switches */
     1027 	rq.maxlen = maxl;				/* max length */
     1028 	ctlw = "01"b;				/* allocating task only, no processing */
     1029 	errlabel = command_ignored;			/* no error recovery either */
     1030 	call ios_$attach ("installation_error_", "syn", "error_output", "w", status);
     1031 						/* attach error stream in case one occurs.	*/
     1032 	call condition_("task_error_", task_error);	/* set up condition handler for task errors */
     1033 	call condition_("task_linkage_err_", linkage_err);/* .. for linkage errors */
     1034 	call condition_("thread_task_", thread_task);	/* .. for task threading */
     1035 	call upd_add_task_$init (Pmsa_ptr, log.linkp);	/* tell tasker where area and link list are */
     1036 	call upd_install_task_(ctlw, Pmsa_ptr, log.nullp, rq.code, rq.sev, rq.taskp, rq.seqno,
     1037 	     rq.dir, rq.seg, rq.rb, rq.ap, rq.an, rq.np, rq.nn, rq.options, rq.temp, rq.maxlen,
     1038 	     log.sw.full_recovery, log.d.log_directory, log.fcn(3).date, log.fcn(4).date);
     1039 	log.sw.special_segs = log.sw.special_segs | substr (sws, 3, 1); /* if we're installing a special segment */
     1040 	log.sw.logging_sw = log.sw.logging_sw | substr (sws, 4, 1);    /* if there's documenting... */
     1041 	log.fcn(1).date = fs_date();			/* record date that log was changed. */
     1042 	log.fcn(1).group_id = log.lock.group_id;	/* record who changed the log last */
     1043 	go to cleanerr;				/* do some cleanup work, then quit */
     1044 command_ignored:
     1045 	call com_err_ (error_table_$fatal_error, (proc),
     1046 	     "^/As a result, the  ""^a ^a""  command has been ignored.",
     1047 	     (proc), (function_table(f)));
     1048 	log.sw.error = "0"b;			/* ignore this error in any listing. */
     1049 	go to cleanerr;				/* see, we had an error. Detach error stream. */
     1050 
     1051 
     1052 start(9):	call init_log ("1"b);			/* "install" function; make sure log exists 	*/
     1053 	if log.listp = null then do;			/* no listp -> no tasks in list		*/
     1054 nolistp:	     call com_err_(error_table_$out_of_sequence, (proc), "^/Installation log is empty.  ^a>^a.",
     1055 		logdir, logseg );			/* let user figure this one out !		*/
     1056 	     goto return;				/* and exit stage do_nothing			*/
     1057 	     end;
     1058 	if log.processp = log.listp then		/* if log was installed before, but completely	*/
     1059 	     if log.sw.error then do;			/* de_installed, and if errors occurred during	*/
     1060 	 	endlabel = start9a;			/* installation, then clear these errors by	*/
     1061 		ctlw = "00000000010"b;		/* calling "update_seg clear -error" function as	*/
     1062 		go to start11a;			/* internal subroutine.			*/
     1063 		end;
     1064 start9a:	endlabel = full_recovery_off;			/* if installation completes successfully, then	*/
     1065 						/* installation can never be fully-de_installed	*/
     1066 	ctlw = "00101"b;				/* set up a "compile" and "task_run" control word	*/
     1067 	xxx = "Installation";			/* set up directional variable for com_err_ msg	*/
     1068 	log.fcn(3).date = fs_date();			/* set date and time of installation. 		*/
     1069 	log.fcn(3).group_id = log.lock.group_id;	/* record who installed the log.		*/
     1070 	log.fcn(4).date = 0;			/* clear date for possible future de_installation.*/
     1071 	go to start9b;				/* skip initialization for "de_install" function	*/
     1072 
     1073 start(10):call init_log ("1"b);			/* "de_install" function; make sure log exists	*/
     1074 	if log.listp = null 			/* and make sure listp -> a list of tasks	*/
     1075 	     then goto nolistp;			/* no listp -> no task list			*/
     1076 	if log.fcn(3).date = 0 then do;		/* zero install date means we can't "de_install"	*/
     1077 	     call com_err_(error_table_$out_of_sequence, (proc),
     1078 		"^/Installation Object segment ^a>^a has NOT been ""installed"".",
     1079 		logdir, logseg );			/* tell user the good news			*/
     1080 	     goto return;				/* and exit				*/
     1081 	     end;
     1082 	endlabel = clean_up;			/* cleanup when done.			*/
     1083 	ctlw = "10101"b;				/* set "reverse", "compile", & "task_run" control	*/
     1084 	xxx = "De-installation";			/* set reverse direction in var for com_err_ msg	*/
     1085 	log.fcn(4).date = fs_date();			/* set date and time of de_installation.	*/
     1086 	log.fcn(4).group_id = log.lock.group_id;	/* record who de_installed the log.		*/
     1087 
     1088 start9b:	if stopsw then				/* user doesn't want error recovery */
     1089 	     errlabel = abort;			/* customer always knows best */
     1090 	else					/* he didn't say, */
     1091 	     errlabel = recover;			/* so do it for him */
     1092 	call ios_$attach ("installation_list_", "syn", "user_output", "w", status);
     1093 	call ios_$attach ("installation_error_", "syn", "error_output", "w", status);
     1094 						/* Here We GO!  Attach installation streams first */
     1095 	call condition_("task_error_", task_error);	/* set up condition handlers */
     1096 	call condition_("task_linkage_err_", linkage_err);/* for all kinds of errors */
     1097 	call condition_("thread_task_", thread_task);	/* set up handler for task threading */
     1098 	call condition_ ("area", msa_manager_$area_handler);
     1099 						/* handler for "area" condition.	*/
     1100           call condition_ ( "any_other", default_handler );	/* handle all conditions and treat them as */
     1101 						/* fatal errors unless they're very special. */
     1102 	call upd_add_task_$init (Pmsa_ptr, log.linkp);	/* initialize task allocator */
     1103 	if log.processp = null then do;		/* is this the very first time we've "process"ed log? */
     1104 	     allocate in in (area);			/* get some space to put things in for initialize call */
     1105 	     in.io_name = logseg;			/* copy name of current io seg */
     1106 	     call upd_install_task_$init ("01"b, Pmsa_ptr, log.nullp, in.code, in.sev, in.taskp, in.seqno,
     1107 		log.sw.special_segs, log.sw.full_recovery, in.temp, in.io_name);
     1108 						/* add installer message routine to task list. */
     1109 	     log.processp = log.listp;		/* copy task list root pointer */
     1110 	     if log.description ^= null then		/* at least we're writing a description */
     1111 		log.sw.logging_sw = "1"b;		/* make sure the switch is set */
     1112 	     if log.sw.logging_sw then do;		/* add description task, (if logging anything) */
     1113 		allocate desc in (area);		/* grab space for description call */
     1114 		call upd_describe_task_ ("01"b, Pmsa_ptr, log.nullp, desc.code, desc.sev, 
     1115 		     desc.taskp, desc.seqno, desc.temp, log.d.log_directory, log.description, log.fcn(3).date);
     1116 		end;
     1117 	     end;
     1118 rerun:	call upd_subtask_(ctlw, Pmsa_ptr, log.nullp, log.t.code, log.t.sev, log.t.taskp, log.t.seqno,
     1119 	     log.processp, log.t.temp);		/* process task list */
     1120 	go to endlabel;				/* "full_recovery_off" or "clean_up" */
     1121 
     1122 recover:	call reversion_ ("any_other");				/* stop handling conditions */
     1123 	substr (ctlw, 1, 1) = ^(substr (ctlw, 1, 1));	/* here for error recovery, do it backward now */
     1124 	call com_err_(error_table_$fatal_error, (proc), "^/^a aborted. The installation will be de-installed.", xxx);
     1125 	errlabel = abort;				/* avoid infinite error recovery loop */
     1126 	endlabel = clean_up;			/* after recovery; don't unset full_recovery sw */
     1127 	xxx = "Error recovery";			/* for com_err_ call */
     1128 	log.fcn(4).date = fs_date();			/* set date of restoration and		*/
     1129 	log.fcn(4).group_id = log.lock.group_id;	/* record who is restoring the installation	*/
     1130 	go to rerun;				/* and call task dispatcher again */
     1131 
     1132 abort:	call reversion_ ("any_other");				/* stop handling conditions */
     1133 	call com_err_(error_table_$fatal_error, (proc), "^a aborted.", xxx);
     1134 	go to clean_up;				/* cleanup, then return to user */
     1135 
     1136 full_recovery_off:
     1137 	log.sw.full_recovery = "0"b;			/* once installation is complete, we cannot	*/
     1138 	go to clean_up;				/* cleanup io streams and return. */
     1139 						/* fully recover (by deleting new segs) during a	*/
     1140 						/* de_installation operation.	*/
     1141 
     1142 
     1143 start(11):call init_log("1"b);			/* "clear" function; make sure log exists 	*/
     1144 	if cerrorsw then				/* are we clearing errors? */
     1145 	     if log.listp ^= null then		/* if log has been installed before, */
     1146 		if log.processp ^= log.listp then do;	/* but hasn't been completely de-installed... */
     1147 		     call com_err_ (error_table_$out_of_sequence, (proc),
     1148 			"^/Performing the ""^a ^a -error"" function at this time^/will render ^a>^a unusable.", 
     1149 			(proc), (function_table(f)), logdir, logseg);
     1150 		     goto return;
     1151 		     end;
     1152 	ctlw = substr("000000000"b || sws,1,length(ctlw));/* do nothing but clearing task indicated by user */
     1153 start11a:	call condition_("task_linkage_err_", linkage_err);/* resolve our special linkage errors 		*/
     1154 	call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
     1155 						/* process all upd_install_task_'s in task list 	*/
     1156 	log.fcn(2).date = fs_date();			/* record date clear operation was performed. */
     1157 	log.fcn(2).group_id = log.lock.group_id;	/* record who cleared the log.		*/
     1158 	if ctlw & "00000000010"b then			/* if errors have been cleared, then		*/
     1159 	     log.sw.error = "0"b;			/* reset global error switch.			*/
     1160 	go to endlabel;
     1161 
     1162 
     1163 start(12):call init_log("1"b);			/* "list" function, log must exist */
     1164 	call suffixed_name_$new_suffix (logseg, "io", "il", listseg, code);
     1165 						/* store name of listing segment */
     1166 	listdir = get_wdir_();			/* put listing segment in working directory */
     1167 	Llistdir = mod (index (listdir, " ")+168, 169);	/* calculate length of non-blank part of dir */
     1168 	call msf_manager_$open (listdir, listseg, fcbp, code);
     1169 	if code = 0 then do;			/* if it already exists, truncate it */
     1170 	     call msf_manager_$adjust (fcbp, 0, 0, "111"b, code);
     1171 	     if code ^= 0 then
     1172 		go to listerr;
     1173 	     end;
     1174 	else if code = error_table_$noentry then;	/* if it doesn't exist yet, all is well */
     1175 	else do;
     1176 listerr:	     call com_err_ (code, (proc), 		/* report other errors to user */
     1177 		"^/Installation list (il) segment  ^a>^a  cannot be created.", listdir, listseg);
     1178 	     go to return;				/* unlock the log and return to installer.	*/
     1179 	     end;
     1180 	call msf_manager_$close (fcbp);		/* close msf to conserve space in system_free_ */
     1181 
     1182 	call ios_$attach ("installation_list_", "file_", substr (listdir, 1, Llistdir) || ">" || listseg,
     1183 	     "w", status);				/* attach I/O streams to installation list segment */
     1184 	if stat.code ^= 0 then do;
     1185 	     code = stat.code;
     1186 	     go to listerr;
     1187 	     end;
     1188 	call ios_$attach ("installation_error_", "syn", "installation_list_", "w", status);
     1189 						/* write error messages into the segment, too */
     1190 	call condition_ ("task_linkage_err_", linkage_err);	/* resolve task linkage errors */
     1191 
     1192 	call date_time_ (clock(), date);		/* write header of listing segment */
     1193 	call ioa_$ioa_stream ("installation_list_", "^|^/^a^2x^a>^a^2/^20a^a",
     1194 	     "INSTALLATION OBJECT SEGMENT", logdir, logseg,
     1195 	     "Listed on:", date);
     1196 
     1197 	call date_time_$fstime (log.fcn(1).date, date);
     1198 	call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a (^a ^a)^/^20a^a",
     1199 	     "Created by:", log.fcn(1).group_id,
     1200 	     "Created with:", (proc), "MIS Version", log.version,
     1201 	     "Created on:", date);
     1202 
     1203 	if log.fcn(2).date ^= 0 then do;		/* if log has been cleared, tell about that. */
     1204 	     call date_time_$fstime (log.fcn(2).date, date);
     1205 	     call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a",
     1206 		"Cleared by:", log.fcn(2).group_id,
     1207 		"Cleared on:", date);
     1208 	     end;
     1209 
     1210 	if log.fcn(3).date ^= 0 then do;		/* if log has been installed, tell about that. 	*/
     1211 	     call date_time_$fstime (log.fcn(3).date, date);
     1212 	     call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a",
     1213 		"Installed by:", log.fcn(3).group_id,
     1214 		"Installed on:", date);
     1215 	     end;
     1216 
     1217 	if log.fcn(4).date ^= 0 then do;		/* if log has been de_installed, tell about that 	*/
     1218 	     call date_time_$fstime (log.fcn(4).date, date);
     1219 						/* emphasize the fact of de-installation */
     1220 	     call ioa_$ioa_stream ("installation_list_", "^/INSTALLATION HAS BEEN DE-INSTALLED");
     1221 	     call ioa_$ioa_stream ("installation_list_", "^20a^a^/^20a^a",
     1222 		"De-installed by:", log.fcn(4).group_id,
     1223 		"De-installed on:", date);
     1224 	     end;
     1225 
     1226 
     1227 	if log.description ^= null then do;		/* documentation description follows: */
     1228 	     call ioa_$ioa_stream ("installation_list_", "^/DOCUMENTATION DESCRIPTION FOLLOWS:");
     1229 						/* pass only minimum args. */
     1230 	     call upd_describe_task_ ( "00000100100"b, log.nullp, log.nullp, 0, 0, log.nullp, 0,
     1231 		log.nullp, "", log.description, log.fcn(3).date);
     1232 	     end;
     1233 
     1234 	call ioa_$ioa_stream ("installation_list_", "^3/SUMMARY OF THE INSTALLATION:");
     1235 	ctlw = "00000101000"b;			/* output in brief mode */
     1236 	call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
     1237 						/* let installation primitives generate output */
     1238 
     1239 	if log.sw.error then do;			/* if errors occurred, list them next */
     1240 	     call ioa_$ioa_stream ("installation_list_", "^3/SUMMARY OF ERRORS WHICH OCCURRED DURING INSTALLATION:");
     1241 	     ctlw = "00000110000"b;			/* output errors only */
     1242 	     call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
     1243 	     end;
     1244 	else if log.fcn(3).date ^= 0 then		/* if no errors occurred during installation, tell user */
     1245 	     call ioa_$ioa_stream ("installation_list_", "^3/NO ERRORS OCCURRED DURING INSTALLATION.");
     1246 	else					/* otherwise, tell user log hasn't been installed */
     1247 	     call ioa_$ioa_stream ("installation_list_",
     1248 		"^3/INSTALLATION OBJECT SEGMENT HAS N_O_T_ BEEN INSTALLED.");
     1249 
     1250 	if ^briefsw then do;			/* if ^"-brief" mode, then print normal output */
     1251 	     call ioa_$ioa_stream ("installation_list_",
     1252 		"^5/A DESCRIPTION OF THE INSTALLATION FOLLOWS.^|^/INSTALLATION DESCRIPTION:");
     1253 	     ctlw = "00000100000"b;			/* output in normal mode */
     1254 	     call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
     1255 	     end;
     1256 
     1257 	if longsw then do;				/* if "-long" mode, then print details */
     1258 	     call ioa_$ioa_stream ("installation_list_", "^5/INSTALLATION DETAILS FOLLOW:");
     1259 	     ctlw = "00000100100"b;			/* output in detailed mode */
     1260 	     call upd_task_ ("0"b, (log.listp), upd_gen_call_, addr (ctlw));
     1261 	     end;
     1262 
     1263 
     1264 clean_up:	call ios_$detach ("installation_list_", "", "", status);
     1265 cleanerr:	call ios_$detach ("installation_error_", "", "", status);
     1266 						/* detach streams as a cleanup measure. */
     1267 	go to return;				/* unlock the log and return to installer.	*/
     1268 
     1269 /**/
     1270 
     1271 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1272 
     1273 
     1274 init_log:		procedure (sw);			/* initialize installation log segment 		*/
     1275 
     1276 
     1277      dcl	sw			bit(1) aligned;	/* non-zero if reinitiating old segment 	*/
     1278 
     1279      dcl	process_id		bit(36) aligned;	/* process id.				*/
     1280 
     1281      dcl	seg_fault_error		condition;	/* condition				*/
     1282 
     1283 
     1284 	if npath = 0 then do;			/* no log specified as argument 		*/
     1285 	     on seg_fault_error begin;		/* trap condition where io seg deleted without	*/
     1286 		logp = null;			/* telling update_seg.			*/
     1287 		go to faultlabel;
     1288 		end;
     1289 	     if logp ^= null then			/* validate our log pointer as best we can.	*/
     1290 		if logp = log.selfp then do;
     1291 		     revert seg_fault_error;		/* stop handling this condition		 */
     1292 		     call validate_user;
     1293 		     return;
     1294 		     end;
     1295 	     logp = null;				/* already null, or inconsistent 		*/
     1296 	     go to faultlabel;			/* go bitch at user 			*/
     1297 	     end;
     1298 	logp = null;				/* make sure pointer, name not inconsistent 	*/
     1299 	msa_ptr = null;				/* ditto					*/
     1300 	logdir = dir(1);				/* copy dirname of segment specified 		*/
     1301 	call suffixed_name_$find (logdir, seg(1), "io", logseg, type, mode, code);
     1302 						/* find the io seg if it exists, or create	*/
     1303 						/* properly-suffixed path name from the one given	*/
     1304 						/* to us by the user.			*/
     1305 	if sw then do;				/* perform re-initiation processing.		*/
     1306 	     if code ^= 0 then do;			/* if we're re-init-ing a seg which doesn't exist,*/
     1307 re_init_fail:	call com_err_ (code, (proc),
     1308 		     "^/Installation object (io) segment ^a>^a cannot be re-initiated.", logdir, seg(1));
     1309 	 	go to return_without_unlocking;	/* then tell installer about it, and return.	*/
     1310 		end;
     1311 	     if type = 2 then do;			/* if a directory was found, then		*/
     1312 		call com_err_ (error_table_$dirseg, (proc), "^/^a>^a ^a.^/^a.", logdir, logseg,
     1313 		     "is a directory",
     1314 		     "It cannot be re-initiated as an installation object (io) segment");
     1315 		go to return_without_unlocking;
     1316 		end;
     1317 	     if mod (mode, 4) = 0 then do;		/* if user can't useio seg, then complain.	*/
     1318 		code = error_table_$moderr;
     1319 		go to re_init_fail;
     1320 		end;
     1321 	     call msa_manager_$initiate (logdir, logseg, msa_ptr, (size(log)), logp, code);
     1322 	     if code ^= 0 then do;			/* Oh, Boy!  An error during initialization.	*/
     1323 		if code = error_table_$segno_in_use then 
     1324 						/* Component of io seg couldn't be initiated	*/
     1325 						/* with segno which was used before.  Tell the	*/
     1326 						/* user he must free this segno.		*/
     1327 		     call com_err_ (code, (proc), "^/^a ^a>^a^/^a ^o (octal).^/^a^/^a ^a again.",
     1328 			"A component of the installation object (io) segment", logdir, logseg,
     1329 			"must be initiated with the segment number", fixed (baseno(msa_ptr), 35),
     1330 			"Please terminate the segment which is now known",
     1331 			"by this number, and re-initiate", logseg);
     1332 		else
     1333 		     if code = error_table_$noentry then do;
     1334 						/* The first SSA of the MSA was not found.	*/
     1335 			call com_err_ (code, (proc), "^/^a ^a>^a^/^a.^/^a.",
     1336 			     "The first component of the installation object (io) segment", logdir, logseg,
     1337 			     "was discovered to be missing",
     1338 			     "The installation object (io) segment cannot be re-initiated");
     1339 			go to return_without_unlocking;
     1340 			end;
     1341 		else
     1342 		     if code = error_table_$seg_not_found then
     1343 						/* An SSA, other than the first SSA of MSA, was	*/
     1344 						/* discovered to be missing.  A new SSA is	*/
     1345 						/* created to replace the old SSA.		*/
     1346 			call com_err_ ( code, (proc), "^/^a ^a>^a^/^a.^/^a.",
     1347 			     "A component of the installation object (io) segment", logdir, logseg,
     1348 			     "was discovered to be missing.  A new component was created to replace it",
     1349 			     "Some data may be missing" );
     1350 		else
     1351 		     if code = error_table_$improper_data_format then
     1352 						/* an attempt was made to initiate an MSA which	*/
     1353 						/* was found to not be an MSA.		*/
     1354 		     call com_err_ (code, (proc), "^/^a>^a ^a.^/^a.",
     1355 			logdir, logseg, "does not have the format of an installation object (io) segment",
     1356 			"Please check its consistency" );
     1357 		else 				/* otherwise, it was another error.		*/
     1358 		     call com_err_ ( code, (proc), "^a>^a", logdir, logseg);
     1359 		go to return;
     1360 		end;
     1361 	     if msa_ptr = null then			/* initiation failed.			*/
     1362 		go to re_init_fail;
     1363 	     if log.init_id = "0"b then do;		/* if this segment was never initiated before,	*/
     1364 		call msa_manager_$terminate (msa_ptr, code);
     1365 						/* terminate it, and go initiate it with a high number. */
     1366 		logp, msa_ptr = null;		/* null ptr's, because terminate_seg doesn't.	*/
     1367 		go to init_high;
     1368 		end;
     1369 	     call validate_user;			/* make sure this user knows what he's doing.	*/
     1370 	     process_id = get_process_id_();
     1371 	     if log.init_id ^= process_id then		/* has log been initialized by this process?	*/
     1372 		call upd_add_task_$reset (log.linkp);	/* no, reset procedure entry pointers.		*/
     1373 	     log.init_id = process_id;		/* leave out mark.				*/
     1374 	     end;
     1375 
     1376 	else do;					/* otherwise, we're creating the io seg.	*/
     1377 	     if code = 0 then do;			/* zero code means log already exists. Tell user.	*/
     1378 		call com_err_ (error_table_$namedup, (proc),
     1379 		     "^/Installation object (io) segment ^a>^a already exists.", logdir, logseg);
     1380 		go to return_without_unlocking;	/* quit.					*/
     1381 		end;
     1382 	     if code ^= error_table_$noentry then do;	/* any other errors are somewhat serious.	*/
     1383 randomerr:	call com_err_ (code, (proc),
     1384 		     "^/^a  ^a>^a  ^a", "Installation object segment", logdir, seg(1),
     1385 		     "cannot be initiated.");
     1386 		go to return_without_unlocking;	/* quit.					*/
     1387 		end;
     1388 init_high:     call msa_manager_$make_special (256, logdir, logseg, msa_ptr, (size(log)), logp, code);
     1389 	     if code ^= 0 then do;
     1390 		msa_ptr = null;			/* make sure it's null */
     1391 		if sw then go to randomerr;		/* re-initting old one */
     1392 		if code = error_table_$segno_in_use then do;/* msa_man_ has this gross bug */
     1393 						/* which leaves new seg hanging around */
     1394 		     call hcs_$delentry_file ( logdir, logseg, (0) );
     1395 	     	     call com_err_ (code, (proc), "^/^a.  ^a>^a ^a.^/^a.",
     1396 		          "No high segment numbers are available", logdir, logseg,
     1397 		          "cannot be initiated",
     1398 			"Type:  ""new_proc""  and try again");
     1399 
     1400 	     	     go to return_without_unlocking;
     1401 		     end;
     1402 		go to randomerr;			/* something else */
     1403 	          end;
     1404 
     1405 	     log.lock.word = "0"b;			/* lock the new installation object segment.	*/
     1406 	     log.lock.group_id = get_group_id_$tag_star();
     1407 	     log.version = Version_No;		/* initialize the io seg header.		*/
     1408 	     call validate_user;
     1409 	     log.areap = msa_ptr;
     1410 	     log.d.log_directory = "";
     1411 	     log.init_id = "0"b;			/* make sure it's 0				*/
     1412 	     log.selfp = logp;			/* save copy of log pointer in log segment	*/
     1413 	     log.linkp,				/* initialize linkage list ptr.		*/
     1414 	     log.listp,				/* no task list...				*/
     1415 	     log.processp,				/* no task-last-processed.			*/
     1416 	     log.nullp,
     1417 	     log.description,
     1418 	     log.t.taskp,
     1419 	     log.t.temp = null;
     1420 	     log.fcn.group_id = log.lock.group_id;	/* record creator of io seg.  Only he can build,	*/
     1421 						/* install, de_install, or clear seg w/o questions*/
     1422 
     1423 	     log.fcn.date,
     1424 	     log.d.rb(1),
     1425 	     log.d.rb(2),
     1426 	     log.d.rb(3),
     1427 	     log.d.acl.n,
     1428 	     log.t.code,
     1429 	     log.t.sev = 0;
     1430 
     1431 	     log.t.seqno = 32767;			/* highest seqno means append upd_subtask_ to the	*/
     1432 						/* very end of the primary task list.		*/
     1433 	     log.sw.full_recovery = "1"b;		/* to start with, full recoveries are allowed.	*/
     1434 	     log.sw.special_segs,			/* to start with, there are no special segs 	*/
     1435 	     log.sw.error,				/* there are no errors,			*/
     1436 	     log.sw.logging_sw = "0"b;		/* and, to start, there's no documentation 	*/
     1437 
     1438 	     log.init_id = get_process_id_();		/* leave our mark.				*/
     1439 	     end;
     1440 
     1441 	end init_log;
     1442 
     1443 
     1444 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1445 
     1446 
     1447 /**/
     1448 
     1449 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1450 
     1451 
     1452 validate_user:	procedure;			/* This procedure validates the current user	*/
     1453 
     1454 	if log.version ^= Version_No then do;		/* first, check version numbers		*/
     1455 						/* if not same, tell user the bad news		*/
     1456 		call com_err_ (error_table_$fatal_error, (proc),
     1457 		     "^a>^a was created with MIS Version ^a.^/^a ^a.^/^a ^a ^a ^a.", logdir, logseg,
     1458 		     log.version, "The version you are now using is MIS Version ", Version_No,
     1459 		     "As a result, the", (proc), (function_table(f)), "command has been ignored");
     1460 		logp = null;
     1461 		go to return;			/* can't use this log */
     1462 		end;
     1463 
     1464 	call set_lock_$lock (log.lock.word, 0, code);	/* lock the installation object segment.	*/
     1465 	if code ^= 0 then
     1466 	     if code = error_table_$invalid_lock_reset then;
     1467 						/* somebody bombed out while processing io seg?	*/
     1468 						/* ignore him.				*/
     1469 	     else if code = error_table_$locked_by_this_process then
     1470 		call com_err_ (code, (proc), "^/^a  ^a>^a.^/^a ^a ^a function.",
     1471 		     "Non-fatal error encountered while locking", logdir, logseg,
     1472 		     (proc), "will continue performing the", (function_table(f)));
     1473 	     else if code = error_table_$lock_wait_time_exceeded then do;
     1474 lockerr:		call com_err_ (error_table_$seglock, (proc), "^/^a  ^a>^a^/^a ^a.^/The  ""^a ^a""  ^a.",
     1475 		     "Installation object (io) segment", logdir, logseg,
     1476 		     "is already being manipulated by", log.lock.group_id,
     1477 		     (proc), (function_table(f)), "command cannot be performed");
     1478 		go to return_without_unlocking;	/* don't unlock seg; just return.		*/
     1479 		end;
     1480 	     else					/* report any other errors.			*/
     1481 	 	go to lockerr;
     1482 	if log.lock.group_id ^= get_group_id_$tag_star() then do;
     1483 						/* if another installer last referenced this log	*/
     1484 						/* then ask this installer if he knows what he's	*/
     1485 						/* doing.					*/
     1486 	     call command_query_ (addr (query_info), answer, (proc), 
     1487 		"^a>^a ^a ^a.^/^a  ""^a ^a""  command?",
     1488 		logdir, logseg, "was created by", log.lock.group_id,
     1489 		"Do you still wish to issue the", (proc), (function_table(f)));
     1490 		     				/* make sure this user wants to do his thing.	*/
     1491 	     if answer = "yes" then
     1492 		log.lock.group_id = get_group_id_$tag_star();
     1493 	     	     				/* now this guy owns the io seg.		*/
     1494 	     else do;
     1495 		logp = null;			/* forget the initialization done so far. 	*/
     1496 		go to return;
     1497 		end;
     1498 	     end;
     1499 	end validate_user;				/* return to init_log, if user is OK.		*/
     1500 
     1501 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1502 /*  */
     1503 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1504 
     1505 
     1506 
     1507 unlock_log:	procedure;			/* unlock io segment, if it is locked.		*/
     1508 
     1509 	if logp ^= null then if log.lock.word then do;	/* if we have an io seg which is locked, then	*/
     1510 	     call set_lock_$unlock (log.lock.word, code);	/* unlock it.				*/
     1511 	     if code ^= 0 then
     1512 		call com_err_ (code, (proc), "^/While unlocking  ^a>^a.", logdir, logseg);
     1513 	     end;
     1514 	end unlock_log;				/* return to caller.			*/
     1515 
     1516 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1517 
     1518 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1519 
     1520 
     1521 fs_date:		procedure returns (fixed bin(35));	/* return current fs_time value.		*/
     1522 
     1523      dcl	date			fixed bin(35),	/* the fs_date value.			*/
     1524 	date_str			bit(36) aligned based (addr (date)),
     1525 	time			fixed bin(71),	/* the current time.			*/
     1526 	time_str			bit(72) aligned based (addr (time));
     1527 
     1528 	time = clock();				/* The time is now ...			*/
     1529 	date_str = substr (time_str, 21, 36);		/* The fs_time is now...			*/
     1530 	return (date);
     1531 
     1532 	end fs_date;
     1533 
     1534 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1535 
     1536 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1537 
     1538 
     1539 thread_task:	procedure (mcp, name, wcp, taskp, csw);	/* handler for "thread_task_" condition */
     1540 
     1541 
     1542      dcl	mcp			ptr,		/* machine conditions pointer */
     1543 	name			char(*),		/* condition name */
     1544 	wcp			ptr,		/* crawl-out data pointer */
     1545 	taskp			ptr,		/* pointer to allocated task */
     1546 	csw			bit(1) aligned;	/* continue switch */
     1547 
     1548 	call upd_thread_task_(log.listp, taskp);	/* add task to current task list */
     1549 	end thread_task;				/* and return to signaller. */
     1550 
     1551 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1552 /**/
     1553 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1554 
     1555 
     1556 task_error:	procedure (mcp, name, wcp, sp, csw);	/* "task_error_" handler */
     1557 
     1558      dcl	mcp			ptr,		/* machine conditions pointer */
     1559 	name			char(*),		/* condition name signalled */
     1560 	wcp			ptr,		/* crawl-out data pointer */
     1561 	sp			ptr,		/* status block pointer */
     1562 	csw			bit(1) aligned;	/* continue switch */
     1563 
     1564      dcl	1 s			aligned based (sp),	/* status block for task error */
     1565 	  2 proc			char(32) unal,	/* name of procedure causing error */
     1566 	  2 entry			char(32) unal,	/* entry point name */
     1567 	  2 code			fixed bin(35),	/* status code */
     1568 	  2 sev			fixed bin,	/* severity code */
     1569 	  2 string		char(200);	/* optional message */
     1570 
     1571 
     1572 	log.sw.error = "1"b;			/* record the fact that some error occurred 	*/
     1573 	if s.sev >= fail then do;			/* if the error is fatal, then attempt to recover	*/
     1574 	     call upd_print_err_(s.code, s.sev, "Error", "", s.proc, s.entry, s.string);
     1575 	     go to errlabel;			/* unwind stack and begin error recovery */
     1576 	     end;
     1577 	else					/* report non-fatal errors to user & continue.	*/
     1578 	     call upd_print_err_ (s.code, s.sev, "Warning", "", s.proc, s.entry, s.string);
     1579 	end task_error;				/* continue installing/de_installing 		*/
     1580 
     1581 
     1582 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1583 
     1584 
     1585 linkage_err:	procedure (mcp, name, wcp, sp, csw);	/* handler for "task_linkage_err_" condition */
     1586 
     1587 
     1588      dcl	mcp			ptr,		/* machine conditions pointer */
     1589 	name			char(*),		/* condition name */
     1590 	wcp			ptr,		/* crawl-out data pointer */
     1591 	sp			ptr,		/* pointer to status block */
     1592 	csw			bit(1) aligned;	/* continue switch */
     1593 
     1594      dcl	1 s			aligned based (sp),	/* n.b. not same as for "error", above */
     1595 	  2 proc			char(32),		/* name of procedure signalling error */
     1596 	  2 entry			char(32),		/* entry point name */
     1597 	  2 code			fixed bin(35),	/* status code */
     1598 	  2 sev			fixed bin,	/* severity code */
     1599 	  2 rname			char(32),		/* refname of referenced procedure */
     1600 	  2 ename			char(32);		/* entryname of referenced procedure */
     1601 
     1602 
     1603 	call upd_print_err_(s.code, s.sev, "Task linkage error", "", s.proc, s.entry,
     1604 	     "Entry point referenced was ^a$^a", s.rname, s.ename);
     1605 	call cu_$cl;				/* reenter command level, let user fix it */
     1606 	end linkage_err;				/* return to try again */
     1607 
     1608 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1609 /**/
     1610 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1611 
     1612 
     1613 
     1614 
     1615 default_handler:	procedure;			/* handler for "unknown" conditions		*/
     1616 
     1617 
     1618      dcl	1  cond_info aligned,			/* condition info */
     1619 	   2 mcptr	ptr,
     1620 	   2 version	fixed bin,
     1621 	   2 condition_name char(32) var,
     1622 	   2 infop	ptr,
     1623 	   2 wcptr	ptr,
     1624 	   2 loc_ptr	ptr,
     1625 	   2 flags	aligned,
     1626 	     3 crawlout	bit(1) unal,
     1627 	     3 pad1	bit(35) unal,
     1628 	   2 pad_word	bit(36) aligned,
     1629 	   2 user_loc	ptr,
     1630 	   2 pad(4)	bit(36) aligned;
     1631 
     1632 	call find_condition_info_ ( null, addr(cond_info), code);
     1633 	if code ^= 0 then do;
     1634 	     call ioa_$ioa_stream ("error_output", "Error:  Unknown signal has been received." );
     1635 	     go to errlabel;				/* if call fails then try to back up */
     1636 	     end;
     1637 
     1638 	if cond_info.condition_name = "alrm" then do;
     1639 continue:	     call continue_to_signal_ (code);			/* pass this error on to another handler. */
     1640 	     return;
     1641 	     end;
     1642 	if cond_info.condition_name = "signal_io_" then 
     1643 	     go to continue;
     1644 
     1645 	if cond_info.condition_name = "cput" then		/* ditto					*/
     1646 	     go to continue;
     1647 	if cond_info.condition_name = "linkage_error" then	/* let system's default handler handle these	*/
     1648 	     go to continue;
     1649 	if cond_info.condition_name = "mme2" then		/* let debug intercept breakpoints.		*/
     1650 	     go to continue;
     1651 	if cond_info.condition_name = "quit" then		/* let system quit handler handle them.		*/
     1652 	     go to continue;
     1653 	if cond_info.condition_name = "command_error" then	/* if our own error handler passed, 	*/
     1654 	     go to continue;				/* pass it on.  */
     1655 	if cond_info.condition_name = "finish" then		/* means it's all over anyway 	*/
     1656 	     go to continue;
     1657 	if cond_info.condition_name = "stack" then		/* we're coming close to the end	*/
     1658 	     go to continue;
     1659 	if cond_info.condition_name = "program_interrupt" then	/* ignore program interrupts.			*/
     1660 	     return;
     1661 	if cond_info.condition_name = "stringsize" then do;	/* handle stringsize by reporting it. */
     1662 	     call ioa_$ioa_stream ("error_output", "Error: stringsize condition occurred.");
     1663 	     go to STOP;					/* condition_interpreter_ ignores these */
     1664 	     end;						/*  conditions.			*/
     1665 
     1666 	call condition_interpreter_ (null(), null(), 0, 3, cond_info.mcptr, (cond_info.condition_name),
     1667 	      cond_info.wcptr, cond_info.infop);
     1668 	if stopsw then do;
     1669 STOP:	     call ioa_$ioa_stream ("error_output",
     1670 		"Returning to command level.  Type: ""start"" to begin recovery operations.");
     1671 	     call cu_$cl();
     1672 	     go to recover;
     1673 	     end;
     1674 
     1675 	go to errlabel;					/* treat them as fatal errors.		*/
     1676 
     1677 	end default_handler;
     1678 
     1679 
     1680 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1681 /**/
     1682 get_reason:	proc (areap, nofillsw, rcp);		/* this proc accepts typed line input for */
     1683 						/* documentation later */
     1684 	/* As of March, 1980, the "reason" may be contained in a segment
     1685*	   rather than always asking the user to type it in.  The variable
     1686*	   init_log_segment is the pathname of that segment.	      */
     1687 
     1688 dcl
     1689      areap	ptr,				/* area ptr for allocation */
     1690      nofillsw	bit(1) aligned,			/* on if reason is NOT to be filled.		*/
     1691      rcp		ptr;				/* ptr to description within area */
     1692 
     1693 dcl						/* misc. error codes */
     1694     (error_table_$end_of_info,
     1695      error_table_$short_record,
     1696      error_table_$not_detached)	ext static fixed bin(35);
     1697 dcl
     1698      code		fixed bin(35),
     1699      i		fixed bin,
     1700      total	fixed bin,			/* total no. of chars in area */
     1701      null		builtin,
     1702      substr	builtin,
     1703      break_sw	bit (1),
     1704      tab_sw	bit(1),
     1705      nelemt	fixed bin(21),			/* no. of elements read */
     1706      blockp	ptr,				/* ptr to allocated block */
     1707      buffp	ptr;				/* ptr to input buffer */
     1708 
     1709 dcl  buffer	char (512) aligned;			/* input buffer */
     1710 
     1711 dcl  out_buffer	char (16384) aligned;		/* output buffer */
     1712 
     1713 dcl  Area		area based (areap);			/* allocation area */
     1714 
     1715 dcl  1 block	based (blockp),			/* block to be allocated */
     1716        2 editsw	bit(1),				/* edit sw, "on" if already editted */
     1717        2 no_chars	fixed bin(35),			/* # of chars in this block */
     1718        2 string	char (total refer (block.no_chars));	/* the character string */
     1719 
     1720 dcl  term_line (4)	char (1) init (
     1721 	".",
     1722 	"?",
     1723 	":",
     1724 	";");
     1725 
     1726 dcl  HT		char (1) int static options(constant) init("	");
     1727 dcl  NL		char (1) int static options(constant) init ("
     1728 ");						/* new_line char */
     1729 
     1730 dcl
     1731      ioa_			entry options (variable),
     1732      iox_$attach_name	entry (char(*), ptr, char(*), ptr, fixed bin(35)),
     1733      iox_$find_iocb		entry ( char(*), ptr, fixed bin(35)),
     1734      iox_$open		entry ( ptr, fixed bin, bit(1) aligned, fixed bin(35)),
     1735      iox_$get_line		entry ( ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35)),
     1736      iox_$detach_iocb	entry ( ptr, fixed bin(35)),
     1737      iox_$close		entry ( ptr, fixed bin(35));
     1738 dcl
     1739      iocb_ptr		ptr,			/* ptr to the I/O control block */
     1740      atd			char(256),		/* attach description */
     1741      switch_name		char(32),
     1742      Path			bit(1),			/* ON = look for segment */
     1743      ref_ptr		ptr;
     1744 
     1745 	total = 0;
     1746 	out_buffer = "";
     1747 	ref_ptr = null;
     1748 	buffp = addr(buffer);
     1749 
     1750 	if init_log_segment ^= ""			/* means look for a segment */
     1751 	     then Path = "1"b;
     1752 	     else	Path = "0"b;			/* otherwise, ask from the terminal */
     1753 
     1754 	if Path then do;
     1755 	     switch_name = "upd_init_log_sw_";
     1756 	     atd = "vfile_ " || init_log_segment;	/* build attach description */
     1757 	     call iox_$attach_name ( switch_name, iocb_ptr, atd, ref_ptr, code);
     1758 	     if ( code ^= 0 ) & (code ^= error_table_$not_detached) then do;
     1759 		call com_err_ (code, (proc), "Attaching ^a.^/^a",
     1760 		     init_log_segment,
     1761 		     "The ""log"" information remains unchanged.");
     1762 		return;
     1763 	     end;
     1764 
     1765 	     call iox_$open ( iocb_ptr, 1, "0"b, code);
     1766 	     if code ^= 0 then do;
     1767 		call com_err_ (code, (proc), "Opening ^a^/^a",
     1768 		     init_log_segment,
     1769 		     "The ""log"" information remains unchanged.");
     1770 		go to DETACH_ILS;
     1771 	     end;
     1772 	end;
     1773 	else do;
     1774 	     call iox_$find_iocb ( "user_input", iocb_ptr, code );
     1775 	     if code ^=0 then do;
     1776 		call com_err_ ( code, (proc),
     1777 		     "Attaching ""user_input"".^/^a",
     1778 		     "the ""log"" information remains unchanged.");
     1779 	     end;
     1780 	     call ioa_ ("Input");			/* tell user to type */
     1781 	end;
     1782 
     1783 read:	call iox_$get_line (iocb_ptr, buffp, length(buffer), nelemt, code);
     1784 	if code = error_table_$end_of_info
     1785 	     then go to process;
     1786 	if (code ^= 0) & (code ^= error_table_$short_record) then do;
     1787 	     call com_err_ (code, (proc), "Reading ""log"" information.^/^a",
     1788 		"The ""log"" information remains unchanged.");
     1789 	     go to RETURN;
     1790 	end;
     1791 	if nelemt = 2
     1792 	     then if substr(buffer,1,1) = "."
     1793 		then goto process;			/* end of input reached */
     1794 	if nelemt < 2 then do;
     1795 	     nelemt = 3;				/* just so we don't lose a NL char */
     1796 	     substr(buffer,2,1) = NL;			/* takes 2 NL's to make a blank line */
     1797 	     end;
     1798 	if (total + (nelemt-1)) >= length(out_buffer)
     1799 	     then goto warn;			/* too many chars read */
     1800 	if nofillsw then;
     1801 	else do;
     1802 	     tab_sw = "0"b;
     1803 tab:	     i = index(substr (buffer, 1, nelemt), HT);
     1804 						/* look for tabs */
     1805 	     if i ^= 0 then do;			/* found one */
     1806 	          substr( buffer,i,1) = " ";		/* convert to single char */
     1807 		tab_sw = "1"b;			/* tell the user later. */
     1808 		go to tab;
     1809 		end;
     1810 	     break_sw = "0"b;
     1811 	     do i = 1 to 4;				/* search for end of sentence chars */
     1812 		if substr(buffer,(nelemt-1),1) = term_line(i)
     1813 		     then break_sw = "1"b;
     1814 		end;
     1815 	     if break_sw then do;
     1816 		substr(buffer,nelemt,2) = "  ";	/* add 2 blanks */
     1817 		nelemt = nelemt + 2;
     1818 		end;
     1819 	     end;
     1820 
     1821 	if substr(buffer, 1, 1) = " " then 		/* start on new line */
     1822 	     if total ^= 0 then do;
     1823 	     total = total + 1;
     1824 	     substr(out_buffer,total,1) = NL;		/* append new_line to out buffer */
     1825 	     end;
     1826 	if total ^= 0
     1827 	     then if substr(out_buffer,total,1) ^= NL
     1828 		then if substr(out_buffer,total,1) ^= " " then do; /* add a blank between words */
     1829 		     total = total + 1;
     1830 		     substr(out_buffer,total,1) = " ";
     1831 		     end;
     1832 						/* copy buffer into temp storage */
     1833 	substr(out_buffer,(total+1),(nelemt-1)) = substr(buffer,1,(nelemt-1));
     1834 	total = total + (nelemt -1);			/* reset total */
     1835 	if total >= length(out_buffer)		/* check total again */
     1836 	     then goto warn;
     1837 	goto read;
     1838 
     1839 process:						/* allocate in area for keeping */
     1840 	if total = 0 then do;			/* someone wanted to zap previous desc. */
     1841 	     rcp = null;				/* null the pointer */
     1842 	     go to RETURN;;				/* and xfer out */
     1843 	     end;
     1844 	allocate block in (Area) set (blockp);		/* grab the storage */
     1845 	blockp->block.editsw = nofillsw;		/* not editted yet */
     1846 	blockp->block.no_chars = total;		/* copy the number of characters */
     1847 	blockp->block.string = substr(out_buffer,1,total); /* and copy the characters */
     1848 	rcp = blockp;				/* finally, the return ptr */
     1849 	if tab_sw then				/* tell the user about any conversion */
     1850 	     call ioa_ ( "Warning:  tabs have been converted to single blanks.^/");
     1851 RETURN:	code = 0;
     1852 	if Path
     1853 	     then call iox_$close ( iocb_ptr, code);
     1854 	if code ^= 0
     1855 	     then call com_err_ (code, (proc), "Closing ""log"" info.");
     1856 DETACH_ILS:
     1857 	if Path
     1858 	     then call iox_$detach_iocb ( iocb_ptr, code);
     1859 	if code ^= 0
     1860 	     then call com_err_ (code, (proc), "Detaching ""log"" info.");
     1861 	return;					/* finished */
     1862 
     1863 warn:						/* too many characters entered */
     1864 	call ioa_("Maximum number of characters have been entered.^/""Input"" mode is terminated");
     1865 	goto process;
     1866 	end;
     1867 
     1868 	end update_seg;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/19/86  2159.5  update_seg.pl1                    >spec>install>1129>update_seg.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Area                                   based           area(1024)               dcl 1713 ref 1844
HT                                     constant        char(1)                  initial unaligned dcl 1726 ref 1803
Llistdir                        000560 automatic       fixed bin(17,0)          dcl 178 set ref 1167* 1182
NL                              020232 constant        char(1)                  initial unaligned dcl 1727 ref 1796 1824 1826
Path                            015070 automatic       bit(1)                   unaligned dcl 1738 set ref 1750* 1752* 1754 1852
                                                                                  1856
Pmsa_ptr                               based           pointer                  dcl 156 set ref 945* 1004 1011 1019 1035* 1036*
                                                                                  1102* 1104 1106* 1113 1114* 1118*
Version_No                      000076 internal static char(4)                  initial dcl 178 set ref 1407 1454 1456*
a                        56     000662 automatic       structure                array level 3 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 672 673 673 1012
a                               000116 automatic       fixed bin(17,0)          dcl 158 in procedure "us" set ref 661* 678 679 680
                                                                                  683 686 690 695 736* 751 752 753 756
a                      2017     000662 automatic       structure                array level 3 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 745 746 746 1020
a                        56            based           structure                array level 3 in structure "default" dcl 284
                                                                                  in procedure "us" set ref 911 911 919 919
acl                     151            based           structure                level 3 in structure "log" dcl 337 in procedure "us"
acl                      55     000662 automatic       structure                array level 2 in structure "t" dcl 267 in procedure
                                                                                  "us"
acl                                    based           structure                array level 1 dcl 295 in procedure "us" set ref 1011
                                                                                  1013* 1013
acl                      55            based           structure                level 2 in structure "default" dcl 284 in procedure
                                                                                  "us"
addr                                                   builtin function         dcl 120 ref 514 542 544 576 577 602 643 643 643 643
                                                                                  649 649 649 649 649 649 820 820 840 840 892 893
                                                                                  907 911 911 915 919 919 928 929 966 966 1012 1020
                                                                                  1154 1154 1184 1185 1236 1236 1242 1242 1254 1254
                                                                                  1260 1260 1486 1486 1529 1529 1632 1632 1748
an                       20            based           fixed bin(17,0)          initial array level 2 dcl 321 set ref 1004* 1004*
                                                                                  1004* 1015* 1036*
answer                          000141 automatic       char(3)                  dcl 178 set ref 1486* 1491
ap                        4            based           pointer                  initial array level 2 dcl 321 set ref 1004* 1004*
                                                                                  1004* 1014* 1036*
archivesw                              based           bit(1)                   level 2 packed unaligned dcl 210 set ref 766*
area                                   based           area(1024)               dcl 150 ref 1004 1011 1019 1104 1113
areap                     4            based           pointer                  level 2 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1409*
areap                                  parameter       pointer                  dcl 1688 in procedure "get_reason" ref 1682 1844
arg                                    based           char                     unaligned dcl 176 set ref 604* 607 615 622* 640 683*
                                                                                  690* 705* 751 772* 774* 840 857* 859*
argi                            000117 automatic       fixed bin(17,0)          dcl 158 set ref 523* 524* 597* 597 598 600* 604* 612
argl                            000120 automatic       fixed bin(17,0)          dcl 158 set ref 600* 603* 604 604 607 615 622 622
                                                                                  640 643* 683 683 690 690 705 705 751 772 772 774
                                                                                  774 820* 840 840* 857 857 859 859
argp                            000100 automatic       pointer                  dcl 152 set ref 600* 602* 604 607 615 622 640 643*
                                                                                  683 690 705 751 772 774 820* 840 840* 857 859
atd                             014760 automatic       char(256)                unaligned dcl 1738 set ref 1756* 1757*
baseno                                                 builtin function         dcl 120 ref 1323 1323
block                                  based           structure                level 1 unaligned dcl 1715 set ref 1844
blockp                          004550 automatic       pointer                  dcl 1697 set ref 1844* 1845 1846 1847 1848
break_sw                        004545 automatic       bit(1)                   unaligned dcl 1697 set ref 1810* 1812* 1815
briefsw                   0(01)        based           bit(1)                   level 2 packed unaligned dcl 219 set ref 801* 1250
buffer                          004554 automatic       char(512)                dcl 1709 set ref 1748 1783 1783 1791 1796* 1803
                                                                                  1806* 1812 1816* 1821 1833
buffp                           004552 automatic       pointer                  dcl 1697 set ref 1748* 1783*
cerrorsw                               based           bit(1)                   level 2 packed unaligned dcl 226 ref 1144
cleanup                         004510 stack reference condition                dcl 509 ref 530
clear_option_word                      based           structure                level 1 dcl 226
clock                                                  builtin function         dcl 120 ref 1192 1192 1528
code                     20            based           fixed bin(35,0)          level 2 in structure "s" dcl 1594 in procedure
                                                                                  "linkage_err" set ref 1603*
code                                   based           fixed bin(35,0)          level 2 in structure "stat" dcl 247 in procedure
                                                                                  "us" ref 1184 1185
code                     26            based           fixed bin(35,0)          initial level 2 in structure "rq" dcl 321
                                                                                  in procedure "us" set ref 1004* 1036*
code                     70     000662 automatic       fixed bin(35,0)          array level 4 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 678*
code                     20            based           fixed bin(35,0)          level 2 in structure "s" dcl 1564 in procedure
                                                                                  "task_error" set ref 1574* 1577*
code                            004542 automatic       fixed bin(35,0)          dcl 1697 in procedure "get_reason" set ref 1757*
                                                                                  1758 1758 1759* 1765* 1766 1767* 1774* 1775 1776*
                                                                                  1783* 1784 1786 1786 1787* 1851* 1852* 1854 1854*
                                                                                  1856* 1859 1859*
code                            000121 automatic       fixed bin(35,0)          dcl 158 in procedure "us" set ref 524* 525 600* 601
                                                                                  604* 643* 644 649* 650 683* 684 705* 706 707* 715*
                                                                                  772* 773 820* 821 840* 842 849* 857* 858 1164*
                                                                                  1168* 1169 1170* 1171 1174 1176* 1185* 1301* 1306
                                                                                  1307* 1318* 1321* 1322 1323 1323* 1332 1335* 1341
                                                                                  1341* 1350 1350* 1357* 1364* 1377 1382 1383* 1388*
                                                                                  1389 1392 1395* 1464* 1465 1465 1469 1469* 1473
                                                                                  1510* 1511 1511* 1632* 1633 1639*
code                      2            based           fixed bin(35,0)          initial level 2 in structure "desc" dcl 314
                                                                                  in procedure "us" set ref 1113* 1114*
code                      4            based           fixed bin(35,0)          initial level 2 in structure "in" dcl 306
                                                                                  in procedure "us" set ref 1104* 1106*
code                    672            based           fixed bin(35,0)          level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1118* 1423*
com_err_                        000676 constant        entry                    external dcl 64 ref 518 538 604 622 625 673 746 774
                                                                                  781 859 933 940 978 988 1044 1054 1077 1124 1133
                                                                                  1147 1176 1307 1312 1323 1335 1341 1350 1357 1378
                                                                                  1383 1395 1456 1469 1474 1511 1759 1767 1776 1787
                                                                                  1854 1859
command_query_                  000700 constant        entry                    external dcl 64 ref 1486
cond_info                       000100 automatic       structure                level 1 dcl 1618 set ref 1632 1632
condition_                      000702 constant        entry                    external dcl 64 ref 965 1002 1032 1033 1034 1095
                                                                                  1096 1097 1098 1100 1153 1190
condition_interpreter_          000704 constant        entry                    external dcl 64 ref 1666
condition_name            3     000100 automatic       varying char(32)         level 2 dcl 1618 set ref 1638 1642 1645 1647 1649
                                                                                  1651 1653 1655 1657 1659 1661 1666
continue_to_signal_             000706 constant        entry                    external dcl 64 ref 1639
csw                                    parameter       bit(1)                   dcl 1542 in procedure "thread_task" ref 1539
csw                                    parameter       bit(1)                   dcl 1558 in procedure "task_error" ref 1556
csw                                    parameter       bit(1)                   dcl 1588 in procedure "linkage_err" ref 1585
ctlw                            000636 automatic       bit(36)                  dcl 200 set ref 964* 964 966 966 1028* 1036* 1061*
                                                                                  1066* 1083* 1118* 1123* 1123 1152* 1152 1154 1154
                                                                                  1158 1235* 1236 1236 1241* 1242 1242 1253* 1254
                                                                                  1254 1259* 1260 1260
cu_$arg_count                   000710 constant        entry                    external dcl 64 ref 516
cu_$arg_ptr                     000712 constant        entry                    external dcl 64 ref 524 600
cu_$cl                          000714 constant        entry                    external dcl 64 ref 1605 1671
cu_$level_get                   000716 constant        entry                    external dcl 64 ref 726 730
cv_dec_check_                   000720 constant        entry                    external dcl 64 ref 705 772 857
cv_mode_                        000722 constant        entry                    external dcl 64 ref 683
cv_userid_                      000724 constant        entry                    external dcl 64 ref 690
d                        74            based           structure                level 2 dcl 337 set ref 577 907 928
date                            004530 automatic       fixed bin(35,0)          dcl 1523 in procedure "fs_date" set ref 1529 1530
date                            000142 automatic       char(24)                 dcl 178 in procedure "us" set ref 1192* 1193* 1197*
                                                                                  1198* 1204* 1205* 1211* 1212* 1218* 1221*
date                     37            based           fixed bin(35,0)          array level 3 in structure "log" dcl 337
                                                                                  in procedure "us" set ref 931* 958* 1036* 1036*
                                                                                  1041* 1068* 1070* 1076 1085* 1114* 1128* 1156*
                                                                                  1197* 1203 1204* 1210 1211* 1217 1218* 1230* 1244
                                                                                  1423*
date_str                               based           bit(36)                  dcl 1523 set ref 1529*
date_time_                      000726 constant        entry                    external dcl 64 ref 1192
date_time_$fstime               000730 constant        entry                    external dcl 64 ref 1197 1204 1211 1218
default                                based           structure                level 1 dcl 284 set ref 545* 545 578* 578 894* 894
                                                                                  930* 930
defersw                   0(04)        based           bit(1)                   level 2 packed unaligned dcl 210 set ref 828*
desc                                   based           structure                level 1 dcl 314 set ref 1113
description             664            based           pointer                  level 2 dcl 337 set ref 945* 958 958* 1110 1114*
                                                                                  1227 1230* 1413*
desp                            000114 automatic       pointer                  dcl 152 set ref 1113* 1114 1114 1114 1114 1114
dim                                                    builtin function         dcl 120 ref 527 614 672 673 673 745 746 746
dir                             000150 automatic       char(168)                array unaligned dcl 178 in procedure "us" set ref
                                                                                  573* 642* 643 643 994* 994 1006 1300
dir                      31            based           char(168)                array level 2 in structure "rq" packed unaligned
                                                                                  dcl 321 in procedure "us" set ref 1006* 1036*
doc_dir                         000346 automatic       char(168)                dcl 178 set ref 839* 840 840 844
docsw                           000420 automatic       bit(1)                   initial unaligned dcl 178 set ref 178* 845* 933
dummy                           000421 automatic       char(1)                  unaligned dcl 178 set ref 602
editsw                                 based           bit(1)                   level 2 packed unaligned dcl 1715 set ref 1845*
ename                    32            based           char(32)                 level 2 dcl 1594 set ref 1603*
endlabel                        000646 automatic       label variable           local dcl 241 set ref 559* 1060* 1064* 1082* 1120
                                                                                  1126* 1160
entry                    10            based           char(32)                 level 2 in structure "s" packed unaligned dcl 1564
                                                                                  in procedure "task_error" set ref 1574* 1577*
entry                    10            based           char(32)                 level 2 in structure "s" dcl 1594 in procedure
                                                                                  "linkage_err" set ref 1603*
eqseg                           000422 automatic       char(32)                 unaligned dcl 178 set ref 649 649 653* 984* 986*
                                                                                  988*
eqsw                            000637 automatic       bit(1)                   dcl 200 set ref 596* 647 654*
equal_                          000732 constant        entry                    external dcl 64 ref 649
errlabel                        000652 automatic       label variable           local dcl 241 set ref 1029* 1088* 1090* 1125* 1575
                                                                                  1635 1675
error                    73(02)        based           bit(1)                   level 3 packed unaligned dcl 337 set ref 1048* 1058
                                                                                  1158* 1239 1434* 1572*
error_table_$bad_conversion     001034 external static fixed bin(35,0)          dcl 123 set ref 707 774* 859*
error_table_$bad_ring_brackets  001036 external static fixed bin(35,0)          dcl 123 ref 715
error_table_$badcall            001040 external static fixed bin(35,0)          dcl 123 set ref 538*
error_table_$badopt             001042 external static fixed bin(35,0)          dcl 123 set ref 622*
error_table_$dirseg             001044 external static fixed bin(35,0)          dcl 123 set ref 1312*
error_table_$end_of_info        001114 external static fixed bin(35,0)          dcl 1693 ref 1784
error_table_$fatal_error        001046 external static fixed bin(35,0)          dcl 123 set ref 1044* 1124* 1133* 1456*
error_table_$improper_data_format
                                001050 external static fixed bin(35,0)          dcl 123 ref 1350
error_table_$invalid_lock_reset 001052 external static fixed bin(35,0)          dcl 123 ref 1465
error_table_$lock_wait_time_exceeded
                                001060 external static fixed bin(35,0)          dcl 123 ref 1473
error_table_$locked_by_this_process
                                001056 external static fixed bin(35,0)          dcl 123 ref 1469
error_table_$moderr             001062 external static fixed bin(35,0)          dcl 123 ref 1318
error_table_$namedup            001064 external static fixed bin(35,0)          dcl 123 set ref 1378*
error_table_$noentry            001066 external static fixed bin(35,0)          dcl 123 ref 1174 1332 1382
error_table_$not_detached       001120 external static fixed bin(35,0)          dcl 1693 ref 1758
error_table_$not_done           001070 external static fixed bin(35,0)          dcl 123 ref 752
error_table_$out_of_bounds      001072 external static fixed bin(35,0)          dcl 123 set ref 781*
error_table_$out_of_sequence    001074 external static fixed bin(35,0)          dcl 123 set ref 625* 933* 940* 978* 1054* 1077*
                                                                                  1147*
error_table_$seg_not_found      001076 external static fixed bin(35,0)          dcl 123 ref 1341
error_table_$seglock            001100 external static fixed bin(35,0)          dcl 123 set ref 1474*
error_table_$segno_in_use       001054 external static fixed bin(35,0)          dcl 123 ref 1323 1392
error_table_$short_record       001116 external static fixed bin(35,0)          dcl 1693 ref 1786
error_table_$too_many_acl_entries
                                001104 external static fixed bin(35,0)          dcl 123 set ref 673*
error_table_$too_many_names     001102 external static fixed bin(35,0)          dcl 123 set ref 746*
error_table_$wrong_no_of_args   001106 external static fixed bin(35,0)          dcl 123 set ref 518* 849 988*
expand_path_                    000734 constant        entry                    external dcl 64 ref 643 820 840
f                               000122 automatic       fixed bin(17,0)          dcl 158 set ref 529* 535 579 581 581 612 616 638 641
                                                                                  814 871 983 984 984 988 988 988 993 998 998 1044
                                                                                  1147 1456 1469 1474 1486
fail                            000123 automatic       fixed bin(17,0)          dcl 158 set ref 570* 592* 772* 780 780 781* 1573
fail_max                               constant        fixed bin(35,0)          initial dcl 499 ref 780 781
fail_min                               constant        fixed bin(35,0)          initial dcl 499 ref 780 781
faultlabel                      000656 automatic       label variable           local initial dcl 243 set ref 243* 900* 1287 1296
fcbp                            000432 automatic       pointer                  dcl 178 set ref 1168* 1170* 1180*
fcn                      27            based           structure                array level 2 dcl 337
find_condition_info_            000736 constant        entry                    external dcl 64 ref 1632
fixed                                                  builtin function         dcl 120 ref 1323 1323
fl                              000124 automatic       fixed bin(17,0)          dcl 158 set ref 524* 528 538 538
fp                              000102 automatic       pointer                  dcl 152 set ref 524* 528 538
full_recovery            73            based           bit(1)                   level 3 packed unaligned dcl 337 set ref 1036* 1106*
                                                                                  1136* 1433*
function                               based           char                     unaligned dcl 178 set ref 528 538*
function_index                  001224 constant        fixed bin(17,0)          initial array dcl 399 ref 529
function_table                  001250 constant        char(16)                 initial array dcl 377 ref 527 528 988 1044 1147 1456
                                                                                  1469 1474 1486
get_group_id_$tag_star          000740 constant        entry                    external dcl 64 ref 1406 1482 1491
get_process_id_                 000742 constant        entry                    external dcl 64 ref 1370 1438
get_wdir_                       000744 constant        entry                    external dcl 64 ref 1166
global_default                  000077 internal static structure                level 1 dcl 251 set ref 544 892 915
group_id                 17            based           char(32)                 level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 932 1042 1069 1086 1129 1157 1406* 1420
                                                                                  1474* 1482 1486* 1491*
group_id                 27            based           char(32)                 array level 3 in structure "log" dcl 337
                                                                                  in procedure "us" set ref 932* 1042* 1069* 1086*
                                                                                  1129* 1157* 1198* 1205* 1212* 1221* 1420*
hcs_$delentry_file              000746 constant        entry                    external dcl 64 ref 1394
i                               000125 automatic       fixed bin(17,0)          dcl 158 in procedure "us" set ref 527* 528 529* 572*
                                                                                  573 573 574 574* 581* 582* 614* 615 616* 646* 647
                                                                                  728* 730 730* 1005* 1006 1006 1007 1007 1008 1008
                                                                                  1009 1012 1014 1015 1017 1020 1022 1023*
i                               004543 automatic       fixed bin(17,0)          dcl 1697 in procedure "get_reason" set ref 1803*
                                                                                  1805 1806 1811* 1812*
in                                     based           structure                level 1 dcl 306 set ref 1104
index                                                  builtin function         dcl 120 ref 646 1167 1803
infop                    14     000100 automatic       pointer                  level 2 dcl 1618 set ref 1666*
init_id                   1            based           bit(36)                  level 2 dcl 337 set ref 1363 1371 1373* 1411* 1438*
init_log_segment                000434 automatic       char(168)                dcl 178 set ref 819* 820 820 825* 1750 1756 1759*
                                                                                  1767*
inp                             000110 automatic       pointer                  dcl 152 set ref 1104* 1105 1106 1106 1106 1106 1106
                                                                                  1106
io_name                   7            based           char(32)                 initial level 2 dcl 306 set ref 1104* 1105* 1106*
ioa_                            001122 constant        entry                    external dcl 1730 ref 1780 1849 1863
ioa_$ioa_stream                 000750 constant        entry                    external dcl 64 ref 908 912 916 920 923 968 1193
                                                                                  1198 1205 1212 1220 1221 1228 1234 1240 1244 1246
                                                                                  1251 1258 1634 1662 1669
iocb_ptr                        014756 automatic       pointer                  dcl 1738 set ref 1757* 1765* 1774* 1783* 1852* 1856*
ios_$attach                     000752 constant        entry                    external dcl 64 ref 899 954 955 1030 1092 1093 1182
                                                                                  1188
ios_$detach                     000754 constant        entry                    external dcl 64 ref 531 532 1264 1265
iox_$attach_name                001124 constant        entry                    external dcl 1730 ref 1757
iox_$close                      001136 constant        entry                    external dcl 1730 ref 1852
iox_$detach_iocb                001134 constant        entry                    external dcl 1730 ref 1856
iox_$find_iocb                  001126 constant        entry                    external dcl 1730 ref 1774
iox_$get_line                   001132 constant        entry                    external dcl 1730 ref 1783
iox_$open                       001130 constant        entry                    external dcl 1730 ref 1765
j                               000126 automatic       fixed bin(17,0)          dcl 158 set ref 641* 642 642 643 643 643 643 646 648
                                                                                  649 649 653
length                                                 builtin function         dcl 120 ref 964 1152 1783 1783 1798 1835
linkp                     6            based           pointer                  level 2 dcl 337 set ref 1035* 1102* 1371* 1413*
listdir                         000506 automatic       char(168)                unaligned dcl 178 set ref 1166* 1167 1168* 1176*
                                                                                  1182
listp                    10            based           pointer                  level 2 dcl 337 set ref 966 1053 1058 1074 1109 1144
                                                                                  1144 1154 1236 1242 1254 1260 1413* 1548*
listseg                         000561 automatic       char(32)                 unaligned dcl 178 set ref 1164* 1168* 1176* 1182
lock                     16            based           structure                level 2 dcl 337
log                                    based           structure                level 1 dcl 337 set ref 1321 1388
log_directory                          based           char(168)                level 2 in structure "default" dcl 284 in procedure
                                                                                  "us" set ref 912 912* 920 920*
log_directory            74            based           char(168)                level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 958* 1036* 1114* 1410*
log_directory                   000662 automatic       char(168)                level 2 in structure "t" dcl 267 in procedure "us"
                                                                                  set ref 844*
logdir                          000014 internal static char(168)                unaligned dcl 178 set ref 908* 933* 940* 978* 1054*
                                                                                  1077* 1147* 1193* 1300* 1301* 1307* 1312* 1321*
                                                                                  1323* 1335* 1341* 1350* 1357* 1378* 1383* 1388*
                                                                                  1394* 1395* 1456* 1469* 1474* 1486* 1511*
logging_sw               73(03)        based           bit(1)                   level 3 packed unaligned dcl 337 set ref 1040* 1040
                                                                                  1110* 1112 1434*
logp                            000010 internal static pointer                  initial dcl 154 set ref 577 905 907 928 931 932 932
                                                                                  933 940 945 958 958 958 958 958 958 958 958 966
                                                                                  973 1035 1036 1036 1036 1036 1036 1039 1039 1040
                                                                                  1040 1041 1042 1042 1048 1053 1058 1058 1058 1068
                                                                                  1069 1069 1070 1074 1076 1085 1086 1086 1102 1103
                                                                                  1106 1106 1106 1109 1109 1110 1110 1112 1114 1114
                                                                                  1114 1114 1118 1118 1118 1118 1118 1118 1118 1128
                                                                                  1129 1129 1136 1144 1144 1144 1154 1156 1157 1157
                                                                                  1158 1197 1198 1198 1203 1204 1205 1210 1211 1212
                                                                                  1217 1218 1221 1227 1230 1230 1230 1230 1230 1230
                                                                                  1236 1239 1242 1244 1254 1260 1286* 1289 1289 1289
                                                                                  1295* 1298* 1321 1321* 1363 1366* 1371 1371 1373
                                                                                  1388 1388* 1405 1406 1407 1409 1410 1411 1412 1412
                                                                                  1413 1413 1413 1413 1413 1413 1413 1420 1420 1423
                                                                                  1423 1423 1423 1423 1423 1423 1431 1433 1434 1434
                                                                                  1434 1438 1454 1456 1460* 1464 1474 1482 1486 1491
                                                                                  1495* 1509 1509 1510 1548 1572
logseg                          000066 internal static char(32)                 unaligned dcl 178 set ref 908* 933* 940* 978* 1054*
                                                                                  1077* 1105 1147* 1164* 1193* 1301* 1312* 1321*
                                                                                  1323* 1323* 1335* 1341* 1350* 1357* 1378* 1388*
                                                                                  1394* 1395* 1456* 1469* 1474* 1486* 1511*
logsw                     0(03)        based           bit(1)                   level 2 packed unaligned dcl 210 ref 939 957
longsw                    0(02)        based           bit(1)                   level 2 packed unaligned dcl 219 set ref 805* 1257
max                                                    builtin function         dcl 120 ref 726 730
maxl                            000571 automatic       fixed bin(18,0)          initial dcl 178 set ref 178* 586* 857* 866* 1027
maxlen                  262            based           fixed bin(18,0)          level 2 dcl 321 set ref 1027* 1036*
mcp                                    parameter       pointer                  dcl 1542 in procedure "thread_task" ref 1539
mcp                                    parameter       pointer                  dcl 1558 in procedure "task_error" ref 1556
mcp                                    parameter       pointer                  dcl 1588 in procedure "linkage_err" ref 1585
mcptr                           000100 automatic       pointer                  level 2 dcl 1618 set ref 1666*
mlsw                      0(05)        based           bit(1)                   level 2 packed unaligned dcl 210 set ref 853*
mod                                                    builtin function         dcl 120 ref 1167 1317
mode                            000127 automatic       fixed bin(5,0)           dcl 158 in procedure "us" set ref 1301* 1317
mode                     66     000662 automatic       bit(36)                  array level 4 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 680* 683*
msa_manager_$area_handler       000756 constant        entry                    external dcl 64 ref 1002 1002 1098 1098
msa_manager_$initiate           000762 constant        entry                    external dcl 64 ref 1321
msa_manager_$make_special       000760 constant        entry                    external dcl 64 ref 1388
msa_manager_$terminate          000764 constant        entry                    external dcl 64 ref 1364
msa_ptr                         000012 internal static pointer                  initial dcl 154 set ref 945 1004 1011 1019 1035 1036
                                                                                  1102 1104 1106 1113 1114 1118 1299* 1321* 1323
                                                                                  1323 1361 1364* 1366* 1388* 1390* 1409
msf_manager_$adjust             000766 constant        entry                    external dcl 64 ref 1170
msf_manager_$close              000770 constant        entry                    external dcl 64 ref 1180
msf_manager_$open               000772 constant        entry                    external dcl 64 ref 1168
n                       151            based           fixed bin(17,0)          level 4 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1423*
n                      2016     000662 automatic       fixed bin(17,0)          array level 3 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 574* 756* 998 1017
n                        55            based           fixed bin(17,0)          level 3 in structure "default" dcl 284 in procedure
                                                                                  "us" set ref 911* 919*
n                               000130 automatic       fixed bin(17,0)          dcl 158 in procedure "us" set ref 665* 671* 671 672
                                                                                  678 680 683 686 690 695 701* 704* 704 714 714 718
                                                                                  719 723 725* 726 728 728 739* 742* 742 745 751 752
                                                                                  753 756 1009* 1010 1011 1013 1015 1017* 1018 1019
                                                                                  1021 1023
n                        55     000662 automatic       fixed bin(17,0)          array level 3 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 574* 579* 695* 871* 1009
name                                   parameter       char                     unaligned dcl 1542 in procedure "thread_task" ref
                                                                                  1539
name                                   parameter       char                     unaligned dcl 1558 in procedure "task_error" ref
                                                                                  1556
name                                   parameter       char                     unaligned dcl 1588 in procedure "linkage_err" ref
                                                                                  1585
name                   2017     000662 automatic       char(32)                 array level 4 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 751* 998
names                                  based           structure                array level 1 dcl 301 in procedure "us" set ref 1019
                                                                                  1021* 1021
names                  2016     000662 automatic       structure                array level 2 in structure "t" dcl 267 in procedure
                                                                                  "us"
nargs                           000131 automatic       fixed bin(17,0)          dcl 158 set ref 516* 517 598 612
nelemt                          004547 automatic       fixed bin(21,0)          dcl 1697 set ref 1783* 1791 1794 1795* 1798 1803
                                                                                  1812 1816 1817* 1817 1833 1833 1834
nn                       23            based           fixed bin(17,0)          initial array level 2 dcl 321 set ref 1004* 1004*
                                                                                  1004* 1023* 1036*
no_chars                  1            based           fixed bin(35,0)          level 2 dcl 1715 set ref 1844* 1846* 1847
nofillsw                               parameter       bit(1)                   dcl 1688 in procedure "get_reason" ref 1682 1800
                                                                                  1845
nofillsw                        000640 automatic       bit(1)                   dcl 200 in procedure "us" set ref 556* 876* 880*
                                                                                  945*
np                       12            based           pointer                  initial array level 2 dcl 321 set ref 1004* 1004*
                                                                                  1004* 1022* 1036*
npath                           000132 automatic       fixed bin(17,0)          dcl 158 set ref 549* 553* 562* 566* 584* 591* 637*
                                                                                  637 638 641 903 983 993 998 1284
null                                                   builtin function         dcl 120 in procedure "us" ref 820 820 840 840 905
                                                                                  933 940 958 973 1004 1004 1004 1004 1004 1004 1004
                                                                                  1004 1053 1074 1103 1104 1104 1110 1113 1113 1144
                                                                                  1227 1286 1289 1295 1298 1299 1361 1366 1390 1413
                                                                                  1460 1495 1509 1632 1632 1666 1666 1666 1666
null                                                   builtin function         dcl 1697 in procedure "get_reason" ref 1747 1841
nullp                    14            based           pointer                  level 2 dcl 337 set ref 958* 958* 958* 958* 1036*
                                                                                  1106* 1114* 1118* 1230* 1230* 1230* 1230* 1413*
old_namesw                0(01)        based           bit(1)                   level 2 packed unaligned dcl 210 set ref 762*
option                          000133 automatic       fixed bin(17,0)          dcl 158 set ref 595* 598 607 609 616* 617 619 661
                                                                                  673 719* 732* 736 746 884*
option_index                    000670 constant        fixed bin(17,0)          initial array dcl 451 ref 616
option_matrix                   000230 constant        fixed bin(17,0)          initial array dcl 456 ref 616
option_table                    000744 constant        char(16)                 initial array dcl 403 ref 614 615 673 746
options                 263            based           bit(36)                  level 2 dcl 321 set ref 1026* 1036*
out_buffer                      004754 automatic       char(16384)              dcl 1711 set ref 1746* 1798 1824* 1826 1826 1830*
                                                                                  1833* 1835 1847
owp                             000644 automatic       pointer                  dcl 207 set ref 514* 762 766 801 805 809 828 832 853
                                                                                  939 957 1144 1250 1257
p                               000104 automatic       pointer                  dcl 152 set ref 542* 545 576* 578 892* 894 907* 908
                                                                                  908 908 911 911 911 912 912 915* 916 916 916 919
                                                                                  919 919 920 920 928* 930 1011* 1013 1014 1019*
                                                                                  1021 1022
path_matrix                     000164 constant        fixed bin(17,0)          initial array dcl 482 ref 641
pcode                  2027     000662 automatic       fixed bin(35,0)          array level 4 dcl 267 set ref 752*
pmax                            000150 constant        fixed bin(17,0)          initial array dcl 496 ref 638 984 988
pmin                            000134 constant        fixed bin(17,0)          initial array dcl 496 ref 983 984 988
print_option_word                      based           structure                level 1 dcl 219
proc                            001370 constant        char(10)                 initial dcl 178 in procedure "us" ref 518 518 538
                                                                                  604 622 625 625 673 746 774 781 859 933 940 978
                                                                                  988 1044 1044 1054 1077 1124 1133 1147 1147 1176
                                                                                  1198 1307 1312 1323 1335 1341 1350 1357 1378 1383
                                                                                  1395 1456 1456 1469 1469 1474 1474 1486 1486 1511
                                                                                  1759 1767 1776 1787 1854 1859
proc                                   based           char(32)                 level 2 in structure "s" packed unaligned dcl 1564
                                                                                  in procedure "task_error" set ref 1574* 1577*
proc                                   based           char(32)                 level 2 in structure "s" dcl 1594 in procedure
                                                                                  "linkage_err" set ref 1603*
process_id                      000100 automatic       bit(36)                  dcl 1279 set ref 1370* 1371 1373
processp                 12            based           pointer                  level 2 dcl 337 set ref 933 940 973 1058 1103 1109*
                                                                                  1118* 1144 1413*
q                               000106 automatic       pointer                  dcl 152 set ref 544* 545 577* 578 893* 894 929* 930
                                                                                  1012* 1013 1020* 1021
query_info                      000667 internal static structure                level 1 dcl 502 set ref 1486 1486
r                               000134 automatic       fixed bin(17,0)          dcl 158 set ref 705* 710 712 714 718
rb                      146            based           fixed bin(17,0)          array level 3 in structure "log" dcl 337
                                                                                  in procedure "us" set ref 1423* 1423* 1423*
rb                       52     000662 automatic       fixed bin(17,0)          array level 2 in structure "t" dcl 267 in procedure
                                                                                  "us" set ref 582* 714 718* 726* 730* 730 1008
rb                       52            based           fixed bin(17,0)          array level 2 in structure "default" dcl 284
                                                                                  in procedure "us" set ref 908* 908* 908* 916* 916*
                                                                                  916*
rb                      257            based           fixed bin(5,0)           array level 2 in structure "rq" dcl 321 in procedure
                                                                                  "us" set ref 1008* 1036*
rcode                  2030     000662 automatic       fixed bin(35,0)          array level 4 dcl 267 set ref 753*
rcp                                    parameter       pointer                  dcl 1688 set ref 1682 1841* 1848*
ref_ptr                         015072 automatic       pointer                  dcl 1738 set ref 1747* 1757*
request_option_word                    based           structure                level 1 dcl 210
reversion_                      000776 constant        entry                    external dcl 64 ref 1122 1132
rname                    22            based           char(32)                 level 2 dcl 1594 set ref 1603*
rq                                     based           structure                level 1 dcl 321 set ref 1004
rqp                             000112 automatic       pointer                  dcl 152 set ref 1004* 1006 1007 1008 1014 1015 1022
                                                                                  1023 1026 1027 1036 1036 1036 1036 1036 1036 1036
                                                                                  1036 1036 1036 1036 1036 1036 1036
rstrtsw                         000641 automatic       bit(1)                   dcl 200 set ref 554* 788* 927*
s                                      based           structure                level 1 dcl 1594 in procedure "linkage_err"
s                                      based           structure                level 1 dcl 1564 in procedure "task_error"
seg                     227            based           char(32)                 array level 2 in structure "rq" packed unaligned
                                                                                  dcl 321 in procedure "us" set ref 1007* 1036*
seg                             000572 automatic       char(32)                 array unaligned dcl 178 in procedure "us" set ref
                                                                                  573* 642* 643 643 646 648 649 649 653 995* 995
                                                                                  998* 1007 1301* 1307* 1383*
seg_fault_error                 000102 stack reference condition                dcl 1281 ref 1285 1291
selfp                     2            based           pointer                  level 2 dcl 337 set ref 1289 1412*
seqno                     6            based           fixed bin(17,0)          initial level 2 in structure "in" dcl 306
                                                                                  in procedure "us" set ref 1104* 1106*
seqno                   674            based           fixed bin(17,0)          level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1118* 1431*
seqno                     4            based           fixed bin(17,0)          initial level 2 in structure "desc" dcl 314
                                                                                  in procedure "us" set ref 1113* 1114*
seqno                    30            based           fixed bin(17,0)          initial level 2 in structure "rq" dcl 321
                                                                                  in procedure "us" set ref 1004* 1036*
set_lock_$lock                  001000 constant        entry                    external dcl 64 ref 1464
set_lock_$unlock                001002 constant        entry                    external dcl 64 ref 1510
sev                       5            based           fixed bin(17,0)          initial level 2 in structure "in" dcl 306
                                                                                  in procedure "us" set ref 1104* 1106*
sev                       3            based           fixed bin(17,0)          initial level 2 in structure "desc" dcl 314
                                                                                  in procedure "us" set ref 1113* 1114*
sev                     673            based           fixed bin(17,0)          level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1118* 1423*
sev                      21            based           fixed bin(17,0)          level 2 in structure "s" dcl 1594 in procedure
                                                                                  "linkage_err" set ref 1603*
sev                      21            based           fixed bin(17,0)          level 2 in structure "s" dcl 1564 in procedure
                                                                                  "task_error" set ref 1573 1574* 1577*
sev                      27            based           fixed bin(17,0)          initial level 2 in structure "rq" dcl 321
                                                                                  in procedure "us" set ref 1004* 1036*
size                                                   builtin function         dcl 120 ref 1321 1388
sp                                     parameter       pointer                  dcl 1558 in procedure "task_error" ref 1556 1573
                                                                                  1574 1574 1574 1574 1574 1577 1577 1577 1577 1577
sp                                     parameter       pointer                  dcl 1588 in procedure "linkage_err" ref 1585 1603
                                                                                  1603 1603 1603 1603 1603
spec_segsw                0(02)        based           bit(1)                   level 2 packed unaligned dcl 210 set ref 809*
special_segs             73(01)        based           bit(1)                   level 3 packed unaligned dcl 337 set ref 1039* 1039
                                                                                  1106* 1434*
stat                                   based           structure                level 1 unaligned dcl 247
state                           000135 automatic       fixed bin(17,0)          dcl 158 set ref 664* 668 687* 691*
status                          000136 automatic       bit(72)                  dcl 158 set ref 531* 532* 899* 954* 955* 1030* 1092*
                                                                                  1093* 1182* 1184 1185 1188* 1264* 1265*
stopsw                          000642 automatic       bit(1)                   dcl 200 set ref 590* 793* 1088 1668
string                   22            based           char(200)                level 2 in structure "s" dcl 1564 in procedure
                                                                                  "task_error" set ref 1574* 1577*
string                    2            based           char                     level 2 in structure "block" packed unaligned
                                                                                  dcl 1715 in procedure "get_reason" set ref 1847*
substr                                                 builtin function         dcl 1697 in procedure "get_reason" set ref 1791
                                                                                  1796* 1803 1806* 1812 1816* 1821 1824* 1826 1826
                                                                                  1830* 1833* 1833 1847
substr                                                 builtin function         dcl 120 in procedure "us" set ref 607 789* 797* 813*
                                                                                  870* 964 1039 1040 1123* 1123 1152 1182 1529
suffixed_name_$find             001004 constant        entry                    external dcl 64 ref 1301
suffixed_name_$new_suffix       001006 constant        entry                    external dcl 64 ref 1164
sw                                     parameter       bit(1)                   dcl 1277 in procedure "init_log" ref 1274 1305 1391
sw                       73            based           structure                level 2 in structure "log" dcl 337 in procedure "us"
switch_name                     015060 automatic       char(32)                 unaligned dcl 1738 set ref 1755* 1757*
sws                             000643 automatic       bit(36)                  dcl 200 set ref 514 555* 560* 585* 789* 797* 813*
                                                                                  870* 964 1026 1039 1040 1152
sys_info$default_max_length     001110 external static fixed bin(17,0)          dcl 147 ref 586
sys_info$max_seg_size           001112 external static fixed bin(17,0)          dcl 147 ref 866
t                       666            based           structure                level 2 in structure "log" dcl 337 in procedure "us"
t                               000662 automatic       structure                level 1 dcl 267 in procedure "us" set ref 542 576
                                                                                  893 929
tab_sw                          004546 automatic       bit(1)                   unaligned dcl 1697 set ref 1802* 1807* 1849
taskp                     2            based           pointer                  initial level 2 in structure "rq" dcl 321
                                                                                  in procedure "us" set ref 1004* 1036*
taskp                                  parameter       pointer                  dcl 1542 in procedure "thread_task" set ref 1539
                                                                                  1548*
taskp                     2            based           pointer                  initial level 2 in structure "in" dcl 306
                                                                                  in procedure "us" set ref 1104* 1106*
taskp                   666            based           pointer                  level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1118* 1413*
taskp                                  based           pointer                  initial level 2 in structure "desc" dcl 314
                                                                                  in procedure "us" set ref 1113* 1114*
temp                      6            based           pointer                  initial level 2 in structure "desc" dcl 314
                                                                                  in procedure "us" set ref 1113* 1114*
temp                                   based           pointer                  initial level 2 in structure "in" dcl 306
                                                                                  in procedure "us" set ref 1104* 1106*
temp                                   based           pointer                  initial level 2 in structure "rq" dcl 321
                                                                                  in procedure "us" set ref 1004* 1036*
temp                    670            based           pointer                  level 3 in structure "log" dcl 337 in procedure "us"
                                                                                  set ref 1118* 1413*
term_line                       014754 automatic       char(1)                  initial array unaligned dcl 1720 set ref 1720* 1720*
                                                                                  1720* 1720* 1812
time                            004532 automatic       fixed bin(71,0)          dcl 1523 set ref 1528* 1529
time_str                               based           bit(72)                  dcl 1523 ref 1529
total                           004544 automatic       fixed bin(17,0)          dcl 1697 set ref 1745* 1798 1821 1823* 1823 1824
                                                                                  1826 1826 1826 1829* 1829 1830 1833 1834* 1834
                                                                                  1835 1839 1844 1844 1846 1847
tseg                            000622 automatic       char(32)                 unaligned dcl 178 set ref 648* 649 649
type                            000140 automatic       fixed bin(2,0)           dcl 158 set ref 1301* 1311
uidsw                     0(01)        based           bit(1)                   level 2 packed unaligned dcl 226 set ref 832*
upd_add_task_$init              001010 constant        entry                    external dcl 64 ref 1035 1102
upd_add_task_$reset             001012 constant        entry                    external dcl 64 ref 1371
upd_describe_task_              001030 constant        entry                    external dcl 109 ref 958 1114 1230
upd_gen_call_                   001014 constant        entry                    external dcl 64 ref 966 966 1154 1154 1236 1236 1242
                                                                                  1242 1254 1254 1260 1260
upd_install_task_               001024 constant        entry                    external dcl 109 ref 1036
upd_install_task_$init          001026 constant        entry                    external dcl 109 ref 1106
upd_print_acl_                  000774 constant        entry                    external dcl 64 ref 911 919
upd_print_err_                  001016 constant        entry                    external dcl 64 ref 1574 1577 1603
upd_subtask_                    001032 constant        entry                    external dcl 109 ref 1118
upd_task_                       001020 constant        entry                    external dcl 64 ref 966 1154 1236 1242 1254 1260
upd_thread_task_                001022 constant        entry                    external dcl 64 ref 1548
userid                   56     000662 automatic       char(32)                 array level 4 dcl 267 set ref 686* 690*
version                                based           char(4)                  level 2 dcl 337 set ref 1198* 1407* 1454 1456*
wcp                                    parameter       pointer                  dcl 1588 in procedure "linkage_err" ref 1585
wcp                                    parameter       pointer                  dcl 1558 in procedure "task_error" ref 1556
wcp                                    parameter       pointer                  dcl 1542 in procedure "thread_task" ref 1539
wcptr                    16     000100 automatic       pointer                  level 2 dcl 1618 set ref 1666*
word                     16            based           bit(36)                  level 3 dcl 337 set ref 1405* 1464* 1509 1510*
xxx                             000632 automatic       char(16)                 unaligned dcl 178 set ref 1067* 1084* 1124* 1127*
                                                                                  1133*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
init_option_word                       based           structure                level 1 dcl 235
install_option_word                    based           structure                level 1 dcl 231

NAMES DECLARED BY EXPLICIT CONTEXT.
DETACH_ILS                      020136 constant        label                    dcl 1856 ref 1770
RETURN                          020065 constant        label                    dcl 1851 ref 1789 1842
STOP                            017120 constant        label                    dcl 1669 ref 1663
aarg                            000014 constant        label                    array(0:21) dcl 637 ref 609
aarg2a                          005134 constant        label                    dcl 690 ref 681
abgn                            000070 constant        label                    array(24) dcl 661 ref 619
abort                           011546 constant        label                    dcl 1132 ref 1088 1125
aend                            000042 constant        label                    array(0:21) dcl 658 ref 598 607
argerr                          004356 constant        label                    dcl 604 ref 525 644 650 684 708 716 821 842 850
badopt                          004471 constant        label                    dcl 622 ref 617
ckopt                           004434 constant        label                    dcl 612 ref 658 698 733 759 785 826 867
clean_up                        013652 constant        label                    dcl 1264 ref 924 970 1082 1126 1134 1138
cleanerr                        013701 constant        label                    dcl 1265 ref 1043 1049
command_ignored                 010374 constant        label                    dcl 1044 ref 1029
continue                        016716 constant        label                    dcl 1639 ref 1642 1645 1647 1649 1651 1653 1655 1657
default_handler                 016633 constant        entry                    internal dcl 1615 ref 1100 1100
endopt                          006142 constant        label                    dcl 884 ref 763 767 790 794 798 802 806 810 816 823
                                                                                  829 833 846 863 873 877 881
fs_date                         016336 constant        entry                    internal dcl 1521 ref 931 1041 1068 1085 1128 1156
full_recovery_off               011622 constant        label                    dcl 1136 ref 1064
get_reason                      017156 constant        entry                    internal dcl 1682 ref 945
init                            000000 constant        label                    array(12) dcl 542 ref 535
init_high                       015123 constant        label                    dcl 1388 ref 1367
init_log                        013732 constant        entry                    internal dcl 1274 ref 571 903 927 953 1052 1073 1143
                                                                                  1163
join0                           004167 constant        label                    dcl 542 ref 557
join1                           004324 constant        label                    dcl 595 ref 546 550 563 587
linkage_err                     016534 constant        entry                    internal dcl 1585 ref 965 965 1033 1033 1096 1096
                                                                                  1153 1153 1190 1190
listerr                         012217 constant        label                    dcl 1176 ref 1171 1186
lockerr                         015746 constant        label                    dcl 1474 ref 1473
logerr                          004530 constant        label                    dcl 625 ref 243
nolistp                         010473 constant        label                    dcl 1054 ref 1074
nxtarg                          004326 constant        label                    dcl 597 ref 656 666 693 702 721 740 754 770 778 814
                                                                                  836 854 885
path_err                        007413 constant        label                    dcl 984 ref 638
process                         020001 constant        label                    dcl 1839 ref 1784 1791 1865
randomerr                       015040 constant        label                    dcl 1383 ref 1391 1402
rberr                           005251 constant        label                    dcl 715 ref 710 712
re_init_fail                    014064 constant        label                    dcl 1307 ref 1319 1361
read                            017541 constant        label                    dcl 1783 ref 1837
recover                         011440 constant        label                    dcl 1122 ref 1090 1672
rerun                           011407 constant        label                    dcl 1118 set ref 1130
return                          004614 constant        label                    dcl 629 ref 559 605 623 676 749 776 861 950 981 991
                                                                                  1056 1080 1150 1178 1267 1359 1461 1496
return_without_unlocking        004620 constant        label                    dcl 630 ref 1309 1315 1339 1380 1386 1400 1478
skip_print                      007271 constant        label                    dcl 968 ref 962
start                           000120 constant        label                    array(12) dcl 892 ref 612
start11a                        011745 constant        label                    dcl 1153 ref 1062
start2a                         006375 constant        label                    dcl 915 set ref 900 905
start9a                         010551 constant        label                    dcl 1064 ref 1060
start9b                         010703 constant        label                    dcl 1088 ref 1071
tab                             017661 constant        label                    dcl 1803 ref 1808
task_error                      016400 constant        entry                    internal dcl 1556 ref 1032 1032 1095 1095
thread_task                     016351 constant        entry                    internal dcl 1539 ref 1034 1034 1097 1097
unlock_log                      016245 constant        entry                    internal dcl 1507 ref 533 629
update_seg                      003677 constant        entry                    external dcl 10
us                              003667 constant        entry                    external dcl 10
validate_user                   015456 constant        entry                    internal dcl 1452 ref 1292 1369 1408
warn                            020207 constant        label                    dcl 1863 ref 1798 1835

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     21426       22566   20243       21436
Length     23374   20243      1140         572    1163         664

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
us                                 7008 external procedure  is an external procedure.  
on unit on line 530                  90 on unit               
init_log                            438 internal procedure  enables or reverts conditions.  
on unit on line 1285                 64 on unit               
validate_user                           internal procedure  shares stack frame of internal procedure init_log.  
unlock_log                          100 internal procedure  is called by several nonquick procedures.  
fs_date                                 internal procedure  shares stack frame of external procedure us.  
thread_task                          72 internal procedure  is assigned to an entry variable.  
task_error                           98 internal procedure  is assigned to an entry variable.  
linkage_err                         118 internal procedure  is assigned to an entry variable.  
default_handler                     162 internal procedure  is assigned to an entry variable.  
get_reason                              internal procedure  shares stack frame of external procedure us.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 logp                        us
000012 msa_ptr                     us
000014 logdir                      us
000066 logseg                      us
000076 Version_No                  us
000077 global_default              us
000667 query_info                  us

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
default_handler          000100 cond_info                   default_handler
init_log                 000100 process_id                  init_log
us                       000100 argp                        us
                         000102 fp                          us
                         000104 p                           us
                         000106 q                           us
                         000110 inp                         us
                         000112 rqp                         us
                         000114 desp                        us
                         000116 a                           us
                         000117 argi                        us
                         000120 argl                        us
                         000121 code                        us
                         000122 f                           us
                         000123 fail                        us
                         000124 fl                          us
                         000125 i                           us
                         000126 j                           us
                         000127 mode                        us
                         000130 n                           us
                         000131 nargs                       us
                         000132 npath                       us
                         000133 option                      us
                         000134 r                           us
                         000135 state                       us
                         000136 status                      us
                         000140 type                        us
                         000141 answer                      us
                         000142 date                        us
                         000150 dir                         us
                         000346 doc_dir                     us
                         000420 docsw                       us
                         000421 dummy                       us
                         000422 eqseg                       us
                         000432 fcbp                        us
                         000434 init_log_segment            us
                         000506 listdir                     us
                         000560 Llistdir                    us
                         000561 listseg                     us
                         000571 maxl                        us
                         000572 seg                         us
                         000622 tseg                        us
                         000632 xxx                         us
                         000636 ctlw                        us
                         000637 eqsw                        us
                         000640 nofillsw                    us
                         000641 rstrtsw                     us
                         000642 stopsw                      us
                         000643 sws                         us
                         000644 owp                         us
                         000646 endlabel                    us
                         000652 errlabel                    us
                         000656 faultlabel                  us
                         000662 t                           us
                         004530 date                        fs_date
                         004532 time                        fs_date
                         004542 code                        get_reason
                         004543 i                           get_reason
                         004544 total                       get_reason
                         004545 break_sw                    get_reason
                         004546 tab_sw                      get_reason
                         004547 nelemt                      get_reason
                         004550 blockp                      get_reason
                         004552 buffp                       get_reason
                         004554 buffer                      get_reason
                         004754 out_buffer                  get_reason
                         014754 term_line                   get_reason
                         014756 iocb_ptr                    get_reason
                         014760 atd                         get_reason
                         015060 switch_name                 get_reason
                         015070 Path                        get_reason
                         015072 ref_ptr                     get_reason

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          tra_ext_1           tra_ext_2           mdfx1               enable_op
shorten_stack       ext_entry           int_entry           int_entry_desc      clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                condition_                    condition_interpreter_
continue_to_signal_           cu_$arg_count                 cu_$arg_ptr                   cu_$cl
cu_$level_get                 cv_dec_check_                 cv_mode_                      cv_userid_
date_time_                    date_time_$fstime             equal_                        expand_path_
find_condition_info_          get_group_id_$tag_star        get_process_id_               get_wdir_
hcs_$delentry_file            ioa_                          ioa_$ioa_stream               ios_$attach
ios_$detach                   iox_$attach_name              iox_$close                    iox_$detach_iocb
iox_$find_iocb                iox_$get_line                 iox_$open                     msa_manager_$area_handler
msa_manager_$initiate         msa_manager_$make_special     msa_manager_$terminate        msf_manager_$adjust
msf_manager_$close            msf_manager_$open             reversion_                    set_lock_$lock
set_lock_$unlock              smart_alloc_                  suffixed_name_$find           suffixed_name_$new_suffix
upd_add_task_$init            upd_add_task_$reset           upd_describe_task_            upd_gen_call_
upd_install_task_             upd_install_task_$init        upd_print_acl_                upd_print_err_
upd_subtask_                  upd_task_                     upd_thread_task_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_conversion   error_table_$bad_ring_brackets                              error_table_$badcall
error_table_$badopt           error_table_$dirseg           error_table_$end_of_info      error_table_$fatal_error
error_table_$improper_data_format                           error_table_$invalid_lock_reset
error_table_$lock_wait_time_exceeded                        error_table_$locked_by_this_process
error_table_$moderr           error_table_$namedup          error_table_$noentry          error_table_$not_detached
error_table_$not_done         error_table_$out_of_bounds    error_table_$out_of_sequence  error_table_$seg_not_found
error_table_$seglock          error_table_$segno_in_use     error_table_$short_record
error_table_$too_many_acl_entries                           error_table_$too_many_names   error_table_$wrong_no_of_args
sys_info$default_max_length   sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    178 003657       243 003661        10 003666       514 003705       516 003707       517 003716       518 003720
    521 003757       523 003760       524 003762       525 003777       527 004001       528 004007       529 004017
    530 004022       531 004036       532 004065       533 004115       534 004122       535 004123       537 004125
    538 004127       539 004166       542 004167       544 004171       545 004174       546 004177       549 004200
    550 004201       553 004202       554 004203       555 004204       556 004205       557 004206       559 004207
    560 004212       562 004213       563 004214       566 004215       570 004216       571 004220       572 004230
    573 004235       574 004250       575 004256       576 004260       577 004262       578 004266       579 004271
    581 004275       582 004307       583 004310       584 004312       585 004313       586 004314       587 004317
    590 004320       591 004321       592 004322       595 004324       596 004325       597 004326       598 004327
    600 004334       601 004351       602 004353       603 004355       604 004356       605 004422       607 004423
    609 004432       612 004434       614 004441       615 004447       616 004457       617 004465       619 004466
    621 004467       622 004471       623 004527       625 004530       629 004614       630 004620       637 004621
    638 004622       640 004626       641 004633       642 004640       643 004654       644 004677       646 004701
    647 004716       648 004721       649 004724       650 004750       653 004752       654 004760       656 004762
    658 004763       661 004764       664 004765       665 004766       666 004767       668 004770       671 004772
    672 004773       673 004776       676 005051       678 005052       679 005061       680 005065       681 005067
    683 005070       684 005115       686 005117       687 005131       688 005133       690 005134       691 005170
    693 005171       695 005172       698 005177       701 005200       702 005201       704 005202       705 005203
    706 005230       707 005232       708 005235       710 005236       712 005240       714 005242       715 005251
    716 005254       718 005255       719 005260       721 005264       723 005265       725 005267       726 005271
    728 005306       730 005317       731 005337       732 005341       733 005342       736 005343       739 005345
    740 005346       742 005347       745 005350       746 005353       749 005426       751 005427       752 005442
    753 005446       754 005447       756 005450       759 005455       762 005456       763 005460       766 005461
    767 005463       770 005464       772 005465       773 005512       774 005514       776 005562       778 005563
    780 005564       781 005571       783 005651       785 005652       788 005653       789 005655       790 005657
    793 005660       794 005662       797 005663       798 005665       801 005666       802 005670       805 005671
    806 005673       809 005674       810 005676       813 005677       814 005701       816 005704       819 005705
    820 005710       821 005733       823 005735       825 005736       826 005741       828 005742       829 005744
    832 005745       833 005747       836 005750       839 005751       840 005754       842 006004       844 006006
    845 006011       846 006013       849 006014       850 006017       853 006020       854 006022       857 006023
    858 006050       859 006052       861 006120       863 006121       866 006122       867 006125       870 006126
    871 006130       873 006134       876 006135       877 006136       880 006137       881 006141       884 006142
    885 006143       892 006144       893 006147       894 006151       895 006154       899 006155       900 006222
    903 006225       905 006236       907 006243       908 006246       911 006312       912 006341       915 006375
    916 006400       919 006434       920 006463       923 006517       924 006537       927 006540       928 006546
    929 006552       930 006554       931 006557       932 006566       933 006573       939 006670       940 006673
    945 007000       950 007012       953 007013       954 007023       955 007070       957 007134       958 007137
    962 007204       964 007205       965 007213       966 007241       968 007271       970 007311       973 007312
    978 007320       981 007407       983 007410       984 007413       986 007423       988 007426       991 007531
    993 007532       994 007540       995 007543       998 007546      1002 007563      1004 007605      1005 007724
   1006 007731      1007 007740      1008 007750      1009 007754      1010 007760      1011 007761      1012 010001
   1013 010005      1014 010014      1015 010020      1017 010023      1018 010027      1019 010030      1020 010050
   1021 010054      1022 010063      1023 010067      1025 010072      1026 010074      1027 010077      1028 010101
   1029 010103      1030 010106      1032 010152      1033 010176      1034 010224      1035 010251      1036 010263
   1039 010344      1040 010353      1041 010360      1042 010366      1043 010373      1044 010374      1048 010450
   1049 010454      1052 010455      1053 010465      1054 010473      1056 010533      1058 010534      1060 010543
   1061 010546      1062 010550      1064 010551      1066 010554      1067 010556      1068 010561      1069 010571
   1070 010576      1071 010577      1073 010600      1074 010610      1076 010616      1077 010620      1080 010657
   1082 010660      1083 010663      1084 010665      1085 010670      1086 010676      1088 010703      1090 010711
   1092 010714      1093 010760      1095 011024      1096 011050      1097 011076      1098 011123      1100 011146
   1102 011172      1103 011204      1104 011212      1105 011241      1106 011245      1109 011304      1110 011311
   1112 011320      1113 011323      1114 011351      1118 011407      1120 011437      1122 011440      1123 011455
   1124 011463      1125 011517      1126 011522      1127 011525      1128 011530      1129 011540      1130 011545
   1132 011546      1133 011563      1134 011621      1136 011622      1138 011626      1143 011627      1144 011637
   1147 011654      1150 011737      1152 011740      1153 011745      1154 011773      1156 012023      1157 012033
   1158 012040      1160 012045      1163 012046      1164 012056      1166 012111      1167 012123      1168 012136
   1169 012163      1170 012165      1171 012210      1173 012212      1174 012213      1176 012217      1178 012257
   1180 012260      1182 012267      1184 012354      1185 012357      1186 012360      1188 012361      1190 012424
   1192 012452      1193 012471      1197 012552      1198 012570      1203 012700      1204 012704      1205 012720
   1210 012775      1211 013001      1212 013015      1217 013071      1218 013075      1220 013111      1221 013134
   1227 013210      1228 013216      1230 013240      1234 013304      1235 013327      1236 013331      1239 013361
   1240 013366      1241 013410      1242 013412      1243 013442      1244 013443      1246 013470      1250 013512
   1251 013515      1253 013540      1254 013542      1257 013572      1258 013575      1259 013620      1260 013622
   1264 013652      1265 013701      1267 013730      1274 013731      1284 013737      1285 013742      1286 013756
   1287 013760      1289 013764      1291 013776      1292 013777      1293 014000      1295 014001      1296 014003
   1298 014006      1299 014010      1300 014011      1301 014014      1305 014055      1306 014061      1307 014064
   1309 014125      1311 014130      1312 014133      1315 014213      1317 014216      1318 014222      1319 014225
   1321 014226      1322 014264      1323 014267      1332 014400      1335 014402      1339 014470      1341 014473
   1350 014570      1357 014651      1359 014707      1361 014712      1363 014717      1364 014722      1366 014732
   1367 014736      1369 014737      1370 014740      1371 014747      1373 014762      1374 014766      1377 014767
   1378 014772      1380 015032      1382 015035      1383 015040      1386 015120      1388 015123      1389 015166
   1390 015171      1391 015174      1392 015200      1394 015203      1395 015224      1400 015320      1402 015323
   1405 015324      1406 015327      1407 015335      1408 015340      1409 015341      1410 015345      1411 015351
   1412 015352      1413 015353      1420 015372      1423 015414      1431 015435      1433 015437      1434 015441
   1438 015447      1441 015455      1452 015456      1454 015457      1456 015463      1460 015606      1461 015611
   1464 015614      1465 015631      1469 015640      1473 015744      1474 015746      1478 016062      1482 016065
   1486 016102      1491 016217      1495 016235      1496 016240      1499 016243      1507 016244      1509 016252
   1510 016261      1511 016272      1514 016335      1521 016336      1528 016340      1529 016342      1530 016345
   1539 016350      1548 016364      1549 016376      1556 016377      1572 016413      1573 016416      1574 016425
   1575 016466      1577 016471      1579 016532      1585 016533      1603 016547      1605 016624      1606 016631
   1615 016632      1632 016640      1633 016657      1634 016662      1635 016706      1638 016711      1639 016716
   1640 016726      1642 016727      1645 016734      1647 016741      1649 016746      1651 016753      1653 016760
   1655 016765      1657 016772      1659 016777      1661 017004      1662 017011      1663 017035      1666 017036
   1668 017114      1669 017120      1671 017144      1672 017151      1675 017154      1682 017156      1720 017160
   1745 017205      1746 017206      1747 017212      1748 017214      1750 017216      1752 017225      1754 017226
   1755 017230      1756 017233      1757 017246      1758 017277      1759 017304      1762 017346      1765 017347
   1766 017370      1767 017372      1770 017436      1772 017437      1774 017440      1775 017465      1776 017467
   1780 017526      1783 017541      1784 017562      1786 017566      1787 017572      1789 017630      1791 017631
   1794 017640      1795 017643      1796 017645      1798 017647      1800 017653      1802 017660      1803 017661
   1805 017673      1806 017674      1807 017677      1808 017701      1810 017702      1811 017703      1812 017711
   1814 017720      1815 017722      1816 017724      1817 017730      1821 017732      1823 017740      1824 017741
   1826 017745      1829 017757      1830 017760      1833 017764      1834 017772      1835 017775      1837 020000
   1839 020001      1841 020003      1842 020006      1844 020007      1845 020035      1847 020041      1848 020046
   1849 020047      1851 020065      1852 020066      1854 020101      1856 020136      1859 020151      1861 020206
   1863 020207      1865 020223


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
