	COMPILATION LISTING OF SEGMENT save_request_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1339.1 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 save_request_: proc (descr_ptr, dev_class_ptr);
       13 
       14 /* This procedure is used to thread a completed request onto the end of the "saved"
       15*   *  list, and delete the request message from the appropriate queue.
       16*   *  If it happens to be the one most recently read from that queue, we will have to update
       17*   *  that information before deleting it.
       18**/
       19 
       20 
       21 /* Coded August 1973 by Robert S. Coren */
       22 /* Modified by J. Stern, 12/27/74 */
       23 /* Modified by J. Stern, 11/25/75 */
       24 /* Modified by J. C. Whitmore, 4/78, to use the keep_in_queue flag */
       25 /* Modified by J. C. Whitmore, 7/78, to mark deferred requests in the queue */
       26 /* Modified by J. C. Whitmore, 5/80, to not add user deleted requests to the saved list */
       27 /* Modified by C. Marker, 02/23/85, to use version 5 message segments */
       28 
       29 
       30 /****^  HISTORY COMMENTS:
       31*  1) change(88-06-03,Brunelle), approve(88-06-03,MCR7911),
       32*     audit(88-10-18,Wallman), install(88-10-28,MR12.2-1199):
       33*     Upgraded to handle version 5 I/O daemon tables.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 
       37 	dcl     descr_ptr		 ptr;		/* pointer to descriptor being threaded */
       38 	dcl     dev_class_ptr	 ptr;		/* pointer to entry for this request's device class */
       39 
       40 	dcl     code		 fixed bin (35);
       41 	dcl     desc_p		 ptr;
       42 	dcl     desc_off		 fixed bin (18);
       43 	dcl     rest_p		 ptr;
       44 
       45 	dcl     err_msg		 char (64);
       46 	dcl     err_len		 fixed bin;
       47 	dcl     last_ptr		 ptr;		/* pointer to previous descriptor in list */
       48 	dcl     mseg_idx		 fixed bin;
       49 	dcl     q			 fixed bin;
       50 	dcl     retry		 fixed bin;
       51 
       52 	dcl     msg_id		 bit (72) aligned;	/* id of message from the current descr */
       53 	dcl     msg_p		 ptr;		/* pointer to the message text in request area */
       54 	dcl     msg_len		 fixed bin (18);
       55 
       56 	dcl     based_offset	 fixed bin (18) based;
       57 
       58 	dcl     deferred		 fixed bin int static options (constant) init (1);
       59 
       60 	dcl     error_table_$bad_segment fixed bin (35) ext;
       61 	dcl     error_table_$no_message fixed bin (35) ext;
       62 
       63 	dcl     (addr, fixed, ptr, rel, divide) builtin;
       64 
       65 
       66 	dcl     clock_		 entry returns (fixed bin (71));
       67 	dcl     ioa_$rsnnl		 entry options (variable);
       68 	dcl     iodc_message_	 entry (bit (3) aligned, fixed bin (35), char (*));
       69 	dcl     message_segment_$delete_index entry (fixed bin, bit (72) aligned, fixed bin (35));
       70 	dcl     message_segment_$update_message_index entry (fixed bin, fixed bin (18), bit (72) aligned, ptr, fixed bin (35));
       71 	dcl     timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2) aligned, fixed bin (71));
       72 
       73 
       74 	dctep = dev_class_ptr;			/* copy pointer args */
       75 	desc_p = descr_ptr;
       76 	desc_off = fixed (rel (desc_p), 18);
       77 
       78 	qgtep = addr (iodc_static.qgtp -> q_group_tab.entries (dcte.qgte_index));
       79 	q = desc_p -> request_descriptor.q;
       80 	mseg_idx = qgte.mseg_index (q);
       81 	msg_p = desc_p -> request_descriptor.ms_ptr;
       82 	msg_len = desc_p -> request_descriptor.ms_len;
       83 	msg_id = desc_p -> request_descriptor.ms_id;
       84 
       85 	if desc_p -> request_descriptor.keep_in_queue then do; /* this is highest priority action */
       86 		msg_p -> queue_msg_hdr.state = deferred;/* mark the request as deferred */
       87 
       88 		retry = 0;
       89 update:		call message_segment_$update_message_index (mseg_idx, msg_len, msg_id, msg_p, code);
       90 		if code ^= 0 then
       91 		     if code ^= error_table_$no_message
       92 		     then if code = error_table_$bad_segment /* message seg was salvaged */
       93 			then do;
       94 				if retry = 0 then do; /* try once more */
       95 					retry = 1;
       96 					go to update;
       97 				     end;
       98 				go to no_update;
       99 			     end;
      100 			else do;
      101 no_update:			call ioa_$rsnnl ("Could not update message in queue ^d of request type ^a.",
      102 				     err_msg, err_len, q, qgte.name);
      103 				call iodc_message_ ("101"b, code, err_msg);
      104 			     end;
      105 		free msg_p -> queue_msg_hdr in (req_area);
      106 		free desc_p -> request_descriptor in (req_desc_seg.descr_area);
      107 		return;				/* this one is done, like we never saw it */
      108 	     end;
      109 
      110 	else if desc_p -> request_descriptor.cancelled then do;
      111 
      112 /* if it was "cancelled", we will not really save it, rather the reverse */
      113 
      114 		call delete_from_queue (code);
      115 
      116 		free msg_p -> queue_msg_hdr in (req_area);
      117 		free desc_p -> request_descriptor in (req_desc_seg.descr_area);
      118 	     end;
      119 
      120 	else do;
      121 
      122 /* If not deferred or cancelled, we must add it to the saved list */
      123 
      124 		desc_p -> request_descriptor.finished = "1"b; /* be sure the descriptor is right */
      125 		desc_p -> request_descriptor.continued = "0"b;
      126 		desc_p -> request_descriptor.series_restart = "0"b;
      127 		desc_p -> request_descriptor.priority_request = "0"b;
      128 
      129 		if dcte.restart_req ^= 0 then do;	/* restart in progress */
      130 						/* see if this request should be added to series */
      131 			rest_p = ptr (iodc_static.descr_seg_ptr, dcte.restart_req);
      132 			if rest_p -> request_descriptor.series_restart then do; /* it was a series, check more */
      133 				if divide (rest_p -> request_descriptor.seq_id, 10000, 35, 0) =
      134 				     divide (desc_p -> request_descriptor.seq_id, 10000, 35, 0) then do; /* same series */
      135 					desc_p -> request_descriptor.saved = "1"b; /* make sure it stays around */
      136 					desc_p -> request_descriptor.series_restart = "1"b; /* mark as part of series */
      137 				     end;
      138 			     end;
      139 		     end;
      140 
      141 /* remove the message from the queue, indicating that from the users view it is done */
      142 
      143 		call delete_from_queue (code);
      144 		if code ^= 0 then
      145 		     if code = error_table_$no_message then do; /* already gone? Maybe the user deleted it. */
      146 			     if ^desc_p -> request_descriptor.restarted then do; /* if restarted, we deleted it earlier */
      147 						/* otherwise, assume the user deleted the message and flush it */
      148 				     free msg_p -> queue_msg_hdr in (req_area);
      149 				     free desc_p -> request_descriptor in (req_desc_seg.descr_area);
      150 				     return;
      151 				end;
      152 			end;
      153 
      154 /* set time done and set up alarm to delete it later */
      155 
      156 		desc_p -> request_descriptor.time_done = clock_ ();
      157 		if ^(desc_p -> request_descriptor.saved) then
      158 		     call timer_manager_$alarm_wakeup (iodc_static.time_interval, "10"b, iodc_static.timer_chan);
      159 
      160 		if iodc_static.last_req_done = 0 then do; /* if no requests in the list, point head of list at this one */
      161 			desc_p -> request_descriptor.prev_done,
      162 			     desc_p -> request_descriptor.next_done = 0;
      163 			iodc_static.first_req_done = desc_off;
      164 			iodc_static.save_first_req_p -> based_offset = desc_off; /* also store in req_desc_seg for reinit */
      165 		     end;
      166 		else do;				/* Yes, chain them together */
      167 			desc_p -> request_descriptor.next_done = 0; /* this is the end of the chain */
      168 			desc_p -> request_descriptor.prev_done = last_req_done;
      169 			last_ptr = ptr (iodc_static.descr_seg_ptr, iodc_static.last_req_done); /* get ptr to previous descr */
      170 			last_ptr -> request_descriptor.next_done = desc_off; /* make it point to this one */
      171 		     end;
      172 		iodc_static.last_req_done = desc_off;
      173 	     end;
      174 
      175 	return;
      176 
      177 
      178 delete_from_queue: proc (code);
      179 
      180 	dcl     code		 fixed bin (35);
      181 
      182 	retry = 0;
      183 delete:	call message_segment_$delete_index (mseg_idx, msg_id, code);
      184 	if code ^= 0
      185 	then if code ^= error_table_$no_message
      186 	     then if code = error_table_$bad_segment	/* message seg was salvaged */
      187 		then do;
      188 			if retry = 0 then do;	/* try once more */
      189 				retry = 1;
      190 				go to delete;
      191 			     end;
      192 			go to fatal_err2;
      193 		     end;
      194 		else do;
      195 
      196 /* trouble deleting from queue; to avoid further problems, */
      197 /* drop the queue */
      198 
      199 fatal_err2:		call ioa_$rsnnl ("Could not delete message from queue ^d of request type ^a. Queue will be dropped",
      200 			     err_msg, err_len, q, qgte.name);
      201 			call iodc_message_ ("101"b, code, err_msg);
      202 			qgte.mseg_index (q) = 0;
      203 		     end;
      204 
      205 	return;
      206 
      207      end delete_from_queue;
      208 
      209 
      210 init: entry (a_ptr);
      211 
      212 	dcl     a_ptr		 ptr;
      213 
      214 	stat_p = a_ptr;
      215 	return;
      216  /* BEGIN INCLUDE FILE...device_class.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  1     7*     Ancient History
  1     8*     Coded by R.S.Coren August 1973
  1     9*     Modified by J. Stern, 1/8/75
  1    10*     Modified by J. C. Whitmore, 5/78, to extent the size of the device list
  1    11*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  1    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    13*     Added comment field in dcte.
  1    14*                                                   END HISTORY COMMENTS */
  1    15 
  1    16 
  1    17 /* format: style4 */
  1    18 
  1    19 dcl  dctp ptr;					/* ptr to device class table */
  1    20 dcl  1 dev_class_tab aligned based (dctp),		/* the device class table */
  1    21        2 n_classes fixed bin,				/* number of device classes */
  1    22        2 pad fixed bin,
  1    23        2 entries (1 refer (dev_class_tab.n_classes)) like dcte;
  1    24 
  1    25 dcl  dctep ptr;					/* device class table entry ptr */
  1    26 
  1    27 dcl  1 dcte aligned based (dctep),			/* device class table entry */
  1    28 
  1    29 /* following items are initialized before daemon is run */
  1    30 
  1    31        2 id char (32),				/* device class name for this entry */
  1    32        2 comment unaligned like text_offset,		/* comment to apply to the device class */
  1    33        2 qgte_index fixed bin,			/* index of queue group table entry */
  1    34        2 pad1 fixed bin,
  1    35        2 max_access bit (72),				/* max request access class */
  1    36        2 min_access bit (72),				/* min request access class */
  1    37        2 min_banner bit (72),				/* min access class to be placed on output banner */
  1    38        2 device_list bit (360),			/* bit _i ON => minor device _i is valid for device class */
  1    39 
  1    40 /* remaining info is dynamic */
  1    41 
  1    42        2 pending_request fixed bin (18),		/* descriptor offset for allocated but unassigned request */
  1    43        2 restart_req fixed bin (18),			/* offset of next (or last) descriptor to be restarted */
  1    44        2 pad2 (3) fixed bin,
  1    45        2 n_waiting fixed bin,				/* number of waiting requests for device class */
  1    46        2 per_queue_info (4),				/* one copy of this for each queue */
  1    47          3 first_waiting fixed bin,			/* index of first waiting list entry */
  1    48          3 last_waiting fixed bin;			/* index of last waiting list entry */
  1    49 
  1    50 
  1    51 /* END INCLUDE FILE...device_class.incl.pl1 */
      216 
      217  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  2     2 
  2     3 
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  2     7*     Ancient History
  2     8*     Created by J. Stern, 1/20/75
  2     9*     Modified by J. C. Whitmore April 1978 for enhancements
  2    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  2    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  2    12*     q_group_tab
  2    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  2    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  2    15*     Change version number to reflect changes in q_group_tab and
  2    16*     iod_device_tab for laser printer support.  Added font tables.
  2    17*                                                   END HISTORY COMMENTS */
  2    18 
  2    19 
  2    20 /* format: style4 */
  2    21 
  2    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  2    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  2    24        2 version char (8),				/* version of this structure */
  2    25        2 date_time_compiled fixed bin (71),
  2    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  2    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  2    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  2    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  2    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  2    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  2    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  2    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  2    34        2 text_strings_offset fixed bin (18),
  2    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  2    36 
  2    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  2    38 dcl  text_strings_ptr ptr;
  2    39 dcl  1 text_strings aligned based (text_strings_ptr),
  2    40        2 length fixed bin,
  2    41        2 chars char (1 refer (text_strings.length)) unaligned;
  2    42 
  2    43 /* this defines text offsets used to locate i/o daemon tables strings in
  2    44*   the text_strings structure */
  2    45 dcl  1 text_offset based,
  2    46        2 first_char fixed bin (18) unsigned unaligned,
  2    47        2 total_chars fixed bin (18) unsigned unaligned;
  2    48 
  2    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  2    50 
  2    51 
  2    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      217 
      218  /* BEGIN INCLUDE FILE...iodc_static.incl.pl1 */
  3     2 
  3     3 dcl stat_p ptr int static init(null);
  3     4 
  3     5 dcl 1 iodc_static aligned based(stat_p),
  3     6 	2 dctp ptr,		/* pointer to device class table */
  3     7 	2 qgtp ptr,		/* pointer to queue group table */
  3     8 	2 wait_list_ptr ptr,	/* pointer to waiting list segment */
  3     9 	2 req_seg_ptr ptr,		/* pointer to base of request segment */
  3    10 	2 descr_seg_ptr ptr,	/* pointer to base of request descriptor segment */
  3    11 	2 save_first_req_p ptr,	/* pointer to req_desc_seg.first_saved */
  3    12 	2 first_req_done fixed bin(18),	/* offset of first descriptor on "saved" list */
  3    13 	2 last_req_done fixed bin(18),	/* offset of last  descriptor on "saved" list */
  3    14 	2 time_interval fixed bin(71),	/* time interval to elapse between completion */
  3    15 					/* and deletion of request */
  3    16 	2 max_q fixed bin,			/* maximum number of priority queues */
  3    17 	2 timer_chan fixed bin(71);		/* event channel for timer wakeups */
  3    18 
  3    19 dcl req_area area(131096) based(iodc_static.req_seg_ptr);
  3    20 
  3    21 dcl 1 req_desc_seg aligned based (iodc_static.descr_seg_ptr),
  3    22 	2 first_saved fixed bin(18),		/* offset of head of saved list */
  3    23 	2 pad fixed bin,
  3    24 	2 descr_area area (65560);		/* area where request descriptors are allocated */
  3    25 
  3    26 /* END INCLUDE FILE...iodc_static.incl.pl1 */
      218 
      219  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  4     2 /* format: style3,idind30 */
  4     3 
  4     4 /* structure returned when message is read from a message segment */
  4     5 
  4     6 
  4     7 dcl	mseg_message_info_ptr	pointer;
  4     8 
  4     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  4    10 	  2 version		char (8) aligned,
  4    11 	  2 message_code		fixed bin,
  4    12 	  2 control_flags		unaligned,
  4    13 	    3 own			bit (1),
  4    14 	    3 delete		bit (1),
  4    15 	    3 pad			bit (34),
  4    16 	  2 ms_ptr		ptr,		/* pointer to message */
  4    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  4    18 	  2 ms_id			bit (72),		/* unique ID of message */
  4    19 						/* input in some cases */
  4    20 	  2 ms_access_class		bit (72),		/* message access class */
  4    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  4    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  4    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  4    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  4    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  4    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  4    27 
  4    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  4    29 
  4    30 declare	(
  4    31 	MSEG_READ_FIRST		init (1),
  4    32 	MSEG_READ_LAST		init (2),
  4    33 	MSEG_READ_SPECIFIED		init (3),
  4    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  4    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  4    36 	fixed bin int static options (constant);
  4    37 
  4    38 declare  (MSEG_READ_OWN		init ("1"b),
  4    39 	MSEG_READ_DELETE		init ("01"b)
  4    40 	)			bit (36) aligned internal static options (constant);
  4    41 
  4    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
      219 
      220  /* BEGIN INCLUDE FILE...q_group_tab.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  5     7*     Ancient History
  5     8*     Created by J. Stern, December 1974
  5     9*     Modified by J. Whitmore April 1978
  5    10*     Modified by R. McDonald May 1980 to include page charges (UNCA)
  5    11*     Modified by E. N. Kittlitz June 1981 for UNCA changes
  5    12*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  5    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5    14*     Add forms_validation, default_form and font_dir variables for laser
  5    15*     printer support.
  5    16*                                                   END HISTORY COMMENTS */
  5    17 
  5    18 
  5    19 /* format: style4 */
  5    20 
  5    21 dcl  qgtp ptr;					/* ptr to queue group table */
  5    22 dcl  1 q_group_tab aligned based (qgtp),
  5    23        2 n_q_groups fixed bin,			/* number of queue groups */
  5    24        2 pad fixed bin,
  5    25        2 entries (1 refer (q_group_tab.n_q_groups)) like qgte; /* entries of queue group table */
  5    26 
  5    27 dcl  qgtep ptr;					/* queue group table entry pointer */
  5    28 dcl  1 qgte aligned based (qgtep),			/* queue group table entry */
  5    29 
  5    30 /* static info from the parms file */
  5    31 
  5    32        2 name char (24),				/* queue group name */
  5    33        2 comment unaligned like text_offset,		/* comment to apply to the request_type */
  5    34        2 driver_id char (32),				/* person.project name of drivers for this q group */
  5    35        2 accounting unaligned like text_offset,		/* offset to accounting routine pathname, "system" => charge_user_ */
  5    36        2 generic_type char (32),			/* generic type of requests in this queue */
  5    37        2 default_generic_queue fixed bin (1),		/* 1 if this is default queue for above generic type, else 0 */
  5    38        2 rqti_seg_name char (32),			/* name of rqti seg, if required, else blank */
  5    39        2 max_queues fixed bin,			/* number of queues for this request type */
  5    40        2 default_queue fixed bin,			/* number of the default queue */
  5    41        2 line_charge,				/* price names for line charges */
  5    42          3 queue (4) char (32),			/* one name for each queue */
  5    43        2 page_charge,				/* price names for page charges */
  5    44          3 queue (4) char (32),			/* one name for each queue */
  5    45        2 forms_table unaligned like text_offset,		/* offset to forms table to apply to this queue group */
  5    46        2 forms_validation unaligned like text_offset,	/* offset to name of routine for forms validation */
  5    47        2 default_form unaligned like text_offset,		/* offset to default -form string if none given */
  5    48        2 font_dir unaligned like text_offset,		/* offset to location of downloadable fonts */
  5    49        2 first_dev_class fixed bin,			/* index of first device class entry of queue group */
  5    50        2 last_dev_class fixed bin,			/* index of last device class entry of queue group */
  5    51 
  5    52 /* dynamic info reflecting current status of queues */
  5    53 
  5    54        2 open fixed bin,				/* 1 if queues have been opened, else 0 */
  5    55        2 per_queue_info (4),
  5    56          3 last_read bit (72),			/* ID of last message read */
  5    57          3 mseg_index fixed bin,			/* message segment index */
  5    58          3 pad fixed bin;				/* pad to even word boundary */
  5    59 
  5    60 /* END INCLUDE FILE...q_group_tab.incl.pl1 */
      220 
      221  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
  6     2 
  6     3 /* This is the message header used for standard system queue messages, namely:
  6     4*   IO daemon requests, absentee requests, retrieval requests.
  6     5**/
  6     6 
  6     7 /* Written by Jerry Whitmore, Spring 1978.
  6     8*   Modified by T. Casey, November 1978, to add values for state.
  6     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
  6    10**/
  6    11 
  6    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
  6    13     2 msg_time fixed bin (71),			/* date and time of request */
  6    14     2 hdr_version fixed bin,				/* version of this declaration */
  6    15     2 dirname char (168),				/* directory name */
  6    16     2 ename char (32),				/* entry name of file requested */
  6    17     2 message_type fixed bin,				/* message format descriptor   */
  6    18 						/* 0 = absentee request        */
  6    19 						/* 1 = print request           */
  6    20 						/* 2 = punch request           */
  6    21 						/* 3 = tape request            */
  6    22 						/* 4 = retrieval request       */
  6    23     2 bit_flags,
  6    24       3 delete_sw bit (1) unal,			/* delete file when done */
  6    25       3 notify bit (1) unal,				/* user wants to be notified */
  6    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
  6    27       3 padding bit (33) unal,
  6    28     2 state fixed bin,				/* stage of processing after being queued:
  6    29*						   0 = initial unprocessed state, 1 = deferred,
  6    30*						   2 = in state transition, 3 = eligible, 4 = running,
  6    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
  6    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
  6    33     2 std_length fixed bin,				/* length of std msg for this type */
  6    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
  6    35     2 hdr_pad (3) fixed bin;
  6    36 
  6    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
  6    38 
  6    39 /* Values for queue_msg_hdr.state */
  6    40 
  6    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
  6    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
  6    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
  6    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
  6    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
  6    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
  6    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
  6    48 
  6    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
      221 
      222  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
  7     2 
  7     3 /* Descriptor associated with an I/O daemon request */
  7     4 /* Coded August 1973 by Robert S. Coren */
  7     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
  7     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
  7     7 
  7     8 dcl  1 request_descriptor based aligned,
  7     9 	2 mseg_message_info_copy like mseg_message_info,
  7    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
  7    11 	2 q fixed bin,		/* priority queue in which request was submitted */
  7    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
  7    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
  7    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
  7    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
  7    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
  7    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
  7    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
  7    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
  7    20 	2 driver_data bit(252),	/* driver maintained data */
  7    21 	2 flags,
  7    22 	   (3 continued,		/* unfinished by one driver and given to another */
  7    23 	    3 finished,
  7    24 	    3 restarted,
  7    25 	    3 cancelled,
  7    26 	    3 dont_delete,
  7    27 	    3 saved,		/* not to be freed */
  7    28 	    3 keep_in_queue,	/* keep request in queue */
  7    29 	    3 series_restart,	/* this request is part of restarted series */
  7    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
  7    31 	    3 pad bit(27) unal,
  7    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
  7    33 
  7    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
      222 
      223 
      224      end save_request_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1233.7  save_request_.pl1                 >special_ldd>install>MR12.2-1199>save_request_.pl1
216          1    10/28/88  1227.7  device_class.incl.pl1             >special_ldd>install>MR12.2-1199>device_class.incl.pl1
217          2    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
218          3    09/28/78  1359.8  iodc_static.incl.pl1              >ldd>include>iodc_static.incl.pl1
219          4    01/10/85  2002.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
220          5    10/28/88  1227.2  q_group_tab.incl.pl1              >special_ldd>install>MR12.2-1199>q_group_tab.incl.pl1
221          6    08/31/82  1636.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
222          7    03/15/85  0953.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_ptr                                  parameter       pointer                  dcl 212 ref 210 214
addr                                                   builtin function         dcl 63 ref 78
based_offset                           based           fixed bin(18,0)          dcl 56 set ref 164*
cancelled                53(03)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 ref 110
clock_                          000016 constant        entry                    external dcl 66 ref 156
code                            000100 automatic       fixed bin(35,0)          dcl 40 in procedure "save_request_" set ref 89* 90
                                                                                  90 90 103* 114* 143* 144 144
code                                   parameter       fixed bin(35,0)          dcl 180 in procedure "delete_from_queue" set ref 178
                                                                                  183* 184 184 184 201*
continued                53            based           bit(1)                   level 3 packed packed unaligned dcl 7-8 set ref 125*
dcte                                   based           structure                level 1 dcl 1-27
dctep                           000146 automatic       pointer                  dcl 1-25 set ref 74* 78 129 131
deferred                               constant        fixed bin(17,0)          initial dcl 58 ref 86
desc_off                        000104 automatic       fixed bin(18,0)          dcl 42 set ref 76* 163 164 170 172
desc_p                          000102 automatic       pointer                  dcl 41 set ref 75* 76 79 81 82 83 85 106 110 117 124
                                                                                  125 126 127 133 135 136 146 149 156 157 161 161
                                                                                  167 168
descr_area                2            based           area(65560)              level 2 dcl 3-21 ref 106 117 149
descr_ptr                              parameter       pointer                  dcl 37 ref 12 75
descr_seg_ptr            10            based           pointer                  level 2 dcl 3-5 ref 106 117 131 149 169
dev_class_ptr                          parameter       pointer                  dcl 38 ref 12 74
divide                                                 builtin function         dcl 63 ref 133 133
entries                   2            based           structure                array level 2 dcl 5-22 set ref 78
err_len                         000130 automatic       fixed bin(17,0)          dcl 46 set ref 101* 199*
err_msg                         000110 automatic       char(64)                 packed unaligned dcl 45 set ref 101* 103* 199* 201*
error_table_$bad_segment        000012 external static fixed bin(35,0)          dcl 60 ref 90 184
error_table_$no_message         000014 external static fixed bin(35,0)          dcl 61 ref 90 144 184
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 set ref 124*
first_req_done           14            based           fixed bin(18,0)          level 2 dcl 3-5 set ref 163*
fixed                                                  builtin function         dcl 63 ref 76
flags                    53            based           structure                level 2 dcl 7-8
ioa_$rsnnl                      000020 constant        entry                    external dcl 67 ref 101 199
iodc_message_                   000022 constant        entry                    external dcl 68 ref 103 201
iodc_static                            based           structure                level 1 dcl 3-5
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 ref 85
last_ptr                        000132 automatic       pointer                  dcl 47 set ref 169* 170
last_req_done            15            based           fixed bin(18,0)          level 2 dcl 3-5 set ref 160 168 169 172*
message_segment_$delete_index   000024 constant        entry                    external dcl 69 ref 183
message_segment_$update_message_index
                                000026 constant        entry                    external dcl 70 ref 89
ms_id                     7            based           bit(72)                  level 3 dcl 7-8 ref 83
ms_len                    6            based           fixed bin(24,0)          level 3 dcl 7-8 ref 82
ms_ptr                    4            based           pointer                  level 3 dcl 7-8 ref 81
mseg_idx                        000134 automatic       fixed bin(17,0)          dcl 48 set ref 80* 89* 183*
mseg_index              154            based           fixed bin(17,0)          array level 3 dcl 5-28 set ref 80 202*
mseg_message_info                      based           structure                level 1 dcl 4-9
mseg_message_info_copy                 based           structure                level 2 dcl 7-8
msg_id                          000140 automatic       bit(72)                  dcl 52 set ref 83* 89* 183*
msg_len                         000144 automatic       fixed bin(18,0)          dcl 54 set ref 82* 89*
msg_p                           000142 automatic       pointer                  dcl 53 set ref 81* 86 89* 105 116 148
name                                   based           char(24)                 level 2 dcl 5-28 set ref 101* 199*
next_done                43            based           fixed bin(18,0)          level 2 dcl 7-8 set ref 161* 167* 170*
per_queue_info          152            based           structure                array level 2 dcl 5-28
prev_done                42            based           fixed bin(18,0)          level 2 dcl 7-8 set ref 161* 168*
priority_request         53(08)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 set ref 127*
ptr                                                    builtin function         dcl 63 ref 131 169
q                               000135 automatic       fixed bin(17,0)          dcl 49 in procedure "save_request_" set ref 79* 80
                                                                                  101* 199* 202
q                        33            based           fixed bin(17,0)          level 2 in structure "request_descriptor" dcl 7-8
                                                                                  in procedure "save_request_" ref 79
q_group_tab                            based           structure                level 1 dcl 5-22
qgte                                   based           structure                level 1 dcl 5-28
qgte_index               11            based           fixed bin(17,0)          level 2 dcl 1-27 ref 78
qgtep                           000150 automatic       pointer                  dcl 5-27 set ref 78* 80 101 199 202
qgtp                      2            based           pointer                  level 2 dcl 3-5 ref 78
queue_msg_hdr                          based           structure                level 1 dcl 6-12 set ref 105 116 148
rel                                                    builtin function         dcl 63 ref 76
req_area                               based           area(131096)             dcl 3-19 ref 105 116 148
req_desc_seg                           based           structure                level 1 dcl 3-21
req_seg_ptr               6            based           pointer                  level 2 dcl 3-5 ref 105 116 148
request_descriptor                     based           structure                level 1 dcl 7-8 set ref 106 117 149
rest_p                          000106 automatic       pointer                  dcl 43 set ref 131* 132 133
restart_req              34            based           fixed bin(18,0)          level 2 dcl 1-27 ref 129 131
restarted                53(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 ref 146
retry                           000136 automatic       fixed bin(17,0)          dcl 50 set ref 88* 94 95* 182* 188 189*
save_first_req_p         12            based           pointer                  level 2 dcl 3-5 ref 164
saved                    53(05)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 set ref 135*
                                                                                  157
seq_id                   32            based           fixed bin(35,0)          level 2 dcl 7-8 ref 133 133
series_restart           53(07)        based           bit(1)                   level 3 packed packed unaligned dcl 7-8 set ref 126*
                                                                                  132 136*
stat_p                          000010 internal static pointer                  initial dcl 3-3 set ref 78 105 106 116 117 131 148
                                                                                  149 157 157 160 163 164 168 169 169 172 214*
state                    67            based           fixed bin(17,0)          level 2 dcl 6-12 set ref 86*
text_offset                            based           structure                level 1 packed packed unaligned dcl 2-45
time_done                40            based           fixed bin(71,0)          level 2 dcl 7-8 set ref 156*
time_interval            16            based           fixed bin(71,0)          level 2 dcl 3-5 set ref 157*
timer_chan               22            based           fixed bin(71,0)          level 2 dcl 3-5 set ref 157*
timer_manager_$alarm_wakeup     000030 constant        entry                    external dcl 71 ref 157

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 2-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 4-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 4-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 4-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 4-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 4-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 4-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 4-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 4-30
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 6-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 6-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 6-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 6-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 6-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 6-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 6-41
dctp                                   automatic       pointer                  dcl 1-19
dev_class_tab                          based           structure                level 1 dcl 1-20
iod_tables_hdr                         based           structure                level 1 dcl 2-23
ithp                                   automatic       pointer                  dcl 2-22
mseg_message_info_ptr                  automatic       pointer                  dcl 4-7
qgtp                                   automatic       pointer                  dcl 5-21
queue_msg_hdr_version_1                internal static fixed bin(17,0)          initial dcl 6-37
text_strings                           based           structure                level 1 dcl 2-39
text_strings_ptr                       automatic       pointer                  dcl 2-38

NAMES DECLARED BY EXPLICIT CONTEXT.
delete                          000437 constant        label                    dcl 183 ref 190
delete_from_queue               000434 constant        entry                    internal dcl 178 ref 114 143
fatal_err2                      000471 constant        label                    dcl 199 ref 192
init                            000421 constant        entry                    external dcl 210
no_update                       000163 constant        label                    dcl 101 ref 98
save_request_                   000057 constant        entry                    external dcl 12
update                          000127 constant        label                    dcl 89 ref 96

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       722         754     564         732
Length      1320     564        32         330     135           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
save_request_                       212 external procedure  is an external procedure.  
delete_from_queue                       internal procedure  shares stack frame of external procedure save_request_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 stat_p                      save_request_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
save_request_            000100 code                        save_request_
                         000102 desc_p                      save_request_
                         000104 desc_off                    save_request_
                         000106 rest_p                      save_request_
                         000110 err_msg                     save_request_
                         000130 err_len                     save_request_
                         000132 last_ptr                    save_request_
                         000134 mseg_idx                    save_request_
                         000135 q                           save_request_
                         000136 retry                       save_request_
                         000140 msg_id                      save_request_
                         000142 msg_p                       save_request_
                         000144 msg_len                     save_request_
                         000146 dctep                       save_request_
                         000150 qgtep                       save_request_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          ext_entry           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        ioa_$rsnnl                    iodc_message_                 message_segment_$delete_index
message_segment_$update_message_index                       timer_manager_$alarm_wakeup

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$no_message




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000053        74 000064        75 000070        76 000073        78 000076        79 000104        80 000107
     81 000112        82 000114        83 000116        85 000121        86 000124        88 000126        89 000127
     90 000146        94 000155        95 000157        96 000161        98 000162       101 000163       103 000216
    105 000241       106 000243       107 000245       110 000246       114 000251       116 000253       117 000255
    118 000257       124 000260       125 000262       126 000264       127 000266       129 000270       131 000273
    132 000277       133 000302       135 000311       136 000313       143 000315       144 000317       146 000324
    148 000330       149 000332       150 000334       156 000335       157 000345       160 000367       161 000373
    163 000376       164 000400       165 000401       167 000402       168 000404       169 000406       170 000412
    172 000414       175 000415       210 000416       214 000426       215 000433       178 000434       182 000436
    183 000437       184 000453       188 000463       189 000465       190 000467       192 000470       199 000471
    201 000524       202 000550       205 000554


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
