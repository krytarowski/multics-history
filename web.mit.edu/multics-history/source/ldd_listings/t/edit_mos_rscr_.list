	COMPILATION LISTING OF SEGMENT edit_mos_rscr_
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 06/02/83  1217.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* EDIT_MOS_RSCR_: Procedure to interpret and edit contents memory maintence register. */
       12 
       13 /* Written May 1976 by Larry Johnson */
       14 /* Modified September 1977 by Larry Johnson for 16k chips */
       15 /* Modified November 1979 by Larry Johnson for $decode entry */
       16 /* Modified April 1983 by Paul Farley, with input from D. A. Fudge (UofC), for 64k chips */
       17 
       18 edit_mos_rscr_: proc (arg_scrp, arg_descrip);
       19 
       20 /* Arguments */
       21 
       22 dcl  arg_descrip char (*) var;			/* Description built here */
       23 dcl  arg_mem_type char (*);
       24 dcl  arg_error char (*);
       25 dcl  arg_scrp ptr;
       26 
       27 /* Automatic */
       28 
       29 dcl  decode_sw bit (1);
       30 dcl  mem_type char (32);
       31 dcl  error char (32);
       32 dcl  syndrome fixed bin;
       33 dcl  bit_no fixed bin;
       34 dcl  board char (1);
       35 dcl  quad fixed bin;
       36 dcl  i fixed bin;
       37 dcl  chip fixed bin;
       38 
       39 dcl  ioa_ entry options (variable);
       40 dcl  ioa_$rsnpnnl entry options (variable);
       41 
       42 dcl (bin, bit, divide, mod, substr) builtin;
       43 
  1     1 /* ***********************************************************
  1     2*   *                                                         *
  1     3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
  1     4*   *                                                         *
  1     5*   *********************************************************** */
  1     6 /* Begin include file ...... scr.incl.pl1
  1     7*   modified 5/75 by Noel I. Morris
  1     8*   modified 10/81 by M.R. Jordan for 64K chip, M64 memory */
  1     9 
  1    10 /* This include file is to be used in conjunction with pmut$rscr and pmut$sscr.
  1    11*   Wherever possible the terms in the processor manual are used in the declaration. */
  1    12 
  1    13 dcl (SC_MR init (0),				/* SC Mode Register */
  1    14      SC_CFG init (1),				/* SC Configuration Switches */
  1    15      SC_MSK init (2),				/* SC Interrupt Mask */
  1    16      SC_IC init (3),				/* SC Interrupt Cells */
  1    17      SC_ETC init (4),				/* SC Elapsed Time Clock */
  1    18      SC_SU init (6)) fixed bin (6) static;		/* SU Mode Register */
  1    19 
  1    20 
  1    21 dcl  scrp ptr;					/* pointer to SC data */
  1    22 
  1    23 dcl 1 scr_cfg1 based (scrp) aligned,			/* configuration data for 6000 SC */
  1    24 
  1    25    (2 mode_a bit (3),				/* 000 => on-line
  1    26*						   001 => test mode
  1    27*						   010 => off-line */
  1    28     2 bdry_a bit (3),				/* 000 => 32K, 001 => 64K, etc */
  1    29     2 mode_b bit (3),				/* see mode_a */
  1    30     2 bdry_b bit (3),				/* see bdry_a */
  1    31     2 int bit (1),					/* 1 => stores are internally interlaced */
  1    32     2 lwr bit (1),					/* 1 => store B is low */
  1    33     2 addr_offset bit (2),				/* 00 => no offset, 01 => 32K offset, etc. */
  1    34     2 port_no bit (4),				/* requester's port number */
  1    35     2 port_enable (0:7) bit (2),			/* 00 => port disabled
  1    36*						   01 => port under program control
  1    37*						   11 => port enabled */
  1    38     2 pima (4) bit (9)) unaligned;			/* program interrupt mask assignments
  1    39*						   000 => unassigned
  1    40*						   400 => assigned to port 0
  1    41*						   200 => assigned to port 1
  1    42*						   .
  1    43*						   .
  1    44*						   .
  1    45*						   002 => assigned to port 7
  1    46*						   001 => assigned to maint. panel */
  1    47 
  1    48 
  1    49 dcl 1 scr_cfg2 based (scrp) aligned,			/* configuration data for 4MW SCU */
  1    50 
  1    51    (2 mask_a_assign bit (9),				/* interrupt mask "A" port assignment
  1    52*						   400 => assigned to port 0
  1    53*						   .
  1    54*						   .
  1    55*						   002 => assigned to port 7
  1    56*						   001 => mask off */
  1    57     2 size bit (3),					/* size of lower store */
  1    58     2 a_online bit (1),				/* 1 => store A online */
  1    59     2 a1_online bit (1),				/* 1 => store A1 online */
  1    60     2 b_online bit (1),				/* 1 => store B online */
  1    61     2 b1_online bit (1),				/* 1 => store B1 online */
  1    62     2 port_no bit (4),				/* requester's port number */
  1    63     2 pad1 bit (1),
  1    64     2 mode bit (1),					/* 1 => programmable mode */
  1    65     2 nea_enabled bit (1),				/* 1 => non-existent address logic enabled */
  1    66     2 nea bit (7),					/* 001 => 32K, 002 => 64K, 003 => 96K, etc. */
  1    67     2 int bit (1),					/* 1 => stores are internally interlaced */
  1    68     2 lwr bit (1),					/* 1 => store B is low */
  1    69     2 port_mask_0_3 bit (4),				/* 1 => corresponding port enabled */
  1    70 
  1    71     2 mask_b_assign bit (9),				/* interrupt mask "B" port assignment */
  1    72     2 pad2 bit (12),
  1    73     2 cyclic_prior bit (7),				/* cyclic port priority switches */
  1    74     2 pad3 bit (4),
  1    75     2 port_mask_4_7 bit (4)) unal;			/* 1 => corresponding port enabled */
  1    76 
  1    77 
  1    78 dcl 1 scr_mr based (scrp) aligned,			/* SC mode register */
  1    79 
  1    80    (2 pad1 bit (50),
  1    81     2 identification bit (4),				/* 0000 => 8034, 8035
  1    82*						   0001 => 6000 SC
  1    83*						   0010 => 4MW SCU */
  1    84     2 TS_strobe_margin bit (2),			/* 00 => normal timing
  1    85*						   01 => slow timing
  1    86*						   10 => inhibit strobe
  1    87*						   11 => fast timing */
  1    88     2 G0_strobe_margin bit (2),
  1    89     2 ANSWER_strobe_margin bit (2),
  1    90     2 DA_strobe_margin bit (2),
  1    91     2 EOC_strobe_margin bit (2),
  1    92     2 PLUS_5_VOLT_margin bit (2),			/* 00 => normal voltage
  1    93*						   01 => -5%
  1    94*						   10 => normal voltage
  1    95*						   11 => +5% */
  1    96     2 parity_override bit (1),			/* 1 => SU forced to accept data with incorrect parity */
  1    97     2 parity_disable bit (1),				/* 1 => disable data and ZAC parity checking */
  1    98     2 store_IA_disable bit (1),			/* 1 => disable illegal action indication */
  1    99     2 ZAC_parity_error bit (1),			/* 1 => cause ZAC parity error */
  1   100     2 SGR_accepted bit (1),				/* 1 => SGR command accepted by SC */
  1   101     2 pad2 bit (1)) unal;
  1   102 
  1   103 
  1   104 dcl 1 scr_msk based (scrp) aligned,			/* SC mask register */
  1   105 
  1   106    (2 interrupt_mask_1 bit (16),			/* mask bits for interrupts 0 thru 15 */
  1   107     2 pad1 bit (16),
  1   108     2 port_mask_1 bit (4),				/* mask bits for ports 0 thru 3 */
  1   109 
  1   110     2 interrupt_mask_2 bit (16),			/* mask bits for interrupts 16 thru 31 */
  1   111     2 pad2 bit (16),
  1   112     2 port_mask_2 bit (4)) unal;			/* mask bits for ports 4 thru 7 */
  1   113 
  1   114 
  1   115 dcl 1 scr_su based (scrp) aligned,			/* store unit mode register */
  1   116 
  1   117    (2 pad1 bit (36),
  1   118     2 ZAC_line bit (6),				/* EDAC mode only - address field */
  1   119     2 syndrome bit (8),				/* EDAC mode only - failure syndrome */
  1   120     2 identification bit (4),				/* 0000 => High Speed Core Model AA1
  1   121*						   0001 => High Speed Core Model AA3
  1   122*						   0011 => 4K, 16 pin chip, MOS memory, M32 boards
  1   123*						   0100 => 1K chip MOS memory with EDAC enabled
  1   124*						   1010 => 64K, 16 pin chip, MOS memory, M64 boards
  1   125*						   1011 => 16K, 16 pin chip, MOS memory, M264 boards
  1   126*						   1100 => 1K chip MOS memory with EDAC disabled
  1   127*						   1110 => 16K, 16 pin chip, MOS memory, M128 boards
  1   128*						   1111 => 4K, 22 pin chip MOS memory, M16 boards */
  1   129     2 EDAC_disabled bit (1),				/* 1 => correction disabled but detection still enabled */
  1   130     2 pad2 bit (4),
  1   131     2 MINUS_5_VOLT_margin bit (2),
  1   132     2 PLUS_5_VOLT_margin bit (2),
  1   133     2 spare_margin bit (2),
  1   134     2 PLUS_19_VOLT_margin bit (2),
  1   135     2 pad3 bit (1),
  1   136     2 SENSE_strobe_margin bit (2),			/* core only */
  1   137     2 pad4 bit (1),
  1   138     2 maint_functions_enabled bit (1)) unal;		/* 1 => maintenance functions enabled */
  1   139 
  1   140 /* End of include file ...... scr.incl.pl1 */
  1   141 
       44 
       45 
       46 /* The following delcarations are for 1k MOS chips */
       47 
       48 /* This table translates a syndrome to a board bit number */
       49 
       50 dcl  bit_1k (128) fixed bin (8) unal int static options (constant) init (
       51      19, 18, 19, 17, 18, 16, 15, -1, 19, 14, 13, 11, 12, 10, 09, -1,
       52      18, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1,
       53      19, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
       54      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1,
       55      18, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
       56      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1,
       57      -1, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
       58      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1);
       59 
       60 /* This table translates a syndrom into a "quandrant" in the error chart */
       61 
       62 dcl  quad_1k (128) fixed bin (3) unal int static options (constant) init (
       63      4, 4, 3, 4, 3, 4, 4, 0, 2, 4, 4, 4, 4, 4, 4, 0,
       64      2, 4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 0, 4, 0, 0, 0,
       65      1, 0, 0, 3, 0, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 0,
       66      0, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 0, 3, 0, 0, 0,
       67      1, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0,
       68      0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 2, 0, 2, 0, 0, 0,
       69      0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0,
       70      0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0);
       71 
       72 /* This table is used to determine a board number. One string applies to each quandrant. */
       73 
       74 dcl  board_1k (4) char (8) int static options (constant) init (
       75      "ACEGBDFH", "JLNQKMPR", "LJGEKHFD", "USQNTRPM");
       76 
       77 dcl  bay_1k (4) char (3) int static options (constant) init (
       78      "AA0", "AA0", "AA1", "AA1");
       79 
       80 /* End of 1k chip declarations */
       81 
       82 /* The following declarations are for 4k and 16k mos chips. */
       83 
       84 dcl  bit_4k (128) fixed bin (8) unal int static options (constant) init (
       85      19, 18, 17, 15, 16, 14, 13, -1, 19, 12, 11, 09, 10, 08, 07, -1,
       86      18, 06, 05, 03, 04, 02, 01, -1, -1, 00, 19, -1, 18, -1, -1, -1,
       87      17, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
       88      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1,
       89      16, -1, -1, 15, -1, 14, 13, -1, -1, 12, 11, 09, 10, 08, 07, -1,
       90      -1, 06, 05, 03, 04, 02, 01, -1, -1, 00, 19, -1, 18, -1, -1, -1,
       91      -1, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
       92      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1);
       93 
       94 /* The following table translate a syndrome into a quadrant in the error chard */
       95 
       96 dcl  quad_4k (128) fixed bin (3) unal int static options (constant) init (
       97      4, 4, 4, 4, 4, 4, 4, 0, 2, 4, 4, 4, 4, 4, 4, 0,
       98      2, 4, 4, 4, 4, 4, 4, 0, 0, 4, 3, 0, 3, 0, 0, 0,
       99      2, 0, 0, 3, 0, 3, 3, 0, 0, 3, 3, 3, 3, 3, 3, 0,
      100      0, 3, 3, 3, 3, 3, 3, 0, 0, 3, 3, 0, 3, 0, 0, 0,
      101      2, 0, 0, 2, 0, 2, 2, 0, 0, 2, 2, 2, 2, 2, 2, 0,
      102      0, 2, 2, 2, 2, 2, 2, 0, 0, 2, 1, 0, 1, 0, 0, 0,
      103      0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0,
      104      0, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0);
      105 
      106 dcl  board_4k (4) char (4) int static options (constant) init (
      107      "ABCD", "FGHJ", "KLMN", "QRST");
      108 
      109 /* End of 4k chip declarations */
      110 
      111 /* The following tables are for M264 16k chips */
      112 
      113 dcl  bit_16k (128) fixed bin (8) unal int static options (constant) init (
      114      79, 78, 77, 71, 76, 70, 69, -1, 75, 68, 67, 65, 66, 64, 63, -1,
      115      74, 62, 61, 59, 60, 58, 57, -1, -1, 56, 55, -1, 54, -1, -1, -1,
      116      73, -1, -1, 53, -1, 52, 51, -1, -1, 50, 49, 47, 48, 46, 45, -1,
      117      -1, 44, 43, 41, 42, 40, 39, -1, -1, 38, 37, -1, 36, -1, -1, -1,
      118      72, -1, -1, 35, -1, 34, 33, -1, -1, 32, 31, 29, 30, 28, 27, -1,
      119      -1, 26, 25, 23, 24, 22, 21, -1, -1, 20, 19, -1, 18, -1, -1, -1,
      120      -1, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
      121      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1);
      122 
      123 dcl  chip_16k (0:79) char (3) unal int static options (constant) init (
      124      "0A", "2A", "4A", "6A", "0B", "2B", "4B", "6B", "0C", "2C",
      125      "4C", "6C", "0D", "2D", "4D", "6D", "0E", "2E", "4E", "6E",
      126      "0F", "2F", "4F", "6F", "0G", "2G", "4G", "6G", "0H", "2H",
      127      "4H", "6H", "0J", "2J", "4J", "6J", "0K", "2K", "4K", "6K",
      128      "0R", "2R", "4R", "6R", "0S", "2S", "4S", "6S", "0T", "2T",
      129      "4T", "6T", "0U", "2U", "4U", "6U", "0V", "2V", "4V", "6V",
      130      "0W", "2W", "4W", "6W", "0X", "2X", "4X", "6X", "0Y", "2Y",
      131      "4Y", "6Y", "0Z", "2Z", "4Z", "6Z", "0AA", "2AA", "4AA", "6AA");
      132 
      133 dcl  board_16k (0:15) char (1) unal int static options (constant) init (
      134      "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R");
      135 
      136 /* The following tables are for M64 64k chips */
      137 
      138 dcl  bit_64k (128) fixed bin (8) unal int static options (constant) init (
      139      79, 78, 77, 71, 76, 70, 69, -1, 75, 68, 67, 65, 66, 64, 63, -1,
      140      74, 62, 61, 59, 60, 58, 57, -1, -1, 56, 55, -1, 54, -1, -1, -1,
      141      73, -1, -1, 53, -1, 52, 51, -1, -1, 50, 49, 47, 48, 46, 45, -1,
      142      -1, 44, 43, 41, 42, 40, 39, -1, -1, 38, 37, -1, 36, -1, -1, -1,
      143      72, -1, -1, 35, -1, 34, 33, -1, -1, 32, 31, 29, 30, 28, 27, -1,
      144      -1, 26, 25, 23, 24, 22, 21, -1, -1, 20, 19, -1, 18, -1, -1, -1,
      145      -1, -1, -1, 17, -1, 16, 15, -1, -1, 14, 13, 11, 12, 10, 09, -1,
      146      -1, 08, 07, 05, 06, 04, 03, -1, -1, 02, 01, -1, 00, -1, -1, -1);
      147 
      148 dcl  chip_64k_not_a6 (0:79) char (3) unal int static options (constant) init (
      149      "01A", "19A", "37A", "55A", "01B", "19B", "37B", "55B", "01C", "19C",
      150      "37C", "55C", "01D", "19D", "37D", "55D", "01E", "19E", "37E", "55E",
      151      "01F", "19F", "37F", "55F", "01G", "19G", "37G", "55G", "01H", "19H",
      152      "37H", "55H", "01J", "19J", "37J", "55J", "01K", "19K", "37K", "55K",
      153      "01N", "19N", "37N", "55N", "01P", "19P", "37P", "55P", "01Q", "19Q",
      154      "37Q", "55Q", "01R", "19R", "37R", "55R", "01S", "19S", "37S", "55S",
      155      "01T", "19T", "37T", "55T", "01U", "19U", "37U", "55U", "01V", "19V",
      156      "37V", "55V", "01W", "19W", "37W", "55W", "01X", "19X", "37X", "55X");
      157 
      158 dcl  chip_64k_a6 (0:79) char (3) unal int static options (constant) init (
      159      "10A", "28A", "46A", "64A", "10B", "28B", "46B", "64B", "10C", "28C",
      160      "46C", "64C", "10D", "28D", "46D", "64D", "10E", "28E", "46E", "64E",
      161      "10F", "28F", "46F", "64F", "10G", "28G", "46G", "64G", "10H", "28H",
      162      "46H", "64H", "10J", "28J", "46J", "64J", "10K", "28K", "46K", "64K",
      163      "10N", "28N", "46N", "64N", "10P", "28P", "46P", "64P", "10Q", "28Q",
      164      "46Q", "64Q", "10R", "28R", "46R", "64R", "10S", "28S", "46S", "64S",
      165      "10T", "28T", "46T", "64T", "10U", "28U", "46U", "64U", "10V", "28V",
      166      "46V", "64V", "10W", "28W", "46W", "64W", "10X", "28X", "46X", "64X");
      167 
      168 dcl  board_64k (0:15) char (1) unal int static options (constant) init (
      169      "A", "B", "C", "D", "E", "F", "G", "H", "J", "K", "L", "M", "N", "P", "Q", "R");
      170 
      171 /* The edit_mos_rscr_ entry */
      172 
      173 	decode_sw = "0"b;
      174 
      175 join:	scrp = arg_scrp;
      176 	mem_type, error = "";
      177 
      178 /* First, determine the kind of memory */
      179 
      180 	if scr_su.identification = "0000"b then mem_type = "High Speed Core, Model AA1";
      181 	else if scr_su.identification = "0001"b then mem_type = "High Speed Core, Model AA3";
      182 	else if scr_su.identification = "1100"b then mem_type = "MOS, 1k chip, EDAC disabled";
      183 	else if scr_su.identification = "0100"b then call edit_1k;
      184 	else if scr_su.identification = "1111"b then call edit_M16;
      185 	else if scr_su.identification = "1110"b then call edit_M128;
      186           else if scr_su.identification = "1010"b then call edit_M64;
      187 	else if scr_su.identification = "1011"b then call edit_M264;
      188 	else if scr_su.identification = "0011"b then call edit_M32;
      189 	else do;
      190 	     call ioa_$rsnpnnl ("Unknown memory type, id=^4b", mem_type, (0), scr_su.identification);
      191 	     call ioa_$rsnpnnl ("ZAC line(bits 36-41)=^b, syndrome=^.3b", error, (0), scr_su.ZAC_line, "0"b || scr_su.syndrome);
      192 	end;
      193 
      194 	if decode_sw then do;
      195 	     arg_mem_type = mem_type;
      196 	     arg_error = error;
      197 	end;
      198 	else call ioa_$rsnpnnl ("^a, ^[Error: ^a^;No error.^]", arg_descrip, (0), mem_type, (error ^= ""), error);
      199 	return;
      200 
      201 
      202 
      203 /* The edit_mos_rscr_$decode entry. Returns mem_type and error in seperate feilds */
      204 
      205 decode:	entry (arg_scrp, arg_mem_type, arg_error);
      206 
      207 	decode_sw = "1"b;
      208 	go to join;
      209 
      210 /* Procedure to edit data for 1k chip */
      211 
      212 edit_1k:	proc;
      213 
      214 dcl  a234 fixed bin;				/* Bits 2,3,4 of addr */
      215 dcl  a56 fixed bin;					/* Bits 5 and 6 */
      216 
      217 	     mem_type = "MOS, 1k chip";
      218 	     if scr_su.syndrome = "0"b then return;	/* No error */
      219 
      220 	     if ^substr (scr_su.syndrome, 8, 1) then do;	/* Syndrome must be odd */
      221 bad_1k_synd:	call ioa_$rsnpnnl ("A2-A6=^b, syndrome=^.3b",
      222 		     error, (0), substr (scr_su.ZAC_line, 1, 5), "0"b || scr_su.syndrome);
      223 		return;
      224 	     end;
      225 
      226 	     syndrome = bin (substr (scr_su.syndrome, 1, 7), 7) + 1;
      227 	     bit_no = bit_1k (syndrome);		/* Map syndrome into bit number */
      228 	     if bit_no < 0 then go to bad_1k_synd;
      229 	     quad = quad_1k (syndrome);
      230 
      231 	     a234 = bin (substr (scr_su.ZAC_line, 2, 3), 3);
      232 	     board = substr (board_1k (quad), a234 + 1, 1);
      233 	     a56 = bin (substr (scr_su.ZAC_line, 5, 2), 2);
      234 	     if bit_no < 10 then chip = 10 * a56 + bit_no + 1;
      235 	     else chip = 10 * a56 + (bit_no - 10) + 41;
      236 	     call ioa_$rsnpnnl ("board ^a-^a, chip A^d", error, (0), bay_1k (quad), board, chip);
      237 	     return;
      238 
      239 	end edit_1k;
      240 
      241 /* Procedure to edit 4k mos data */
      242 
      243 edit_M16:	proc;
      244 
      245 dcl  a78 fixed bin;					/* Bits 7-8 of address */
      246 dcl  a910 fixed bin;				/* Bits 9 and 10 of address */
      247 
      248 	     mem_type = "MOS-M16, 4k chip";
      249 	     if scr_su.syndrome = "0"b then return;
      250 
      251 	     if ^substr (scr_su.syndrome, 8, 1) then do;	/* Must be odd */
      252 bad_4k_synd:	call ioa_$rsnpnnl ("A7-A10=^b, syndrome=^.3b",
      253 		     error, (0), substr (scr_su.ZAC_line, 1, 4), "0"b || scr_su.syndrome);
      254 		return;
      255 	     end;
      256 
      257 	     syndrome = bin (substr (scr_su.syndrome, 1, 7), 7) + 1;
      258 	     bit_no = bit_4k (syndrome);
      259 	     if bit_no < 0 then go to bad_4k_synd;
      260 	     quad = quad_4k (syndrome);
      261 	     a78 = bin (substr (scr_su.ZAC_line, 1, 2), 2);
      262 	     board = substr (board_4k (quad), a78 + 1, 1);
      263 	     a910 = bin (substr (scr_su.ZAC_line, 3, 2), 2);
      264 	     chip = 20 * a910 + bit_no;
      265 	     call ioa_$rsnpnnl ("board ^a, chip A^d", error, (0), board, chip);
      266 	     return;
      267 
      268 	end edit_M16;
      269 
      270 /* Procedure to edit data from 16-pin chip memories - 4k and 16k chips */
      271 
      272 edit_M128: proc;
      273 
      274 dcl  a45 fixed bin;
      275 dcl  a678 fixed bin;
      276 dcl  chip_letter char (1);
      277 dcl  chip_pic picture "99";
      278 dcl  addr_bits char (32) var;
      279 
      280 	     mem_type = "MOS-M128, 16k chip";
      281 	     addr_bits = "A4-A8";
      282 edit_join:
      283 	     if scr_su.syndrome = "0"b then return;	/* No error */
      284 
      285 	     if ^substr (scr_su.syndrome, 8, 1) then do;	/* Syndrome not odd */
      286 bad_M128_synd:	call ioa_$rsnpnnl ("^a=^b, syndrome=^.3b", error, (0),
      287 		     addr_bits, substr (scr_su.ZAC_line, 1, 5), "0"b || scr_su.syndrome);
      288 		return;
      289 	     end;
      290 
      291 	     syndrome = bin (substr (scr_su.syndrome, 1, 7), 7) + 1;
      292 	     bit_no = bit_4k (syndrome);
      293 	     if bit_no < 0 then go to bad_M128_synd;
      294 	     quad = quad_4k (syndrome);
      295 	     a45 = bin (substr (scr_su.ZAC_line, 1, 2));
      296 	     a678 = bin (substr (scr_su.ZAC_line, 3, 3));
      297 	     board = substr (board_4k (quad), a45 + 1);
      298 	     chip_letter = substr ("ABCDEGHJKL", divide (bit_no, 2, 17, 0) + 1, 1);
      299 	     if mod (bit_no, 2) = 1 then chip_pic = 7 - a678;
      300 	     else chip_pic = 18 - a678;
      301 	     call ioa_$rsnpnnl ("board ^a, chip ^a^a", error, (0),
      302 		board, chip_pic, chip_letter);
      303 	     return;
      304 
      305 edit_M32:	     entry;
      306 
      307 	     mem_type = "MOS-M32, 4k chip";
      308 	     addr_bits = "A6-A10";
      309 	     go to edit_join;
      310 
      311 	end edit_M128;
      312 
      313 /* Procedure to edit 16k M264 chip */
      314 
      315 edit_M264: proc;
      316 
      317 dcl  a4567 fixed bin;
      318 dcl  a8 bit (1);
      319 dcl  chip_name char (3);
      320 dcl  chip_pic pic "9";
      321 
      322 	     mem_type = "MOS-M264, 16k chip";
      323 
      324 	     if scr_su.syndrome = "0"b then return;
      325 
      326 	     if ^substr (scr_su.syndrome, 8, 1) then do;	/* Must be odd */
      327 bad_M264_synd:	call ioa_$rsnpnnl ("A4-A8=^b, syndrome=^.3b", error, (0),
      328 		     substr (scr_su.ZAC_line, 1, 5), "0"b || scr_su.syndrome);
      329 		return;
      330 	     end;
      331 
      332 	     syndrome = bin (substr (scr_su.syndrome, 1, 7), 7) + 1;
      333 	     bit_no = bit_16k (syndrome);
      334 	     if bit_no < 0 then go to bad_M264_synd;
      335 	     a4567 = bin (substr (scr_su.ZAC_line, 1, 4), 4);
      336 	     a8 = substr (scr_su.ZAC_line, 5, 1);
      337 	     chip_name = chip_16k (bit_no);
      338 	     if a8 then do;
      339 		chip_pic = bin (substr (chip_name, 1, 1)) + 1;
      340 		substr (chip_name, 1, 1) = chip_pic;
      341 	     end;
      342 	     call ioa_$rsnpnnl ("board ^a, chip ^a", error, (0),
      343 		board_16k (a4567), chip_name);
      344 	     return;
      345 
      346 	end edit_M264;
      347 
      348 /* Procedure to edit 64k M64 chip */
      349 
      350 edit_M64: proc;
      351 
      352 dcl  a2345 fixed bin;
      353 dcl  a6 bit (1);
      354 dcl  chip_name char (3);
      355 
      356 	     mem_type = "MOS-M64, 64k chip";
      357 
      358 	     if scr_su.syndrome = "0"b then return;
      359 
      360 	     if ^substr (scr_su.syndrome, 8, 1) then do;	/* Must be odd */
      361 bad_M64_synd:	call ioa_$rsnpnnl ("A2-A6=^b, syndrome=^.3b", error, (0),
      362 		     substr (scr_su.ZAC_line, 1, 5), "0"b || scr_su.syndrome);
      363 		return;
      364 	     end;
      365 
      366 	     syndrome = bin (substr (scr_su.syndrome, 1, 7), 7) + 1;
      367 	     bit_no = bit_64k (syndrome);
      368 	     if bit_no < 0 then go to bad_M64_synd;
      369 	     a2345 = bin (substr (scr_su.ZAC_line, 1, 4), 4);
      370 	     a6 = substr (scr_su.ZAC_line, 5, 1);
      371 	     if a6 then chip_name = chip_64k_a6 (bit_no);
      372                else chip_name = chip_64k_not_a6 (bit_no);     
      373 	     call ioa_$rsnpnnl ("board ^a, chip ^a", error, (0),
      374 		board_64k (a2345), chip_name);
      375 	     return;
      376 
      377 	end edit_M64;
      378 
      379 /* The following debuging entries are commands which will check
      380*   the translation tables for consistency and print a syndome table in a format
      381*   similiar to that on the memory. These entries are not retained and are used
      382*   only to help in verifying the correctness of the tables. */
      383 
      384 debug_1k:	entry;
      385 
      386 	call debug_test (bit_1k, quad_1k);
      387 	return;
      388 
      389 debug_4k:	entry;
      390 
      391 	call debug_test (bit_4k, quad_4k);
      392 	return;
      393 
      394 debug_test: proc (b, q);
      395 
      396 dcl  b (128) fixed bin (8) unal;
      397 dcl  q (128) fixed bin (3) unal;
      398 dcl  dat (4, 0:19) fixed bin;				/* Table built here */
      399 dcl (i, j) fixed bin;
      400 dcl  bits (4) bit (9);
      401 
      402 	     dat = -1;
      403 	     do i = 1 to 128;
      404 		if ^(b (i) = -1 & q (i) = 0) then do;	/* If position not undefined */
      405 		     if b (i) < 0 | b (i) > 19 | q (i) < 1 | q (i) > 4 then /* Bad number */
      406 			call ioa_ ("error at ^d: ^d, ^d", i, b (i), q (i));
      407 		     else if dat (q (i), b (i)) ^= -1 then /* Duplicate (reused address?) */
      408 			call ioa_ ("duplicate at ^d: ^d, ^d", i, b (i), q (i));
      409 		     else dat (q (i), b (i)) = i;
      410 		end;
      411 	     end;
      412 	     do i = 1 to 4;				/* Check for missing entries */
      413 		do j = 0 to 19;
      414 		     if dat (i, j) = -1 then call ioa_ ("no entry for ^d, ^d", j, i);
      415 		end;
      416 	     end;
      417 	     do j = 0 to 19;			/* Print table */
      418 		do i = 1 to 4;
      419 		     if dat (i, j) = -1 then bits (i) = (9)"1"b;
      420 		     else bits (i) = bit (bin (dat (i, j)-1, 8), 8) || "1"b;
      421 		end;
      422 		call ioa_ ("^2d   ^(^3.3b ^)", j, bits);
      423 	     end;
      424 	     return;
      425 
      426 	end debug_test;
      427 
      428 debug_16k: entry;
      429 
      430 	do i = 1 to 128;
      431 	     if bit_16k (i) >= 0 then
      432 		call ioa_ ("^.3b ^a", "0"b || bit (bin (2 * (i-1) + 1, 8), 8), bit_name_16k ((bit_16k (i))));
      433 	end;
      434 	do i = 0 to 79;
      435 	     call ioa_ ("^4a ^a ^d^a", bit_name_16k (i), chip_16k (i), bin (substr (chip_16k (i), 1, 1)) + 1, substr (chip_16k (i), 2));
      436 	end;
      437 	return;
      438 
      439 bit_name_16k: proc (b) returns (char (2));
      440 
      441 dcl  b fixed bin;
      442 dcl  p picture "99";
      443 
      444 	     if b <= 71 then do;
      445 		p = b;
      446 		return (p);
      447 	     end;
      448 	     else do;
      449 		p = b-71;
      450 		return ("P" || substr (p, 2));
      451 	     end;
      452 
      453 	end bit_name_16k;
      454 
      455 debug_64k: entry;
      456 
      457 	do i = 1 to 128;
      458 	     if bit_64k (i) >= 0 then
      459 		call ioa_ ("^.3b ^a", "0"b || bit (bin (2 * (i-1) + 1, 8), 8), bit_name_64k ((bit_64k (i))));
      460 	end;
      461 	do i = 0 to 79;
      462 	     call ioa_ ("^4a ^a ^a", bit_name_64k (i), chip_64k_not_a6 (i), chip_64k_a6 (i));
      463 	end;
      464 	return;
      465 
      466 bit_name_64k: proc (b) returns (char (3));
      467 
      468 dcl  b fixed bin;
      469 dcl  p picture "99";
      470 
      471 	     if b <= 71 then do;
      472 		p = b;
      473 		return (p);
      474 	     end;
      475 	     else do;
      476 		p = b-71;
      477 		return ("PC" || substr (p, 2));
      478 	     end;
      479 
      480 	end bit_name_64k;
      481 
      482      end edit_mos_rscr_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/02/83  1103.3  edit_mos_rscr_.pl1                >special_ldd>on>06/02/83>edit_mos_rscr_.pl1
44           1    06/10/82  1045.2  scr.incl.pl1                      >ldd>include>scr.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ZAC_line                  1            based           bit(6)                   level 2 packed unaligned dcl 1-115 set ref 191* 221
                                                                                  221 231 233 252 252 261 263 286 286 295 296 327
                                                                                  327 335 336 361 361 369 370
a234                            000140 automatic       fixed bin(17,0)          dcl 214 set ref 231* 232
a2345                           000216 automatic       fixed bin(17,0)          dcl 352 set ref 369* 373
a45                             000160 automatic       fixed bin(17,0)          dcl 274 set ref 295* 297
a4567                           000204 automatic       fixed bin(17,0)          dcl 317 set ref 335* 342
a56                             000141 automatic       fixed bin(17,0)          dcl 215 set ref 233* 234 235
a6                              000217 automatic       bit(1)                   unaligned dcl 353 set ref 370* 371
a678                            000161 automatic       fixed bin(17,0)          dcl 275 set ref 296* 299 300
a78                             000150 automatic       fixed bin(17,0)          dcl 245 set ref 261* 262
a8                              000205 automatic       bit(1)                   unaligned dcl 318 set ref 336* 338
a910                            000151 automatic       fixed bin(17,0)          dcl 246 set ref 263* 264
addr_bits                       000164 automatic       varying char(32)         dcl 278 set ref 281* 286* 308*
arg_descrip                            parameter       varying char             dcl 22 set ref 18 198*
arg_error                              parameter       char                     unaligned dcl 24 set ref 196* 205
arg_mem_type                           parameter       char                     unaligned dcl 23 set ref 195* 205
arg_scrp                               parameter       pointer                  dcl 25 ref 18 175 205
b                                      parameter       fixed bin(17,0)          dcl 441 in procedure "bit_name_16k" ref 439 444 445
                                                                                  449
b                                      parameter       fixed bin(17,0)          dcl 468 in procedure "bit_name_64k" ref 466 471 472
                                                                                  476
b                                      parameter       fixed bin(8,0)           array unaligned dcl 396 in procedure "debug_test"
                                                                                  set ref 394 404 405 405 405* 407 407* 409
bay_1k                          000457 constant        char(3)                  initial array unaligned dcl 77 set ref 236*
bin                                                    builtin function         dcl 42 ref 226 231 233 257 261 263 291 295 296 332
                                                                                  335 339 366 369 420 431 435 458
bit                                                    builtin function         dcl 42 ref 420 431 458
bit_16k                         000334 constant        fixed bin(8,0)           initial array unaligned dcl 113 ref 333 431 431 431
bit_1k                          000511 constant        fixed bin(8,0)           initial array unaligned dcl 50 set ref 227 386*
bit_4k                          000417 constant        fixed bin(8,0)           initial array unaligned dcl 84 set ref 258 292 391*
bit_64k                         000174 constant        fixed bin(8,0)           initial array unaligned dcl 138 ref 367 458 458 458
bit_no                          000122 automatic       fixed bin(17,0)          dcl 33 set ref 227* 228 234 234 235 258* 259 264
                                                                                  292* 293 298 299 333* 334 337 367* 368 371 372
bits                            000352 automatic       bit(9)                   array unaligned dcl 400 set ref 419* 420* 422*
board                           000123 automatic       char(1)                  unaligned dcl 34 set ref 232* 236* 262* 265* 297*
                                                                                  301*
board_16k                       000234 constant        char(1)                  initial array unaligned dcl 133 set ref 342*
board_1k                        000462 constant        char(8)                  initial array unaligned dcl 74 ref 232
board_4k                        000374 constant        char(4)                  initial array unaligned dcl 106 ref 262 297
board_64k                       000000 constant        char(1)                  initial array unaligned dcl 168 set ref 373*
chip                            000126 automatic       fixed bin(17,0)          dcl 37 set ref 234* 235* 236* 264* 265*
chip_16k                        000240 constant        char(3)                  initial array unaligned dcl 123 set ref 337 435* 435
                                                                                  435 435
chip_64k_a6                     000004 constant        char(3)                  initial array unaligned dcl 158 set ref 371 462*
chip_64k_not_a6                 000100 constant        char(3)                  initial array unaligned dcl 148 set ref 372 462*
chip_letter                     000162 automatic       char(1)                  unaligned dcl 276 set ref 298* 301*
chip_name                       000220 automatic       char(3)                  unaligned dcl 354 in procedure "edit_M64" set ref
                                                                                  371* 372* 373*
chip_name                       000206 automatic       char(3)                  unaligned dcl 319 in procedure "edit_M264" set ref
                                                                                  337* 339 340* 342*
chip_pic                        000163 automatic       picture(2)               unaligned dcl 277 in procedure "edit_M128" set ref
                                                                                  299* 300* 301*
chip_pic                        000207 automatic       picture(1)               unaligned dcl 320 in procedure "edit_M264" set ref
                                                                                  339* 340
dat                             000230 automatic       fixed bin(17,0)          array dcl 398 set ref 402* 407 409* 414 419 420
decode_sw                       000100 automatic       bit(1)                   unaligned dcl 29 set ref 173* 194 207*
divide                                                 builtin function         dcl 42 ref 298
error                           000111 automatic       char(32)                 unaligned dcl 31 set ref 176* 191* 196 198 198* 221*
                                                                                  236* 252* 265* 286* 301* 327* 342* 361* 373*
i                               000350 automatic       fixed bin(17,0)          dcl 399 in procedure "debug_test" set ref 403* 404
                                                                                  404 405 405 405 405 405* 405 405 407 407 407* 407
                                                                                  407 409 409 409* 412* 414 414* 418* 419 419 420
                                                                                  420*
i                               000125 automatic       fixed bin(17,0)          dcl 36 in procedure "edit_mos_rscr_" set ref 430*
                                                                                  431 431 431 431* 434* 435* 435* 435 435 435 435*
                                                                                  457* 458 458 458 458* 461* 462* 462* 462 462*
identification            1(14)        based           bit(4)                   level 2 packed unaligned dcl 1-115 set ref 180 181
                                                                                  182 183 184 185 186 187 188 190*
ioa_                            000010 constant        entry                    external dcl 39 ref 405 407 414 422 431 435 458 462
ioa_$rsnpnnl                    000012 constant        entry                    external dcl 40 ref 190 191 198 221 236 252 265 286
                                                                                  301 327 342 361 373
j                               000351 automatic       fixed bin(17,0)          dcl 399 set ref 413* 414 414* 417* 419 420 422*
mem_type                        000101 automatic       char(32)                 unaligned dcl 30 set ref 176* 180* 181* 182* 190*
                                                                                  195 198* 217* 248* 280* 307* 322* 356*
mod                                                    builtin function         dcl 42 ref 299
p                               000374 automatic       picture(2)               unaligned dcl 469 in procedure "bit_name_64k" set
                                                                                  ref 472* 473 476* 477
p                               000364 automatic       picture(2)               unaligned dcl 442 in procedure "bit_name_16k" set
                                                                                  ref 445* 446 449* 450
q                                      parameter       fixed bin(3,0)           array unaligned dcl 397 set ref 394 404 405 405 405*
                                                                                  407 407* 409
quad                            000124 automatic       fixed bin(17,0)          dcl 35 set ref 229* 232 236 260* 262 294* 297
quad_1k                         000472 constant        fixed bin(3,0)           initial array unaligned dcl 62 set ref 229 386*
quad_4k                         000400 constant        fixed bin(3,0)           initial array unaligned dcl 96 set ref 260 294 391*
scr_su                                 based           structure                level 1 dcl 1-115
scrp                            000130 automatic       pointer                  dcl 1-21 set ref 175* 180 181 182 183 184 185 186
                                                                                  187 188 190 191 191 218 220 221 221 221 226 231
                                                                                  233 249 251 252 252 252 257 261 263 282 285 286
                                                                                  286 286 291 295 296 324 326 327 327 327 332 335
                                                                                  336 358 360 361 361 361 366 369 370
substr                                                 builtin function         dcl 42 set ref 220 221 221 226 231 232 233 251 252
                                                                                  252 257 261 262 263 285 286 286 291 295 296 297
                                                                                  298 326 327 327 332 335 336 339 340* 360 361 361
                                                                                  366 369 370 435 435 435 450 477
syndrome                  1(06)        based           bit(8)                   level 2 in structure "scr_su" packed unaligned
                                                                                  dcl 1-115 in procedure "edit_mos_rscr_" ref 191
                                                                                  218 220 221 226 249 251 252 257 282 285 286 291
                                                                                  324 326 327 332 358 360 361 366
syndrome                        000121 automatic       fixed bin(17,0)          dcl 32 in procedure "edit_mos_rscr_" set ref 226*
                                                                                  227 229 257* 258 260 291* 292 294 332* 333 366*
                                                                                  367

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SC_CFG                                 internal static fixed bin(6,0)           initial dcl 1-13
SC_ETC                                 internal static fixed bin(6,0)           initial dcl 1-13
SC_IC                                  internal static fixed bin(6,0)           initial dcl 1-13
SC_MR                                  internal static fixed bin(6,0)           initial dcl 1-13
SC_MSK                                 internal static fixed bin(6,0)           initial dcl 1-13
SC_SU                                  internal static fixed bin(6,0)           initial dcl 1-13
scr_cfg1                               based           structure                level 1 dcl 1-23
scr_cfg2                               based           structure                level 1 dcl 1-49
scr_mr                                 based           structure                level 1 dcl 1-78
scr_msk                                based           structure                level 1 dcl 1-104

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_1k_synd                     001761 constant        label                    dcl 221 ref 228
bad_4k_synd                     002204 constant        label                    dcl 252 ref 259
bad_M128_synd                   002402 constant        label                    dcl 286 ref 293
bad_M264_synd                   002655 constant        label                    dcl 327 ref 334
bad_M64_synd                    003067 constant        label                    dcl 361 ref 368
bit_name_16k                    003640 constant        entry                    internal dcl 439 ref 431 431 435 435
bit_name_64k                    003710 constant        entry                    internal dcl 466 ref 458 458 462 462
debug_16k                       001426 constant        entry                    external dcl 428
debug_1k                        001404 constant        entry                    external dcl 384
debug_4k                        001415 constant        entry                    external dcl 389
debug_64k                       001610 constant        entry                    external dcl 455
debug_test                      003245 constant        entry                    internal dcl 394 ref 386 391
decode                          001360 constant        entry                    external dcl 205
edit_1k                         001745 constant        entry                    internal dcl 212 ref 183
edit_M128                       002361 constant        entry                    internal dcl 272 ref 185
edit_M16                        002170 constant        entry                    internal dcl 243 ref 184
edit_M264                       002641 constant        entry                    internal dcl 315 ref 187
edit_M32                        002627 constant        entry                    internal dcl 305 ref 188
edit_M64                        003053 constant        entry                    internal dcl 350 ref 186
edit_join                       002372 constant        label                    dcl 282 ref 309
edit_mos_rscr_                  001065 constant        entry                    external dcl 18
join                            001101 constant        label                    dcl 175 ref 208

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4124        4140    4030        4134
Length      4362    4030        14         205      74           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
edit_mos_rscr_                      894 external procedure  is an external procedure.  
edit_1k                                 internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
edit_M16                                internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
edit_M128                               internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
edit_M264                               internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
edit_M64                                internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
debug_test                              internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
bit_name_16k                            internal procedure  shares stack frame of external procedure edit_mos_rscr_.  
bit_name_64k                            internal procedure  shares stack frame of external procedure edit_mos_rscr_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
edit_mos_rscr_           000100 decode_sw                   edit_mos_rscr_
                         000101 mem_type                    edit_mos_rscr_
                         000111 error                       edit_mos_rscr_
                         000121 syndrome                    edit_mos_rscr_
                         000122 bit_no                      edit_mos_rscr_
                         000123 board                       edit_mos_rscr_
                         000124 quad                        edit_mos_rscr_
                         000125 i                           edit_mos_rscr_
                         000126 chip                        edit_mos_rscr_
                         000130 scrp                        edit_mos_rscr_
                         000140 a234                        edit_1k
                         000141 a56                         edit_1k
                         000150 a78                         edit_M16
                         000151 a910                        edit_M16
                         000160 a45                         edit_M128
                         000161 a678                        edit_M128
                         000162 chip_letter                 edit_M128
                         000163 chip_pic                    edit_M128
                         000164 addr_bits                   edit_M128
                         000204 a4567                       edit_M264
                         000205 a8                          edit_M264
                         000206 chip_name                   edit_M264
                         000207 chip_pic                    edit_M264
                         000216 a2345                       edit_M64
                         000217 a6                          edit_M64
                         000220 chip_name                   edit_M64
                         000230 dat                         debug_test
                         000350 i                           debug_test
                         000351 j                           debug_test
                         000352 bits                        debug_test
                         000364 p                           bit_name_16k
                         000374 p                           bit_name_64k

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   return              mod_fx1             ext_entry           ext_entry_desc
any_to_any_tr

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
ioa_                          ioa_$rsnpnnl

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 001061       173 001100       175 001101       176 001105       180 001113       181 001124       182 001132
    183 001140       184 001144       185 001150       186 001154       187 001160       188 001164       190 001170
    191 001223       194 001266       195 001270       196 001276       197 001303       198 001304       199 001353
    205 001354       207 001400       208 001402       384 001403       386 001411       387 001413       389 001414
    391 001422       392 001424       428 001425       430 001433       431 001441       433 001513       434 001515
    435 001521       436 001604       437 001606       455 001607       457 001615       458 001623       460 001675
    461 001677       462 001703       463 001742       464 001744       212 001745       217 001746       218 001751
    220 001756       221 001761       223 002032       226 002033       227 002040       228 002047       229 002050
    231 002060       232 002064       233 002073       234 002077       235 002110       236 002117       237 002167
    243 002170       248 002171       249 002174       251 002201       252 002204       254 002255       257 002256
    258 002263       259 002272       260 002273       261 002303       262 002306       263 002314       264 002320
    265 002323       266 002360       272 002361       280 002362       281 002365       282 002372       285 002377
    286 002402       288 002454       291 002455       292 002462       293 002471       294 002472       295 002502
    296 002505       297 002511       298 002522       299 002530       300 002551       301 002563       303 002626
    305 002627       307 002630       308 002633       309 002640       315 002641       322 002642       324 002645
    326 002652       327 002655       329 002726       332 002727       333 002734       334 002743       335 002744
    336 002747       337 002753       338 002761       339 002763       340 003006       342 003010       344 003052
    350 003053       356 003054       358 003057       360 003064       361 003067       363 003140       366 003141
    367 003146       368 003155       369 003156       370 003161       371 003165       372 003175       373 003202
    375 003244       394 003245       402 003247       403 003275       404 003303       405 003333       407 003406
    409 003460       411 003463       412 003465       413 003473       414 003477       415 003530       416 003532
    417 003534       418 003541       419 003547       420 003563       421 003604       422 003606       423 003635
    424 003637       439 003640       444 003642       445 003645       446 003656       449 003663       450 003675
    466 003710       471 003712       472 003715       473 003726       476 003733       477 003745


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
