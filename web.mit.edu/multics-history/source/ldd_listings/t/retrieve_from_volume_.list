	COMPILATION LISTING OF SEGMENT retrieve_from_volume_
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/21/92  1509.2 mdt Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1991   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 /****^  HISTORY COMMENTS:
       17*  1) change(88-08-10,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
       18*     install(88-10-17,MR12.2-1173):
       19*     Updated iox_ dcls and calls.
       20*     Changed read mechanism to deal with incomplete data from dump tapes.
       21*  2) change(91-11-12,Schroth), approve(91-12-02,MCR8252),
       22*     audit(92-10-15,Zimmerman), install(92-10-21,MR12.5-1035):
       23*     Correct error in truncating segments containing embedded nulled pages.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 
       27 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       28 
       29 retrieve_from_volume_: proc (a_rvcp, code);
       30 
       31 
       32 /* This proc searches a dump volume specified by the volume control seg for all the objects specified therein.
       33*   If one is found, then the appropriate action, either entry appending, or object copying is attempted. If
       34*   successful the operator, and the requestor if he indicated, are notified.  The dump volume is searched
       35*   until no more useful information can be read. It is then closed but not detached in case the next volume to be read
       36*   should be the same.
       37**/
       38 
       39 /* Modified by D. Vinograd 6/79 to change check for logical header, to correct authorization in notify
       40*   messages, to fix bug in buffer truncation, and xxx.
       41**/
       42 /* Modified 2/10/82 by GA Texada to delete a recovered branch if the object cannot be recovered (hardcore 347)     */
       43 /* Modified 4/27/82 by GA Texada to change error handling on read errors.     */
       44 /* Modified July 1982 by GA Texada to fix a bug introduced above.		     */
       45 /* Modified: 8/82 by GA Texada to fix phx07704				     */
       46 /* Modified: 84-03-16 by BIM to put in temporary fix to retrieve multi-class segments. 
       47*	   This introduces a security hole that is closed by code in ring zero 
       48*	   that sets SOOS when retv-appending multiclass objects. */
       49 /* Modified: 84-12-27 by Keith Loepere for version 2 create_branch_info. */
       50 /* Modified 03/12/85 by Greg Texada to fix phx19165, don't give up so soon when resynching (D. Kitson)	*/
       51 
       52 dcl a_rvcp	     ptr;
       53 dcl aclc		     fixed bin;
       54 dcl aclp		     ptr;
       55 dcl aclrp		     bit (18);
       56 dcl answer	     char (3) var;
       57 dcl att_desc	     char (256);
       58 dcl attributes	     bit (36);
       59 dcl nelt		     fixed bin (21);
       60 dcl code		     fixed bin (35);
       61 dcl crbp		     ptr;
       62 dcl dp		     ptr;
       63 dcl dtd		     bit (36);
       64 dcl dtm		     bit (36);
       65 dcl emode		     bit (36);
       66 dcl ename		     char (32) aligned;
       67 dcl cslx		     fixed bin;
       68 dcl nmx		     fixed bin;
       69 dcl rvlx		     fixed bin;
       70 dcl ignore	     fixed bin (35);
       71 dcl iocbp		     ptr;
       72 dcl long		     char (100) aligned;
       73 dcl message	     char (512) var init ("");
       74 dcl message_len	     fixed bin;
       75 dcl new_contentsp	     ptr;
       76 dcl nlc		     fixed bin;
       77 dcl nlp		     ptr;
       78 dcl nrp		     bit (18);
       79 dcl object_read	     bit (1);
       80 dcl object_size	     fixed bin (19);
       81 dcl objectp	     ptr;
       82 dcl page_bufferp	     ptr;
       83 dcl page_offset	     fixed bin (21);
       84 dcl pmode		     bit (36);
       85 dcl pname		     char (168) aligned;
       86 dcl pnl		     fixed bin;
       87 dcl pvid		     bit (36);
       88 dcl nel		     fixed bin (21);
       89 dcl requests_left	     fixed bin;
       90 dcl resynch_retry_count  fixed bin;
       91 dcl resynching	     bit (1);
       92 dcl resynching_completed bit (1);
       93 dcl short		     char (8) aligned;
       94 dcl temp_dirname	     char (168);
       95 dcl temp_ename	     char (32);
       96 dcl type		     fixed bin;
       97 dcl uid		     bit (36);
       98 dcl volid		     bit (36);
       99 dcl volname	     char (32);
      100 dcl vtoce_volid	     (3) bit (36);
      101 dcl words_skipped	     fixed bin (35);
      102 
      103 dcl page		     bit (BITS_PER_PAGE) aligned based;
      104 dcl based_area	     area based (retv_data_.areap);
      105 dcl copy		     (divide (nel, CHARS_PER_WORD, 17, 0)) fixed bin based;
      106 dcl name_list	     (2) char (32) aligned based (nlp);
      107 
      108 dcl 1 local_entry	     like entry;
      109 dcl 1 local_retv_append_args like retv_append_args aligned;
      110 dcl 1 local_create_branch_info like create_branch_info aligned;
      111 dcl 1 local_mseg_return_args like mseg_return_args aligned;
      112 
      113 dcl 1 acl_list	     (1) based (aclp) aligned,
      114     2 person	     char (32),
      115     2 project	     char (32),
      116     2 tag		     char (1),
      117     2 mode	     bit (36),
      118     2 ex_mode	     bit (36);
      119 
      120 
      121 dcl dates_set	     defined attributes position (1) bit (1);
      122 dcl dump_switches_set    defined attributes position (2) bit (1);
      123 dcl dump_info_set	     defined attributes position (3) bit (1);
      124 dcl pc_switches_set	     defined attributes position (4) bit (1);
      125 dcl quota_info_set	     defined attributes position (5) bit (1);
      126 
      127 dcl word		     (size (backup_volume_header)) bit (36) based (recordp);
      128 dcl input_buf	     (divide (nelt, CHARS_PER_WORD, 17, 0)) bit (36) based (recordp);
      129 dcl string	     bit (BITS_PER_WORD * size (backup_volume_header)) based (recordp);
      130 dcl DELIMITED	     bit (1) aligned internal static options (constant)
      131 		     init ("1"b);
      132 dcl FORWARD_CHAR_POSITIONING fixed bin int static init (3) options (constant);
      133 dcl myname	     char (32) int static init ("retrieve_from_volume_") options (constant);
      134 dcl SEG		     fixed bin static init (1) options (constant);
      135 dcl sm		     bit (3) int static init ("110"b) options (constant);
      136 dcl directory	     fixed bin int static init (1) options (constant);
      137 
      138 dcl (error_table_$namedup,
      139   error_table_$data_loss,
      140   error_table_$force_unassign,
      141   error_table_$notadir,
      142   error_table_$resource_unavailable,
      143   error_table_$noentry,
      144   error_table_$moderr,
      145   error_table_$vtoce_connection_fail,
      146   error_table_$bad_segment,
      147   error_table_$device_end,
      148   error_table_$end_of_info,
      149   error_table_$root)     fixed bin (35) ext static;
      150 
      151 dcl retv_notify_	     entry (char (*), ptr, char (*));
      152 dcl command_query_	     entry options (variable);
      153 dcl hc_backup_$delete    entry (char (*), char (*), fixed bin (35));
      154 dcl hc_backup_$set_bc    entry (char (*), char (*), fixed bin (24), fixed bin (24), fixed bin (35));
      155 dcl hc_backup_$get_entry entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
      156 dcl hc_backup_$decode_uidpath entry ((16) bit (36) aligned, char (*), char (*), fixed bin (35));
      157 dcl suffixed_name_$make  entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
      158 dcl hc_backup_$retv_status entry (char (*) aligned, char (*) aligned, bit (72) aligned, char (*) aligned,
      159 		     fixed bin, fixed bin, bit (36), bit (36), bit (36), bit (36), (3) bit (36), bit (36), fixed bin (35));
      160 dcl convert_status_code_ entry (fixed bin (35), char (8) aligned, char (100) aligned);
      161 dcl hcs_$truncate_seg    entry (ptr, fixed bin (19), fixed bin (35));
      162 dcl hcs_$make_seg	     entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (5), ptr, fixed bin (35));
      163 dcl ioa_$rsnnl	     entry options (variable);
      164 dcl message_segment_$incremental_read_index entry (fixed bin, ptr, bit (2), bit (72) aligned, ptr, fixed bin (35));
      165 dcl message_segment_$update_message_index entry (fixed bin, fixed bin, bit (72) aligned, ptr, fixed bin (35));
      166 dcl retv_report_$error_output entry options (variable);
      167 dcl retv_report_$online_output entry options (variable);
      168 dcl hc_backup_$retv_check entry (char (*) aligned, char (*) aligned, fixed bin, bit (36), fixed bin (35));
      169 dcl hc_backup_$retv_add_acl entry (char (*) aligned, char (*) aligned, ptr, fixed bin, fixed bin (35));
      170 dcl hc_backup_$retv_addname entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (35));
      171 dcl hc_backup_$retv_hash_search entry (ptr, ptr, ptr, fixed bin (35));
      172 dcl hc_backup_$retv_append entry (char (*) aligned, char (*) aligned, ptr, ptr, fixed bin (35));
      173 dcl hc_backup_$retv_copy entry (char (*) aligned, char (*) aligned, bit (72) aligned, char (*) aligned, fixed bin,
      174 		     ptr, ptr, bit (36), fixed bin (35));
      175 dcl (addcharno, addr, bit, divide, fixed, index, length, min, null, ptr, rtrim, size, substr, unspec) builtin;
      176 
      177     rvcp = a_rvcp;
      178     code = 0;
      179     if retv_vol_control.in_use_cnt = 0 then return;	/* nothing to look at */
      180 						/* pick static ptr */
      181     recordp = retv_data_.recordp;
      182     nlp = retv_data_.nlp;
      183     aclp = retv_data_.aclp;
      184     objectp = retv_data_.objectp;
      185     page_bufferp = retv_data_.page_buffer_ptr;
      186 						/* initialize local variables */
      187     ms_arg_ptr = addr (local_mseg_return_args);
      188     resynching = "0"b;
      189     resynching_completed = "0"b;
      190     iocbp = null;
      191     inputp = null;
      192 						/* initialize mail structure */
      193 
      194 /* construct attach description */
      195     volname = retv_vol_control.volname;
      196     volid = retv_vol_control.volid;
      197     if retv_data_.input_volume_desc ^= "" then
      198       call ioa_$rsnnl (retv_data_.input_volume_desc, att_desc, (0), volname);
      199     else call ioa_$rsnnl ("tape_mult_ ^a -system", att_desc, (0), volname);
      200 
      201 /* Check if volume to be read is same as last volume read. If so then its already mounted and at
      202*   load point. If not then detach old volume and attach new volume. In either case open volume */
      203 
      204     if volname ^= retv_data_.last_volname then do;
      205         if retv_data_.input_iocbp ^= null then
      206 	call iox_$detach_iocb (retv_data_.input_iocbp, ignore);
      207         iocbp = null;
      208 retry:  call iox_$attach_name ("input_volume", iocbp, att_desc, null (), code);
      209         retv_data_.input_iocbp = iocbp;
      210         if code ^= 0 then do;
      211 	  if code = error_table_$resource_unavailable |
      212 	       code = error_table_$force_unassign then do;
      213 	      if ^retv_vol_control.skip_query then do;
      214 		query_info.version = query_info_version_5;
      215 		call command_query_ (addr (query_info), answer, myname, "^/^a^/^a",
      216 		     "The physical drive or dump volume is not available or is in use by an other process.",
      217 		     "Do you wish to retry the attachment ");
      218 		if answer = "yes" then goto retry;
      219 		else retv_vol_control.skip_query = "1"b;
      220 	        end;
      221 	      else code = -1;			/* special code that we skipped volume */
      222 	    end;
      223 	  call retv_report_$error_output (code, myname, "Unable to attach dump volume ^a via desc ^a",
      224 	       volname, att_desc);
      225 	  goto finish;
      226 	end;
      227       end;
      228     else iocbp = retv_data_.input_iocbp;
      229 
      230     call iox_$open (iocbp, Stream_input, "0"b, code);
      231     if code ^= 0 then do;
      232         call retv_report_$error_output (code, myname, "Unable to  open dump volume ^a", volname);
      233         goto finish;
      234       end;
      235     retv_data_.last_volname = volname;
      236     requests_left = retv_vol_control.n_entries;
      237     if retv_data_.long then do;
      238         call retv_report_$online_output (0, "", "Reading ^a looking for:", volname);
      239         do rvlx = 1 to retv_vol_control.n_entries;
      240 	rvcep = addr (retv_vol_control.array (rvlx));
      241 	if rvce.in_use then do;
      242 	    if rvce.entry_retrieval then
      243 	      call retv_report_$online_output (0, "", "Entry retrieval of ^a^[>^]^[^a>^;^s^]^a",
      244 		 rvce.dirname, (rvce.dirname ^= ">"), (rvce.ename ^= ""), rvce.ename, rvce.entry_name);
      245 	    else call retv_report_$online_output (0, "", "Object retrieval of ^a^[>^]^a",
      246 		    rvce.dirname, (rvce.dirname ^= ">"), rvce.ename);
      247 	  end;
      248         end;
      249       end;
      250 
      251 /* This is the main reading loop. The reading scheme is like that of the reloader. Each read is checked for
      252*   an error and if one occured recovery is attempted. Recovery is made a brute force resynching on the pattern
      253*   contained in the record header.  If a read is ok then then the header pattern is checked. If ok then the rest of the
      254*   header is read and checked for type. If it is contents seg then a check is made to see if
      255*   the segment is online. If not an attempt is made to recover it for latter retrievals. If the version of the
      256*   header does not check then the data in the record is skipped. */
      257 search_loop:
      258     nel = CHARS_PER_WORD * size (backup_volume_header);
      259     call read (recordp, nel, nelt, ^DELIMITED, code);
      260     call check_input_error;
      261 
      262     if backup_volume_record.pattern1 ^= pattern1
      263          | backup_volume_record.pattern2 ^= pattern2
      264          | backup_volume_record.pattern3 ^= pattern3 then do;
      265         code = -1;
      266         call check_input_error;			/* treat as bad read */
      267       end;
      268 
      269 pattern_match:
      270     nel = backup_volume_record.rec1_len - size (backup_volume_header) * CHARS_PER_WORD;
      271     call read (ptr (recordp, size (backup_volume_header)), nel, nelt,
      272          ^DELIMITED, code);
      273     call check_input_error;
      274 
      275     if backup_volume_record.rec1_type = contents_type then do;
      276         call record_contents_segment;
      277         goto search_loop;
      278       end;
      279 
      280     if backup_volume_record.rec1_type ^= vtoce_type then do;
      281         nel = backup_volume_record.rec2_len;
      282         if nel ^= 0 then call skip_chars;
      283         goto search_loop;
      284       end;
      285 
      286     if backup_volume_record.version ^= backup_volume_record_version_1 &
      287          backup_volume_record.version ^= backup_volume_record_version_2 then do;
      288         call retv_report_$error_output (0, myname, "Invalid volume record on dump volume ^a", volname);
      289         nel = backup_volume_record.rec2_len;
      290         if nel ^= 0 then call skip_chars;
      291         goto search_loop;
      292       end;
      293 
      294     if backup_volume_record.uid ^= "0"b then do;
      295         retv_data_.last_valid_puid = backup_volume_record.uid_path;
      296         retv_data_.last_valid_vtoce_ename = backup_volume_record.primary_name;
      297       end;
      298 						/* inform operator of last valid object read */
      299     if resynching_completed & backup_volume_record.uid ^= "0"b then do;
      300         resynching_completed = "0"b;
      301         call retv_report_$error_output (0, myname,
      302 	   "First object after resynching ^a on dump volume ^a", convert_puid_ (), volname);
      303       end;
      304 
      305     object_read = "0"b;
      306 
      307 /* Once an object has been read successfully the volume control segment is scanned for a uid match.  */
      308 
      309     do rvlx = 1 to retv_vol_control.n_entries;
      310       rvcep = addr (retv_vol_control.array (rvlx));
      311       if rvce.in_use & rvce.uid = backup_volume_record.uid then do;
      312 
      313 /* The two following checks make sure that that we recover either the most recent object or the object specified
      314*   by the requestor.  As dump volumes are read in reverse chronological order once an object is
      315*   recovered it should not be recovered again unless it comes from the same dump volume. The requestor may though
      316*   want an object dumped within
      317*   some specific time bracket.  If the conditions are not met we skip the request and try the next one. */
      318 
      319 /* Now read the request associated with this control segment entry */
      320 
      321 	call read_incremental_queue_message;
      322 	inputp = mseg_return_args.ms_ptr;
      323 
      324 	if (retv_input.object_recovered | retv_input.entry_recovered)
      325 	     & retv_input.volid ^= volid then goto check_next_request;
      326 
      327 	if ^rvce.entry_retrieval then do;
      328 	    if (rvce.to_time ^= 0 & fixed (bit (backup_volume_record.time_dumped, 52), 52) > rvce.to_time)
      329 	         | (rvce.from_time ^= 0 & fixed (bit (backup_volume_record.time_dumped, 52), 52) < rvce.from_time)
      330 	         then goto check_next_request;
      331 	  end;
      332 
      333 /* The object is read only once even though there may be many request for it. When it was written on the
      334*   dump volume it was written in a compact form with no full zero pages. Thus if csl does not
      335*   equal records the zero pages must be reconstructed according to the file map. */
      336 
      337 	if ^object_read then do;
      338 	    object_read = "1"b;
      339 	    nel = backup_volume_record.rec2_len;
      340 	    if fixed (backup_volume_record.csl) = fixed (backup_volume_record.records) then do;
      341 	        call read (objectp, nel, nelt,
      342 		   (backup_volume_record.version > backup_volume_record_version_1), code);
      343 	        call check_input_error;
      344 	      end;
      345 	    else do;
      346 	        call read (page_bufferp, nel, nelt,
      347 		   (backup_volume_record.version > backup_volume_record_version_1), code);
      348 	        call check_input_error;
      349 
      350 	        page_offset = 0;
      351 	        do cslx = 0 to fixed (backup_volume_record.csl) - 1;
      352 		if ^substr (backup_volume_record.fm (cslx), 1, 1) then do;
      353 		    ptr (objectp, cslx * WORDS_PER_PAGE) -> page =
      354 		         ptr (page_bufferp, page_offset) -> page;
      355 		    page_offset = page_offset + WORDS_PER_PAGE;
      356 		  end;
      357 		else
      358 		     ptr (objectp, cslx * WORDS_PER_PAGE) -> page = "0"b;
      359 	        end;
      360 	      end;
      361 	  end;
      362 
      363 
      364 /*  If the request is for entry retrieval then what has been recovered is a parent directory. First we locate
      365*   the entry in the directory by name. Once located we constructed a name and access conrol lists. The we initialize
      366*   some control structures and call a special entry in append which appends a given entry structure. If successful
      367*   we notify the operator and requestor(if requested) and attemp to add the other names and the access
      368*   information. If any failures occurr, the operator and possibly the requestor are notified. If though the request
      369*   is for an object then the input buffer is truncated. Next a check is made to see if the object is already there.
      370*   This may have happend as the result of a previous retrieval. If so we will only overwrite
      371*   it if the dump copy is newer or the requestor has specified a time bracket. In either case the
      372*   operator and possibly the requestor are notified.
      373**/
      374 
      375 	if rvce.entry_retrieval then do;
      376 	    call locate_entry;
      377 	    if ep ^= null then do;
      378 	        call build_name_list;
      379 	        call build_access_list;
      380 	        call init_append_args;
      381 	        call ioa_$rsnnl ("^a^[>^]^a", pname, pnl, rvce.dirname, rvce.dirname ^= ">",
      382 		   rvce.ename);
      383 retry_append:     call hc_backup_$retv_append (pname, name_list (1), crbp, retv_append_argp, code);
      384 	        if code ^= 0 then do;
      385 		  if code = error_table_$namedup then do;
      386 		      call ioa_$rsnnl ("Failed to append branch ^a^[>^]^a "
      387 			 || "because object already there with other name",
      388 			 message, (0), pname, pname ^= ">", name_list (1));
      389 		      call retv_notify_ ((message), inputp, myname);
      390 		      code = -1;
      391 		    end;
      392 		  retv_input.errcode = code;
      393 		end;
      394 	        else do;
      395 		  retv_input.entry_recovered = "1"b;
      396 		  call ioa_$rsnnl ("Appended branch ^a^[>^]^a", message, message_len,
      397 		       pname, pname ^= ">", name_list (1));
      398 		  call retv_notify_ ((message), inputp, myname);
      399 		  call hc_backup_$retv_add_acl (pname, name_list (1), aclp, aclc, code);
      400 		  if code ^= 0 then do;
      401 		      call convert_status_code_ (code, short, long);
      402 		      call ioa_$rsnnl ("Failed to append access list to ^a^[>^]^a because ^a",
      403 			 message, message_len, pname, pname ^= ">", name_list (1), long);
      404 		      call retv_notify_ ((message), inputp, myname);
      405 		    end;
      406 		  do nmx = 2 to nlc;
      407 		    call hc_backup_$retv_addname (pname, name_list (1), name_list (nmx), code);
      408 		    if code ^= 0 then do;
      409 		        call convert_status_code_ (code, short, long);
      410 		        call ioa_$rsnnl ("Failed to add name ^a to ^a^[>^]^a because ^a",
      411 			   message, message_len, name_list (nmx), pname, pname ^= ">",
      412 			   name_list (1), long);
      413 		        call retv_notify_ ((message), inputp, myname);
      414 		      end;
      415 		  end;
      416 		end;
      417 	      end;
      418 	    else goto check_next_request;
      419 	  end;
      420 	else do;
      421 	    object_size = fixed (backup_volume_record.csl, 18, 0) * WORDS_PER_PAGE;
      422 	    call hcs_$truncate_seg (objectp, object_size + 1, ignore); /* object_size + 1 is first word to discard */
      423 	    if retv_input.new_dirname ^= "" then do;	/* cross object retrieval */
      424 	        call hc_backup_$retv_status (retv_input.new_dirname, "",
      425 		   retv_input.access_class, retv_input.requestor, retv_input.level, type,
      426 		   emode, pmode, uid, pvid, vtoce_volid, dtd, code);
      427 	        if code ^= 0 then do;
      428 		  if uid = "0"b then
      429 		    code = error_table_$noentry;
      430 		  else if type ^= directory then
      431 		    code = error_table_$notadir;
      432 		  else if ^((emode & sm) = sm | (pmode & sm) = sm) then
      433 		    code = error_table_$moderr;
      434 		  call convert_status_code_ (code, short, long);
      435 		  call ioa_$rsnnl ("Failed to cross retrieve into ^a  because ^a", message, message_len,
      436 		       retv_input.new_dirname, long);
      437 		  call retv_notify_ ((message), inputp, myname);
      438 		  code = -1;
      439 		  goto set_code;
      440 		end;
      441 	        ep = addr (local_entry);
      442 	        call hc_backup_$get_entry (retv_input.dirname, retv_input.ename, ep, code);
      443 	        if code ^= 0 then do;
      444 		  call convert_status_code_ (code, short, long);
      445 		  call ioa_$rsnnl (
      446 		       "Failed to cross retrieve  ^a^[>^]^a because unable to locate ^a^[>^]^a because ^a",
      447 		       message, message_len, retv_input.new_dirname, retv_input.new_dirname ^= ">",
      448 		       retv_input.new_ename, retv_input.dirname, retv_input.dirname ^= ">",
      449 		       retv_input.ename, long);
      450 		  call retv_notify_ ((message), inputp, myname);
      451 		  code = -1;
      452 		  goto set_code;
      453 		end;
      454 	        backup_volume_record.uid = entry.uid;
      455 	        backup_volume_record.dtd = "0"b;
      456 	        backup_volume_record.volid (*) = "0"b;
      457 	        call init_append_args;
      458 	        retv_append_args.cross_segment = "1"b;
      459 	        call hc_backup_$retv_append (retv_input.new_dirname, retv_input.new_ename, crbp,
      460 		   retv_append_argp, code);
      461 	        if code ^= 0 then do;
      462 		  call convert_status_code_ (code, short, long);
      463 		  call ioa_$rsnnl ("Failed to append cross retrieval branch ^a^[>^]^a  because ^a",
      464 		       message, message_len, retv_input.new_dirname, retv_input.new_dirname ^= ">",
      465 		       retv_input.new_ename, long);
      466 		  call retv_notify_ ((message), inputp, myname);
      467 		  code = -1;
      468 		  goto set_code;
      469 		end;
      470 	        call hc_backup_$retv_copy (retv_input.new_dirname, retv_input.new_ename,
      471 		   retv_input.access_class, retv_input.requestor, retv_input.level,
      472 		   addr (backup_volume_record.vtoce), objectp, attributes, code);
      473 	        if code ^= 0 then do;
      474 		  call convert_status_code_ (code, short, long);
      475 		  call ioa_$rsnnl ("Failed to copy cross retrieval object ^a^[>^]^a  because ^a",
      476 		       message, message_len, retv_input.new_dirname, retv_input.new_dirname ^= ">",
      477 		       retv_input.new_ename, long);
      478 		  call retv_notify_ ((message), inputp, myname);
      479 		  code = -1;
      480 		  goto set_code;
      481 		end;
      482 	      end;
      483 	    else do;				/* object retrieval */
      484 	        call hc_backup_$retv_check (rvce.dirname, rvce.ename, type, dtm, code);
      485 	        if code = error_table_$vtoce_connection_fail
      486 		   | code = 0 & backup_volume_record.dtm >= dtm
      487 		   | code = 0 & (rvce.from_time ^= 0 | rvce.to_time ^= 0)
      488 		   | code = 0 & rvce.previous then do;
      489 		  call hc_backup_$retv_copy (rvce.dirname, rvce.ename, retv_input.access_class,
      490 		       retv_input.requestor, retv_input.level, addr (backup_volume_record.vtoce), objectp,
      491 		       attributes, code);
      492 		end;
      493 	        else if code = 0 then do;
      494 		  call ioa_$rsnnl ("Failed to recover object ^a^[>^]^a because more recent copy online",
      495 		       message, message_len, rvce.dirname, rvce.dirname ^= ">", rvce.ename);
      496 		  call retv_notify_ ((message), inputp, myname);
      497 		  retv_input.errcode = -1;		/* in this case, we don't want to delete the recovered*/
      498 		  goto update_message;		/* branch, or we would leave a connection failure.*/
      499 		end;
      500 	      end;
      501 set_code:	    if code ^= 0 then do;
      502 	        retv_input.errcode = code;
      503 	        if retv_input.entry_recovered then do;
      504 		  if retv_append_args.cross_segment then
      505 		    call hc_backup_$delete ((retv_input.new_dirname),
      506 		         (retv_input.new_ename), code);
      507 		  else call hc_backup_$delete ((rvce.dirname), (rvce.ename), code);
      508 		end;
      509 	        goto update_message;
      510 	      end;
      511 	    else do;
      512 	        if retv_input.new_dirname ^= "" then temp_dirname = retv_input.new_dirname;
      513 	        else temp_dirname = rvce.dirname;
      514 	        if retv_input.new_ename ^= "" then temp_ename = retv_input.new_ename;
      515 	        else temp_ename = rvce.ename;
      516 	        call ioa_$rsnnl ("Recovered ^[segment^;directory^] ^a^[>^]^a", message, message_len,
      517 		   type = SEG, temp_dirname, temp_dirname ^= ">", temp_ename);
      518 	        if ^backup_volume_record.dirsw then
      519 		call set_bc (temp_dirname, temp_ename);
      520 	        call retv_notify_ ((message), inputp, myname);
      521 	        if attributes then do;
      522 		  call ioa_$rsnnl
      523 		       ("Failed to set ^[dates ^]^[dump_switches ^]^[dump_info ^]^[pc_switches ^]"
      524 		       || "^[quota_info^] for ^a^[>^]^a",
      525 		       message, message_len, dates_set, dump_switches_set, dump_info_set, pc_switches_set,
      526 		       quota_info_set, temp_dirname, temp_dirname ^= ">", temp_ename);
      527 		  call retv_notify_ ((message), inputp, myname);
      528 		end;
      529 	        retv_input.object_recovered = "1"b;
      530 	        retv_input.errcode = 0;
      531 	      end;
      532 	  end;
      533 update_message:
      534 	retv_input.volid = volid;
      535 	call update_queue_message;
      536 	if retv_vol_control.dump_type ^= incr then requests_left = requests_left - 1;
      537 	if requests_left = 0 then do;
      538 	    call close;
      539 	    goto finish;
      540 	  end;
      541         end;
      542 check_next_request:
      543     end;
      544     if ^object_read then do;
      545         nel = backup_volume_record.rec2_len;
      546         if nel ^= 0 then do;
      547 /**** skip object, but use read procedure to skip the full object and check for
      548*      object delimiters (if applicable). */
      549 	  call read (objectp, nel, nelt,
      550 	       (backup_volume_record.version > backup_volume_record_version_1), code);
      551 	  call check_input_error;
      552 	end;
      553       end;
      554     goto search_loop;
      555 finish:
      556     if inputp ^= null then free retv_input in (based_area);
      557     return;
      558 
      559 skip_chars: proc;
      560 
      561 /* This proc skips foward the number of chars specified in the variable nel.
      562**/
      563 
      564     nelt = nel;
      565     call read (null (), nel, nelt, ^DELIMITED, code);
      566     call check_input_error;
      567   end skip_chars;
      568 
      569 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      570 
      571 
      572 check_input_error: proc;
      573 
      574 /* This proc checks for errors after a read of the dump volume. It we have reached the end of the volume then a non
      575*   local return is made and the main routine returns to its caller. Otherwise if an error has
      576*   occurred we attempted to recover. If we are already recovering we terminate the retrieval. Of course
      577*   in the errorless case we just return */
      578 
      579     if code ^= 0 | nelt ^= nel then do;
      580         if (code = error_table_$end_of_info | code = error_table_$device_end) then do;
      581 	  if resynching then do;
      582 	      call retv_report_$error_output (0, myname, "Resynchronization terminated by end of volume ^a",
      583 		 volname);
      584 	      call retv_report_$error_output (0, myname, "Skipped ^d words on dump volume ^a",
      585 		 words_skipped, volname);
      586 	    end;
      587 	  call close;
      588 	  goto finish;
      589 	end;
      590         else do;
      591 	  if ^resynching then do;
      592 	      if nel ^= nelt then
      593 	        call retv_report_$error_output (0, myname, "Read did not complete on dump volume ^a", volname);
      594 	      if code = -1 then
      595 	        call retv_report_$error_output (0, myname, "Invalid dump record header on ^a", volname);
      596 	      else call retv_report_$error_output (code, myname, "I/O error reading dump volume ^a",
      597 		      volname);
      598 	      call retv_report_$error_output (0, myname,
      599 		 "Invalid input record on dump volume ^a after ^a  - resynching started",
      600 		 volname, convert_puid_ ());
      601 	      resynch_retry_count = 0;
      602 	      call resynch_input_volume;
      603 	    end;
      604 	  else do;				/* already had an error			*/
      605 	      resynch_retry_count = resynch_retry_count + 1;
      606 						/* keep track so we don't try this forever	*/
      607 	      if resynch_retry_count > 64 then do;
      608 		call retv_report_$error_output (code, myname,
      609 		     "Resynchronization failed due to I/O error during resynching on volume ^a", volname);
      610 		call close;
      611 		goto finish;
      612 	        end;
      613 	    end;
      614 	end;
      615       end;
      616   end check_input_error;
      617 
      618 close: proc;
      619 
      620 /* This proc closes the open switch. It does not detach it, as the next dump volume to be read
      621*   may be the same volume just read. */
      622 
      623     call iox_$close (iocbp, code);
      624     if code ^= 0 then
      625       call retv_report_$error_output (code, myname, "Unable to close input volume ^a", volname);
      626   end close;
      627 
      628 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      629 
      630 
      631 resynch_input_volume: proc;
      632 
      633 /* This proc  resynchronizes a dump volume by stepping through the input one word at a time until it
      634*   recognizes the volume header unique pattern or until we get to the end of the volume. An upper
      635*   bound of one million words is placed on the loop so it will finish */
      636 
      637     resynching = "1"b;
      638     input_buf (*) = "0"b;
      639     nel = CHARS_PER_WORD * size (backup_volume_header);
      640     call read (recordp, nel, nelt, ^DELIMITED, code);
      641     call check_input_error;
      642 
      643     words_skipped = 0;
      644 test: if word (1) = pattern1 & word (4) = pattern2 & word (7) = pattern3 then do;
      645         call retv_report_$error_output (0, myname,
      646 	   "Synchronization completed ^d words skipped on dump volume ^a",
      647 	   words_skipped, volname);
      648         resynching = "0"b;
      649         resynching_completed = "1"b;
      650         goto pattern_match;
      651       end;
      652 
      653     string = substr (string, 37, (size (backup_volume_header) - 1) * BITS_PER_WORD);
      654     nel = CHARS_PER_WORD;
      655     call read (addr (word (size (backup_volume_header))), nel, nelt,
      656          ^DELIMITED, code);
      657     call check_input_error;
      658 
      659     words_skipped = words_skipped + 1;
      660     if words_skipped > 256 * WORDS_PER_PAGE then do;	/* put a limit on it */
      661         call retv_report_$error_output (0, myname, "Resynchronization failed on dump volume ^a", volname);
      662         code = error_table_$end_of_info;
      663         call check_input_error;
      664       end;
      665     goto test;
      666   end resynch_input_volume;
      667 
      668 locate_entry: proc;
      669 
      670 /* This proc locates an entry in a temp copy of a directory by using an interface to the
      671*   ring 0 hash routine. It returns a non null entry pointer if the entry was found */
      672 
      673     ep = null;
      674     dp = objectp;
      675     np = addr (rvce.entry_name);
      676     call hc_backup_$retv_hash_search (dp, np, ep, code);
      677     if code ^= 0 then ep = null;
      678     if ep = null then return;
      679     if rvce.link_retrieval then if entry.bs then ep = null;
      680   end locate_entry;
      681 
      682 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      683 
      684 
      685 build_name_list: proc;
      686 
      687 /* This proc constructs an array of names associated with some entry. */
      688 
      689     nlc = 0;
      690     do nrp = entry.name_frp repeat (np -> names.fp) while (nrp ^= "0"b);
      691       np = ptr (ep, nrp);
      692       nlc = nlc + 1;
      693       name_list (nlc) = np -> names.name;
      694     end;
      695     return;
      696   end build_name_list;
      697 
      698 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      699 
      700 
      701 build_access_list: proc;
      702 
      703 /* This proc constructs an array of access control items associated with some entry */
      704 
      705     aclc = 0;
      706     if ^entry.bs then return;
      707     do aclrp = entry.acl_frp repeat (acl_entry.frp) while (aclrp ^= "0"b);
      708       aclep = ptr (ep, aclrp);
      709       aclc = aclc + 1;
      710       if acl_entry.pers_rp = "0"b then acl_list (aclc).person = "*";
      711       else acl_list (aclc).person = ptr (ep, acl_entry.pers_rp) -> access_name.name;
      712       if acl_entry.proj_rp = "0"b then acl_list (aclc).project = "*";
      713       else acl_list (aclc).project = ptr (ep, acl_entry.proj_rp) -> access_name.name;
      714       acl_list (aclc).tag = acl_entry.tag;
      715       acl_list (aclc).mode = acl_entry.mode;
      716       acl_list (aclc).ex_mode = acl_entry.ex_mode;
      717     end;
      718     return;
      719   end build_access_list;
      720 
      721 record_contents_segment: proc;
      722 
      723 /* This proc recovers a contents segment from the dump volume if it is not already online. */
      724 
      725     contentsp = recordp;
      726     call suffixed_name_$make (backup_volume_contents.volname, "contents", ename, code);
      727     if code ^= 0 then do;
      728         call retv_report_$error_output (code, myname, "Unable to construct ^a.contents",
      729 	   backup_volume_contents.volname);
      730         return;
      731       end;
      732     call hcs_$make_seg (rtrim (retv_data_.sys_dir) || ">contents",
      733          ename, "", 01010b, new_contentsp, code);
      734     if code = 0 then new_contentsp -> copy = contentsp -> copy;
      735   end record_contents_segment;
      736 
      737 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      738 
      739 update_queue_message: proc;
      740 
      741 /* This proc updates an existant message in the retrieve's private queue */
      742 
      743 retry_update: call message_segment_$update_message_index (retv_data_.qidx (retriever),
      744          size (retv_input) * BITS_PER_WORD, rvce.retv_ms_id, inputp, code);
      745     if code ^= 0 then do;
      746         if code = error_table_$bad_segment then do;
      747 	  call retv_report_$error_output (0, myname, "Private queue has been salvaged");
      748 	  goto retry_update;
      749 	end;
      750         else do;
      751 	  call retv_report_$error_output (code, myname, "Update of private queue failed");
      752 	  goto finish;
      753 	end;
      754       end;
      755   end update_queue_message;
      756 
      757 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      758 
      759 read_incremental_queue_message: proc;
      760 
      761 /* This proc reads a specified message from the retrievers private queue. It takes care to manage the allocated
      762*   storage so it is not slowly eaten away */
      763 
      764     if inputp ^= null then free retv_input in (based_area);
      765 reread: call message_segment_$incremental_read_index (retv_data_.qidx (retriever), retv_data_.areap,
      766          "00"b, rvce.retv_ms_id, ms_arg_ptr, code);
      767     if code ^= 0 then do;
      768         if code = error_table_$bad_segment then do;
      769 	  call retv_report_$error_output (0, myname, "Private queue has been salvaged");
      770 	  goto reread;
      771 	end;
      772         else do;
      773 	  call retv_report_$error_output (code, myname, "Read of private queue failed");
      774 	  goto finish;
      775 	end;
      776       end;
      777   end read_incremental_queue_message;
      778 
      779 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      780 
      781 
      782 init_append_args: proc;
      783 
      784 /* This proc setups the control structures for the special entry appending call */
      785 
      786     crbp = addr (local_create_branch_info);
      787     crbp -> create_branch_info.version = create_branch_version_2;
      788     if entry.bs then crbp -> create_branch_info.dir_sw = entry.dirsw;
      789     else crbp -> create_branch_info.dir_sw = "0"b;
      790     if entry.bs then crbp -> create_branch_info.copy_sw = entry.copysw;
      791     else crbp -> create_branch_info.copy_sw = "0"b;
      792     crbp -> create_branch_info.chase_sw = "0"b;
      793     crbp -> create_branch_info.parent_ac_sw = "0"b;
      794     crbp -> create_branch_info.priv_upgrade_sw = "1"b;
      795     crbp -> create_branch_info.mode = "0"b;
      796     if entry.bs then crbp -> create_branch_info.rings (*) = fixed (entry.ring_brackets (*), 3);
      797     else crbp -> create_branch_info.rings (*) = 0;
      798     crbp -> create_branch_info.userid = retv_input.requestor;
      799     if entry.bs then crbp -> create_branch_info.bitcnt = entry.bc;
      800     else crbp -> create_branch_info.bitcnt = 0;
      801     crbp -> create_branch_info.quota = 0;
      802     crbp -> create_branch_info.dir_quota = 0;
      803     if entry.bs then crbp -> create_branch_info.access_class = entry.access_class;
      804     else crbp -> create_branch_info.access_class = "0"b;
      805     unspec (local_retv_append_args) = "0"b;
      806     retv_append_argp = addr (local_retv_append_args);
      807     retv_append_args.version = RETV_APPEND_ARGS_VERSION_1;
      808     retv_append_args.level = retv_input.level;
      809     retv_append_args.access_authorization = retv_input.access_class; /* user auth at time of err */
      810     retv_append_args.max_access_authorization = crbp -> create_branch_info.access_class; /* This is a LIE. We have no idea what the user's max */
      811 						/* authorization is. This is high enough to make the append succeed, and then */
      812 						/* append in ring zero will set it SOOS until an administrator wanders by. */
      813     retv_append_args.ep = ep;
      814     retv_append_args.link = ^entry.bs;
      815     return;
      816 
      817   end init_append_args;
      818 
      819 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      820 
      821 
      822 convert_puid_: proc returns (char (168) var);
      823 
      824 /* This proc is used to convert a unique id pathname to an ascii pathname  */
      825 
      826 dcl dn		     char (168);
      827 dcl en		     char (32);
      828 dcl ret_dn	     char (168);
      829     call hc_backup_$decode_uidpath (retv_data_.last_valid_puid, dn, en, code);
      830     if code = error_table_$root then ;
      831     else if code ^= 0 then return ("UNKNOWN_PATH>" || rtrim (retv_data_.last_valid_vtoce_ename));
      832     call ioa_$rsnnl ("^a^[>^]^[^a>^;^s^]^a", ret_dn, (0), dn, dn ^= ">", en ^= "", en, retv_data_.last_valid_vtoce_ename);
      833     return (ret_dn);
      834   end convert_puid_;
      835 
      836 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      837 read: proc (return_buffer_ptr,
      838        Nrequested_chars,
      839        Nreturned_chars,
      840        Sdelimited,
      841        code);
      842 
      843 dcl return_buffer_ptr    ptr,
      844   Nrequested_chars	     fixed bin (21),
      845   Nreturned_chars	     fixed bin (21),
      846   Sdelimited	     bit (1) aligned,
      847   code		     fixed bin (35);
      848 
      849 dcl input_buffer	     char (256 * CHARS_PER_PAGE)
      850 		     based (retv_data_.input_buffer_ptr);
      851 
      852 dcl return_string	     char (Nrequested_chars)
      853 		     based (return_buffer_ptr);
      854 
      855 dcl Nassign_chars	     fixed bin (21),
      856   Nread_chars	     fixed bin (21),
      857   end_of_record	     fixed bin,
      858   tape_check1 /* bit (72) */ char (8),
      859   tape_check2 /* bit (72) */ char (8);
      860 
      861     Nreturned_chars, Nread_chars, code = 0;
      862 
      863     do while (Nreturned_chars < Nrequested_chars & code = 0);
      864       if retv_data_.input_buffer_len = 0 then do;
      865 	retv_data_.input_buffer_start = 1;
      866 
      867 	if Sdelimited & Nreturned_chars = 0 then do;
      868 	    call iox_$get_chars (retv_data_.input_iocbp,
      869 	         addr (tape_check1), length (tape_check1), Nread_chars, code);
      870 	    if code ^= 0 then return;
      871 	  end;
      872 
      873 	if return_buffer_ptr = null then do;
      874 	    call iox_$position (retv_data_.input_iocbp, FORWARD_CHAR_POSITIONING,
      875 	         Nrequested_chars - Nreturned_chars, code);
      876 	    Nreturned_chars = Nreturned_chars + Nrequested_chars;
      877 	  end;
      878 	else do;
      879 	    call iox_$get_chars (retv_data_.input_iocbp,
      880 	         addcharno (return_buffer_ptr, Nreturned_chars),
      881 	         Nrequested_chars - Nreturned_chars, Nread_chars, code);
      882 	    Nreturned_chars = Nreturned_chars + Nread_chars;
      883 	  end;
      884 	if code ^= 0 then return;
      885 
      886 	if Sdelimited then do;
      887 	    call iox_$get_chars (retv_data_.input_iocbp,
      888 	         addr (tape_check2), length (tape_check2), Nread_chars, code);
      889 	    if code ^= 0 then
      890 	      return;
      891 
      892 	    if tape_check1 ^= tape_check2 then do;
      893 						/* found a short segment, move       */
      894 						/* return string into the temp input */
      895 						/* buffer and start parsing          */
      896 	        retv_data_.input_buffer_len = Nreturned_chars;
      897 	        substr (input_buffer, 1, retv_data_.input_buffer_len) =
      898 		   return_string;
      899 	      end;
      900 	  end;
      901         end;
      902 
      903       else
      904 	 if Sdelimited then do;
      905 	tape_check1 = substr (input_buffer,
      906 	     retv_data_.input_buffer_start, length (tape_check1));
      907 	tape_check2 = "";
      908 	retv_data_.input_buffer_start =
      909 	     retv_data_.input_buffer_start + length (tape_check1);
      910 	retv_data_.input_buffer_len =
      911 	     retv_data_.input_buffer_len - length (tape_check1);
      912         end;
      913 
      914       if retv_data_.input_buffer_len > 0 then do;
      915 	Nassign_chars =
      916 	     min (retv_data_.input_buffer_len, Nrequested_chars);
      917 
      918 	if Sdelimited then do;
      919 	    if tape_check1 ^= tape_check2 then do;
      920 	        end_of_record = index (substr (input_buffer, retv_data_.input_buffer_start,
      921 		   retv_data_.input_buffer_len), tape_check1);
      922 	        if end_of_record > 0 then do;
      923 		  Nassign_chars = end_of_record - 1;
      924 		  if Nrequested_chars ^= Nassign_chars then
      925 		    code = error_table_$data_loss;
      926 		end;
      927 	      end;
      928 	  end;
      929 
      930 	if return_buffer_ptr ^= null then
      931 	  return_string = substr (input_buffer,
      932 	       retv_data_.input_buffer_start, Nassign_chars);
      933 	Nreturned_chars = Nassign_chars;
      934 
      935 	retv_data_.input_buffer_start =
      936 	     retv_data_.input_buffer_start + Nassign_chars;
      937 	retv_data_.input_buffer_len =
      938 	     retv_data_.input_buffer_len - Nassign_chars;
      939 
      940 	if Sdelimited & retv_data_.input_buffer_len > 0 then do;
      941 	    retv_data_.input_buffer_start =
      942 	         retv_data_.input_buffer_start + length (tape_check2);
      943 	    substr (input_buffer, 1, retv_data_.input_buffer_len) =
      944 	         substr (input_buffer, retv_data_.input_buffer_start,
      945 	         retv_data_.input_buffer_len - length (tape_check2))
      946 	         || tape_check2;
      947 	    retv_data_.input_buffer_start = 1;
      948 	  end;
      949         end;
      950     end;
      951 
      952     return;
      953   end read;
      954 
      955 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      956 
      957 
      958 set_bc: proc (dirname, ename);
      959 dcl old_bc	     fixed bin (24);
      960 dcl (dirname, ename)     char (*);
      961 dcl new_bc	     fixed bin (24);
      962 
      963 /* This proc sets the bit count of the recovered object */
      964 
      965     new_bc = 9 * backup_volume_record.rec2_len;
      966     if fixed (backup_volume_record.csl, 9) ^= fixed (backup_volume_record.records, 9) then
      967       new_bc = new_bc + WORDS_PER_PAGE * BITS_PER_WORD * (fixed (backup_volume_record.csl, 9)
      968 	 - fixed (backup_volume_record.records, 9));
      969     call hc_backup_$set_bc (dirname, ename, new_bc, old_bc, code);
      970     if code ^= 0 then do;
      971         call convert_status_code_ (code, short, long);
      972         call ioa_$rsnnl ("^a^/Bit count could not be set for ^a>^a because ^a",
      973 	   message, 0, message, rvce.dirname, rvce.ename, long);
      974         return;
      975       end;
      976     if new_bc ^= old_bc then do;
      977         call ioa_$rsnnl ("^a^/Bit count of ^a>^a reset to ^d from ^d", message, 0,
      978 	   message, dirname, ename, new_bc, old_bc);
      979       end;
      980 
      981   end set_bc;
      982 
  1     1 /* BEGIN INCLUDE FILE ... retv_data_.incl.pl1 ... 8/76 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-11-17,GWMay), approve(86-11-17,MCR7445), audit(86-11-19,GDixon),
  1     7*     install(86-11-21,MR12.0-1223):
  1     8*     Changed declaration of queue_dir from constant to just internal static so
  1     9*     that the entrypoints "test" in the err and retrieve_from_volume requests
  1    10*     are able to modify the value.
  1    11*  2) change(88-08-10,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  1    12*     install(88-10-17,MR12.2-1173):
  1    13*     Added pointer and length values for use as an input_buffer for
  1    14*     intermediate reads.
  1    15*                                                   END HISTORY COMMENTS */
  1    16 
  1    17 
  1    18 dcl  retv_data_version_1 fixed bin static init (1) options(constant);	/* version of data base */
  1    19 
  1    20 /* queue_dir should not be declared options (constant). $test entrypoints in */
  1    21 /* enter_retrieval_request and retrieve_from_volume programs modify it.      */
  1    22 
  1    23 dcl  queue_dir char (168) int static init (">daemon_dir_dir>volume_retriever");
  1    24 dcl  user fixed bin static init (1) options (constant);
  1    25 dcl  retriever fixed bin static init (2) options (constant);
  1    26 
  1    27 dcl 1 retv_data_ external static aligned,
  1    28     2 version fixed bin,				/* version of structure */
  1    29     2 fixed,
  1    30       3 qidx (2) fixed bin,				/* indexs of queues */
  1    31       3 queue fixed bin,				/* mseg queue */
  1    32       3 nvol fixed bin,				/* number of volume control segments */
  1    33       3 spare fixed bin,
  1    34       3 input_buffer_len fixed bin (21),		/* length of the data in the read buffer */
  1    35       3 input_buffer_start fixed bin (21),		/* position in read buffer where new data begins */
  1    36     2 chars,
  1    37       3 sys_dir char (168),				/* system dir where files live */
  1    38       3 last_valid_vtoce_ename char (32),		/* last valid entry name from vtoce */
  1    39       3 last_volname char (32),			/* last volume mounted */
  1    40       3 io_module char (32),				/* name of io outer module */
  1    41       3 input_volume_desc char (256),			/* alternate input attach description */
  1    42     2 bits,
  1    43       3 last_valid_puid (16) bit (36),			/* last valid uid pathname */
  1    44       3 flags,
  1    45         4 manual bit (1) unal,			/* if on operator will tell us what tapes to use */
  1    46         4 arg_init bit (1) unal,			/* if on indicates that args have been processed */
  1    47         4 err_online bit (1) unal,			/* if on causes errors to be printed */
  1    48         4 disable_error_report bit (1) unal,		/* if on  - no errors are reported */
  1    49         4 all bit (1) unal,				/* if on indicates all queues are processed */
  1    50         4 accounting bit (1) unal,			/* if on  enable accounting */
  1    51         4 debug bit (1) unal,				/* if on, enable debugging features */
  1    52         4 long bit(1) unal,				/* if on enable long messages */
  1    53     2 ptrs,
  1    54       3 page_buffer_ptr ptr,                                /* ptr to paged read buffer */
  1    55       3 input_buffer_ptr ptr,				/* ptr to read buffer */
  1    56       3 skip ptr,					/* ptr to skip_list */
  1    57       3 rasp ptr,					/* ptr to accounting seg */
  1    58       3 input_iocbp ptr,				/* iocb ptr for input */
  1    59       3 error_iocbp ptr,				/* iocb ptr for error output */
  1    60       3 areap ptr,					/* ptr to system area */
  1    61       3 contentsp ptr,				/* ptr to most recent contents seg from input volume */
  1    62       3 nlp ptr,					/* ptr to name array for branch being retrieved */
  1    63       3 aclp ptr,					/* ptr to acl array for branch being retrieved */
  1    64       3 recordp ptr,				/* ptr to last read volume record */
  1    65       3 objectp ptr,				/* ptr to last read segmet or directory  */
  1    66       3 vlp ptr,					/* ptr to last reload group generated */
  1    67       3 rvcp (1000) ptr;				/* ptrs to volume control segments */
  1    68 
  1    69 /* END INCLUDE FILE ... retv_data_.incl.pl1 */
      983 
  2     1 /* BEGIN INCLUDE FILE ... retv_request.incl.pl1 ... June 1976 */
  2     2 
  2     3 dcl  requestp ptr;
  2     4 
  2     5 dcl  retv_request_version_2 fixed bin int static init (2) options (constant);
  2     6 
  2     7 dcl 1 retv_request based (requestp) aligned,
  2     8     2 header like queue_msg_hdr,
  2     9     2 bits,
  2    10       3 subtree bit (1),				/* on if sub-tree retrieval desired */
  2    11       3 dirs bit (1),				/* on if only subtree dirs desired */
  2    12       3 segs bit (1),				/* on if only subtree segments desired */
  2    13       3 previous bit (1),				/* on if prior object desired */
  2    14     2 fixed_bin,
  2    15       3 version fixed bin,				/* version of structure */
  2    16       3 to_time fixed bin (71),			/* latest time to start search from */
  2    17       3 from_time fixed bin (71),			/* from_time time not to search past */
  2    18     2 chars,
  2    19       3 new_dirname char (168),			/* cross retrieval directory name */
  2    20       3 new_ename char (32);				/* cross retrieval entry name */
  2    21 
  2    22 /* END INCLUDE FILE ... retv_request.incl.pl1 */
      984 
  3     1 /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
  3     2 
  3     3 /* This is the message header used for standard system queue messages, namely:
  3     4*   IO daemon requests, absentee requests, retrieval requests.
  3     5**/
  3     6 
  3     7 /* Written by Jerry Whitmore, Spring 1978.
  3     8*   Modified by T. Casey, November 1978, to add values for state.
  3     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
  3    10**/
  3    11 
  3    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
  3    13     2 msg_time fixed bin (71),			/* date and time of request */
  3    14     2 hdr_version fixed bin,				/* version of this declaration */
  3    15     2 dirname char (168),				/* directory name */
  3    16     2 ename char (32),				/* entry name of file requested */
  3    17     2 message_type fixed bin,				/* message format descriptor   */
  3    18 						/* 0 = absentee request        */
  3    19 						/* 1 = print request           */
  3    20 						/* 2 = punch request           */
  3    21 						/* 3 = tape request            */
  3    22 						/* 4 = retrieval request       */
  3    23     2 bit_flags,
  3    24       3 delete_sw bit (1) unal,			/* delete file when done */
  3    25       3 notify bit (1) unal,				/* user wants to be notified */
  3    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
  3    27       3 padding bit (33) unal,
  3    28     2 state fixed bin,				/* stage of processing after being queued:
  3    29*						   0 = initial unprocessed state, 1 = deferred,
  3    30*						   2 = in state transition, 3 = eligible, 4 = running,
  3    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
  3    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
  3    33     2 std_length fixed bin,				/* length of std msg for this type */
  3    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
  3    35     2 hdr_pad (3) fixed bin;
  3    36 
  3    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
  3    38 
  3    39 /* Values for queue_msg_hdr.state */
  3    40 
  3    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
  3    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
  3    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
  3    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
  3    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
  3    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
  3    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
  3    48 
  3    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
      985 
  4     1 /* BEGIN INCLUDE FILE ... retv_input.incl.pl1 ... June 1976 */
  4     2 
  4     3 dcl  inputp ptr;
  4     4 
  4     5 
  4     6 dcl 1 retv_input based (inputp) aligned,
  4     7     2 request like retv_request aligned,		/* orignal request */
  4     8     2 bits,
  4     9       3 dir_scanned bit (1),				/* if on indicates that dir already scanned for subtree requests */
  4    10       3 proxy bit (1),				/* on if request submitted as result of -all option */
  4    11       3 user_ms_id bit (72),				/* uid of message in user queue */
  4    12       3 retv_ms_id bit(72),				/* uid of message in retv queue */
  4    13       3 access_class bit (72),			/* access class of requestor */
  4    14       3 uid bit (36),				/* uid of object being retrieved */
  4    15       3 entry_retrieval bit (1),			/* on if this is a entry retrieval */
  4    16       3 entry_recovered bit (1),			/* on if entry recovered */
  4    17       3 in_progress bit (1),				/* on if retrieval in progress */
  4    18       3 object_recovered bit (1),			/* on if object finished */
  4    19       3 recovery_complete bit (1),			/* on if recovery complete */
  4    20       3 skip_it bit (1),				/* if on skip this request */
  4    21       3 volid bit (36),				/* volid object recoverd from */
  4    22     2 fixed_bin,
  4    23       3 level fixed bin,				/* validation level of requestor */
  4    24       3 q_num fixed bin,				/* queue number of user queue being serviced */
  4    25       3 errcode fixed bin (35),			/* error code if retrieval failed */
  4    26       3 submission_time fixed bin (71),			/* time request submitted */
  4    27     2 chars,
  4    28       3 requestor char (32),				/* qed */
  4    29       3 entry_name char (32);				/* name of entry being retrieved */
  4    30 
  4    31 /* END INCLUDE FILE ... retv_input.incl.pl1 */
      986 
  5     1 /* BEGIN INCLUDE FILE . . . mseg_return_args.incl.pl1 */
  5     2 
  5     3 
  5     4 /* structure returned when message is read from a message segment */
  5     5 
  5     6 
  5     7 dcl  ms_arg_ptr ptr;
  5     8 
  5     9 dcl 1 mseg_return_args based (ms_arg_ptr) aligned,
  5    10     2 ms_ptr ptr,					/* pointer to message */
  5    11     2 ms_len fixed bin (24),				/* length of message  in bits */
  5    12     2 sender_id char (32) unaligned,				/* process-group ID of sender */
  5    13     2 level fixed bin,				/* validation level of sender */
  5    14     2 ms_id bit (72),				/* unique ID of message */
  5    15     2 sender_authorization bit (72),			/* access authorization of message sender */
  5    16     2 access_class bit (72);				/* message access class */
  5    17 
  5    18 
  5    19 /* END INCLUDE FILE . . . mseg_return_args.incl.pl1 */
      987 
  6     1 /* BEGIN INCLUDE FILE ... backup_static_variables.incl.pl1 ... March 1976 */
  6     2 
  6     3 
  6     4 dcl  incr fixed bin init (1) internal static options (constant); /* incremental dump mode */
  6     5 dcl  cons fixed bin init (2) internal static options (constant); /* consolidated dump mode */
  6     6 dcl  comp fixed bin init (3) internal static options (constant); /* complete dump mode */
  6     7 dcl  backup_version_1 fixed bin init (1) static internal options (constant); /* backup_version_1 of input/output structures */
  6     8 
  6     9 
  6    10 
  6    11 /* END INCLUDE FILE ... backup_static_variables.incl.pl1 */
      988 
  7     1 /* BEGIN INCLUDE FILE backup_volume_contents.incl.pl1 ... May 1976 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(86-11-10,GWMay), approve(86-11-10,MCR7445), audit(86-11-19,GDixon),
  7     7*     install(86-11-21,MR12.0-1223):
  7     8*     increased the size of the offset field to fixed bin (18).
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 
  7    12 dcl  contentsp ptr;					/* ptr to structure */
  7    13 
  7    14 dcl  backup_volume_contents_version_3 fixed bin static init (3) options (constant);
  7    15 
  7    16 
  7    17 dcl 1 v1_backup_volume_contents based (contentsp) aligned,
  7    18     2 header like backup_volume_header aligned,
  7    19     2 version fixed bin,				/* version number of structure */
  7    20     2 volname char (32),				/* volume name */
  7    21     2 volid bit (36),				/* volume id */
  7    22     2 next fixed bin,				/* index of next available slot in uid array */
  7    23     2 array (1: 1 refer (backup_volume_contents.next)),	/* array of arrays of data objects on this output volume */
  7    24       3 uid bit (36);				/* uid */
  7    25 
  7    26 dcl 1 v2_backup_volume_contents based (contentsp) aligned,
  7    27     2 header like backup_volume_header aligned,
  7    28     2 version fixed bin,				/* version number of structure */
  7    29     2 volname char (32),				/* volume name */
  7    30     2 volid bit (36),				/* volume id */
  7    31     2 next fixed bin,				/* index of next available slot in uid array */
  7    32     2 pad (10) bit (36),
  7    33     2 array (1: 1 refer (backup_volume_contents.next)),	/* array of arrays of data objects on this output volume */
  7    34       3 uid bit (36),				/* uid */
  7    35       3 location,					/* offset of name string */
  7    36         4 component fixed bin (17) unal,
  7    37         4 offset fixed bin (17) unal ;
  7    38 
  7    39 dcl 1 backup_volume_contents based (contentsp) aligned,
  7    40     2 header like backup_volume_header aligned,
  7    41     2 version fixed bin,				/* version number of structure */
  7    42     2 volname char (32),				/* volume name */
  7    43     2 volid bit (36),				/* volume id */
  7    44     2 next fixed bin,				/* index of next available slot in uid array */
  7    45     2 pad (10) bit (36),
  7    46     2 array (1: 1 refer (backup_volume_contents.next)),	/* array of arrays of data objects on this output volume */
  7    47       3 uid bit (36),				/* uid */
  7    48       3 tape_loc fixed bin (35),
  7    49       3 pad1 bit (36),
  7    50       3 location,					/* offset of name string */
  7    51         4 component fixed bin (18) unsigned unal,
  7    52         4 offset fixed bin (18) unsigned unal ;
  7    53 
  7    54 dcl  contents_namesp ptr;				/* ptr to optional name seg */
  7    55 
  7    56 dcl 1 backup_volume_contents_names based (contents_namesp) aligned,
  7    57     2 version fixed bin,
  7    58     2 offset fixed bin (18),				/* next free location */
  7    59     2 pad (6) bit (36),
  7    60     2 begin bit (36);
  7    61 
  7    62 
  7    63 /* END INCLUDE FILE backup_volume_contents.incl.pl1 */
      989 
  8     1 /* BEGIN INCLUDE FILE ... backup_volume_record.incl.pl1 ... March 1976 */
  8     2 
  8     3 
  8     4 
  8     5 /****^  HISTORY COMMENTS:
  8     6*  1) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  8     7*     install(88-10-17,MR12.2-1173):
  8     8*     Added a version 2 constant
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 
  8    12 dcl  recordp ptr;
  8    13 
  8    14 dcl  backup_volume_record_version_1 fixed bin static init (1) options (constant);
  8    15 dcl  backup_volume_record_version_2 fixed bin static init (2) options (constant);
  8    16 
  8    17 dcl 1 backup_volume_record based (recordp) aligned,
  8    18     2 header like backup_volume_header aligned,
  8    19     2 version fixed bin,				/* version number of structure */
  8    20     2 pvid bit (36),				/* physical volume id */
  8    21     2 vtocx fixed bin,				/* vtoc index of returned vtoc entry */
  8    22     2 vtoce like vtoce aligned;			/* vtoc entry */
  8    23 
  8    24 /* END INCLUDE FILE ... backup_volume_record.incl.pl1 */
      990 
  9     1 /* BEGIN INCLUDE FILE ... backup_volume_header ... Feb 1976 */
  9     2 
  9     3 dcl  hdp ptr;					/* ptr to header */
  9     4 
  9     5 dcl 1 backup_volume_header based (hdp) aligned,
  9     6     2 pattern1 bit (36),				/* unique  word 1 */
  9     7     2 rec1_type fixed bin,				/* record 1 type */
  9     8     2 rec1_len fixed bin,				/* length in chars */
  9     9     2 pattern2 bit (36),				/* unique word 2 */
  9    10     2 rec2_type fixed bin,				/* record 2 type */
  9    11     2 rec2_len fixed bin,				/* length in chars */
  9    12     2 pattern3 bit (36),				/* unique word 3 */
  9    13     2 time_dumped bit (36);				/* dump time of this record */
  9    14 
  9    15 dcl  vtoce_type fixed bin static init (1) options (constant); /* type code for vtoce */
  9    16 dcl  dir_type fixed bin static init (2) options (constant); /* type code for directory */
  9    17 dcl  seg_type fixed bin static init (3) options (constant); /* type code for segment */
  9    18 dcl  null_type fixed bin static init (4) options (constant); /* type code for null record */
  9    19 dcl  volume_log_type fixed bin static init (5) options (constant); /* type code for volume log */
  9    20 dcl  prev_output_log_type fixed bin static init (6) options (constant); /* type code for prev output log */
  9    21 dcl  contents_type fixed bin static init (7) options (constant); /* type code for contents segment of previous volume */
  9    22 dcl  info_type fixed bin static init (8) options (constant); /* type code for info structure */
  9    23 
  9    24 dcl  pattern1 bit (36) int static init ("110111000011001100011101101010100101"b) options (constant);
  9    25 dcl  pattern2 bit (36) int static init ("101001010101101110001100110000111011"b) options (constant);
  9    26 dcl  pattern3 bit (36) int static init ("001000111100110011100010010101011010"b) options (constant);
  9    27 
  9    28 /* END INCLUDE FILE ... backup_volume_header */
      991 
 10     1 /* BEGIN INCLUDE FILE ... backup_pvol_info.incl.pl1 */
 10     2 
 10     3 dcl  bpvip ptr;
 10     4 
 10     5 dcl 1 backup_pvol_info based (bpvip) aligned,
 10     6     2 label like label aligned,
 10     7     2 n_vtoce fixed bin,
 10     8     2 n_free_vtoce fixed bin,
 10     9     2 n_rec fixed bin,
 10    10     2 baseadd fixed bin,
 10    11     2 n_free_rec fixed bin;
 10    12 
 10    13 /* END INCLUDE FILE ... backup_pvol_info.incl.pl1 */
      992 
 11     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
 11     2 
 11     3 /****^  HISTORY COMMENTS:
 11     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
 11     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
 11     6*     Add the subvolume info.
 11     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
 11     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
 11     9*     Added inconsistent_dbm bit used to determine consistency of volume
 11    10*     dumper bit maps.
 11    11*                                                   END HISTORY COMMENTS */
 11    12 
 11    13 /* This is the label at fixed location of each physical volume. Length 1 page */
 11    14 /* Note: fsout_vol clears pad fields before writing the label */
 11    15 
 11    16 dcl  labelp ptr;
 11    17 
 11    18 dcl 1 label based (labelp) aligned,
 11    19 
 11    20 /* First comes data not used by Multics.. for compatibility with GCOS */
 11    21 
 11    22     2 gcos (5*64) fixed bin,
 11    23 
 11    24 /* Now we have the Multics label */
 11    25 
 11    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
 11    27     2 version fixed bin,				/* Version 1 */
 11    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
 11    29     2 pv_name char (32),				/* Physical volume name. */
 11    30     2 lv_name char (32),				/* Name of logical volume for pack */
 11    31     2 pvid bit (36),				/* Unique ID of this pack */
 11    32     2 lvid bit (36),				/* unique ID of its logical vol */
 11    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
 11    34     2 time_registered fixed bin (71),			/* time imported to system */
 11    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
 11    36     2 vol_size fixed bin,				/* total size of volume, in records */
 11    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
 11    38     2 not_used bit (1) unal,				/* used to be multiple_class */
 11    39     2 private bit (1) unal,				/* TRUE if was registered as private */
 11    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
 11    41     2 flagpad bit (33) unal,
 11    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
 11    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
 11    44     2 password bit (72),				/* not yet used */
 11    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
 11    46     2 this_sv fixed bin,				/* what subvolume number it is */
 11    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
 11    48     2 pad1 (13) fixed bin,
 11    49     2 time_mounted fixed bin (71),			/* time mounted */
 11    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
 11    51 
 11    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
 11    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
 11    54* */
 11    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
 11    56     2 pad6 fixed bin,				
 11    57 
 11    58     2 time_salvaged fixed bin (71),			/* time salvaged */
 11    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
 11    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
 11    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
 11    62     2 pad1a (2) fixed bin,
 11    63     2 err_hist_size fixed bin,			/* size of pack error history */
 11    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
 11    65     2 time_last_reloaded fixed bin (71),		/* what it says */
 11    66     2 pad2 (40) fixed bin,
 11    67     2 root,
 11    68       3 here bit (1),				/* TRUE if the root is on this pack */
 11    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
 11    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
 11    71       3 pad7 bit (1) aligned,				
 11    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
 11    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
 11    74       3 esd_state fixed bin,				/* State of esd */
 11    75     2 volmap_record fixed bin,			/* Begin record of volume map */
 11    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
 11    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
 11    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
 11    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
 11    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
 11    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
 11    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
 11    83     2 pad3 (52) fixed bin,
 11    84     2 nparts fixed bin,				/* Number of special partitions on pack */
 11    85     2 parts (47),
 11    86       3 part char (4),				/* Name of partition */
 11    87       3 frec fixed bin,				/* First record */
 11    88       3 nrec fixed bin,				/* Number of records */
 11    89       3 pad5 fixed bin,
 11    90     2 pad4 (5*64) fixed bin;
 11    91 
 11    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
 11    93 
 11    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      993 
 12     1 /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
 12     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
 12     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
 12     4 
 12     5 dcl  vtocep ptr;
 12     6 
 12     7 dcl 1 vtoce based (vtocep) aligned,
 12     8 
 12     9 
 12    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
 12    11 
 12    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
 12    13 
 12    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
 12    15     2 csl bit (9),					/* current segment length - in 1024 word units */
 12    16     2 records bit (9),				/* number of records used by the seg in second storage */
 12    17     2 pad2 bit (9),
 12    18 
 12    19     2 dtu bit (36),					/* date and time segment was last used */
 12    20 
 12    21     2 dtm bit (36),					/* date and time segment was last modified */
 12    22 
 12    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
 12    24     2 deciduous bit (1),				/* true if hc_sdw */
 12    25     2 nid bit (1),					/* no incremental dump switch */
 12    26     2 dnzp bit (1),					/* Dont null zero pages */
 12    27     2 gtpd bit (1),					/* Global transparent paging device */
 12    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
 12    29     2 damaged bit (1),				/* TRUE if contents damaged */
 12    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
 12    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
 12    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
 12    33     2 pad3 bit (8),
 12    34     2 dirsw bit (1),				/* directory switch */
 12    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
 12    36     2 pad4 bit (16)) unaligned,			/* not used */
 12    37 
 12    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
 12    39 
 12    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
 12    41 
 12    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
 12    43 
 12    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
 12    45 
 12    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
 12    47 
 12    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
 12    49 
 12    50 
 12    51 
 12    52 
 12    53 
 12    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
 12    55 
 12    56     2 pad6 (10) bit (36),				/* not used */
 12    57 
 12    58     2 ncd bit (1),					/* no complete dump switch */
 12    59     2 pad7 bit (17),
 12    60     2 pad8 bit (18),
 12    61 
 12    62     2 dtd bit (36),					/* date-time-dumped */
 12    63 
 12    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
 12    65 
 12    66     2 master_dir_uid bit (36),			/* superior master directory uid */
 12    67 
 12    68 
 12    69 
 12    70 
 12    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
 12    72 
 12    73     2 primary_name char (32),				/* primary name of the segment */
 12    74 
 12    75     2 time_created bit (36),				/* time the segment was created */
 12    76 
 12    77     2 par_pvid bit (36),				/* physical volume id of the parent */
 12    78 
 12    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
 12    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
 12    81 
 12    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
 12    83 
 12    84     2 access_class bit (72),				/* access class in branch */
 12    85     2 perm_flags aligned,
 12    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
 12    87       3 pad9 bit (35) unal,
 12    88     2 owner bit (36);				/* pvid of this volume */
 12    89 
 12    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
 12    91 
 12    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
 12    93     2 pad1 bit (7*36),
 12    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
 12    95     2 pad2 bit (184*36);
 12    96 
 12    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      994 
 13     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
 13     2 
 13     3 
 13     4 /* Template for an entry. Length = 38 words */
 13     5 
 13     6 dcl  ep ptr;
 13     7 
 13     8 dcl 1 entry based (ep) aligned,
 13     9 
 13    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
 13    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
 13    12 
 13    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
 13    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
 13    15 
 13    16     2 uid bit (36),					/* unique id of entry */
 13    17 
 13    18     2 dtem bit (36),				/* date-time entry modified */
 13    19 
 13    20     (2 bs bit (1),					/* branch switch = 1 if branch */
 13    21     2 pad0 bit (17),
 13    22     2 nnames fixed bin (17),				/* number of names for this entry */
 13    23 
 13    24     2 name_frp bit (18),				/* rel pointer to start of name list */
 13    25     2 name_brp bit (18),				/* rel pointer to end of name list */
 13    26 
 13    27     2 author,					/* user who created branch */
 13    28       3 pers_rp bit (18),				/* name of user who created branch */
 13    29       3 proj_rp bit (18),				/* project of user who created branch */
 13    30 
 13    31       3 tag char (1),				/* tag of user who created branch */
 13    32       3 pad1 char (3),
 13    33 
 13    34     2 primary_name bit (504),				/* first name on name list */
 13    35 
 13    36     2 dtd bit (36),					/* date time dumped */
 13    37 
 13    38     2 pad2 bit (36),
 13    39 
 13    40 
 13    41 /* the declarations below are for branch only */
 13    42 
 13    43 
 13    44     2 pvid bit (36),				/* physical volume id */
 13    45 
 13    46     2 vtocx fixed bin (17),				/* vtoc entry index */
 13    47     2 pad3 bit (18),
 13    48 
 13    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
 13    50     2 oosw bit (1),					/* out of service switch  on = 1 */
 13    51     2 per_process_sw bit (1),				/* indicates segment is per process */
 13    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
 13    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
 13    54     2 multiple_class bit (1),				/* segment has multiple security classes */
 13    55     2 audit_flag bit (1),				/* segment must be audited for security */
 13    56     2 security_oosw bit (1),				/* security out of service switch */
 13    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
 13    58     2 master_dir bit (1),				/* TRUE for master directory */
 13    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
 13    60     2 pad4 bit (11),
 13    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
 13    62 
 13    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
 13    64 
 13    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
 13    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
 13    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
 13    68 
 13    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
 13    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
 13    71 
 13    72     2 bc_author,					/* user who last set the bit count */
 13    73       3 pers_rp bit (18),				/* name of user who set the bit count */
 13    74       3 proj_rp bit (18),				/* project of user who set the bit count */
 13    75 
 13    76       3 tag char (1),				/* tag of user who set the bit count */
 13    77       3 pad5 bit (2),
 13    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
 13    79 
 13    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
 13    81 
 13    82     2 pad6 bit (36),
 13    83 
 13    84     2 checksum bit (36),				/* checksum from dtd */
 13    85 
 13    86     2 owner bit (36);				/* uid of containing directory */
 13    87 
 13    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
      995 
 14     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
 14     2 
 14     3 /* Template for names of branches or links. Length = 14 words. */
 14     4 
 14     5 dcl np ptr;
 14     6 
 14     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
 14     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
 14     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
 14    10 
 14    11     2 type bit (18) unaligned,			/* type = dir name */
 14    12     2 size fixed bin (17) unaligned,			/* size of dir name */
 14    13 
 14    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
 14    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
 14    16 
 14    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
 14    18     2 pad3 bit (18) unal,
 14    19 
 14    20     2 name char(32) aligned,
 14    21 
 14    22     2 checksum bit (36),				/* checksum from entry_rp */
 14    23 
 14    24     2 owner bit (36);				/* uid of entry */
 14    25 
 14    26 
 14    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
      996 
 15     1 /*     BEGIN INCLUDE FILE ... dir_acl.incl.pl1 ... last modified Nov 1975 for nss */
 15     2 
 15     3 /* Template for an ACL entry. Length = 8 words */
 15     4 
 15     5 dcl aclep ptr;
 15     6 
 15     7 dcl 1 acl_entry based (aclep) aligned,			/* length is 8 words */
 15     8     2 frp bit(18) unaligned,				/* rel ptr to next entry */
 15     9     2 brp bit(18) unaligned,				/* rel ptr to previous entry */
 15    10 
 15    11     2 type bit (18) unaligned,			/* type = dir acl */
 15    12     2 size fixed bin (17) unaligned,			/* size of acl entry */
 15    13 
 15    14 
 15    15     2 name unaligned,				/* user name associated with this ACL entry */
 15    16         3 pers_rp bit(18) unaligned,			/* name of user */
 15    17         3 proj_rp bit(18) unaligned,			/* project of user */
 15    18         3 tag char(1) unaligned,			/* tag of user */
 15    19     2 mode bit (3) unaligned,				/* mode for userid */
 15    20     2 pad24 bit(24) unaligned,
 15    21 
 15    22     2 ex_mode bit(36),				/* extended access modes */
 15    23 
 15    24     2 checksum bit (36),				/* checksum from acl_entry.name */
 15    25     2  owner bit (36);				/* uid of owning entry */
 15    26 
 15    27 /* Template for a person or project name on ACL. Length = 14 words. */
 15    28 
 15    29 dcl 1 access_name aligned based,			/* person or project name */
 15    30     2 frp bit(18) unaligned,				/* rel ptr to next name structure */
 15    31     2 brp bit(18) unaligned,				/* rel ptr to prev name structure */
 15    32 
 15    33     2 type bit (18) unaligned,			/* type = access name */
 15    34     2 size fixed bin (17) unaligned,			/* size of access name */
 15    35 
 15    36     2 salv_flag fixed bin(17) unaligned,		/* used by salvager to check for ascii names */
 15    37     2 usage fixed bin(17) unaligned,			/* number of ACL entries that refer to this name */
 15    38 
 15    39     2 pad1 bit (36),
 15    40 
 15    41     2 name char(32) aligned,				/* person or project name itself */
 15    42 
 15    43     2 checksum bit (36),				/* checksum from salv_flag */
 15    44 
 15    45     2 owner bit (36);				/* uid of containing directory */
 15    46 
 15    47 /*     END INCLUDE FILE ... dir_acl.incl.pl1 */
      997 
 16     1 /* BEGIN INCLUDE FILE ... retv_vol_control.incl.pl1 8/76 */
 16     2 
 16     3 dcl  rvcp ptr;					/* ptr to volume control segment */
 16     4 dcl  rvcep ptr;					/* ptr to entry in volume control segment */
 16     5 
 16     6 dcl  retv_vol_control_version_1 fixed bin static init (1) options (constant); /* version of structure */
 16     7 
 16     8 dcl 1 retv_vol_control based (rvcp) aligned,
 16     9     2 version fixed bin,				/* version number */
 16    10     2 volname char (32),				/* name of volume that this segment represents */
 16    11     2 volid bit (36),				/* volume id of volume that this segment controls */
 16    12     2 open_time fixed bin (71),			/* time this volume was opened */
 16    13     2 in_use_cnt fixed bin,				/* number of in use entries */
 16    14     2 n_entries fixed bin,				/* total number of entries */
 16    15     2 switches,
 16    16       3 skip_query bit (1) unal,
 16    17       3 unused bit (35) unal,
 16    18     2 dump_type fixed bin,				/* type of dump volume */
 16    19     2 pad (1) bit (36),
 16    20     2 array (1 : 1 refer (retv_vol_control.n_entries)) like rvce aligned; /* array of entries */
 16    21 
 16    22 dcl 1 rvce aligned based (rvcep),
 16    23     2 uid bit (36),					/* uid of object being retrieved */
 16    24     2 contentsx fixed bin,				/* index in contents seg */
 16    25     2 dirname char (168),				/* parent directory pathname */
 16    26     2 ename char (32),				/* entry name */
 16    27     2 entry_name char (32),				/* name of entry being retrieved */
 16    28     2 queue fixed bin,				/* queue  request was taken from */
 16    29     2 retv_ms_id bit (72),				/* id of request in retv queue */
 16    30     2 vdtd bit (36),				/* volume dtd of object if previously dumped */
 16    31     2 to_time fixed bin (71),				/* time not to retrived after */
 16    32     2 from_time fixed bin (71),			/* time not to retrieve befor */
 16    33     2 flags,
 16    34      (3 link_retrieval bit (1),			/* on if link retrieval */
 16    35       3 entry_retrieval bit (1),			/* on if entry retrieval */
 16    36       3 object_retrieval bit (1),			/* on if object is  to be retrieved */
 16    37       3 vtoce_volname bit (1),			/* on if valid volume id found in vtoce */
 16    38       3 in_use bit (1),				/* on if entry in use */
 16    39       3 previous bit (1),				/* on if previous object to dtd wanted */
 16    40       3 no_contents_seg bit (1))unaligned,		/* on if could not find contents segment */
 16    41     2 pad bit (36);
 16    42 
 16    43 /* END INCLUDE FILE ... retv_vol_control.incl.pl1 */
      998 
 17     1 /* BEGIN INCLUDE FILE ... retv_append_args.incl.pl1 ... Modified BIM 84-03-16 */
 17     2 
 17     3 dcl  retv_append_argp ptr;
 17     4 
 17     5 dcl 1 retv_append_args based (retv_append_argp) aligned,
 17     6     2 version char (8) aligned,
 17     7     2 level fixed bin,
 17     8     2 access_authorization bit (72), /* of user making request */
 17     9     2 max_access_authorization bit (72), /* ditto */
 17    10     2 ep ptr,
 17    11     2 flags,
 17    12      (3 link bit (1),
 17    13       3 cross_segment bit (1))unal;
 17    14 
 17    15 declare RETV_APPEND_ARGS_VERSION_1 char (8) aligned init ("rtvag001") int static options (constant);
 17    16 
 17    17 /* END INCLUDE FILE ... retv_append_args.incl.pl1 */
      999 
 18     1 /*  BEGIN INCLUDE FILE - - - create_branch_info.incl.pl1 - - - created January 1975 */
 18     2 
 18     3 
 18     4 /****^  HISTORY COMMENTS:
 18     5*  1) change(89-01-16,TLNguyen), approve(89-01-16,MCR8049),
 18     6*     audit(89-02-03,Parisek), install(89-03-15,MR12.3-1025):
 18     7*       1. Declare version constant properly.
 18     8*       2. Remove version 1 since it was never referenced and to force
 18     9*          callers to upgrade their programs.
 18    10*                                                   END HISTORY COMMENTS */
 18    11 
 18    12 
 18    13 /* Modified December 1984 for dir_quota, Keith Loepere. */
 18    14 
 18    15 /* this include files gives the argument structure for create_branch_ */
 18    16 
 18    17 dcl 1 create_branch_info aligned based,
 18    18     2 version fixed bin,				/* set this to the largest value given below */
 18    19     2 switches unaligned,
 18    20       3 dir_sw bit (1) unaligned,			/* if on, a directory branch is wanted */
 18    21       3 copy_sw bit (1) unaligned,			/* if on, initiating segment will be done by copying */
 18    22       3 chase_sw bit (1) unaligned,			/* if on, if pathname is a link, it will be chased */
 18    23       3 priv_upgrade_sw bit (1) unaligned,		/* privileged creation (ring 1) of upgraded object */
 18    24       3 parent_ac_sw bit (1) unaligned,			/* if on, use parent's access class for seg or dir created */
 18    25       3 mbz1 bit (31) unaligned,			/* pad to full word */
 18    26     2 mode bit (3) unaligned,				/* segment or directory for acl for userid */
 18    27     2 mbz2 bit (33) unaligned,			/* pad to full word */
 18    28     2 rings (3) fixed bin (3),			/* branch's ring brackets */
 18    29     2 userid char (32),				/* user's access control name */
 18    30     2 bitcnt fixed bin (24),				/* bit count of the segment */
 18    31     2 quota fixed bin (18),				/* for directories, this am't of quota will be moved to it */
 18    32     2 access_class bit (72),				/* is the access class of the body of the branch */
 18    33     2 dir_quota fixed bin (18);			/* for directories, this am't of dir quota will be moved to it */
 18    34 
 18    35 dcl  create_branch_version_2 fixed bin int static options (constant) init (2);
 18    36 
 18    37 /* END INCLUDE FILE - - - create_branch_info.incl.pl1 - - - */
 18    38 
     1000 
 19     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
 19     2 
 19     3 /* Written 05/04/78 by C. D. Tavares */
 19     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
 19     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
 19     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
 19     7 
 19     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
 19     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
 19    10      iox_$close entry (pointer, fixed bin (35)),
 19    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
 19    12      iox_$delete_record entry (pointer, fixed bin (35)),
 19    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
 19    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
 19    15      iox_$err_not_attached entry options (variable),
 19    16      iox_$err_not_closed entry options (variable),
 19    17      iox_$err_no_operation entry options (variable),
 19    18      iox_$err_not_open entry options (variable),
 19    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
 19    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
 19    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 19    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 19    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
 19    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
 19    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
 19    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
 19    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
 19    28      iox_$propagate entry (pointer),
 19    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 19    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 19    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
 19    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
 19    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 19    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
 19    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
 19    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
 19    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
 19    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
 19    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
 19    40 
 19    41 dcl (iox_$user_output,
 19    42      iox_$user_input,
 19    43      iox_$user_io,
 19    44      iox_$error_output) external static pointer;
 19    45 
 19    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
     1001 
 20     1 /* Begin include file ..... iox_modes.incl.pl1 */
 20     2 
 20     3 /* Written by C. D. Tavares, 03/17/75 */
 20     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 20     5 
 20     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 20     7     ("stream_input", "stream_output", "stream_input_output",
 20     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 20     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 20    10      "direct_input", "direct_output", "direct_update");
 20    11 
 20    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 20    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 20    14 
 20    15 dcl (Stream_input initial (1),
 20    16      Stream_output initial (2),
 20    17      Stream_input_output initial (3),
 20    18      Sequential_input initial (4),
 20    19      Sequential_output initial (5),
 20    20      Sequential_input_output initial (6),
 20    21      Sequential_update initial (7),
 20    22      Keyed_sequential_input initial (8),
 20    23      Keyed_sequential_output initial (9),
 20    24      Keyed_sequential_update initial (10),
 20    25      Direct_input initial (11),
 20    26      Direct_output initial (12),
 20    27      Direct_update initial (13)) fixed bin int static options (constant);
 20    28 
 20    29 /* End include file ..... iox_modes.incl.pl1 */
     1002 
 21     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
 21     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
 21     3 /*	version number changed to 4, 08/10/78 WOS */
 21     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
 21     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
 21     6 
 21     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
 21     8     2 version fixed bin,				/* version of this structure - must be set, see below */
 21     9     2 switches aligned,                                     /* various bit switch values */
 21    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
 21    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
 21    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
 21    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
 21    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
 21    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
 21    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
 21    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
 21    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
 21    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
 21    20 
 21    21 /*  Limit of data defined for version 2 */
 21    22 
 21    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
 21    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
 21    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
 21    26 						/* minimum of 30 seconds required for repeat */
 21    27 						/* otherwise, no repeat will occur */
 21    28 /* Limit of data defined for version 4 */
 21    29 
 21    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
 21    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
 21    32 
 21    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
 21    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
 21    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
 21    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
 21    37 
 21    38 /*	END INCLUDE FILE query_info.incl.pl1 */
     1003 
 22     1 /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
 22     2 
 22     3 /****^  HISTORY COMMENTS:
 22     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
 22     5*     install(86-11-21,MR12.0-1223):
 22     6*     created.
 22     7*                                                   END HISTORY COMMENTS */
 22     8 
 22     9 /* format: off */
 22    10 
 22    11 /* ************************************************************************ */
 22    12 /*							      */
 22    13 /* Function: Provides constants for commonly used Multics system values.    */
 22    14 /*							      */
 22    15 /* Usage: These values are available for use in place of "magic" numbers    */
 22    16 /*        (unexplained numbers) in programming applications.	      */
 22    17 /*							      */
 22    18 /* Definitions:						      */
 22    19 /*							      */
 22    20 /*   PER             bit     character/byte     word     page     segment   */
 22    21 /*		 					      */
 22    22 /*   bits              1            9             36     36864    9400320   */
 22    23 /*   characters/bytes	      1	           4      4096    1044480   */
 22    24 /*   words				 1      1024     261120   */
 22    25 /*   pages				           1        255   */
 22    26 /*   segments						  1   */
 22    27 /*							      */
 22    28 /*  The base values for a bit, char, word and page are determined by the    */
 22    29 /*  Multics hardware implementation.  The other values are calculated from  */
 22    30 /*  their relation to one another as shown in the matrix above.	      */
 22    31 /*							      */
 22    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
 22    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
 22    34 /*		  = 9 * 4					      */
 22    35 /*		  = 36					      */
 22    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
 22    37 /*		  = 9 * 4 * 1024				      */
 22    38 /*		  = 36864					      */
 22    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
 22    40 /*		    PAGES_PER_SEGMENT			      */
 22    41 /*		  = 9 * 4 * 1024 * 255			      */
 22    42 /*		  = 9400320				      */
 22    43 /*							      */
 22    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
 22    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
 22    46 /*		  = 4 * 1024				      */
 22    47 /*		  = 4096					      */
 22    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
 22    49 /*		  = 4 * 1024 * 255				      */
 22    50 /*		  = 1044480				      */
 22    51 /*							      */
 22    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
 22    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
 22    54 /*		  = 1024 * 255				      */
 22    55 /*		  = 261120				      */
 22    56 /*							      */
 22    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
 22    58 /*							      */
 22    59 /* ************************************************************************ */
 22    60 
 22    61        declare BITS_PER_CHAR		fixed bin (4) internal static
 22    62 				options (constant) initial (9);
 22    63 
 22    64        declare BITS_PER_WORD		fixed bin (6) internal static
 22    65 				options (constant) initial (36);
 22    66 
 22    67        declare BITS_PER_PAGE		fixed bin (16) internal static
 22    68 				options (constant) initial (36864);
 22    69 
 22    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
 22    71 				options (constant) initial (9400320);
 22    72 
 22    73        declare CHARS_PER_WORD		fixed bin (3) internal static
 22    74 				options (constant) initial (4);
 22    75 
 22    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
 22    77 				options (constant) initial (4096);
 22    78 
 22    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
 22    80 				options (constant) initial (1044480);
 22    81 
 22    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
 22    83 
 22    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
 22    85 				options (constant) initial (1024);
 22    86 
 22    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
 22    88 
 22    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
 22    90 				options (constant) initial (261120);
 22    91 
 22    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
 22    93 				options (constant) initial (255);
 22    94 
 22    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
 22    96 
     1004 
     1005 
     1006   end retrieve_from_volume_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/21/92  1509.3  retrieve_from_volume_.pl1         >spec>install>1035>retrieve_from_volume_.pl1
983          1    10/18/88  1315.0  retv_data_.incl.pl1               >ldd>include>retv_data_.incl.pl1
984          2    09/04/80  2106.4  retv_request.incl.pl1             >ldd>include>retv_request.incl.pl1
985          3    08/31/82  1736.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
986          4    05/01/81  2021.2  retv_input.incl.pl1               >ldd>include>retv_input.incl.pl1
987          5    05/17/82  1511.5  mseg_return_args.incl.pl1         >ldd>include>mseg_return_args.incl.pl1
988          6    09/05/80  1236.5  backup_static_variables.incl.pl1  >ldd>include>backup_static_variables.incl.pl1
989          7    11/24/86  1343.9  backup_volume_contents.incl.pl1   >ldd>include>backup_volume_contents.incl.pl1
990          8    10/18/88  1315.0  backup_volume_record.incl.pl1     >ldd>include>backup_volume_record.incl.pl1
991          9    09/05/80  1236.5  backup_volume_header.incl.pl1     >ldd>include>backup_volume_header.incl.pl1
992         10    06/07/77  1333.6  backup_pvol_info.incl.pl1         >ldd>include>backup_pvol_info.incl.pl1
993         11    07/21/88  2136.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
994         12    10/04/83  1205.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
995         13    04/29/76  1200.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
996         14    11/02/76  1514.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
997         15    04/29/76  1148.9  dir_acl.incl.pl1                  >ldd>include>dir_acl.incl.pl1
998         16    05/01/81  2021.2  retv_vol_control.incl.pl1         >ldd>include>retv_vol_control.incl.pl1
999         17    03/23/84  2028.6  retv_append_args.incl.pl1         >ldd>include>retv_append_args.incl.pl1
1000        18    03/16/89  2112.8  create_branch_info.incl.pl1       >ldd>include>create_branch_info.incl.pl1
1001        19    05/23/83  1016.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
1002        20    02/02/78  1329.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1003        21    03/11/83  1304.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
1004        22    11/24/86  1343.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_PAGE                          constant        fixed bin(16,0)          initial dcl 22-67 ref 353 353 357
BITS_PER_WORD                          constant        fixed bin(6,0)           initial dcl 22-64 ref 653 653 653 743 966
CHARS_PER_PAGE                         constant        fixed bin(13,0)          initial dcl 22-76 ref 897 905 920 930 943 943
CHARS_PER_WORD                         constant        fixed bin(3,0)           initial dcl 22-73 ref 257 269 638 639 654 734
DELIMITED                              constant        bit(1)                   initial dcl 130 ref 259 271 565 640 655
FORWARD_CHAR_POSITIONING        000101 constant        fixed bin(17,0)          initial dcl 132 set ref 874*
Nassign_chars                   000100 automatic       fixed bin(21,0)          dcl 855 set ref 915* 923* 924 930 933 935 937
Nread_chars                     000101 automatic       fixed bin(21,0)          dcl 855 set ref 861* 868* 879* 882 887*
Nrequested_chars                       parameter       fixed bin(21,0)          dcl 843 ref 837 863 874 876 879 897 915 924 930
Nreturned_chars                        parameter       fixed bin(21,0)          dcl 843 set ref 837 861* 863 867 874 876* 876 879
                                                                                  879 879 882* 882 896 933*
RETV_APPEND_ARGS_VERSION_1      000000 constant        char(8)                  initial dcl 17-15 ref 807
SEG                                    constant        fixed bin(17,0)          initial dcl 134 ref 516
Sdelimited                             parameter       bit(1)                   dcl 843 ref 837 867 886 903 918 940
Stream_input                    000103 constant        fixed bin(17,0)          initial dcl 20-15 set ref 230*
WORDS_PER_PAGE                         constant        fixed bin(11,0)          initial dcl 22-84 ref 353 355 357 421 660 966
a_rvcp                                 parameter       pointer                  dcl 52 ref 29 177
access_authorization      3            based           bit(72)                  level 2 dcl 17-5 set ref 809*
access_class            200            based           bit(72)                  level 3 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_" set ref 424*
                                                                                  470* 489* 809
access_class             20            based           bit(72)                  level 2 in structure "create_branch_info" dcl 18-17
                                                                                  in procedure "retrieve_from_volume_" set ref 803*
                                                                                  804* 810
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 13-8 in procedure
                                                                                  "retrieve_from_volume_" ref 803
access_name                            based           structure                level 1 dcl 15-29
acl_entry                              based           structure                level 1 dcl 15-7
acl_frp                  36            based           bit(18)                  level 2 packed packed unaligned dcl 13-8 ref 707
acl_list                               based           structure                array level 1 dcl 113
aclc                            000100 automatic       fixed bin(17,0)          dcl 53 set ref 399* 705* 709* 709 710 711 712 713
                                                                                  714 715 716
aclep                           001042 automatic       pointer                  dcl 15-5 set ref 708* 710 711 712 713 714 715 716
                                                                                  717
aclp                    256     000114 external static pointer                  level 3 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_" ref 183
aclp                            000102 automatic       pointer                  dcl 54 in procedure "retrieve_from_volume_" set ref
                                                                                  183* 399* 710 711 712 713 714 715 716
aclrp                           000104 automatic       bit(18)                  packed unaligned dcl 55 set ref 707* 707* 708*
addcharno                                              builtin function         dcl 175 ref 879 879
addr                                                   builtin function         dcl 175 ref 187 215 215 240 310 441 470 470 489 489
                                                                                  655 655 675 786 806 868 868 887 887
answer                          000106 automatic       varying char(3)          dcl 56 set ref 215* 218
answer_iocbp              6     001052 automatic       pointer                  initial level 2 dcl 21-7 set ref 21-7*
areap                   250     000114 external static pointer                  level 3 dcl 1-27 set ref 555 764 765*
array                    22            based           structure                array level 2 dcl 16-8 set ref 240 310
att_desc                        000110 automatic       char(256)                packed unaligned dcl 57 set ref 197* 199* 208* 223*
attributes                      000210 automatic       bit(36)                  packed unaligned dcl 58 set ref 470* 489* 521 522
                                                                                  522 522 522 522 522 522 522 522 522
backup_volume_contents                 based           structure                level 1 dcl 7-39
backup_volume_header                   based           structure                level 1 dcl 9-5 ref 257 269 271 271 639 653 653 653
                                                                                  655 655
backup_volume_record                   based           structure                level 1 dcl 8-17
backup_volume_record_version_1         constant        fixed bin(17,0)          initial dcl 8-14 ref 286 341 346 549
backup_volume_record_version_2         constant        fixed bin(17,0)          initial dcl 8-15 ref 286
based_area                             based           area(1024)               dcl 104 ref 555 764
bc                       40(11)        based           fixed bin(24,0)          level 2 packed packed unaligned dcl 13-8 ref 799
bit                                                    builtin function         dcl 175 ref 328 328
bitcnt                   16            based           fixed bin(24,0)          level 2 dcl 18-17 set ref 799* 800*
bits                    172            based           structure                level 2 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_"
bits                    212     000114 external static structure                level 2 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_"
bs                        4            based           bit(1)                   level 2 packed packed unaligned dcl 13-8 ref 679 706
                                                                                  788 790 796 799 803 814
chars                   220            based           structure                level 2 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_"
chars                    10     000114 external static structure                level 2 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_"
chars                   110            based           structure                level 3 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_"
chase_sw                  1(02)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  792*
code                                   parameter       fixed bin(35,0)          dcl 60 in procedure "retrieve_from_volume_" set ref
                                                                                  29 178* 208* 210 211 211 221* 223* 230* 231 232*
                                                                                  259* 265* 271* 341* 346* 383* 384 385 390* 392
                                                                                  399* 400 401* 407* 408 409* 424* 427 428* 430*
                                                                                  432* 434* 438* 442* 443 444* 451* 459* 461 462*
                                                                                  467* 470* 473 474* 479* 484* 485 485 485 485 489*
                                                                                  493 501 502 504* 507* 549* 565* 579 580 580 594
                                                                                  596* 608* 623* 624 624* 640* 655* 662* 676* 677
                                                                                  726* 727 728* 732* 734 743* 745 746 751* 765* 767
                                                                                  768 773* 829* 830 831 969* 970 971*
code                                   parameter       fixed bin(35,0)          dcl 843 in procedure "read" set ref 837 861* 863
                                                                                  868* 870 874* 879* 884 887* 889 924*
command_query_                  000042 constant        entry                    external dcl 152 ref 215
contents_type                          constant        fixed bin(17,0)          initial dcl 9-21 ref 275
contentsp                       001032 automatic       pointer                  dcl 7-12 set ref 725* 726 728 734
convert_status_code_            000060 constant        entry                    external dcl 160 ref 401 409 434 444 462 474 971
copy                                   based           fixed bin(17,0)          array dcl 105 set ref 734* 734
copy_sw                   1(01)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  790* 791*
copysw                   32(03)        based           bit(1)                   level 2 packed packed unaligned dcl 13-8 ref 790
cp_escape_control         1(02) 001052 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*
crbp                            000212 automatic       pointer                  dcl 61 set ref 383* 459* 786* 787 788 789 790 791
                                                                                  792 793 794 795 796 797 798 799 800 801 802 803
                                                                                  804 810
create_branch_info                     based           structure                level 1 dcl 18-17
create_branch_version_2                constant        fixed bin(17,0)          initial dcl 18-35 ref 787
cross_segment            12(01)        based           bit(1)                   level 3 packed packed unaligned dcl 17-5 set ref
                                                                                  458* 504
csl                      15(09)        based           bit(9)                   level 3 packed packed unaligned dcl 8-17 set ref 340
                                                                                  351 421 966 966
cslx                            000231 automatic       fixed bin(17,0)          dcl 67 set ref 351* 352 353 357*
dates_set                              defined         bit(1)                   packed unaligned dcl 121 set ref 522*
dir_quota                22            based           fixed bin(18,0)          level 2 dcl 18-17 set ref 802*
dir_sw                    1            based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  788* 789*
directory                              constant        fixed bin(17,0)          initial dcl 136 ref 430
dirname                   3            based           char(168)                level 4 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_" set ref 442*
                                                                                  445* 445
dirname                                parameter       char                     packed unaligned dcl 960 in procedure "set_bc" set
                                                                                  ref 958 969* 977*
dirname                   2            based           char(168)                level 2 in structure "rvce" dcl 16-22 in procedure
                                                                                  "retrieve_from_volume_" set ref 242* 242 245* 245
                                                                                  381* 381 484* 489* 494* 494 507 513 972*
dirsw                    20(18)        based           bit(1)                   level 3 in structure "backup_volume_record" packed
                                                                                  packed unaligned dcl 8-17 in procedure
                                                                                  "retrieve_from_volume_" set ref 518
dirsw                    32            based           bit(1)                   level 2 in structure "entry" packed packed unaligned
                                                                                  dcl 13-8 in procedure "retrieve_from_volume_" ref
                                                                                  788
divide                                                 builtin function         dcl 175 ref 638 734
dn                              000100 automatic       char(168)                packed unaligned dcl 826 set ref 829* 832* 832
dp                              000214 automatic       pointer                  dcl 62 set ref 674* 676*
dtd                             000216 automatic       bit(36)                  packed unaligned dcl 63 in procedure
                                                                                  "retrieve_from_volume_" set ref 424*
dtd                     246            based           bit(36)                  level 3 in structure "backup_volume_record" packed
                                                                                  packed unaligned dcl 8-17 in procedure
                                                                                  "retrieve_from_volume_" set ref 455*
dtm                      17            based           bit(36)                  level 3 in structure "backup_volume_record" packed
                                                                                  packed unaligned dcl 8-17 in procedure
                                                                                  "retrieve_from_volume_" set ref 485
dtm                             000217 automatic       bit(36)                  packed unaligned dcl 64 in procedure
                                                                                  "retrieve_from_volume_" set ref 484* 485
dump_info_set                          defined         bit(1)                   packed unaligned dcl 123 set ref 522*
dump_switches_set                      defined         bit(1)                   packed unaligned dcl 122 set ref 522*
dump_type                17            based           fixed bin(17,0)          level 2 dcl 16-8 ref 536
emode                           000220 automatic       bit(36)                  packed unaligned dcl 65 set ref 424* 432
en                              000152 automatic       char(32)                 packed unaligned dcl 827 set ref 829* 832 832*
ename                    55            based           char(32)                 level 4 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_" set ref 442*
                                                                                  445*
ename                    54            based           char(32)                 level 2 in structure "rvce" dcl 16-22 in procedure
                                                                                  "retrieve_from_volume_" set ref 242 242* 245* 381*
                                                                                  484* 489* 494* 507 515 972*
ename                                  parameter       char                     packed unaligned dcl 960 in procedure "set_bc" set
                                                                                  ref 958 969* 977*
ename                           000221 automatic       char(32)                 dcl 66 in procedure "retrieve_from_volume_" set ref
                                                                                  726* 732*
end_of_record                   000102 automatic       fixed bin(17,0)          dcl 855 set ref 920* 922 923
entry                                  based           structure                level 1 dcl 13-8
entry_name               64            based           char(32)                 level 2 dcl 16-22 set ref 242* 675
entry_recovered         204            based           bit(1)                   level 3 dcl 4-6 set ref 324 395* 503
entry_retrieval         104(01)        based           bit(1)                   level 3 packed packed unaligned dcl 16-22 ref 242
                                                                                  327 375
ep                       10            based           pointer                  level 2 in structure "retv_append_args" dcl 17-5
                                                                                  in procedure "retrieve_from_volume_" set ref 813*
ep                              001036 automatic       pointer                  dcl 13-6 in procedure "retrieve_from_volume_" set
                                                                                  ref 377 441* 442* 454 673* 676* 677* 678 679 679*
                                                                                  690 691 706 707 708 711 713 788 788 790 790 796
                                                                                  796 799 799 803 803 813 814
errcode                 214            based           fixed bin(35,0)          level 3 dcl 4-6 set ref 392* 497* 502* 530*
error_table_$bad_segment        000030 external static fixed bin(35,0)          dcl 138 ref 746 768
error_table_$data_loss          000012 external static fixed bin(35,0)          dcl 138 ref 924
error_table_$device_end         000032 external static fixed bin(35,0)          dcl 138 ref 580
error_table_$end_of_info        000034 external static fixed bin(35,0)          dcl 138 ref 580 662
error_table_$force_unassign     000014 external static fixed bin(35,0)          dcl 138 ref 211
error_table_$moderr             000024 external static fixed bin(35,0)          dcl 138 ref 432
error_table_$namedup            000010 external static fixed bin(35,0)          dcl 138 ref 385
error_table_$noentry            000022 external static fixed bin(35,0)          dcl 138 ref 428
error_table_$notadir            000016 external static fixed bin(35,0)          dcl 138 ref 430
error_table_$resource_unavailable
                                000020 external static fixed bin(35,0)          dcl 138 ref 211
error_table_$root               000036 external static fixed bin(35,0)          dcl 138 ref 830
error_table_$vtoce_connection_fail
                                000026 external static fixed bin(35,0)          dcl 138 ref 485
ex_mode                   4            based           bit(36)                  level 2 in structure "acl_entry" dcl 15-7
                                                                                  in procedure "retrieve_from_volume_" ref 716
ex_mode                  22            based           bit(36)                  array level 2 in structure "acl_list" dcl 113
                                                                                  in procedure "retrieve_from_volume_" set ref 716*
explanation_len          14     001052 automatic       fixed bin(21,0)          initial level 2 dcl 21-7 set ref 21-7*
explanation_ptr          12     001052 automatic       pointer                  initial level 2 dcl 21-7 set ref 21-7*
fixed                     1     000114 external static structure                level 2 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_"
fixed                                                  builtin function         dcl 175 in procedure "retrieve_from_volume_" ref 328
                                                                                  328 340 340 351 421 796 966 966 966 966
fixed_bin               212            based           structure                level 2 dcl 4-6
flags                   104            based           structure                level 2 in structure "rvce" dcl 16-22 in procedure
                                                                                  "retrieve_from_volume_"
flags                   232     000114 external static structure                level 3 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_"
flags                    12            based           structure                level 2 in structure "retv_append_args" dcl 17-5
                                                                                  in procedure "retrieve_from_volume_"
fm                       33            based           bit(18)                  array level 3 packed packed unaligned dcl 8-17 set
                                                                                  ref 352
fp                                     based           bit(18)                  level 2 packed packed unaligned dcl 14-7 ref 694
from_time               102            based           fixed bin(71,0)          level 2 dcl 16-22 ref 328 328 485
frp                                    based           bit(18)                  level 2 packed packed unaligned dcl 15-7 ref 717
hc_backup_$decode_uidpath       000052 constant        entry                    external dcl 156 ref 829
hc_backup_$delete               000044 constant        entry                    external dcl 153 ref 504 507
hc_backup_$get_entry            000050 constant        entry                    external dcl 155 ref 442
hc_backup_$retv_add_acl         000102 constant        entry                    external dcl 169 ref 399
hc_backup_$retv_addname         000104 constant        entry                    external dcl 170 ref 407
hc_backup_$retv_append          000110 constant        entry                    external dcl 172 ref 383 459
hc_backup_$retv_check           000100 constant        entry                    external dcl 168 ref 484
hc_backup_$retv_copy            000112 constant        entry                    external dcl 173 ref 470 489
hc_backup_$retv_hash_search     000106 constant        entry                    external dcl 171 ref 676
hc_backup_$retv_status          000056 constant        entry                    external dcl 158 ref 424
hc_backup_$set_bc               000046 constant        entry                    external dcl 154 ref 969
hcs_$make_seg                   000064 constant        entry                    external dcl 162 ref 732
hcs_$truncate_seg               000062 constant        entry                    external dcl 161 ref 422
hdp                                    automatic       pointer                  dcl 9-3 ref 257 269 271 271 639 653 653 653 655 655
header                                 based           structure                level 3 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_"
header                                 based           structure                level 2 in structure "backup_volume_record" dcl 8-17
                                                                                  in procedure "retrieve_from_volume_"
ignore                          000234 automatic       fixed bin(35,0)          dcl 70 set ref 205* 422*
in_use                  104(04)        based           bit(1)                   level 3 packed packed unaligned dcl 16-22 ref 241
                                                                                  311
in_use_cnt               14            based           fixed bin(17,0)          level 2 dcl 16-8 ref 179
incr                                   constant        fixed bin(17,0)          initial dcl 6-4 ref 536
index                                                  builtin function         dcl 175 ref 920
input_buf                              based           bit(36)                  array packed unaligned dcl 128 set ref 638*
input_buffer                           based           char                     packed unaligned dcl 849 set ref 897* 905 920 930
                                                                                  943* 943
input_buffer_len          6     000114 external static fixed bin(21,0)          level 3 dcl 1-27 set ref 864 896* 897 910* 910 914
                                                                                  915 920 937* 937 940 943 943
input_buffer_ptr        236     000114 external static pointer                  level 3 dcl 1-27 ref 897 905 920 930 943 943
input_buffer_start        7     000114 external static fixed bin(21,0)          level 3 dcl 1-27 set ref 865* 905 908* 908 920 930
                                                                                  935* 935 941* 941 943 947*
input_iocbp             244     000114 external static pointer                  level 3 dcl 1-27 set ref 205 205* 209* 228 868* 874*
                                                                                  879* 887*
input_volume_desc       112     000114 external static char(256)                level 3 dcl 1-27 set ref 197 197*
inputp                          001026 automatic       pointer                  dcl 4-3 set ref 191* 322* 324 324 324 389* 392 395
                                                                                  398* 404* 413* 423 424 424 424 424 435 437* 442
                                                                                  442 445 445 445 445 445 445 450* 459 459 463 463
                                                                                  463 466* 470 470 470 470 470 475 475 475 478* 489
                                                                                  489 489 496* 497 502 503 504 504 512 512 514 514
                                                                                  520* 527* 529 530 533 555 555 743 743* 764 764 798
                                                                                  808 809
ioa_$rsnnl                      000066 constant        entry                    external dcl 163 ref 197 199 381 386 396 402 410 435
                                                                                  445 463 475 494 516 522 832 972 977
iocbp                           000236 automatic       pointer                  dcl 71 set ref 190* 207* 208* 209 228* 230* 623*
iox_$attach_name                000116 constant        entry                    external dcl 19-8 ref 208
iox_$close                      000120 constant        entry                    external dcl 19-8 ref 623
iox_$detach_iocb                000122 constant        entry                    external dcl 19-8 ref 205
iox_$get_chars                  000124 constant        entry                    external dcl 19-8 ref 868 879 887
iox_$open                       000126 constant        entry                    external dcl 19-8 ref 230
iox_$position                   000130 constant        entry                    external dcl 19-8 ref 874
label                                  based           structure                level 1 dcl 11-18
last_valid_puid         212     000114 external static bit(36)                  array level 3 dcl 1-27 set ref 295* 829*
last_valid_vtoce_ename
                         62     000114 external static char(32)                 level 3 dcl 1-27 set ref 296* 831 832*
last_volname             72     000114 external static char(32)                 level 3 dcl 1-27 set ref 204 235*
length                                                 builtin function         dcl 175 ref 868 868 887 887 905 908 910 941 943
level                   212            based           fixed bin(17,0)          level 3 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_" set ref 424*
                                                                                  470* 489* 808
level                     2            based           fixed bin(17,0)          level 2 in structure "retv_append_args" dcl 17-5
                                                                                  in procedure "retrieve_from_volume_" set ref 808*
link                     12            based           bit(1)                   level 3 packed packed unaligned dcl 17-5 set ref
                                                                                  814*
link_retrieval          104            based           bit(1)                   level 3 packed packed unaligned dcl 16-22 ref 679
literal_sw                1(05) 001052 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*
local_create_branch_info        000761 automatic       structure                level 1 dcl 110 set ref 786
local_entry                     000701 automatic       structure                level 1 unaligned dcl 108 set ref 441
local_mseg_return_args          001004 automatic       structure                level 1 dcl 111 set ref 187
local_retv_append_args          000746 automatic       structure                level 1 dcl 109 set ref 805* 806
long                            000240 automatic       char(100)                dcl 72 in procedure "retrieve_from_volume_" set ref
                                                                                  401* 402* 409* 410* 434* 435* 444* 445* 462* 463*
                                                                                  474* 475* 971* 972*
long                    232(07) 000114 external static bit(1)                   level 4 in structure "retv_data_" packed packed
                                                                                  unaligned dcl 1-27 in procedure
                                                                                  "retrieve_from_volume_" ref 237
max_access_authorization
                          5            based           bit(72)                  level 2 dcl 17-5 set ref 810*
message                         000271 automatic       varying char(512)        initial dcl 73 set ref 73* 386* 389 396* 398 402*
                                                                                  404 410* 413 435* 437 445* 450 463* 466 475* 478
                                                                                  494* 496 516* 520 522* 527 972* 972* 977* 977*
message_len                     000472 automatic       fixed bin(17,0)          dcl 74 set ref 396* 402* 410* 435* 445* 463* 475*
                                                                                  494* 516* 522*
message_segment_$incremental_read_index
                                000070 constant        entry                    external dcl 164 ref 765
message_segment_$update_message_index
                                000072 constant        entry                    external dcl 165 ref 743
min                                                    builtin function         dcl 175 ref 915
mode                      2            based           bit(3)                   level 2 in structure "create_branch_info" packed
                                                                                  packed unaligned dcl 18-17 in procedure
                                                                                  "retrieve_from_volume_" set ref 795*
mode                      3(09)        based           bit(3)                   level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 15-7 in procedure
                                                                                  "retrieve_from_volume_" ref 715
mode                     21            based           bit(36)                  array level 2 in structure "acl_list" dcl 113
                                                                                  in procedure "retrieve_from_volume_" set ref 715*
ms_arg_ptr                      001030 automatic       pointer                  dcl 5-7 set ref 187* 322 765*
ms_ptr                                 based           pointer                  level 2 dcl 5-9 ref 322
mseg_return_args                       based           structure                level 1 dcl 5-9
myname                          000005 constant        char(32)                 initial packed unaligned dcl 133 set ref 215* 223*
                                                                                  232* 288* 301* 389* 398* 404* 413* 437* 450* 466*
                                                                                  478* 496* 520* 527* 582* 584* 592* 594* 596* 598*
                                                                                  608* 624* 645* 661* 728* 747* 751* 769* 773*
n_entries                15            based           fixed bin(17,0)          level 2 dcl 16-8 ref 236 239 309
name                      2            based           structure                level 2 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 15-7 in procedure
                                                                                  "retrieve_from_volume_"
name                      4            based           char(32)                 level 2 in structure "names" dcl 14-7 in procedure
                                                                                  "retrieve_from_volume_" ref 693
name                      4            based           char(32)                 level 2 in structure "access_name" dcl 15-29
                                                                                  in procedure "retrieve_from_volume_" ref 711 713
name_frp                  5            based           bit(18)                  level 2 packed packed unaligned dcl 13-8 ref 690
name_list                              based           char(32)                 array dcl 106 set ref 383* 386* 396* 399* 402* 407*
                                                                                  407* 410* 410* 693*
names                                  based           structure                level 1 dcl 14-7
nel                             000570 automatic       fixed bin(21,0)          dcl 88 set ref 257* 259* 269* 271* 281* 282 289* 290
                                                                                  339* 341* 346* 545* 546 549* 564 565* 579 592 639*
                                                                                  640* 654* 655* 734
nelt                            000211 automatic       fixed bin(21,0)          dcl 59 set ref 259* 271* 341* 346* 549* 564* 565*
                                                                                  579 592 638 640* 655*
new_bc                          001167 automatic       fixed bin(24,0)          dcl 961 set ref 965* 966* 966 969* 976 977*
new_contentsp                   000474 automatic       pointer                  dcl 75 set ref 732* 734
new_dirname             110            based           char(168)                level 4 dcl 4-6 set ref 423 424* 435* 445* 445 459*
                                                                                  463* 463 470* 475* 475 504 512 512
new_ename               162            based           char(32)                 level 4 dcl 4-6 set ref 445* 459* 463* 470* 475* 504
                                                                                  514 514
nlc                             000476 automatic       fixed bin(17,0)          dcl 76 set ref 406 689* 692* 692 693
nlp                     254     000114 external static pointer                  level 3 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_" ref 182
nlp                             000500 automatic       pointer                  dcl 77 in procedure "retrieve_from_volume_" set ref
                                                                                  182* 383 386 396 399 402 407 407 410 410 693
nmx                             000232 automatic       fixed bin(17,0)          dcl 68 set ref 406* 407 410*
np                              001040 automatic       pointer                  dcl 14-5 set ref 675* 676* 691* 693 694
nrp                             000502 automatic       bit(18)                  packed unaligned dcl 78 set ref 690* 690* 691*
null                                                   builtin function         dcl 175 ref 190 191 205 207 208 208 377 555 21-7
                                                                                  21-7 21-7 565 565 673 677 678 679 764 873 930
object_read                     000503 automatic       bit(1)                   packed unaligned dcl 79 set ref 305* 337 338* 544
object_recovered        206            based           bit(1)                   level 3 dcl 4-6 set ref 324 529*
object_size                     000504 automatic       fixed bin(19,0)          dcl 80 set ref 421* 422
objectp                         000506 automatic       pointer                  dcl 81 in procedure "retrieve_from_volume_" set ref
                                                                                  184* 341* 353 357 422* 470* 489* 549* 674
objectp                 262     000114 external static pointer                  level 3 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_" ref 184
old_bc                          001166 automatic       fixed bin(24,0)          dcl 959 set ref 969* 976 977*
padding                   1(07) 001052 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*
page                                   based           bit                      dcl 103 set ref 353* 353 357*
page_buffer_ptr         234     000114 external static pointer                  level 3 dcl 1-27 ref 185
page_bufferp                    000510 automatic       pointer                  dcl 82 set ref 185* 346* 353
page_offset                     000512 automatic       fixed bin(21,0)          dcl 83 set ref 350* 353 355* 355
parent_ac_sw              1(04)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  793*
pattern1                               based           bit(36)                  level 3 in structure "backup_volume_record" dcl 8-17
                                                                                  in procedure "retrieve_from_volume_" ref 262
pattern1                        000004 constant        bit(36)                  initial packed unaligned dcl 9-24 in procedure
                                                                                  "retrieve_from_volume_" ref 262 644
pattern2                        000003 constant        bit(36)                  initial packed unaligned dcl 9-25 in procedure
                                                                                  "retrieve_from_volume_" ref 262 644
pattern2                  3            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 8-17
                                                                                  in procedure "retrieve_from_volume_" ref 262
pattern3                  6            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 8-17
                                                                                  in procedure "retrieve_from_volume_" ref 262
pattern3                        000002 constant        bit(36)                  initial packed unaligned dcl 9-26 in procedure
                                                                                  "retrieve_from_volume_" ref 262 644
pc_switches_set                        defined         bit(1)                   packed unaligned dcl 124 set ref 522*
pers_rp                   2            based           bit(18)                  level 3 packed packed unaligned dcl 15-7 ref 710 711
person                                 based           char(32)                 array level 2 dcl 113 set ref 710* 711*
pmode                           000513 automatic       bit(36)                  packed unaligned dcl 84 set ref 424* 432
pname                           000514 automatic       char(168)                dcl 85 set ref 381* 383* 386* 386 396* 396 399* 402*
                                                                                  402 407* 410* 410
pnl                             000566 automatic       fixed bin(17,0)          dcl 86 set ref 381*
previous                104(05)        based           bit(1)                   level 3 packed packed unaligned dcl 16-22 ref 485
primary_name            273            based           char(32)                 level 3 packed packed unaligned dcl 8-17 set ref 296
priv_upgrade_sw           1(03)        based           bit(1)                   level 3 packed packed unaligned dcl 18-17 set ref
                                                                                  794*
proj_rp                   2(18)        based           bit(18)                  level 3 packed packed unaligned dcl 15-7 ref 712 713
project                  10            based           char(32)                 array level 2 dcl 113 set ref 712* 713*
prompt_after_explanation
                          1(06) 001052 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*
ptr                                                    builtin function         dcl 175 ref 271 271 353 353 357 691 708 711 713
ptrs                    234     000114 external static structure                level 2 dcl 1-27
pvid                            000567 automatic       bit(36)                  packed unaligned dcl 87 set ref 424*
qidx                      1     000114 external static fixed bin(17,0)          array level 3 dcl 1-27 set ref 743* 765*
query_code                3     001052 automatic       fixed bin(35,0)          initial level 2 dcl 21-7 set ref 21-7*
query_info                      001052 automatic       structure                level 1 dcl 21-7 set ref 215 215
query_info_version_5                   constant        fixed bin(17,0)          initial dcl 21-35 ref 214
question_iocbp            4     001052 automatic       pointer                  initial level 2 dcl 21-7 set ref 21-7*
queue_msg_hdr                          based           structure                level 1 dcl 3-12
quota                    17            based           fixed bin(18,0)          level 2 dcl 18-17 set ref 801*
quota_info_set                         defined         bit(1)                   packed unaligned dcl 125 set ref 522*
rec1_len                  2            based           fixed bin(17,0)          level 3 dcl 8-17 ref 269
rec1_type                 1            based           fixed bin(17,0)          level 3 dcl 8-17 ref 275 280
rec2_len                  5            based           fixed bin(17,0)          level 3 dcl 8-17 ref 281 289 339 545 965
recordp                         001034 automatic       pointer                  dcl 8-12 in procedure "retrieve_from_volume_" set
                                                                                  ref 181* 259* 262 262 262 269 271 271 275 280 281
                                                                                  286 286 289 294 295 296 299 311 328 328 339 340
                                                                                  340 341 346 351 352 421 454 455 456 470 470 485
                                                                                  489 489 518 545 549 638 640* 644 644 644 653 653
                                                                                  655 655 725 965 966 966 966 966
recordp                 260     000114 external static pointer                  level 3 in structure "retv_data_" dcl 1-27
                                                                                  in procedure "retrieve_from_volume_" ref 181
records                  15(18)        based           bit(9)                   level 3 packed packed unaligned dcl 8-17 set ref 340
                                                                                  966 966
repeat_time              10     001052 automatic       fixed bin(71,0)          initial level 2 dcl 21-7 set ref 21-7*
request                                based           structure                level 2 dcl 4-6
requestor               220            based           char(32)                 level 3 dcl 4-6 set ref 424* 470* 489* 798
requests_left                   000571 automatic       fixed bin(17,0)          dcl 89 set ref 236* 536* 536 537
resynch_retry_count             000572 automatic       fixed bin(17,0)          dcl 90 set ref 601* 605* 605 607
resynching                      000573 automatic       bit(1)                   packed unaligned dcl 91 set ref 188* 581 591 637*
                                                                                  648*
resynching_completed            000574 automatic       bit(1)                   packed unaligned dcl 92 set ref 189* 299 300* 649*
ret_dn                          000162 automatic       char(168)                packed unaligned dcl 828 set ref 832* 833
retriever                              constant        fixed bin(17,0)          initial dcl 1-25 ref 743 765
return_buffer_ptr                      parameter       pointer                  dcl 843 ref 837 873 879 879 897 930 930
return_string                          based           char                     packed unaligned dcl 852 set ref 897 930*
retv_append_argp                001050 automatic       pointer                  dcl 17-3 set ref 383* 458 459* 504 806* 807 808 809
                                                                                  810 813 814
retv_append_args                       based           structure                level 1 dcl 17-5
retv_data_                      000114 external static structure                level 1 dcl 1-27
retv_input                             based           structure                level 1 dcl 4-6 set ref 555 743 764
retv_ms_id               75            based           bit(72)                  level 2 dcl 16-22 set ref 743* 765*
retv_notify_                    000040 constant        entry                    external dcl 151 ref 389 398 404 413 437 450 466 478
                                                                                  496 520 527
retv_report_$error_output       000074 constant        entry                    external dcl 166 ref 223 232 288 301 582 584 592 594
                                                                                  596 598 608 624 645 661 728 747 751 769 773
retv_report_$online_output      000076 constant        entry                    external dcl 167 ref 238 242 245
retv_request                           based           structure                level 1 dcl 2-7
retv_vol_control                       based           structure                level 1 dcl 16-8
ring_brackets            35            based           bit(3)                   array level 2 packed packed unaligned dcl 13-8 ref
                                                                                  796
rings                     3            based           fixed bin(3,0)           array level 2 dcl 18-17 set ref 796* 797*
rtrim                                                  builtin function         dcl 175 ref 732 831
rvce                                   based           structure                level 1 dcl 16-22
rvcep                           001046 automatic       pointer                  dcl 16-4 set ref 240* 241 242 242 242 242 242 242
                                                                                  245 245 245 310* 311 311 327 328 328 328 328 375
                                                                                  381 381 381 484 484 485 485 485 489 489 494 494
                                                                                  494 507 507 513 515 675 679 743 765 972 972
rvcp                            001044 automatic       pointer                  dcl 16-3 set ref 177* 179 195 196 213 219 236 239
                                                                                  240 309 310 536
rvlx                            000233 automatic       fixed bin(17,0)          dcl 69 set ref 239* 240* 309* 310*
short                           000576 automatic       char(8)                  dcl 93 set ref 401* 409* 434* 444* 462* 474* 971*
size                                                   builtin function         dcl 175 ref 257 269 271 271 639 653 653 653 655 655
                                                                                  743
skip_query               16            based           bit(1)                   level 3 packed packed unaligned dcl 16-8 set ref 213
                                                                                  219*
sm                                     constant        bit(3)                   initial packed unaligned dcl 135 ref 432 432 432 432
status_code               2     001052 automatic       fixed bin(35,0)          initial level 2 dcl 21-7 set ref 21-7*
string                                 based           bit                      packed unaligned dcl 129 set ref 653* 653
substr                                                 builtin function         dcl 175 set ref 352 653 897* 905 920 930 943* 943
suffixed_name_$make             000054 constant        entry                    external dcl 157 ref 726
suppress_name_sw          1(01) 001052 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*
suppress_spacing          1(04) 001052 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*
switches                 16            based           structure                level 2 in structure "retv_vol_control" dcl 16-8
                                                                                  in procedure "retrieve_from_volume_"
switches                  1            based           structure                level 2 in structure "create_branch_info" packed
                                                                                  packed unaligned dcl 18-17 in procedure
                                                                                  "retrieve_from_volume_"
switches                  1     001052 automatic       structure                level 2 in structure "query_info" dcl 21-7
                                                                                  in procedure "retrieve_from_volume_"
sys_dir                  10     000114 external static char(168)                level 3 dcl 1-27 ref 732
tag                       3            based           char(1)                  level 3 in structure "acl_entry" packed packed
                                                                                  unaligned dcl 15-7 in procedure
                                                                                  "retrieve_from_volume_" ref 714
tag                      20            based           char(1)                  array level 2 in structure "acl_list" dcl 113
                                                                                  in procedure "retrieve_from_volume_" set ref 714*
tape_check1                     000104 automatic       char(8)                  packed unaligned dcl 855 set ref 868 868 868 868 892
                                                                                  905* 905 908 910 919 920
tape_check2                     000106 automatic       char(8)                  packed unaligned dcl 855 set ref 887 887 887 887 892
                                                                                  907* 919 941 943 943
temp_dirname                    000600 automatic       char(168)                packed unaligned dcl 94 set ref 512* 513* 516* 516
                                                                                  518* 522* 522
temp_ename                      000652 automatic       char(32)                 packed unaligned dcl 95 set ref 514* 515* 516* 518*
                                                                                  522*
time_dumped               7            based           bit(36)                  level 3 dcl 8-17 ref 328 328
to_time                 100            based           fixed bin(71,0)          level 2 dcl 16-22 ref 328 328 485
type                            000662 automatic       fixed bin(17,0)          dcl 96 set ref 424* 430 484* 516
uid                      14            based           bit(36)                  level 3 in structure "backup_volume_record" packed
                                                                                  packed unaligned dcl 8-17 in procedure
                                                                                  "retrieve_from_volume_" set ref 294 299 311 454*
uid                             000663 automatic       bit(36)                  packed unaligned dcl 97 in procedure
                                                                                  "retrieve_from_volume_" set ref 424* 428
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 13-8 in procedure
                                                                                  "retrieve_from_volume_" ref 454
uid                                    based           bit(36)                  level 2 in structure "rvce" dcl 16-22 in procedure
                                                                                  "retrieve_from_volume_" ref 311
uid_path                253            based           bit(36)                  array level 3 packed packed unaligned dcl 8-17 set
                                                                                  ref 295
unspec                                                 builtin function         dcl 175 set ref 805*
userid                    6            based           char(32)                 level 2 dcl 18-17 set ref 798*
version                  10            based           fixed bin(17,0)          level 2 in structure "backup_volume_record" dcl 8-17
                                                                                  in procedure "retrieve_from_volume_" ref 286 286
                                                                                  341 346 549
version                                based           fixed bin(17,0)          level 2 in structure "create_branch_info" dcl 18-17
                                                                                  in procedure "retrieve_from_volume_" set ref 787*
version                         001052 automatic       fixed bin(17,0)          level 2 in structure "query_info" dcl 21-7
                                                                                  in procedure "retrieve_from_volume_" set ref 214*
version                                based           char(8)                  level 2 in structure "retv_append_args" dcl 17-5
                                                                                  in procedure "retrieve_from_volume_" set ref 807*
volid                    11            based           bit(36)                  level 2 in structure "retv_vol_control" dcl 16-8
                                                                                  in procedure "retrieve_from_volume_" ref 196
volid                           000664 automatic       bit(36)                  packed unaligned dcl 98 in procedure
                                                                                  "retrieve_from_volume_" set ref 196* 324 533
volid                   247            based           bit(36)                  array level 3 in structure "backup_volume_record"
                                                                                  packed packed unaligned dcl 8-17 in procedure
                                                                                  "retrieve_from_volume_" set ref 456*
volid                   211            based           bit(36)                  level 3 in structure "retv_input" dcl 4-6
                                                                                  in procedure "retrieve_from_volume_" set ref 324
                                                                                  533*
volname                  11            based           char(32)                 level 2 in structure "backup_volume_contents"
                                                                                  dcl 7-39 in procedure "retrieve_from_volume_" set
                                                                                  ref 726* 728*
volname                   1            based           char(32)                 level 2 in structure "retv_vol_control" dcl 16-8
                                                                                  in procedure "retrieve_from_volume_" ref 195
volname                         000665 automatic       char(32)                 packed unaligned dcl 99 in procedure
                                                                                  "retrieve_from_volume_" set ref 195* 197* 199* 204
                                                                                  223* 232* 235 238* 288* 301* 582* 584* 592* 594*
                                                                                  596* 598* 608* 624* 645* 661*
vtoce                                  based           structure                level 1 dcl 12-7 in procedure
                                                                                  "retrieve_from_volume_"
vtoce                    13            based           structure                level 2 in structure "backup_volume_record" dcl 8-17
                                                                                  in procedure "retrieve_from_volume_" set ref 470
                                                                                  470 489 489
vtoce_type                             constant        fixed bin(17,0)          initial dcl 9-15 ref 280
vtoce_volid                     000675 automatic       bit(36)                  array packed unaligned dcl 100 set ref 424*
word                                   based           bit(36)                  array packed unaligned dcl 127 set ref 644 644 644
                                                                                  655 655
words_skipped                   000700 automatic       fixed bin(35,0)          dcl 101 set ref 584* 643* 645* 659* 659 660
yes_or_no_sw              1     001052 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 21-7 set
                                                                                  ref 21-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 22-61
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 22-70
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 22-79
Direct_input                           internal static fixed bin(17,0)          initial dcl 20-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 20-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 20-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 20-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 20-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 20-15
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 11-92
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 22-92
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 3-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 3-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 3-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 3-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 3-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 3-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 3-41
Sequential_input                       internal static fixed bin(17,0)          initial dcl 20-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 20-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 20-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 20-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 20-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 20-15
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 22-89
backup_pvol_info                       based           structure                level 1 dcl 10-5
backup_version_1                       internal static fixed bin(17,0)          initial dcl 6-7
backup_volume_contents_names           based           structure                level 1 dcl 7-56
backup_volume_contents_version_3       internal static fixed bin(17,0)          initial dcl 7-14
bpvip                                  automatic       pointer                  dcl 10-3
comp                                   internal static fixed bin(17,0)          initial dcl 6-6
cons                                   internal static fixed bin(17,0)          initial dcl 6-5
contents_namesp                        automatic       pointer                  dcl 7-54
dir_type                               internal static fixed bin(17,0)          initial dcl 9-16
info_type                              internal static fixed bin(17,0)          initial dcl 9-22
iox_$attach_loud                000000 constant        entry                    external dcl 19-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 19-8
iox_$close_file                 000000 constant        entry                    external dcl 19-8
iox_$control                    000000 constant        entry                    external dcl 19-8
iox_$delete_record              000000 constant        entry                    external dcl 19-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 19-8
iox_$detach                     000000 constant        entry                    external dcl 19-8
iox_$err_no_operation           000000 constant        entry                    external dcl 19-8
iox_$err_not_attached           000000 constant        entry                    external dcl 19-8
iox_$err_not_closed             000000 constant        entry                    external dcl 19-8
iox_$err_not_open               000000 constant        entry                    external dcl 19-8
iox_$error_output                      external static pointer                  dcl 19-41
iox_$find_iocb                  000000 constant        entry                    external dcl 19-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 19-8
iox_$get_line                   000000 constant        entry                    external dcl 19-8
iox_$look_iocb                  000000 constant        entry                    external dcl 19-8
iox_$modes                      000000 constant        entry                    external dcl 19-8
iox_$move_attach                000000 constant        entry                    external dcl 19-8
iox_$open_file                  000000 constant        entry                    external dcl 19-8
iox_$propagate                  000000 constant        entry                    external dcl 19-8
iox_$put_chars                  000000 constant        entry                    external dcl 19-8
iox_$read_key                   000000 constant        entry                    external dcl 19-8
iox_$read_length                000000 constant        entry                    external dcl 19-8
iox_$read_record                000000 constant        entry                    external dcl 19-8
iox_$rewrite_record             000000 constant        entry                    external dcl 19-8
iox_$seek_key                   000000 constant        entry                    external dcl 19-8
iox_$user_input                        external static pointer                  dcl 19-41
iox_$user_io                           external static pointer                  dcl 19-41
iox_$user_output                       external static pointer                  dcl 19-41
iox_$write_record               000000 constant        entry                    external dcl 19-8
iox_modes                              internal static char(24)                 initial array dcl 20-6
labelp                                 automatic       pointer                  dcl 11-16
null_type                              internal static fixed bin(17,0)          initial dcl 9-18
prev_output_log_type                   internal static fixed bin(17,0)          initial dcl 9-20
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 21-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 21-34
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 21-36
queue_dir                              internal static char(168)                initial packed unaligned dcl 1-23
queue_msg_hdr_version_1                internal static fixed bin(17,0)          initial dcl 3-37
requestp                               automatic       pointer                  dcl 2-3
retv_data_version_1                    internal static fixed bin(17,0)          initial dcl 1-18
retv_request_version_2                 internal static fixed bin(17,0)          initial dcl 2-5
retv_vol_control_version_1             internal static fixed bin(17,0)          initial dcl 16-6
seg_type                               internal static fixed bin(17,0)          initial dcl 9-17
seg_vtoce                              based           structure                level 1 dcl 12-92
short_iox_modes                        internal static char(4)                  initial array dcl 20-12
user                                   internal static fixed bin(17,0)          initial dcl 1-24
v1_backup_volume_contents              based           structure                level 1 dcl 7-17
v2_backup_volume_contents              based           structure                level 1 dcl 7-26
volume_log_type                        internal static fixed bin(17,0)          initial dcl 9-19
vtoce_parts                            based           bit(2304)                array dcl 12-90
vtocep                                 automatic       pointer                  dcl 12-5

NAMES DECLARED BY EXPLICIT CONTEXT.
build_access_list               006464 constant        entry                    internal dcl 701 ref 379
build_name_list                 006433 constant        entry                    internal dcl 685 ref 378
check_input_error               005447 constant        entry                    internal dcl 572 ref 260 266 273 343 348 551 566 641
                                                                                  657 663
check_next_request              005343 constant        label                    dcl 542 ref 324 328 377
close                           006023 constant        entry                    internal dcl 618 ref 538 587 610
convert_puid_                   007416 constant        entry                    internal dcl 822 ref 301 598
finish                          005403 constant        label                    dcl 555 ref 225 233 539 588 611 752 774
init_append_args                007220 constant        entry                    internal dcl 782 ref 380 457
locate_entry                    006360 constant        entry                    internal dcl 668 ref 376
pattern_match                   002030 constant        label                    dcl 269 ref 650
read                            007613 constant        entry                    internal dcl 837 ref 259 271 341 346 549 565 640 655
read_incremental_queue_message  007102 constant        entry                    internal dcl 759 ref 321
record_contents_segment         006602 constant        entry                    internal dcl 721 ref 276
reread                          007111 constant        label                    dcl 765 ref 770
resynch_input_volume            006076 constant        entry                    internal dcl 631 ref 602
retrieve_from_volume_           001050 constant        entry                    external dcl 29
retry                           001261 constant        label                    dcl 208 ref 218
retry_append                    002563 constant        label                    dcl 383
retry_update                    006776 constant        label                    dcl 743 ref 748
search_loop                     001757 constant        label                    dcl 257 ref 277 283 291 554
set_bc                          010175 constant        entry                    internal dcl 958 ref 518
set_code                        004723 constant        label                    dcl 501 ref 439 452 468 480
skip_chars                      005412 constant        entry                    internal dcl 559 ref 282 290
test                            006160 constant        label                    dcl 644 ref 665
update_message                  005322 constant        label                    dcl 533 ref 498 509
update_queue_message            006775 constant        entry                    internal dcl 739 ref 535

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11176       11330   10457       11206
Length     12324   10457       132         757     517           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
retrieve_from_volume_              1104 external procedure  is an external procedure.  
skip_chars                              internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
check_input_error                   222 internal procedure  calls itself recursively.  
close                                96 internal procedure  is called by several nonquick procedures.  
resynch_input_volume                    internal procedure  shares stack frame of internal procedure check_input_error.  
locate_entry                            internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
build_name_list                         internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
build_access_list                       internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
record_contents_segment                 internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
update_queue_message                    internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
read_incremental_queue_message
                                        internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
init_append_args                        internal procedure  shares stack frame of external procedure retrieve_from_volume_.  
convert_puid_                       212 internal procedure  is called by several nonquick procedures.  
read                                 88 internal procedure  is called by several nonquick procedures.  
set_bc                                  internal procedure  shares stack frame of external procedure retrieve_from_volume_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_puid_            000100 dn                          convert_puid_
                         000152 en                          convert_puid_
                         000162 ret_dn                      convert_puid_
read                     000100 Nassign_chars               read
                         000101 Nread_chars                 read
                         000102 end_of_record               read
                         000104 tape_check1                 read
                         000106 tape_check2                 read
retrieve_from_volume_    000100 aclc                        retrieve_from_volume_
                         000102 aclp                        retrieve_from_volume_
                         000104 aclrp                       retrieve_from_volume_
                         000106 answer                      retrieve_from_volume_
                         000110 att_desc                    retrieve_from_volume_
                         000210 attributes                  retrieve_from_volume_
                         000211 nelt                        retrieve_from_volume_
                         000212 crbp                        retrieve_from_volume_
                         000214 dp                          retrieve_from_volume_
                         000216 dtd                         retrieve_from_volume_
                         000217 dtm                         retrieve_from_volume_
                         000220 emode                       retrieve_from_volume_
                         000221 ename                       retrieve_from_volume_
                         000231 cslx                        retrieve_from_volume_
                         000232 nmx                         retrieve_from_volume_
                         000233 rvlx                        retrieve_from_volume_
                         000234 ignore                      retrieve_from_volume_
                         000236 iocbp                       retrieve_from_volume_
                         000240 long                        retrieve_from_volume_
                         000271 message                     retrieve_from_volume_
                         000472 message_len                 retrieve_from_volume_
                         000474 new_contentsp               retrieve_from_volume_
                         000476 nlc                         retrieve_from_volume_
                         000500 nlp                         retrieve_from_volume_
                         000502 nrp                         retrieve_from_volume_
                         000503 object_read                 retrieve_from_volume_
                         000504 object_size                 retrieve_from_volume_
                         000506 objectp                     retrieve_from_volume_
                         000510 page_bufferp                retrieve_from_volume_
                         000512 page_offset                 retrieve_from_volume_
                         000513 pmode                       retrieve_from_volume_
                         000514 pname                       retrieve_from_volume_
                         000566 pnl                         retrieve_from_volume_
                         000567 pvid                        retrieve_from_volume_
                         000570 nel                         retrieve_from_volume_
                         000571 requests_left               retrieve_from_volume_
                         000572 resynch_retry_count         retrieve_from_volume_
                         000573 resynching                  retrieve_from_volume_
                         000574 resynching_completed        retrieve_from_volume_
                         000576 short                       retrieve_from_volume_
                         000600 temp_dirname                retrieve_from_volume_
                         000652 temp_ename                  retrieve_from_volume_
                         000662 type                        retrieve_from_volume_
                         000663 uid                         retrieve_from_volume_
                         000664 volid                       retrieve_from_volume_
                         000665 volname                     retrieve_from_volume_
                         000675 vtoce_volid                 retrieve_from_volume_
                         000700 words_skipped               retrieve_from_volume_
                         000701 local_entry                 retrieve_from_volume_
                         000746 local_retv_append_args      retrieve_from_volume_
                         000761 local_create_branch_info    retrieve_from_volume_
                         001004 local_mseg_return_args      retrieve_from_volume_
                         001026 inputp                      retrieve_from_volume_
                         001030 ms_arg_ptr                  retrieve_from_volume_
                         001032 contentsp                   retrieve_from_volume_
                         001034 recordp                     retrieve_from_volume_
                         001036 ep                          retrieve_from_volume_
                         001040 np                          retrieve_from_volume_
                         001042 aclep                       retrieve_from_volume_
                         001044 rvcp                        retrieve_from_volume_
                         001046 rvcep                       retrieve_from_volume_
                         001050 retv_append_argp            retrieve_from_volume_
                         001052 query_info                  retrieve_from_volume_
                         001166 old_bc                      set_bc
                         001167 new_bc                      set_bc

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return_mac          tra_ext_1           shorten_stack       ext_entry
int_entry           set_chars_eis       index_chars_eis     op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
command_query_                convert_status_code_          hc_backup_$decode_uidpath     hc_backup_$delete
hc_backup_$get_entry          hc_backup_$retv_add_acl       hc_backup_$retv_addname       hc_backup_$retv_append
hc_backup_$retv_check         hc_backup_$retv_copy          hc_backup_$retv_hash_search   hc_backup_$retv_status
hc_backup_$set_bc             hcs_$make_seg                 hcs_$truncate_seg             ioa_$rsnnl
iox_$attach_name              iox_$close                    iox_$detach_iocb              iox_$get_chars
iox_$open                     iox_$position                 message_segment_$incremental_read_index
message_segment_$update_message_index                       retv_notify_                  retv_report_$error_output
retv_report_$online_output    suffixed_name_$make

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$data_loss        error_table_$device_end       error_table_$end_of_info
error_table_$force_unassign   error_table_$moderr           error_table_$namedup          error_table_$noentry
error_table_$notadir          error_table_$resource_unavailable                           error_table_$root
error_table_$vtoce_connection_fail                          retv_data_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     29 001044        73 001055   21    7 001056       177 001106       178 001112       179 001113       181 001115
    182 001120       183 001123       184 001126       185 001131       187 001134       188 001136       189 001137
    190 001140       191 001142       195 001143       196 001147       197 001151       199 001204       204 001237
    205 001245       208 001261       209 001320       210 001324       211 001327       213 001333       214 001337
    215 001341       218 001407       219 001414       220 001417       221 001420       223 001422       225 001456
    227 001457       228 001460       230 001462       231 001502       232 001505       233 001534       235 001535
    236 001542       237 001545       238 001550       239 001603       240 001613       241 001617       242 001622
    245 001707       248 001755       257 001757       259 001761       260 002003       262 002007       265 002021
    266 002024       269 002030       271 002036       273 002063       275 002067       276 002073       277 002074
    280 002075       281 002077       282 002101       283 002103       286 002104       288 002111       289 002141
    290 002144       291 002146       294 002147       295 002151       296 002166       299 002171       300 002175
    301 002176       305 002240       309 002241       310 002251       311 002255       321 002264       322 002265
    324 002270       327 002277       328 002303       337 002320       338 002322       339 002324       340 002327
    341 002340       343 002363       344 002367       346 002370       348 002413       350 002417       351 002420
    352 002436       353 002446       355 002461       356 002463       357 002464       359 002476       375 002500
    376 002504       377 002505       378 002511       379 002512       380 002513       381 002514       383 002563
    384 002614       385 002617       386 002622       389 002667       390 002720       392 002724       393 002727
    395 002730       396 002733       398 003000       399 003031       400 003064       401 003067       402 003102
    404 003153       405 003204       406 003205       407 003215       408 003245       409 003250       410 003263
    413 003341       414 003372       415 003373       419 003375       421 003376       422 003404       423 003421
    424 003426       427 003513       428 003516       430 003524       432 003533       434 003546       435 003561
    437 003616       438 003647       439 003653       441 003654       442 003656       443 003704       444 003707
    445 003722       450 004012       451 004043       452 004047       454 004050       455 004054       456 004055
    457 004067       458 004070       459 004073       461 004125       462 004130       463 004143       466 004215
    467 004246       468 004252       470 004253       473 004326       474 004331       475 004344       478 004416
    479 004447       480 004453       482 004454       484 004455       485 004510       489 004542       492 004615
    493 004616       494 004620       496 004665       497 004716       498 004722       501 004723       502 004726
    503 004730       504 004732       507 004766       509 005016       512 005017       513 005030       514 005034
    515 005044       516 005050       518 005124       520 005133       521 005164       522 005167       527 005264
    528 005315       529 005316       530 005321       533 005322       535 005325       536 005326       537 005334
    538 005336       539 005342       542 005343       544 005345       545 005347       546 005352       549 005353
    551 005376       554 005402       555 005403       557 005411       559 005412       564 005413       565 005415
    566 005441       567 005445       572 005446       579 005454       580 005463       581 005470       582 005472
    584 005521       587 005556       588 005563       591 005566       592 005570       594 005622       596 005660
    598 005707       601 005753       602 005755       603 005756       605 005757       607 005760       608 005763
    610 006011       611 006016       616 006021       618 006022       623 006030       624 006042       626 006075
    631 006076       637 006077       638 006102       639 006123       640 006126       641 006151       643 006156
    644 006160       645 006176       648 006232       649 006234       650 006236       653 006241       654 006250
    655 006252       657 006277       659 006304       660 006311       661 006315       662 006345       663 006352
    665 006357       668 006360       673 006361       674 006363       675 006365       676 006370       677 006406
    678 006413       679 006420       680 006432       685 006433       689 006434       690 006435       691 006444
    692 006447       693 006450       694 006457       695 006463       701 006464       705 006465       706 006466
    707 006473       708 006500       709 006503       710 006504       711 006520       712 006532       713 006546
    714 006560       715 006567       716 006573       717 006575       718 006601       721 006602       725 006603
    726 006605       727 006635       728 006640       730 006671       732 006672       734 006760       735 006774
    739 006775       743 006776       745 007022       746 007025       747 007030       748 007054       751 007055
    752 007100       755 007101       759 007102       764 007103       765 007111       767 007140       768 007143
    769 007146       770 007172       773 007173       774 007216       777 007217       782 007220       786 007221
    787 007223       788 007225       789 007236       790 007240       791 007251       792 007253       793 007255
    794 007257       795 007261       796 007263       797 007312       798 007323       799 007330       800 007340
    801 007341       802 007342       803 007343       804 007353       805 007356       806 007361       807 007363
    808 007366       809 007371       810 007375       813 007402       814 007404       815 007414       822 007415
    829 007423       830 007452       831 007461       832 007521       833 007602       837 007612       861 007620
    863 007624       864 007632       865 007636       867 007640       868 007645       870 007667       873 007672
    874 007676       876 007717       877 007722       879 007723       882 007753       884 007756       886 007760
    887 007763       889 010007       892 010012       896 010015       897 010021       901 010030       903 010031
    905 010034       907 010041       908 010043       910 010045       914 010047       915 010053       918 010057
    919 010063       920 010066       922 010101       923 010102       924 010104       930 010110       933 010130
    935 010132       937 010134       940 010136       941 010142       943 010144       947 010170       950 010173
    952 010174       958 010175       965 010213       966 010217       969 010236       970 010271       971 010274
    972 010307       974 010354       976 010355       977 010360       981 010431


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
