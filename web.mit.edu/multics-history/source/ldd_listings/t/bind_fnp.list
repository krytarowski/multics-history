	COMPILATION LISTING OF SEGMENT bind_fnp
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1626.0 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 bind_fnp: proc;
       12 
       13 /*
       14*   This command produces a core image from FNP object segments.
       15*
       16*   Written by S.E. Barr 5/76
       17*   Modified 1/9/78 by J. Stern to add -cross_ref control arg.
       18*   Modified 3/15/78 by J. Stern to not require a trace module.
       19*   Modified 1979 May 9 by Art Beattie to accept FNP memory size of 64.
       20*   Modified 1981 Jan 22 by Robert Coren to accept "meter" keyword.
       21*   Modified 1981 June by R Holmstedt to search only working dir for object.
       22*   Modified 1982 April by Robert Coren to allow memory sizes up to 256K and
       23*    to eliminate the -simulator control argument.
       24**/
       25 
       26 dcl  bind_info_ptr ptr;				/* ptr to scratch area for bindfile information */
       27 dcl  bind_len fixed bin;				/* number of characters in bindfile */
       28 dcl  bind_ptr ptr;					/* ptr to bindfile */
       29 dcl  cleanup condition;
       30 dcl  code fixed bin (35);				/* standard Multics code */
       31 dcl  fatal_error bit (1) unal;			/* ON if fatal error */
       32 dcl  get_search_rules bit (1) unal;			/* ON if user supplied search rules */
       33 dcl  list_attach bit (1) unal;			/* ON if iox_ attach was completed */
       34 dcl  list_open bit (1) unal;				/* ON if iox_ open was completed */
       35 dcl  list_ptr ptr;
       36 dcl  obj_acl_ptr ptr;				/* acl information used for tssi_ cleanup */
       37 dcl  obj_ptr ptr;					/* ptr to core image segment */
       38 dcl  arg_version char (4);				/* version number supplied as arg */
       39 
       40 /* based */
       41 
       42 dcl 1 b aligned based (bind_info_ptr) like bind_fnp_info;
       43 dcl  ptr_array (1) ptr based;
       44 
       45 dcl (addr, divide, hbound, index, length, verify, mod, null, reverse, search, substr, string, unspec) builtin;
       46 
       47 /* external */
       48 
       49 dcl  bind_fnp_load_ entry (ptr, bit (1) unal);
       50 dcl  com_err_ entry options (variable);
       51 dcl  expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35));
       52 dcl  get_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
       53 dcl  get_wdir_ entry () returns (char (168));
       54 dcl  hcs_$initiate_count entry (char (*), char (*), char (*), fixed bin (24), fixed bin (2), ptr, fixed bin (35));
       55 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       56 dcl  ioa_$ioa_switch entry options (variable);
       57 dcl  ioa_$rsnnl entry options (variable);
       58 dcl  iox_$attach_ioname entry (char (*), ptr, char (*), fixed bin (35));
       59 dcl  iox_$error_output fixed bin (35) ext;
       60 dcl  iox_$open entry (ptr, fixed bin, bit (1) aligned, fixed bin (35));
       61 dcl  iox_$put_chars entry (ptr, ptr, fixed bin, fixed bin (35));
       62 dcl  tssi_$clean_up_segment entry (ptr);
       63 dcl  tssi_$finish_segment entry (ptr, fixed bin (24), bit (36) aligned, ptr, fixed bin (35));
       64 dcl  tssi_$get_segment entry (char (*), char (*), ptr, ptr, fixed bin (35));
       65 
  1     1 /* BEGIN INCLUDE FILE for bind_fnp_info */
  1     2 /* Written 5/76 by S.E. Barr */
  1     3 /* Modified 1/9/78 by J. Stern for cross reference data */
  1     4 /* Modified 3/15/78 by J. Stern to add trace macro data */
  1     5 /* Modified 1/22/81 by Robert Coren to add metering macro data */
  1     6 
  1     7 dcl 1 bind_fnp_info aligned based,
  1     8     2 obj_name char (32),				/* name of core_image beging built */
  1     9     2 obj_len fixed bin,				/* number of 36 bit words in core image segment */
  1    10     2 obj_ptr ptr,					/* ptr to core image segment */
  1    11     2 list_ptr ptr,					/* ptr to listing if -list was specified */
  1    12     2 flags aligned,
  1    13       3 list bit (1) unal,				/* ON if output listing was requested */
  1    14       3 printer bit (1) unal,				/* ON if printer can be configured */
  1    15       3 console bit (1) unal,				/* ON if console can be configured */
  1    16       3 error_header bit (1) unal,			/* ON if error message header has been printed */
  1    17       3 simulator bit (1) unal,
  1    18       3 cross_ref bit (1) unal,			/* ON if symbol cross reference was requested */
  1    19       3 metering_enabled bit (1) unal,			/* ON if metering code is to be executed */
  1    20       3 pad bit (29) unal,
  1    21     2 version char (4),				/* MCS version number */
  1    22     2 num_hsla fixed bin,				/* maximum HSLA's that can be configured */
  1    23     2 num_lsla fixed bin,				/* maximum LSLA's that can be configured */
  1    24     2 memory fixed bin,				/* amt of memory available in units of 1024 */
  1    25     2 entry char (8),				/* entry at which execution is to begin */
  1    26     2 module (3) aligned,
  1    27       3 name char (25) var,				/* segment name of module without .objdk */
  1    28       3 size fixed bin,				/* size of tables in 18 bit words */
  1    29     2 mask bit (18),				/* trace mask */
  1    30     2 num_segs fixed bin,				/* number of segments to be combined */
  1    31     2 num_directories fixed bin,			/* number of directories in binder search rules */
  1    32     2 directory (10) char (168) var,			/* directories to search for object segments */
  1    33     2 segs (100) aligned,
  1    34       3 seg_name char (32) var,			/* segment name */
  1    35       3 offset fixed bin unal,			/* load offset of module */
  1    36       3 length fixed bin unal,			/* text length of module */
  1    37       3 date char (15),				/* date module was compiled */
  1    38       3 dir_found char (168),				/* search rule used to find module */
  1    39       3 modnum fixed bin,				/* module number used as trace mask index */
  1    40     2 ref (256) fixed bin,				/* index into def table for SYMREF  (allows 8 bit field) */
  1    41     2 def (1000) aligned,				/* SYMDEF table */
  1    42       3 name bit (36) unal,				/* bcd name of SYMDEF */
  1    43       3 offset fixed bin,				/* offset within module in 18 bit words */
  1    44       3 def_module fixed bin,				/* index in segs array of module containing this def */
  1    45       3 ref_modules bit (108) unal,			/* bit i ON if def referenced by module i */
  1    46     2 trace_offset (100) fixed bin,			/* trace macro offsets */
  1    47     2 meter_offset (100) fixed bin,			/* metering macro offsets */
  1    48     2 unresolved (num_unresolved),			/* unresolved reference table */
  1    49       3 core_loc fixed bin,				/* core location offset in 18 bit words */
  1    50       3 index_def fixed bin;				/* index in def table of SYMDEF not yet found */
  1    51 dcl  num_unresolved fixed bin;
  1    52 
  1    53 /* END INCLUDE FILE for bind_fnp_info */
       66 
       67 
       68 	bind_info_ptr, bind_ptr, list_ptr, obj_ptr = null;
       69 	arg_version = "";
       70 	num_unresolved = 0;				/* to prevent error message at compile */
       71 	on cleanup call cleanup_proc ("1"b);
       72 
       73 	call get_temp_segments_ ("bind_fnp", addr (bind_info_ptr) -> ptr_array, code);
       74 	call parse_args;
       75 
       76 	b.metering_enabled = "1"b;			/* for now, at least, let's make metering the default */
       77 	call parse_bindfile;
       78 	if ^fatal_error then do;
       79 	     if arg_version ^= "" then b.version = arg_version;
       80 	     b.list_ptr = list_ptr;
       81 	     b.obj_ptr = obj_ptr;
       82 	     call bind_fnp_load_ (bind_info_ptr, fatal_error);
       83 	end;
       84 	if ^fatal_error then do;
       85 	     call tssi_$finish_segment (obj_ptr, b.obj_len*36, "11"b, obj_acl_ptr, code);
       86 	     call cleanup_proc ("0"b);
       87 	end;
       88 	else call abort (0, "Binding unsuccessful");
       89 
       90 RETURN:
       91 	return;
       92 
       93 /*  This procedure prints error messages on error_output and into the list segment.
       94**/
       95 
       96 
       97 print:	proc (message);
       98 
       99 dcl  message char (*);
      100 
      101 	     if b.list then do;
      102 		if ^b.error_header then do;
      103 		     b.error_header = "1"b;
      104 		     call ioa_$ioa_switch (list_ptr, "ERROR MESSAGES^/^/");
      105 		end;
      106 		call ioa_$ioa_switch (list_ptr, "^a", message);
      107 	     end;
      108 
      109 	     call ioa_$ioa_switch (iox_$error_output, message);
      110 
      111 	     return;
      112 
      113 	end print;
      114 
      115 abort:	proc (code, message);
      116 
      117 dcl  code fixed bin (35);
      118 dcl  message char (*);
      119 
      120 	     call com_err_ (code, "bind_fnp", message);
      121 	     call cleanup_proc ("1"b);
      122 	     goto RETURN;
      123 
      124 	end abort;
      125 
      126 
      127 
      128 
      129 cleanup_proc: proc (error);
      130 
      131 dcl  error bit (1) unal;				/* ON if called by cleanup condition */
      132 
      133 dcl  iox_$close entry (ptr, fixed bin (35));
      134 dcl  iox_$detach_iocb entry (ptr, fixed bin (35));
      135 dcl  release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      136 
      137 	     if bind_info_ptr ^= null then call release_temp_segments_ ("bind_fnp", addr (bind_info_ptr) -> ptr_array,
      138 		code);
      139 	     if bind_ptr ^= null then call hcs_$terminate_noname (bind_ptr, code);
      140 	     if obj_ptr ^= null then if error then call tssi_$clean_up_segment (obj_acl_ptr);
      141 	     if list_ptr ^= null then do;
      142 		if list_open then do;
      143 		     list_open = "0"b;
      144 		     call iox_$close (list_ptr, code);
      145 		     if code ^= 0 then call com_err_ (code, "Attempted to close .list segment.");
      146 		end;
      147 
      148 		if list_attach then do;
      149 		     list_attach = "0"b;
      150 		     call iox_$detach_iocb (list_ptr, code);
      151 		     if code ^= 0 then call com_err_ (code, "Attempted to detach .list segment.");
      152 		end;
      153 	     end;
      154 
      155 	end cleanup_proc;
      156 
      157 parse_args: proc ;
      158 
      159 dcl  arg char (arg_len) based (arg_ptr);
      160 dcl  path char (168);
      161 dcl  dir_name char (168);
      162 dcl  entry_name char (32);
      163 dcl  arg_len fixed bin;
      164 dcl  arg_ptr ptr;
      165 dcl  bit_count fixed bin (24);
      166 dcl  nargs fixed bin;
      167 dcl  i fixed bin;
      168 
      169 dcl  cu_$arg_count entry (fixed bin);
      170 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
      171 dcl  error_table_$badopt fixed bin (35) ext;
      172 dcl  error_table_$wrong_no_of_args fixed bin (35) ext;
      173 
      174 	     b.list, list_open, list_attach, get_search_rules = "0"b;
      175 	     path = "";
      176 
      177 	     call cu_$arg_count (nargs);
      178 	     if nargs > 0 then do;
      179 		do i = 1 to nargs;
      180 		     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      181 		     if code ^= 0 then call abort (code, "Attempted to get argument.");
      182 		     if substr (arg, 1, 1) = "-" then do;
      183 			if arg = "-list" | arg = "-ls" then b.list = "1"b;
      184 			else if arg = "-search" | arg = "-se" then get_search_rules = "1"b;
      185 			else if arg = "-version" | arg = "-vers" then do;
      186 			     i = i + 1;
      187 			     if i > nargs then call abort (error_table_$wrong_no_of_args, "Version not supplied");
      188 			     call cu_$arg_ptr (i, arg_ptr, arg_len, code);
      189 			     if code ^= 0 then call abort (code, "");
      190 			     arg_version = arg;
      191 			end;
      192 			else if arg = "-cross_ref" | arg = "-cref" then b.list, b.cross_ref = "1"b;
      193 			else call abort (error_table_$badopt, arg);
      194 		     end;
      195 
      196 		     else do;
      197 			if path = "" then do;
      198 			     if arg_len < 10 | substr (arg, arg_len - 8, 9) ^= ".bind_fnp"
      199 			     then path = arg || ".bind_fnp";
      200 			     else path = arg;
      201 			end;
      202 			else call abort (error_table_$badopt, arg);
      203 		     end;
      204 		end;
      205 	     end;
      206 
      207 	     else call abort (error_table_$wrong_no_of_args,
      208 		"Usage:  bind_fnp path {-list} {-search} {-simulator} {-version} {-cross_ref}");
      209 
      210 	     if path = "" then call abort (error_table_$wrong_no_of_args, "Pathname missing");
      211 
      212 
      213 /* get pointers to bindfile (bind_ptr), listing output (list_ptr), and core image segment (obj_ptr) */
      214 
      215 	     i = length (path) + 1 - verify (reverse (path), " ");
      216 	     call expand_path_ (addr (path), i, addr (dir_name), addr (entry_name), code);
      217 	     if code = 0 then do;
      218 		call hcs_$initiate_count (dir_name, entry_name, "", bit_count, 0, bind_ptr, code);
      219 		if bind_ptr ^= null then do;
      220 		     bind_len = divide (bit_count, 9, 21, 0);
      221 		     dir_name = get_wdir_ ();
      222 		     i = length (entry_name) - index (reverse (entry_name), reverse (".bind_fnp")) - 8;
      223 		     b.obj_name, entry_name = substr (entry_name, 1, i);
      224 		     call tssi_$get_segment (dir_name, entry_name, obj_ptr, obj_acl_ptr, code);
      225 
      226 /* if list option, get segment and make vfile_ attachment */
      227 
      228 		     if code = 0 & b.list then do;
      229 			entry_name = substr (entry_name, 1, i) || ".list";
      230 			call iox_$attach_ioname ("bind_fnp_list", list_ptr, "vfile_ " || substr (entry_name, 1, i+5), code);
      231 			if code = 0 then do;
      232 			     list_attach = "1"b;
      233 			     call iox_$open (list_ptr, 2, "0"b, code);
      234 			     if code = 0 then list_open = "1"b;
      235 			end;
      236 		     end;
      237 		end;
      238 
      239 		if code = 0 then do;
      240 		     call set_search_directories (substr (entry_name, 1, i));
      241 		     return;
      242 		end;
      243 
      244 		call abort (code, substr (dir_name, 1, length (dir_name) + 1 - verify (reverse (dir_name), " "))
      245 		     || ">" || entry_name);
      246 	     end;
      247 
      248 	     else call abort (code, path);
      249 
      250 	end parse_args;
      251 
      252 /* If the user specified a segment of search rules, it must be in the working directory and have the same name
      253*   as the object segment with a suffix of ".search".  Otherwise the working directory and the default directory will
      254*   be used.
      255**/
      256 
      257 
      258 set_search_directories: proc (name);
      259 
      260 dcl  name char (*);
      261 
      262 dcl  bit_count fixed bin (24);
      263 dcl  seg_ptr ptr;
      264 dcl  seg_end fixed bin;				/* length of search rules segment */
      265 dcl  seg_start fixed bin;				/* index to current directory */
      266 
      267 /* constants */
      268 
      269 dcl  WHITE_SPACE char (3) int static options (constant) init ("
      270 ");						/* tab blank new_line */
      271 dcl  seg char (seg_end) based (seg_ptr);
      272 
      273 	     if get_search_rules then do;
      274 		call hcs_$initiate_count (get_wdir_ (), name || ".search", "", bit_count, 0, seg_ptr, code);
      275 		if seg_ptr ^= null then do;
      276 		     seg_start = 1;
      277 		     seg_end = divide (bit_count, 9, 17, 0);
      278 		     b.num_directories = 0;
      279 		     do while (get_directory ());
      280 		     end;
      281 		     if b.num_directories < 1 then call print ("No search rules were specified");
      282 		     call hcs_$terminate_noname (seg_ptr, (0));
      283 		end;
      284 		else call abort (code, name || ".search");
      285 	     end;
      286 	     else do;
      287 		b.num_directories = 1;    /* we only do working dir by default.*/
      288 		call get_working_dir (b.directory (1));
      289 	     end;
      290 
      291 	     return;
      292 
      293 
      294 
      295 
      296 get_working_dir: proc (dir);
      297 
      298 dcl  dir char (*) var;
      299 
      300 		dir = get_wdir_ ();
      301 		dir = substr (dir, 1, length (dir) + 1 - verify (reverse (dir), " "));
      302 
      303 	     end get_working_dir;
      304 
      305 get_directory: proc () returns (bit (1) unal);
      306 
      307 dcl  i fixed bin;
      308 
      309 		i = verify (substr (seg, seg_start), WHITE_SPACE) -1;
      310 		if i > -1 then do;
      311 		     seg_start = seg_start + i;
      312 		     i = search (substr (seg, seg_start), WHITE_SPACE) -1;
      313 		     if i > -1 then do;
      314 			b.num_directories = b.num_directories + 1;
      315 			if b.num_directories <= hbound (b.directory, 1) then do;
      316 			     if substr (seg, seg_start, i) = "working_dir"
      317 			     then call get_working_dir (b.directory (b.num_directories));
      318 			     else b.directory (b.num_directories) = substr (seg, seg_start, i);
      319 			     seg_start = seg_start + i;
      320 			     return ("1"b);
      321 			end;
      322 			else do;
      323 			     fatal_error = "1"b;
      324 			     call print ("Too many directories specified " || substr (seg, seg_start, i));
      325 			end;
      326 		     end;
      327 		     else call print ("Search file must end with a new line character");
      328 		end;
      329 
      330 		return ("0"b);
      331 
      332 	     end get_directory;
      333 
      334 	end set_search_directories;
      335 
      336 parse_bindfile: proc;
      337 
      338 dcl  b_len fixed bin;
      339 dcl  b_ptr ptr;
      340 dcl  break fixed bin;
      341 dcl  break_char char (break_len) based (break_ptr);
      342 dcl  break_len fixed bin;
      343 dcl  break_ptr ptr;
      344 dcl  eof fixed bin;
      345 dcl  found_console_man bit (1) init ("0"b);
      346 dcl  module_name char (32);
      347 dcl  module_size fixed bin;
      348 dcl  module_type fixed bin;
      349 dcl  token char (token_len) based (token_ptr);
      350 dcl  token_len fixed bin;
      351 dcl  token_ptr ptr;
      352 dcl (i, k) fixed bin;
      353 dcl 1 parse_flags aligned,
      354     2 got_hsla bit (1) unal,
      355     2 got_lsla bit (1) unal,
      356     2 got_memory bit (1) unal,
      357     2 got_console bit (1) unal,
      358     2 got_printer bit (1) unal,
      359     2 got_entry bit (1) unal,
      360     2 got_order bit (1) unal,
      361     2 got_mask bit (1) unal,
      362     2 got_vers bit (1) unal,
      363     2 got_meters bit (1) unal;
      364 dcl  got_end bit (1) unal;
      365 
      366 /* constant */
      367 
      368 dcl  PRINT_TOKEN bit (1) unal int static options (constant) init ("1"b);
      369 dcl  N_REQUIRED_KEYWORDS fixed bin int static options (constant) init (9);
      370 dcl  default_size (3) fixed bin int static options (constant) init (92, 92, 256);
      371 dcl  type_keyword (3) char (5) int static init ("lsla", "hsla", "trace");
      372 dcl  keyword (13) char (12) var int static init ("hsla", "lsla", "memory", "console", "printer", "entry", "order",
      373      "mask", "version", "meter", "module", "type", "size");
      374 						/* external */
      375 
      376 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
      377 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
      378 dcl  parse_file_$parse_file_init_ptr entry (ptr, fixed bin);
      379 dcl  parse_file_$parse_file_unset_break entry (char (*));
      380 dcl  parse_file_$parse_file_ptr entry (ptr, fixed bin, fixed bin, fixed bin);
      381 dcl  parse_file_$parse_file_line_no entry () returns (fixed bin);
      382 
      383 /* print header and bindfile if listing was requested */
      384 
      385 	     if b.list then do;
      386 		call ioa_$ioa_switch (list_ptr, "^-^-Bindfile for ^a^/^/", b.obj_name);
      387 		call iox_$put_chars (list_ptr, bind_ptr, bind_len, code);
      388 		call ioa_$ioa_switch (list_ptr, "^|");
      389 	     end;
      390 
      391 	     b_ptr = bind_ptr;
      392 	     b_len = bind_len;
      393 
      394 	     call parse_file_$parse_file_init_ptr (b_ptr, b_len);
      395 	     call parse_file_$parse_file_unset_break (">_$.-+");
      396 	     b.error_header, fatal_error, string (parse_flags), got_end = "0"b;
      397 	     module_name, b.module (*).name = "";
      398 	     b.num_segs = 0;
      399 
      400 continue_parse: do while (get_token ());
      401 
      402 /* get keyword followed by ':'  */
      403 
      404 		if break_char = ":" then do;
      405 		     k = 0;
      406 		     do i = 1 to hbound (keyword, 1) while (k = 0);
      407 			if keyword (i) = token then do;
      408 			     k = i;
      409 			     if k <= 10 then do;
      410 				if ^substr (string (parse_flags), i, 1) then
      411 				     substr (string (parse_flags), i, 1) = "1"b;
      412 				else call parse_error (PRINT_TOKEN, "statement already specified");
      413 			     end;
      414 			end;
      415 		     end;
      416 
      417 		     if k = 0 then call parse_error (PRINT_TOKEN, "unrecognized keyword");
      418 		     call parse_statement (k);
      419 		end;
      420 
      421 /* check for end statement */
      422 
      423 
      424 		else if token = "end" & break_char = ";" then do;
      425 		     got_end = "1"b;
      426 		     if get_token () then call parse_error (PRINT_TOKEN, "information follows end statement");
      427 		end;
      428 
      429 		else call parse_error (PRINT_TOKEN, "syntax error in statement");
      430 
      431 	     end;
      432 
      433 	     call set_module;			/* finish module statement */
      434 
      435 	     if b.module (3).name = "" then do;		/* no trace module */
      436 		b.module (3).size = 0;
      437 		parse_flags.got_mask = "1"b;
      438 		b.mask = ""b;
      439 	     end;
      440 
      441 /* make sure all required keywords were present */
      442 
      443 	     if ^substr (string (parse_flags), 1, N_REQUIRED_KEYWORDS) ^= ""b then do;
      444 		do i = 1 to N_REQUIRED_KEYWORDS;
      445 		     if ^substr (string (parse_flags), i, 1) then call print (keyword (i) || " statement missing");
      446 		     fatal_error = "1"b;
      447 		end;
      448 	     end;
      449 	     if ^got_end then call print ("End statement is missing"); /* warning only */
      450 
      451 /* make sure special module types were specified and were present in the order statement */
      452 
      453 	     if got_order then do;
      454 		do i = 1 to 3;
      455 		     if b.module (i).name ^= "" then do;
      456 			do k = 1 to b.num_segs while (b.module (i).name ^= b.segs (k).seg_name);
      457 			end;
      458 			if k > b.num_segs then do;
      459 			     fatal_error = "1"b;
      460 			     call print ("Module missing from order statement """ || b.module (i).name || """");
      461 			end;
      462 		     end;
      463 		end;
      464 	     end;
      465 
      466 /* console_man has to be in module list if a console is configured */
      467 
      468 	     if b.console & ^found_console_man then do;
      469 		fatal_error = "1"b;
      470 		call print ("Console was configured without console_man module");
      471 	     end;
      472 
      473 
      474 	     return;
      475 
      476 parse_statement: proc (k);
      477 
      478 dcl  k fixed bin;
      479 
      480 		if keyword (k) ^= "order" then do;
      481 		     if get_token () then do;
      482 			if break_char ^= ";" then call parse_error (PRINT_TOKEN, "break character "";"" is missing ");
      483 		     end;
      484 		     else return;
      485 		end;
      486 		goto label (k);
      487 
      488 /* hsla */
      489 label (1):
      490 		b.num_hsla = cv_dec_check_ (token, code);
      491 
      492 		if code = 0 then if b.num_hsla >= 0 & b.num_hsla <= 3 then return;
      493 
      494 		call parse_error (PRINT_TOKEN, "illegal value");
      495 
      496 /* lsla */
      497 label (2):
      498 		b.num_lsla = cv_dec_check_ (token, code);
      499 		if code = 0 then if b.num_lsla >= 0 & b.num_lsla <= 6 then return;
      500 
      501 		call parse_error (PRINT_TOKEN, "illegal value");
      502 
      503 /* memory */
      504 label (3):
      505 		b.memory = cv_dec_check_ (token, code);
      506 		if code = 0 then if b.memory <= 256 & b.memory > 0 & mod (b.memory, 32) = 0 then return;
      507 
      508 		call parse_error (PRINT_TOKEN, "illegal value");
      509 
      510 
      511 /* console */
      512 label (4):
      513 		if token = "yes" | token = "no" then do;
      514 		     b.console = (token = "yes");
      515 		     return;
      516 		end;
      517 
      518 		call parse_error (PRINT_TOKEN, "yes or no expected");
      519 
      520 
      521 /* printer  */
      522 label (5):
      523 		if token = "yes" | token = "no" then do;
      524 		     b.printer = (token = "yes");
      525 		     return;
      526 		end;
      527 
      528 		call parse_error (PRINT_TOKEN, "yes or no expected");
      529 
      530 
      531 /* entry */
      532 label (6):
      533 		if token_len <= length (b.entry) then do;
      534 		     b.entry = token;
      535 		     return;
      536 		end;
      537 
      538 		call parse_error (PRINT_TOKEN, "entry name too long");
      539 
      540 
      541 /* order */
      542 label (7):
      543 		do while (get_token ());
      544 		     if token_len > 6 then if substr (token, token_len - 5, 6) = ".objdk"
      545 			then token_len = token_len -6;
      546 		     if token_len <= 25 then do;	/* source must be name.map355 */
      547 			do i = 1 to b.num_segs;
      548 			     if token = b.segs (i).seg_name then call parse_error (PRINT_TOKEN, "duplication in order statement");
      549 			end;
      550 			b.num_segs = b.num_segs + 1;
      551 			b.segs (b.num_segs).seg_name = token;
      552 			if token = "console_man" then found_console_man = "1"b;
      553 		     end;
      554 		     else call parse_error (PRINT_TOKEN, "segment name too long");
      555 		     if break_char = ";" then return;
      556 		end;
      557 		return;
      558 
      559 /* mask  */
      560 label (8):
      561 		if module_name = ""
      562 		then call parse_error (^PRINT_TOKEN, "module and type statements must precede mask");
      563 		if module_type = 0
      564 		then call parse_error (^PRINT_TOKEN, "type statement must precede mask");
      565 		if module_type ^= 3
      566 		then call parse_error (^PRINT_TOKEN, "mask statement invalid for modules not of type trace");
      567 		if token_len = 6 then do;
      568 		     i = cv_oct_check_ (token, code);
      569 		     b.mask = substr (unspec (i), 19, 18);
      570 		     if code = 0 then return;
      571 		end;
      572 		call parse_error (PRINT_TOKEN, "mask must be 6 octal digits");
      573 
      574 /* version */
      575 label (9):
      576 		if token_len <= 4 then do;
      577 		     b.version = token;
      578 		     return;
      579 		end;
      580 		call parse_error (PRINT_TOKEN, "Invalid version number");
      581 
      582 /* meter */
      583 label (10):
      584 		if token = "yes" | token = "no" then do;
      585 		     b.metering_enabled = (token = "yes");
      586 		     return;
      587 		end;
      588 
      589 		call parse_error (PRINT_TOKEN, "yes or no expected");
      590 
      591 /* module */
      592 label (11):
      593 		call set_module;			/* store values from previous module */
      594 		if token_len <= length (module_name) then do;
      595 		     module_name = token;
      596 		     return;
      597 		end;
      598 		call parse_error (PRINT_TOKEN, "module name too long");
      599 
      600 /* type */
      601 label (12):
      602 		if module_name ^= "" then do;
      603 		     if module_type = 0 then do;
      604 			do i = 1 to 3 ;
      605 			     if token = type_keyword (i) then do;
      606 				module_type = i;
      607 				if b.module (module_type).name = "" then return;
      608 				module_type = 0;
      609 				call parse_error (PRINT_TOKEN, "type already specified");
      610 			     end;
      611 			end;
      612 			call parse_error (PRINT_TOKEN, "illegal type specified");
      613 		     end;
      614 		     call parse_error (^PRINT_TOKEN, "type already specified");
      615 		end;
      616 		call parse_error (^PRINT_TOKEN, "module statement must precede type");
      617 
      618 /* size */
      619 label (13):
      620 		if module_name ^= "" then do;
      621 		     if module_size = -1 then do;
      622 			module_size = cv_dec_check_ (token, code);
      623 			if code = 0 & module_size >= 0 then return;
      624 			call parse_error (PRINT_TOKEN, "illegal value for size");
      625 		     end;
      626 		     else call parse_error (PRINT_TOKEN, "size  statement already specified");
      627 		end;
      628 		else call parse_error (^PRINT_TOKEN, "module statement must precede size");
      629 		return;
      630 
      631 
      632 	     end parse_statement;
      633 
      634 set_module:    proc;
      635 		if module_name ^= "" then do;
      636 		     if module_type > 0 then do;
      637 			b.module (module_type).name = module_name;
      638 			if module_size = -1 then do;
      639 			     module_size = default_size (module_type);
      640 			     call print ("Using default size for " || module_name);
      641 			end;
      642 
      643 			b.module (module_type).size = module_size;
      644 		     end;
      645 		     else do;
      646 			module_type = 0;
      647 			module_size = -1;
      648 			call print ("Type statement missing for "|| module_name);
      649 			fatal_error = "1"b;
      650 		     end;
      651 		end;
      652 		module_type = 0;
      653 		module_size = -1;
      654 		return;
      655 
      656 	     end set_module;
      657 
      658 /* * This procedure finds the next token and break character.
      659*   *
      660*   *	FOUND		ACTION
      661*   *
      662*   *	token + break	return "1"b
      663*   *	end of file	return "0"b
      664*   *	break + token	error message	non-local goto continue_parse
      665*   *	token + token	error message	non-local goto continue_parse
      666**/
      667 
      668 
      669 get_token:     proc () returns (bit (1) unal);
      670 
      671 		call parse_file_$parse_file_ptr (b_ptr, b_len, break, eof);
      672 		if eof ^= 0 then return ("0"b);
      673 		token_ptr = b_ptr;
      674 		token_len = b_len;
      675 		if break = 0 then do;
      676 		     call parse_file_$parse_file_ptr (b_ptr, b_len, break, eof);
      677 		     if eof ^= 0 then return ("0"b);
      678 		     break_ptr = b_ptr;
      679 		     break_len = b_len;
      680 		     if break ^= 0 then return ("1"b);
      681 		     else call parse_error (PRINT_TOKEN, "break character is missing");
      682 		end;
      683 
      684 		call parse_error (PRINT_TOKEN, "extra break character");
      685 
      686 	     end get_token;
      687 
      688 /*  This procedure prints error messages from parsing the bindfile.  It skips to the end of the statement
      689*   so there is only one error message per statement.  It also sets fatal_error so binding will be terminated
      690*   after all bindfile parsing is completed.
      691**/
      692 
      693 
      694 parse_error:   proc (print_token, message);
      695 
      696 dcl  print_token bit (1) unal;			/* ON if token should be printed */
      697 dcl  message char (*);				/* error message */
      698 
      699 dcl  temp char (150);				/* error message + line number */
      700 dcl  temp_len fixed bin;				/* length of reformatted message */
      701 
      702 /* print error message */
      703 
      704 		if print_token then call ioa_$rsnnl ("^a ""^a"" in line # ^d", temp, temp_len, message, token,
      705 		     parse_file_$parse_file_line_no ());
      706 		else call ioa_$rsnnl ("^a in line # ^d", temp, temp_len, message,
      707 		     parse_file_$parse_file_line_no ());
      708 		call print (substr (temp, 1, temp_len));
      709 
      710 /* skip to end of statement */
      711 
      712 		fatal_error = "1"b;
      713 
      714 		do while (break_char ^= ";"& eof = 0);
      715 		     call parse_file_$parse_file_ptr (break_ptr, break_len, break, eof);
      716 		end;
      717 
      718 		goto continue_parse;
      719 
      720 	     end parse_error;
      721 
      722 	end parse_bindfile;
      723 
      724      end bind_fnp;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1449.8  bind_fnp.pl1                      >dumps>old>recomp>bind_fnp.pl1
66           1    06/19/81  2115.0  bind_fnp_info.incl.pl1            >ldd>include>bind_fnp_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
N_REQUIRED_KEYWORDS                    constant        fixed bin(17,0)          initial dcl 369 ref 443 444
PRINT_TOKEN                            constant        bit(1)                   initial unaligned dcl 368 set ref 412* 417* 426*
                                                                                  429* 482* 494* 501* 508* 518* 528* 538* 548* 554*
                                                                                  560 563 565 572* 580* 589* 598* 609* 612* 614 616
                                                                                  624* 626* 628 681* 684*
WHITE_SPACE                     000110 constant        char(3)                  initial unaligned dcl 269 ref 309 312
addr                                                   builtin function         dcl 45 ref 73 137 216 216 216 216 216 216
arg                                    based           char                     unaligned dcl 159 set ref 182 183 183 184 184 185
                                                                                  185 190 192 192 193* 198 198 200 202*
arg_len                         000274 automatic       fixed bin(17,0)          dcl 163 set ref 180* 182 183 183 184 184 185 185
                                                                                  188* 190 192 192 193 193 198 198 198 198 200 202
                                                                                  202
arg_ptr                         000276 automatic       pointer                  dcl 164 set ref 180* 182 183 183 184 184 185 185
                                                                                  188* 190 192 192 193 198 198 200 202
arg_version                     000130 automatic       char(4)                  unaligned dcl 38 set ref 69* 79 79 190*
b                                      based           structure                level 1 dcl 42
b_len                           000312 automatic       fixed bin(17,0)          dcl 338 set ref 392* 394* 671* 674 676* 679
b_ptr                           000314 automatic       pointer                  dcl 339 set ref 391* 394* 671* 673 676* 678
bind_fnp_info                          based           structure                level 1 dcl 1-7
bind_fnp_load_                  000010 constant        entry                    external dcl 49 ref 82
bind_info_ptr                   000100 automatic       pointer                  dcl 26 set ref 68* 73 76 79 80 81 82* 85 101 102 103
                                                                                  137 137 174 183 192 192 223 228 278 281 287 288
                                                                                  314 314 315 315 316 316 318 318 385 386 396 397
                                                                                  398 435 436 438 455 456 456 456 458 460 468 489
                                                                                  492 492 497 499 499 504 506 506 506 514 524 532
                                                                                  534 547 548 550 550 551 551 569 577 585 607 637
                                                                                  643
bind_len                        000102 automatic       fixed bin(17,0)          dcl 27 set ref 220* 387* 392
bind_ptr                        000104 automatic       pointer                  dcl 28 set ref 68* 139 139* 218* 219 387* 391
bit_count                       000100 automatic       fixed bin(24,0)          dcl 262 in procedure "set_search_directories" set
                                                                                  ref 274* 277
bit_count                       000300 automatic       fixed bin(24,0)          dcl 165 in procedure "parse_args" set ref 218* 220
break                           000316 automatic       fixed bin(17,0)          dcl 340 set ref 671* 675 676* 680 715*
break_char                             based           char                     unaligned dcl 341 ref 404 424 482 555 714
break_len                       000317 automatic       fixed bin(17,0)          dcl 342 set ref 404 424 482 555 679* 714 715*
break_ptr                       000320 automatic       pointer                  dcl 343 set ref 404 424 482 555 678* 714 715*
cleanup                         000106 stack reference condition                dcl 29 ref 71
code                                   parameter       fixed bin(35,0)          dcl 117 in procedure "abort" set ref 115 120*
code                            000114 automatic       fixed bin(35,0)          dcl 30 in procedure "bind_fnp" set ref 73* 85* 137*
                                                                                  139* 144* 145 145* 150* 151 151* 180* 181 181*
                                                                                  188* 189 189* 216* 217 218* 224* 228 230* 231 233*
                                                                                  234 239 244* 248* 274* 284* 387* 489* 492 497* 499
                                                                                  504* 506 568* 570 622* 623
com_err_                        000012 constant        entry                    external dcl 50 ref 120 145 151
console                  16(02)        based           bit(1)                   level 3 packed unaligned dcl 42 set ref 468 514*
cross_ref                16(05)        based           bit(1)                   level 3 packed unaligned dcl 42 set ref 192*
cu_$arg_count                   000056 constant        entry                    external dcl 169 ref 177
cu_$arg_ptr                     000060 constant        entry                    external dcl 170 ref 180 188
cv_dec_check_                   000066 constant        entry                    external dcl 376 ref 489 497 504 622
cv_oct_check_                   000070 constant        entry                    external dcl 377 ref 568
default_size                    000105 constant        fixed bin(17,0)          initial array dcl 370 ref 639
dir                                    parameter       varying char             dcl 298 set ref 296 300* 301* 301 301 301
dir_name                        000212 automatic       char(168)                unaligned dcl 161 set ref 216 216 218* 221* 224* 244
                                                                                  244 244
directory                63            based           varying char(168)        array level 2 dcl 42 set ref 288* 315 316* 318*
divide                                                 builtin function         dcl 45 ref 220 277
entry                    23            based           char(8)                  level 2 dcl 42 set ref 532 534*
entry_name                      000264 automatic       char(32)                 unaligned dcl 162 set ref 216 216 218* 222 222 223
                                                                                  223* 224* 229* 229 230 240 240 244
eof                             000322 automatic       fixed bin(17,0)          dcl 344 set ref 671* 672 676* 677 714 715*
error                                  parameter       bit(1)                   unaligned dcl 131 ref 129 140
error_header             16(03)        based           bit(1)                   level 3 packed unaligned dcl 42 set ref 102 103*
                                                                                  396*
error_table_$badopt             000062 external static fixed bin(35,0)          dcl 171 set ref 193* 202*
error_table_$wrong_no_of_args   000064 external static fixed bin(35,0)          dcl 172 set ref 187* 207* 210*
expand_path_                    000014 constant        entry                    external dcl 51 ref 216
fatal_error                     000115 automatic       bit(1)                   unaligned dcl 31 set ref 78 82* 84 323* 396* 446*
                                                                                  459* 469* 649* 712*
flags                    16            based           structure                level 2 dcl 42
found_console_man               000323 automatic       bit(1)                   initial unaligned dcl 345 set ref 345* 468 552*
get_search_rules                000116 automatic       bit(1)                   unaligned dcl 32 set ref 174* 184* 273
get_temp_segments_              000016 constant        entry                    external dcl 52 ref 73
get_wdir_                       000020 constant        entry                    external dcl 53 ref 221 274 274 300
got_end                         000345 automatic       bit(1)                   unaligned dcl 364 set ref 396* 425* 449
got_mask                  0(07) 000344 automatic       bit(1)                   level 2 packed unaligned dcl 353 set ref 437*
got_order                 0(06) 000344 automatic       bit(1)                   level 2 packed unaligned dcl 353 set ref 453
hbound                                                 builtin function         dcl 45 ref 315 406
hcs_$initiate_count             000022 constant        entry                    external dcl 54 ref 218 274
hcs_$terminate_noname           000024 constant        entry                    external dcl 55 ref 139 282
i                               000342 automatic       fixed bin(17,0)          dcl 352 in procedure "parse_bindfile" set ref 406*
                                                                                  407 408 410 410* 444* 445 445* 454* 455 456 460*
                                                                                  547* 548* 568* 569 604* 605 606*
i                               000302 automatic       fixed bin(17,0)          dcl 167 in procedure "parse_args" set ref 179* 180*
                                                                                  186* 186 187 188* 215* 216* 222* 223 229 230 240
                                                                                  240
i                               000122 automatic       fixed bin(17,0)          dcl 307 in procedure "get_directory" set ref 309*
                                                                                  310 311 312* 313 316 318 319 324
index                                                  builtin function         dcl 45 ref 222
ioa_$ioa_switch                 000026 constant        entry                    external dcl 56 ref 104 106 109 386 388
ioa_$rsnnl                      000030 constant        entry                    external dcl 57 ref 704 706
iox_$attach_ioname              000032 constant        entry                    external dcl 58 ref 230
iox_$close                      000050 constant        entry                    external dcl 133 ref 144
iox_$detach_iocb                000052 constant        entry                    external dcl 134 ref 150
iox_$error_output               000034 external static fixed bin(35,0)          dcl 59 set ref 109*
iox_$open                       000036 constant        entry                    external dcl 60 ref 233
iox_$put_chars                  000040 constant        entry                    external dcl 61 ref 387
k                               000343 automatic       fixed bin(17,0)          dcl 352 in procedure "parse_bindfile" set ref 405*
                                                                                  406 408* 409 417 418* 456* 456* 458
k                                      parameter       fixed bin(17,0)          dcl 478 in procedure "parse_statement" ref 476 480
                                                                                  486
keyword                         000015 constant        varying char(12)         initial array dcl 372 ref 406 407 445 480
length                                                 builtin function         dcl 45 ref 215 222 244 301 532 594
list                     16            based           bit(1)                   level 3 packed unaligned dcl 42 set ref 101 174*
                                                                                  183* 192* 228 385
list_attach                     000117 automatic       bit(1)                   unaligned dcl 33 set ref 148 149* 174* 232*
list_open                       000120 automatic       bit(1)                   unaligned dcl 34 set ref 142 143* 174* 234*
list_ptr                        000122 automatic       pointer                  dcl 35 in procedure "bind_fnp" set ref 68* 80 104*
                                                                                  106* 141 144* 150* 230* 233* 386* 387* 388*
list_ptr                 14            based           pointer                  level 2 in structure "b" dcl 42 in procedure
                                                                                  "bind_fnp" set ref 80*
mask                     60            based           bit(18)                  level 2 dcl 42 set ref 438* 569*
memory                   22            based           fixed bin(17,0)          level 2 dcl 42 set ref 504* 506 506 506
message                                parameter       char                     unaligned dcl 99 in procedure "print" set ref 97
                                                                                  106* 109*
message                                parameter       char                     unaligned dcl 697 in procedure "parse_error" set ref
                                                                                  694 704* 706*
message                                parameter       char                     unaligned dcl 118 in procedure "abort" set ref 115
                                                                                  120*
metering_enabled         16(06)        based           bit(1)                   level 3 packed unaligned dcl 42 set ref 76* 585*
mod                                                    builtin function         dcl 45 ref 506
module                   25            based           structure                array level 2 dcl 42
module_name                     000324 automatic       char(32)                 unaligned dcl 346 set ref 397* 560 594 595* 601 619
                                                                                  635 637 640 648
module_size                     000334 automatic       fixed bin(17,0)          dcl 347 set ref 621 622* 623 638 639* 643 647* 653*
module_type                     000335 automatic       fixed bin(17,0)          dcl 348 set ref 563 565 603 606* 607 608* 636 637
                                                                                  639 643 646* 652*
name                     25            based           varying char(25)         array level 3 in structure "b" dcl 42 in procedure
                                                                                  "bind_fnp" set ref 397* 435 455 456 460 607 637*
name                                   parameter       char                     unaligned dcl 260 in procedure
                                                                                  "set_search_directories" ref 258 274 284
nargs                           000301 automatic       fixed bin(17,0)          dcl 166 set ref 177* 178 179 187
null                                                   builtin function         dcl 45 ref 68 137 139 140 141 219 275
num_directories          62            based           fixed bin(17,0)          level 2 dcl 42 set ref 278* 281 287* 314* 314 315
                                                                                  316 318
num_hsla                 20            based           fixed bin(17,0)          level 2 dcl 42 set ref 489* 492 492
num_lsla                 21            based           fixed bin(17,0)          level 2 dcl 42 set ref 497* 499 499
num_segs                 61            based           fixed bin(17,0)          level 2 dcl 42 set ref 398* 456 458 547 550* 550 551
num_unresolved                  000131 automatic       fixed bin(17,0)          dcl 1-51 set ref 70*
obj_acl_ptr                     000124 automatic       pointer                  dcl 36 set ref 85* 140* 224*
obj_len                  10            based           fixed bin(17,0)          level 2 dcl 42 ref 85
obj_name                               based           char(32)                 level 2 dcl 42 set ref 223* 386*
obj_ptr                  12            based           pointer                  level 2 in structure "b" dcl 42 in procedure
                                                                                  "bind_fnp" set ref 81*
obj_ptr                         000126 automatic       pointer                  dcl 37 in procedure "bind_fnp" set ref 68* 81 85*
                                                                                  140 224*
parse_file_$parse_file_init_ptr 000072 constant        entry                    external dcl 378 ref 394
parse_file_$parse_file_line_no  000100 constant        entry                    external dcl 381 ref 704 704 706 706
parse_file_$parse_file_ptr      000076 constant        entry                    external dcl 380 ref 671 676 715
parse_file_$parse_file_unset_break
                                000074 constant        entry                    external dcl 379 ref 395
parse_flags                     000344 automatic       structure                level 1 dcl 353 set ref 396* 410 410 443 445
path                            000140 automatic       char(168)                unaligned dcl 160 set ref 175* 197 198* 200* 210 215
                                                                                  215 216 216 248*
print_token                            parameter       bit(1)                   unaligned dcl 696 ref 694 704
printer                  16(01)        based           bit(1)                   level 3 packed unaligned dcl 42 set ref 524*
ptr_array                              based           pointer                  array dcl 43 set ref 73* 137*
release_temp_segments_          000054 constant        entry                    external dcl 135 ref 137
reverse                                                builtin function         dcl 45 ref 215 222 222 244 301
search                                                 builtin function         dcl 45 ref 312
seg                                    based           char                     unaligned dcl 271 ref 309 312 316 318 324
seg_end                         000104 automatic       fixed bin(17,0)          dcl 264 set ref 277* 309 312 316 318 324
seg_name                741            based           varying char(32)         array level 3 dcl 42 set ref 456 548 551*
seg_ptr                         000102 automatic       pointer                  dcl 263 set ref 274* 275 282* 309 312 316 318 324
seg_start                       000105 automatic       fixed bin(17,0)          dcl 265 set ref 276* 309 311* 311 312 316 318 319*
                                                                                  319 324
segs                    741            based           structure                array level 2 dcl 42
size                     35            based           fixed bin(17,0)          array level 3 dcl 42 set ref 436* 643*
string                                                 builtin function         dcl 45 set ref 396* 410 410 443 445
substr                                                 builtin function         dcl 45 set ref 182 198 223 229 230 240 240 244 301
                                                                                  309 312 316 318 324 410 410* 443 445 544 569 708
                                                                                  708
temp                            000404 automatic       char(150)                unaligned dcl 699 set ref 704* 706* 708 708
temp_len                        000452 automatic       fixed bin(17,0)          dcl 700 set ref 704* 706* 708 708
token                                  based           char                     unaligned dcl 349 set ref 407 424 489* 497* 504* 512
                                                                                  512 514 522 522 524 534 544 548 551 552 568* 577
                                                                                  583 583 585 595 605 622* 704*
token_len                       000336 automatic       fixed bin(17,0)          dcl 350 set ref 407 424 489 489 497 497 504 504 512
                                                                                  512 514 522 522 524 532 534 544 544 544 544* 544
                                                                                  546 548 551 552 567 568 568 575 577 583 583 585
                                                                                  594 595 605 622 622 674* 704 704
token_ptr                       000340 automatic       pointer                  dcl 351 set ref 407 424 489 497 504 512 512 514 522
                                                                                  522 524 534 544 548 551 552 568 577 583 583 585
                                                                                  595 605 622 673* 704
tssi_$clean_up_segment          000042 constant        entry                    external dcl 62 ref 140
tssi_$finish_segment            000044 constant        entry                    external dcl 63 ref 85
tssi_$get_segment               000046 constant        entry                    external dcl 64 ref 224
type_keyword                    000101 constant        char(5)                  initial array unaligned dcl 371 ref 605
unspec                                                 builtin function         dcl 45 ref 569
verify                                                 builtin function         dcl 45 ref 215 244 301 309
version                  17            based           char(4)                  level 2 dcl 42 set ref 79* 577*

NAMES DECLARED BY EXPLICIT CONTEXT.
RETURN                          001201 constant        label                    dcl 90 ref 122
abort                           001321 constant        entry                    internal dcl 115 ref 88 181 187 189 193 202 207 210
                                                                                  244 248 284
bind_fnp                        000773 constant        entry                    external dcl 11
cleanup_proc                    001374 constant        entry                    internal dcl 129 ref 71 86 121
continue_parse                  003531 constant        label                    dcl 400 ref 718
get_directory                   003171 constant        entry                    internal dcl 305 ref 279
get_token                       005350 constant        entry                    internal dcl 669 ref 400 426 481 542
get_working_dir                 003114 constant        entry                    internal dcl 296 ref 288 316
label                           000000 constant        label                    array(13) dcl 489 ref 486
parse_args                      001575 constant        entry                    internal dcl 157 ref 74
parse_bindfile                  003363 constant        entry                    internal dcl 336 ref 77
parse_error                     005471 constant        entry                    internal dcl 694 ref 412 417 426 429 482 494 501 508
                                                                                  518 528 538 548 554 560 563 565 572 580 589 598
                                                                                  609 612 614 616 624 626 628 681 684
parse_statement                 004147 constant        entry                    internal dcl 476 ref 418
print                           001203 constant        entry                    internal dcl 97 ref 281 324 327 445 449 460 470 640
                                                                                  648 708
set_module                      005246 constant        entry                    internal dcl 634 ref 433 592
set_search_directories          002657 constant        entry                    internal dcl 258 ref 240

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7276        7400    6665        7306
Length      7702    6665       102         266     410           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bind_fnp                            562 external procedure  is an external procedure.  
on unit on line 71                   72 on unit               
print                                96 internal procedure  is called during a stack extension.  
abort                                82 internal procedure  is called during a stack extension.  
cleanup_proc                         90 internal procedure  is called by several nonquick procedures.  
parse_args                              internal procedure  shares stack frame of external procedure bind_fnp.  
set_search_directories              238 internal procedure  is called during a stack extension.  
get_working_dir                         internal procedure  shares stack frame of internal procedure set_search_directories.  
get_directory                           internal procedure  shares stack frame of internal procedure set_search_directories.  
parse_bindfile                          internal procedure  shares stack frame of external procedure bind_fnp.  
parse_statement                         internal procedure  shares stack frame of external procedure bind_fnp.  
set_module                              internal procedure  shares stack frame of external procedure bind_fnp.  
get_token                               internal procedure  shares stack frame of external procedure bind_fnp.  
parse_error                             internal procedure  shares stack frame of external procedure bind_fnp.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bind_fnp                 000100 bind_info_ptr               bind_fnp
                         000102 bind_len                    bind_fnp
                         000104 bind_ptr                    bind_fnp
                         000114 code                        bind_fnp
                         000115 fatal_error                 bind_fnp
                         000116 get_search_rules            bind_fnp
                         000117 list_attach                 bind_fnp
                         000120 list_open                   bind_fnp
                         000122 list_ptr                    bind_fnp
                         000124 obj_acl_ptr                 bind_fnp
                         000126 obj_ptr                     bind_fnp
                         000130 arg_version                 bind_fnp
                         000131 num_unresolved              bind_fnp
                         000140 path                        parse_args
                         000212 dir_name                    parse_args
                         000264 entry_name                  parse_args
                         000274 arg_len                     parse_args
                         000276 arg_ptr                     parse_args
                         000300 bit_count                   parse_args
                         000301 nargs                       parse_args
                         000302 i                           parse_args
                         000312 b_len                       parse_bindfile
                         000314 b_ptr                       parse_bindfile
                         000316 break                       parse_bindfile
                         000317 break_len                   parse_bindfile
                         000320 break_ptr                   parse_bindfile
                         000322 eof                         parse_bindfile
                         000323 found_console_man           parse_bindfile
                         000324 module_name                 parse_bindfile
                         000334 module_size                 parse_bindfile
                         000335 module_type                 parse_bindfile
                         000336 token_len                   parse_bindfile
                         000340 token_ptr                   parse_bindfile
                         000342 i                           parse_bindfile
                         000343 k                           parse_bindfile
                         000344 parse_flags                 parse_bindfile
                         000345 got_end                     parse_bindfile
                         000404 temp                        parse_error
                         000452 temp_len                    parse_error
set_search_directories   000100 bit_count                   set_search_directories
                         000102 seg_ptr                     set_search_directories
                         000104 seg_end                     set_search_directories
                         000105 seg_start                   set_search_directories
                         000122 i                           get_directory

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc
call_int_this       call_int_other_desc call_int_other      return              tra_ext             mod_fx1
signal              enable              shorten_stack       ext_entry           int_entry           int_entry_desc
set_cs_eis          index_reverse_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bind_fnp_load_                com_err_                      cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 cv_oct_check_                 expand_path_                  get_temp_segments_
get_wdir_                     hcs_$initiate_count           hcs_$terminate_noname         ioa_$ioa_switch
ioa_$rsnnl                    iox_$attach_ioname            iox_$close                    iox_$detach_iocb
iox_$open                     iox_$put_chars                parse_file_$parse_file_init_ptr
parse_file_$parse_file_line_no                              parse_file_$parse_file_ptr
parse_file_$parse_file_unset_break                          release_temp_segments_        tssi_$clean_up_segment
tssi_$finish_segment          tssi_$get_segment

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$wrong_no_of_args iox_$error_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000772        68 001000        69 001005        70 001007        71 001010        73 001036        74 001061
     76 001062        77 001065        78 001066        79 001071        80 001101        81 001104        82 001107
     84 001120        85 001123        86 001150        87 001160        88 001161        90 001201        97 001202
    101 001216       102 001223       103 001226       104 001230       106 001252       109 001300       111 001317
    115 001320       120 001334       121 001357       122 001370       129 001373       137 001401       139 001430
    140 001446       141 001470       142 001475       143 001477       144 001500       145 001511       148 001534
    149 001537       150 001540       151 001551       155 001574       157 001575       174 001576       175 001604
    177 001607       178 001616       179 001620       180 001626       181 001643       182 001664       183 001671
    184 001706       185 001721       186 001731       187 001732       188 001755       189 001772       190 002010
    191 002015       192 002016       193 002034       194 002054       197 002055       198 002061       200 002105
    201 002111       202 002112       204 002132       205 002134       207 002135       210 002155       215 002204
    216 002222       217 002247       218 002251       219 002313       220 002317       221 002322       222 002331
    223 002344       224 002357       228 002410       229 002416       230 002433       231 002505       232 002510
    233 002512       234 002533       239 002537       240 002541       241 002560       244 002562       246 002637
    248 002641       250 002655       258 002656       273 002672       274 002675       275 002764       276 002771
    277 002773       278 002776       279 003001       280 003006       281 003007       282 003030       283 003042
    284 003043       285 003076       287 003100       288 003103       291 003113       296 003114       300 003125
    301 003146       303 003170       305 003171       309 003173       310 003213       311 003215       312 003216
    313 003235       314 003237       315 003242       316 003245       318 003264       319 003277       320 003301
    323 003307       324 003311       325 003337       326 003340       327 003341       330 003355       336 003363
    345 003364       385 003365       386 003371       387 003420       388 003435       391 003454       392 003456
    394 003460       395 003471       396 003504       397 003513       398 003530       400 003531       404 003536
    405 003544       406 003545       407 003554       408 003566       409 003570       410 003572       412 003602
    415 003610       417 003612       418 003625       419 003627       424 003630       425 003642       426 003644
    427 003657       429 003660       431 003666       433 003667       435 003670       436 003676       437 003677
    438 003701       443 003702       444 003707       445 003716       446 003753       447 003756       449 003760
    453 004000       454 004003       455 004010       456 004020       457 004047       458 004051       459 004055
    460 004057       461 004120       463 004121       468 004123       469 004131       470 004133       474 004146
    476 004147       480 004151       481 004161       482 004166       483 004202       484 004203       486 004204
    489 004207       492 004234       494 004244       497 004255       499 004302       501 004312       504 004323
    506 004350       508 004364       512 004375       514 004407       515 004420       518 004421       522 004432
    524 004444       525 004455       528 004456       532 004467       534 004472       535 004477       538 004500
    542 004506       544 004513       546 004525       547 004530       548 004540       549 004560       550 004562
    551 004564       552 004601       553 004610       554 004611       555 004622       556 004631       557 004632
    560 004633       563 004650       565 004663       567 004677       568 004702       569 004726       570 004732
    572 004735       575 004743       577 004746       578 004753       580 004754       583 004765       585 004777
    586 005010       589 005011       592 005022       594 005023       595 005026       596 005032       598 005033
    601 005044       603 005050       604 005052       605 005057       606 005066       607 005070       608 005101
    609 005102       611 005113       612 005115       614 005126       616 005142       619 005153       621 005157
    622 005162       623 005206       624 005213       625 005224       626 005225       627 005233       628 005234
    629 005245       634 005246       635 005247       636 005253       637 005255       638 005266       639 005271
    640 005274       643 005312       644 005320       646 005321       647 005322       648 005324       649 005342
    652 005344       653 005345       654 005347       669 005350       671 005352       672 005367       673 005377
    674 005401       675 005403       676 005405       677 005422       678 005432       679 005434       680 005436
    681 005446       684 005454       686 005465       694 005471       704 005502       706 005564       708 005633
    712 005652       714 005655       715 005665       716 005702       718 005703


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
