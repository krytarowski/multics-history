	COMPILATION LISTING OF SEGMENT iodd_get_cmd_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1329.6 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 iodd_get_cmd_: proc (a_wp, a_max_chars, a_chars_read, ctl, a_msg, a_source, a_code);
       13 
       14 /* This is the procedure used by the io daemon to read a command line from
       15*   either of the terminals which can give commands to the driver.
       16*
       17*   It may wait for a command to be read, or it may return if no command
       18*   was typed on either terminal as determined by the ctl (flags) arg.
       19**/
       20 
       21 /* Coded in August 1977 by J. C. Whitmore */
       22 /* Modified Mar 1978 by J. C. Whitmore for bug fix, clearing prompt slave flag */
       23 /* Modified Aug 1978 by J. C. Whitmore to fix the ctl declaration and add slave echo */
       24 
       25 
       26 
       27 /****^  HISTORY COMMENTS:
       28*  1) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
       29*     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
       30*     Upgraded to version 5 iod tables.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 /*	ENTRIES		*/
       35 
       36 	dcl     iodd_msg_		 entry options (variable);
       37 	dcl     continue_to_signal_	 entry (fixed bin (35));
       38 	dcl     convert_ipc_code_	 entry (fixed bin (35));
       39 	dcl     ioa_$rs		 entry options (variable);
       40 	dcl     iox_$get_line	 entry (ptr, ptr, fixed bin (24), fixed bin (24), fixed bin (35));
       41 	dcl     iox_$put_chars	 entry (ptr, ptr, fixed bin (24), fixed bin (35));
       42 	dcl     iox_$control	 entry (ptr, char (*), ptr, fixed bin (35));
       43 	dcl     ios_$attach		 entry (char (*), char (*), char (*), char (*), bit (72) aligned);
       44 	dcl     ipc_$block		 entry (ptr, ptr, fixed bin (35));
       45 	dcl     ipc_$drain_chn	 entry (fixed bin (71), fixed bin (35));
       46 
       47 
       48 /*	ARGUMENTS		*/
       49 
       50 	dcl     a_wp		 ptr;		/* workspace pointer to input buffer */
       51 	dcl     a_max_chars		 fixed bin (24);	/* sixe of the workspace */
       52 	dcl     a_chars_read	 fixed bin (24);	/* number of chars actually read */
       53 	dcl     a_msg		 char (*);	/* added message for Enter command(a_msg): */
       54 	dcl     a_source		 fixed bin;	/* was the cmd from the master(1) or the slave(2) */
       55 	dcl     a_code		 fixed bin (35);	/* you guessed it! error code */
       56 
       57 
       58 
       59 /*	AUTOMATIC		*/
       60 
       61 	dcl     code		 fixed bin (35);
       62 	dcl     prompt_msg		 char (128);	/* command request message */
       63 	dcl     msg_len		 fixed bin (24);
       64 	dcl     quit_signaled	 bit (1);
       65 
       66 	dcl     master		 fixed bin int static options (constant) init (1); /* constant  indicating input from master device */
       67 	dcl     slave		 fixed bin int static options (constant) init (2); /* constant indicating input from slave */
       68 
       69 	dcl     1 ctl		 aligned parameter,
       70 		2 wait_for_input	 bit (1) unal,	/* true if we should wait for a cmd line */
       71 		2 prompt_master	 bit (1) unal,	/* true if we should ask master for cmd */
       72 		2 prompt_slave	 bit (1) unal,	/* true if we should ask slave for cmd */
       73 		2 pad		 bit (33) unal;
       74 
       75 
       76 	dcl     1 read_info		 aligned,		/* structure for ios_$order "read_status" */
       77 		2 read_ev_chan	 fixed bin (71),
       78 		2 input_ready	 bit (1) unal;
       79 
       80 	dcl     1 event_info	 aligned,		/* info about a wakeup received */
       81 		2 chan		 fixed bin (71),
       82 		2 ev_msg		 fixed bin (71),
       83 		2 sender		 bit (36),
       84 		2 origin		 fixed bin,
       85 		2 wait_list_index	 fixed bin;
       86 
       87 
       88 	dcl     1 input_list	 aligned,		/* IPC wait list for operator input */
       89 		2 number		 fixed bin,	/* number of entries in the list = 2 */
       90 		2 channel		 (2) fixed bin (71);/* ipc event channels */
       91 
       92 
       93 /*	CONDITIONS	*/
       94 
       95 	dcl     (daemon_unclaimed, re_init, quit) condition;
       96 
       97 
       98 /*	BUILTINS		*/
       99 
      100 	dcl     (addr, null)	 builtin;
      101 
      102 
      103 /*	BASED STRUCTURES AND INCLUDE FILES		*/
      104 
      105 
      106 	dcl     chan_list_ptr	 ptr;		/* pointer to event channel list */
      107 
      108 	dcl     1 ev_chan_list	 aligned based (chan_list_ptr), /* wait list for all drivers and consoles */
      109 		2 number		 fixed bin,
      110 		2 channel		 (12) fixed bin (71);
      111 
      112 
      113 /*	EXT STATIC	*/
      114 
      115 	dcl     iodd_stat_p		 ptr ext static;
      116 
      117 
  1     1 /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  1     7*     Ancient History
  1     8*     Created by J. Stern, 1/20/75
  1     9*     Modified by J. C. Whitmore April 1978 for enhancements
  1    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  1    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  1    12*     q_group_tab
  1    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  1    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  1    15*     Change version number to reflect changes in q_group_tab and
  1    16*     iod_device_tab for laser printer support.  Added font tables.
  1    17*                                                   END HISTORY COMMENTS */
  1    18 
  1    19 
  1    20 /* format: style4 */
  1    21 
  1    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  1    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  1    24        2 version char (8),				/* version of this structure */
  1    25        2 date_time_compiled fixed bin (71),
  1    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  1    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  1    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  1    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  1    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  1    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  1    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  1    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  1    34        2 text_strings_offset fixed bin (18),
  1    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  1    36 
  1    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  1    38 dcl  text_strings_ptr ptr;
  1    39 dcl  1 text_strings aligned based (text_strings_ptr),
  1    40        2 length fixed bin,
  1    41        2 chars char (1 refer (text_strings.length)) unaligned;
  1    42 
  1    43 /* this defines text offsets used to locate i/o daemon tables strings in
  1    44*   the text_strings structure */
  1    45 dcl  1 text_offset based,
  1    46        2 first_char fixed bin (18) unsigned unaligned,
  1    47        2 total_chars fixed bin (18) unsigned unaligned;
  1    48 
  1    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  1    50 
  1    51 
  1    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
      118 
  2     1 /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  2     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  2     7*     Add support for logout_on_hangup option.
  2     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  2     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  2    10*     Add head/tail_sheet entry variables and paper_type variable.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 /* format: style4 */
  2    14 
  2    15 dcl  stat_p int static ptr;
  2    16 
  2    17 dcl  1 iodd_static based (stat_p) aligned,
  2    18 
  2    19 /*    The first part is set only once for a device driver */
  2    20 
  2    21        2 ithp ptr,					/* pointer to iod tables header */
  2    22        2 ltp ptr,					/* pointer to line table */
  2    23        2 idtp ptr,					/* pointer to device tab */
  2    24        2 mdtp ptr,					/* pointer to minor device table */
  2    25        2 qgtp ptr,					/* pointer to q_group table */
  2    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  2    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  2    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  2    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  2    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  2    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  2    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  2    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  2    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  2    35        2 log_stream char (32),			/* stream name used for log output */
  2    36        2 master_input char (32),			/* master console input stream for commands */
  2    37        2 master_output char (32),			/* master console output stream for messages */
  2    38        2 master_out ptr,				/* master output iocbp */
  2    39        2 master_in ptr,				/* master input iocbp */
  2    40        2 log_iocbp ptr,				/* log output iocbp */
  2    41        2 error_io ptr,				/* error i/o iocbp */
  2    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  2    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  2    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  2    45        2 device_dim char (32),			/* dim which drives the major device */
  2    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  2    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  2    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  2    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  2    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  2    51        2 major_device char (32),			/* name of the major device */
  2    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  2    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  2    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  2    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  2    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  2    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  2    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  2    59 
  2    60 /*    driver module entrypoints are defined by the following entry variables */
  2    61 
  2    62        2 driver_init entry variable options (variable),
  2    63        2 driver_request entry variable options (variable),
  2    64        2 driver_command entry variable options (variable),
  2    65        2 driver_default_handler entry variable options (variable),
  2    66 
  2    67 /*    entrypoints for head/tail_sheet_ entries */
  2    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  2    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  2    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  2    71 
  2    72        2 paper_type fixed bin,			/* type of paper being used */
  2    73 						/* 1 = single sheet */
  2    74 						/* 2 = continuous forms */
  2    75 
  2    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  2    77 
  2    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  2    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  2    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  2    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  2    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  2    83        2 output_device char (32),			/* name of minor device currently in use */
  2    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  2    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  2    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  2    87        2 segptr ptr,				/* ptr to current user segment being processed */
  2    88        2 flags,					/* control flags */
  2    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  2    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  2    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  2    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  2    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  2    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  2    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  2    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  2    97          3 step bit (1) unal,				/* run in step mode */
  2    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  2    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  2   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  2   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  2   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  2   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  2   104          3 pad bit (21) unal,				/* unused space */
  2   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  2   106          3 slave_input char (32),			/* slave input stream name */
  2   107          3 slave_output char (32),			/* slave output stream name */
  2   108          3 slave_pad fixed bin,			/* allocation breakage */
  2   109          3 slave_in ptr,				/* slave input iocbp */
  2   110          3 slave_out ptr,				/* slave output iocbp */
  2   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  2   112          3 active bit (1) unal,			/* on if there is a slave */
  2   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  2   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  2   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  2   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  2   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  2   118          3 priv2 bit (1) unal,
  2   119          3 priv3 bit (1) unal,
  2   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  2   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  2   122        2 ctl_term,					/* control terminal data */
  2   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  2   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  2   125          3 ctl_pad fixed bin,				/* allocation breakage */
  2   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  2   127          3 ctl_input char (32),			/* ctl input stream name */
  2   128          3 ctl_output char (32),			/* ctl output stream name */
  2   129          3 ctl_io char (32),				/* ctl i/o stream name */
  2   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  2   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  2   132          3 ctl_device char (32),			/* ctl terminal device name */
  2   133          3 form_type char (16),			/* format type if printing forms */
  2   134          3 attached bit (1) unal,			/* ctl term attached to process */
  2   135          3 forms bit (1) unal,			/* on if printing forms */
  2   136          3 pad bit (34) unal,
  2   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  2   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  2   139 
  2   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
      119 
      120 
      121 	stat_p = iodd_stat_p;			/* get pointer to iodd_static */
      122 
      123 	quit_signaled = "0"b;
      124 
      125 	a_code = 0;
      126 	a_chars_read = 0;
      127 
      128 	chan_list_ptr = iodd_static.chan_list_ptr;	/* get pointer to list of event channels */
      129 	input_list.number = 2;			/* two input devices, master and slave */
      130 	input_list.channel (1) = ev_chan_list.channel (1);/* copy from the full list */
      131 	input_list.channel (2) = ev_chan_list.channel (2);
      132 	read_info.read_ev_chan = ev_chan_list.channel (1);/* in case the order fails first time */
      133 	read_info.input_ready = "0"b;
      134 
      135 	if ^iodd_static.slave.accept_input then do;
      136 		ctl.prompt_master = "1"b;		/* no slave, so force the master flag */
      137 	     end;
      138 	ctl.prompt_slave = (ctl.prompt_slave | ^ctl.prompt_master); /* ask slave if not master */
      139 
      140 	prompt_msg = "";				/* start clean */
      141 	call ioa_$rs ("Enter command^[(^a)^]:", prompt_msg, msg_len, ^(a_msg = ""), a_msg); /* format the prompt message */
      142 
      143 	on quit begin;				/* check for a quit */
      144 		quit_signaled = "1"b;		/* tell main proc about it */
      145 		call continue_to_signal_ ((0));	/* and pass it on */
      146 	     end;
      147 
      148 	go to read;
      149 
      150 wait:	if ctl.prompt_slave & iodd_static.slave.accept_input then do;
      151 		call iox_$put_chars (iodd_static.slave_out, addr (prompt_msg), msg_len, code);
      152 		if code ^= 0 then ctl.prompt_master = "1"b; /* be sure we prompt someone */
      153 		call iox_$control (iodd_static.slave_out, "runout", null, code);
      154 		ctl.prompt_slave = "0"b;		/* don't repeat til needed */
      155 	     end;
      156 
      157 	if ctl.prompt_master then do;			/* do we ask for a command? */
      158 		call iox_$put_chars (iodd_static.master_out, addr (prompt_msg), msg_len, code);
      159 		ctl.prompt_master = "0"b;		/* don't ask again til necessary */
      160 	     end;
      161 
      162 	quit_signaled = "0"b;			/* watch for a quit while blocked */
      163 
      164 	call ipc_$block (addr (input_list), addr (event_info), code); /* wait for a response */
      165 	if code ^= 0 then do;
      166 		call convert_ipc_code_ (code);	/* make it an error_table_code */
      167 		call iodd_msg_ (2, master, code, "iodd_get_cmd_", "Fatal error: blocking for terminal input");
      168 		if iodd_static.test_entry then signal daemon_unclaimed; /* give programmer a look */
      169 		else signal re_init;
      170 	     end;
      171 	if quit_signaled then ctl.prompt_master, ctl.prompt_slave = "1"b; /* get a quit while blocked? */
      172 
      173 read:	call iox_$control (iodd_static.master_in, "read_status", addr (read_info), code);
      174 
      175 	input_list.channel (1), ev_chan_list.channel (1) = read_info.read_ev_chan; /* master will always prevail */
      176 
      177 	if input_ready then do;
      178 
      179 		call ipc_$drain_chn (input_list.channel (1), code); /* we only want new wakeups later */
      180 		call ipc_$drain_chn (input_list.channel (2), code); /* for the slave too! */
      181 
      182 		ctl.prompt_master = "1"b;		/* be sure we ask for more input */
      183 
      184 		call iox_$get_line (iodd_static.master_in, a_wp, a_max_chars, a_chars_read, code);
      185 
      186 		if a_chars_read = 0 then go to read;	/* not likely...., but... */
      187 
      188 		a_code = code;
      189 		a_source = master;
      190 		return;
      191 
      192 	     end;
      193 
      194 /*	Now see if the slave has anything, if we can accept a cmd line  */
      195 
      196 	if iodd_static.slave.accept_input then do;
      197 
      198 		call iox_$control (iodd_static.slave_in, "read_status", addr (read_info), code);
      199 		if code ^= 0 then go to bad_slave;
      200 						/* redefine the slave event channel, may change */
      201 		input_list.channel (2), ev_chan_list.channel (2) = read_ev_chan;
      202 
      203 		if input_ready then do;
      204 
      205 			call ipc_$drain_chn (input_list.channel (2), code); /* clear old wakeups */
      206 
      207 			ctl.prompt_slave = "1"b;	/* be sure we ask for more later */
      208 
      209 			call iox_$get_line (iodd_static.slave_in, a_wp, a_max_chars, a_chars_read, code);
      210 
      211 			if code ^= 0 then do;	/* we can drop the slave on errors */
      212 bad_slave:			iodd_static.slave.accept_input = "0"b;
      213 				iodd_static.slave.print_errors = "0"b;
      214 				iodd_static.slave.allow_quits = "0"b;
      215 				iodd_static.slave.log_msg = "0"b;
      216 				iodd_static.slave.echo_cmd = "0"b;
      217 				call iox_$control (iodd_static.slave_out, "quit_disable", null, (0)); /* lets try */
      218 				call ios_$attach ("error_output", "syn", "error_i/o", "", ("0"b)); /* just to be sure */
      219 				call iodd_msg_ (2, master, code, "iodd_get_cmd_", "Slave input terminated.");
      220 				call iox_$control (iodd_static.master_in, "resetread", null, code);
      221 				ctl.prompt_master = "1"b; /* we must ask for guidance */
      222 				ctl.wait_for_input = "1"b;
      223 				ctl.prompt_slave = "1"b; /* in case we come back later */
      224 				go to read;
      225 			     end;
      226 
      227 			if a_chars_read = 0 then go to read; /* possible due to g115 dim bug */
      228 
      229 			a_code = code;
      230 			a_source = slave;
      231 
      232 			if iodd_static.slave.echo_cmd then do;
      233 				call iox_$put_chars (iodd_static.slave_out, a_wp, (a_chars_read), code); /* echo cmd line */
      234 				if code ^= 0 then go to bad_slave;
      235 			     end;
      236 
      237 			return;
      238 
      239 		     end;
      240 	     end;
      241 
      242 	if ctl.wait_for_input then go to wait;		/* wakeup, but no input...go and wait */
      243 
      244 	a_source = 0;				/* There was no input */
      245 	a_chars_read = 0;
      246 	a_code = 0;
      247 
      248 	return;
      249 
      250 
      251 
      252      end iodd_get_cmd_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1230.0  iodd_get_cmd_.pl1                 >special_ldd>install>MR12.2-1199>iodd_get_cmd_.pl1
118          1    10/28/88  1227.4  iod_tables_hdr.incl.pl1           >special_ldd>install>MR12.2-1199>iod_tables_hdr.incl.pl1
119          2    10/28/88  1227.2  iodd_static.incl.pl1              >special_ldd>install>MR12.2-1199>iodd_static.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_chars_read                           parameter       fixed bin(24,0)          dcl 52 set ref 12 126* 184* 186 209* 227 233 245*
a_code                                 parameter       fixed bin(35,0)          dcl 55 set ref 12 125* 188* 229* 246*
a_max_chars                            parameter       fixed bin(24,0)          dcl 51 set ref 12 184* 209*
a_msg                                  parameter       char                     packed unaligned dcl 53 set ref 12 141 141*
a_source                               parameter       fixed bin(17,0)          dcl 54 set ref 12 189* 230* 244*
a_wp                                   parameter       pointer                  dcl 50 set ref 12 184* 209* 233*
accept_input            342(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref 135
                                                                                  150 196 212*
addr                                                   builtin function         dcl 100 ref 151 151 158 158 164 164 164 164 173 173
                                                                                  198 198
allow_quits             342(02)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  214*
chan_list_ptr                   000210 automatic       pointer                  dcl 106 in procedure "iodd_get_cmd_" set ref 128*
                                                                                  130 131 132 175 201
chan_list_ptr            20            based           pointer                  level 2 in structure "iodd_static" dcl 2-17
                                                                                  in procedure "iodd_get_cmd_" ref 128
channel                   2     000160 automatic       fixed bin(71,0)          array level 2 in structure "input_list" dcl 88
                                                                                  in procedure "iodd_get_cmd_" set ref 130* 131*
                                                                                  175* 179* 180* 201* 205*
channel                   2            based           fixed bin(71,0)          array level 2 in structure "ev_chan_list" dcl 108
                                                                                  in procedure "iodd_get_cmd_" set ref 130 131 132
                                                                                  175* 201*
code                            000100 automatic       fixed bin(35,0)          dcl 61 set ref 151* 152 153* 158* 164* 165 166* 167*
                                                                                  173* 179* 180* 184* 188 198* 199 205* 209* 211
                                                                                  219* 220* 229 233* 234
continue_to_signal_             000014 constant        entry                    external dcl 37 ref 145
convert_ipc_code_               000016 constant        entry                    external dcl 38 ref 166
ctl                                    parameter       structure                level 1 dcl 69 set ref 12
daemon_unclaimed                000166 stack reference condition                dcl 95 ref 168
echo_cmd                342(08)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  216* 232
ev_chan_list                           based           structure                level 1 dcl 108
event_info                      000150 automatic       structure                level 1 dcl 80 set ref 164 164
flags                   310            based           structure                level 2 dcl 2-17
input_list                      000160 automatic       structure                level 1 dcl 88 set ref 164 164
input_ready               2     000144 automatic       bit(1)                   level 2 packed packed unaligned dcl 76 set ref 133*
                                                                                  177 203
ioa_$rs                         000020 constant        entry                    external dcl 39 ref 141
iodd_msg_                       000012 constant        entry                    external dcl 36 ref 167 219
iodd_stat_p                     000036 external static pointer                  dcl 115 ref 121
iodd_static                            based           structure                level 1 dcl 2-17
ios_$attach                     000030 constant        entry                    external dcl 43 ref 218
iox_$control                    000026 constant        entry                    external dcl 42 ref 153 173 198 217 220
iox_$get_line                   000022 constant        entry                    external dcl 40 ref 184 209
iox_$put_chars                  000024 constant        entry                    external dcl 41 ref 151 158 233
ipc_$block                      000032 constant        entry                    external dcl 44 ref 164
ipc_$drain_chn                  000034 constant        entry                    external dcl 45 ref 179 180 205
log_msg                 342(04)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  215*
master                          000024 constant        fixed bin(17,0)          initial dcl 66 set ref 167* 189 219*
master_in                70            based           pointer                  level 2 dcl 2-17 set ref 173* 184* 220*
master_out               66            based           pointer                  level 2 dcl 2-17 set ref 158*
msg_len                         000141 automatic       fixed bin(24,0)          dcl 63 set ref 141* 151* 158*
null                                                   builtin function         dcl 100 ref 153 153 217 217 220 220
number                          000160 automatic       fixed bin(17,0)          level 2 dcl 88 set ref 129*
print_errors            342(03)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 set ref
                                                                                  213*
prompt_master             0(01)        parameter       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 136*
                                                                                  138 152* 157 159* 171* 182* 221*
prompt_msg                      000101 automatic       char(128)                packed unaligned dcl 62 set ref 140* 141* 151 151
                                                                                  158 158
prompt_slave              0(02)        parameter       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 138*
                                                                                  138 150 154* 171* 207* 223*
quit                            000202 stack reference condition                dcl 95 ref 143
quit_signaled                   000142 automatic       bit(1)                   packed unaligned dcl 64 set ref 123* 144* 162* 171
re_init                         000174 stack reference condition                dcl 95 ref 169
read_ev_chan                    000144 automatic       fixed bin(71,0)          level 2 dcl 76 set ref 132* 175 201
read_info                       000144 automatic       structure                level 1 dcl 76 set ref 173 173 198 198
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 2-17
                                                                                  in procedure "iodd_get_cmd_"
slave                                  constant        fixed bin(17,0)          initial dcl 67 in procedure "iodd_get_cmd_" ref 230
slave_in                334            based           pointer                  level 3 dcl 2-17 set ref 198* 209*
slave_out               336            based           pointer                  level 3 dcl 2-17 set ref 151* 153* 217* 233*
stat_p                          000010 internal static pointer                  dcl 2-15 set ref 121* 128 135 150 151 153 158 168
                                                                                  173 184 196 198 209 212 213 214 215 216 217 220
                                                                                  232 233
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 2-17 ref 168
text_offset                            based           structure                level 1 packed packed unaligned dcl 1-45
wait_for_input                         parameter       bit(1)                   level 2 packed packed unaligned dcl 69 set ref 222*
                                                                                  242

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 1-49
iod_tables_hdr                         based           structure                level 1 dcl 1-23
ithp                                   automatic       pointer                  dcl 1-22
text_strings                           based           structure                level 1 dcl 1-39
text_strings_ptr                       automatic       pointer                  dcl 1-38

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_slave                       000762 constant        label                    dcl 212 ref 199 234
iodd_get_cmd_                   000126 constant        entry                    external dcl 12
read                            000540 constant        label                    dcl 173 ref 148 186 224 227
wait                            000302 constant        label                    dcl 150 ref 242

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1430        1470    1263        1440
Length      1740    1263        40         234     145           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
iodd_get_cmd_                       195 external procedure  is an external procedure.  
on unit on line 143                  70 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 stat_p                      iodd_get_cmd_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
iodd_get_cmd_            000100 code                        iodd_get_cmd_
                         000101 prompt_msg                  iodd_get_cmd_
                         000141 msg_len                     iodd_get_cmd_
                         000142 quit_signaled               iodd_get_cmd_
                         000144 read_info                   iodd_get_cmd_
                         000150 event_info                  iodd_get_cmd_
                         000160 input_list                  iodd_get_cmd_
                         000210 chan_list_ptr               iodd_get_cmd_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return_mac          signal_op           enable_op
ext_entry_desc      int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
continue_to_signal_           convert_ipc_code_             ioa_$rs                       iodd_msg_
ios_$attach                   iox_$control                  iox_$get_line                 iox_$put_chars
ipc_$block                    ipc_$drain_chn

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
iodd_stat_p




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     12 000120       121 000141       123 000144       125 000145       126 000147       128 000150       129 000153
    130 000155       131 000157       132 000161       133 000163       135 000164       136 000170       138 000172
    140 000200       141 000203       143 000252       144 000266       145 000271       146 000300       148 000301
    150 000302       151 000313       152 000331       153 000336       154 000367       157 000372       158 000375
    159 000415       162 000420       164 000421       165 000440       166 000442       167 000451       168 000515
    169 000526       171 000531       173 000540       175 000573       177 000577       179 000601       180 000612
    182 000623       184 000626       186 000646       188 000651       189 000653       190 000655       196 000656
    198 000663       199 000714       201 000716       203 000722       205 000724       207 000735       209 000740
    211 000760       212 000762       213 000766       214 000770       215 000772       216 000774       217 000776
    218 001031       219 001077       220 001146       221 001201       222 001204       223 001206       224 001210
    227 001211       229 001214       230 001216       232 001220       233 001225       234 001243       237 001245
    242 001246       244 001252       245 001253       246 001254       248 001255


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
