	COMPILATION LISTING OF SEGMENT lib_get_tree_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/18/86  1351.7 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(75-08-01,GDixon), approve(), audit(),
       13*     install(86-07-18,MR12.0-1098):
       14*     Written initially.
       15*  2) change(84-01-20,Lippard), approve(), audit(),
       16*     install(86-07-18,MR12.0-1098):
       17*     Use archive_$list_components.
       18*  3) change(84-03-05,Lippard), approve(), audit(),
       19*     install(86-07-18,MR12.0-1098):
       20*     Free the correct archive component array structure and treat
       21*     error_table_$logical_volume_not_connected as a fatal error (so it will
       22*     complain instead of being quiet about it.
       23*  4) change(86-02-15,GDixon), approve(86-03-24,MCR7365),
       24*     audit(86-04-22,Dickson), install(86-04-22,MR12.0-1042):
       25*     Fix bug which prevents listing segments when a .1 version of the segment
       26*     also exists in the libraries.
       27*  5) change(86-05-17,GDixon), approve(86-05-17,MCR7357),
       28*     audit(86-07-10,Farley), install(86-07-18,MR12.0-1098):
       29*     Changed call to tct_ to reference find_char_$first_in_table; this
       30*     subroutine was renamed.
       31*                                                   END HISTORY COMMENTS */
       32 
       33 
       34 
       35 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       36 
       37 
       38 lib_get_tree_:	procedure (APparent, path, Pstarname, Pexclude, Srequirements, Scontrol, tree_level, 
       39 			 link_level, Parea, director, Pdirector_args, Pnodes, Acode)
       40 		options	(rename	((alloc_, smart_alloc_)));
       41 
       42      dcl	APparent			ptr,		/* ptr to parent node of the node array we are	*/
       43 						/* to create.  It must not be null. (In)	*/
       44 	path			char(168) varying;	/* path name of the parent node, or a link path	*/
       45 						/* if the parent node was a link. (In)		*/
  1     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures for the arrays of library names and search*/
  1     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  1     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  1    10 	/* to the lib_descriptor_ subroutine.						*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  1    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  1    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  1    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  1    18 	/*									*/
  1    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    20 
  1    21 
  1    22      dcl	1 library			aligned based (Plibrary),
  1    23 						/* a structure containing names of libraries to	*/
  1    24 						/*   be searched.				*/
  1    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  1    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  1    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  1    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  1    30 						/*     this library name.			*/
  1    31 
  1    32      dcl	1 starname		aligned based (Pstarname),
  1    33 						/* a structure containing names of library entries*/
  1    34 						/*   being searched for.			*/
  1    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  1    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  1    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  1    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    39 						/*     this starname.			*/
  1    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  1    41 
  1    42      dcl	1 exclude			aligned based (Pexclude),
  1    43 						/* a structure containing names of library entries*/
  1    44 						/*   being excluded from the search.		*/
  1    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  1    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  1    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  1    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  1    49 						/*     this exclude.			*/
  1    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  1    51 
  1    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       46 
       47      dcl	tree_level		fixed bin,	/* number of generations which are parent to the	*/
       48 						/* node array we are to create. (In)		*/
       49 	link_level		fixed bin,	/* number of consecutive links we have processed	*/
       50 						/* when in no-chase-links mode. (In)		*/
       51 	Parea			ptr,		/* ptr to MSA we are to create the node in. (In)	*/
       52 	director			entry (ptr, char(168) varying, ptr, ptr, bit(72) aligned, bit(36) aligned,
       53 				       fixed bin, fixed bin, ptr, entry, ptr, ptr, fixed bin(35)),
       54 						/* entry we are to call to validate (and further	*/
       55 						/* process) each node in the array. (In)	*/
       56 						/* Note that the director's calling sequence is	*/
       57 						/* the same as ours.			*/
       58 	Pdirector_args		ptr,		/* ptr to director-defined structure containing	*/
       59 						/* information used by the director. (In)	*/
       60 	Pnodes			ptr,		/* ptr to the node array which we created. (Out)	*/
       61 	Acode			fixed bin(35),	/* (Ignored)				*/
       62 	1 root_names		based (Proot_names),/* list of names on a root. 			*/
       63 	  2 N			fixed bin,	/*     count of names.			*/
       64 	  2 root_name (0 refer (root_names.N))		/*     array of names.			*/
       65 				char (32),
       66 	Proot_names		ptr,		/* ptr to root_names structure. (In)		*/
       67 	root_type			fixed bin,	/* type of a root.  2 = directory, 4 = archive.	*/
       68 	root_search_proc		char(65) varying,	/* procedure used to search root. (In)		*/
       69 	MNnodes			fixed bin;	/* maximum size of the root node array. (In)	*/
       70 
       71      dcl						/*	automatic variables			*/
       72 	Inode			fixed bin,	/* index of the node array element (node) we're	*/
       73 						/* working on now.				*/
       74 	Lstring_			fixed bin(35),	/* length of string_.			*/
       75 	Nentries			fixed bin,	/* number of arch comp entries.		*/
       76 	Nterminal_account		fixed bin(1),	/* terminal account switch from hcs_$quota_read	*/
       77 	PBDarch			ptr unal,		/* ptr to base of archive descriptor chain.	*/
       78 	PDarch			ptr,		/* ptr to an archive descriptor chain entry.	*/
       79 	Pacl			ptr,		/* ptr to a segment ACL.			*/
       80 	Parch			ptr,		/* ptr to the archive component we're working on.	*/
       81 	Pdir_acl			ptr,		/* ptr to a directory ACL.			*/
       82 	Piacl			ptr,		/* ptr to a group of IACLs from list_inacl_all.	*/
       83 	Pparent			ptr,		/* ptr to our node's parent node.		*/
       84 	Pstring_			ptr,		/* ptr to string_.				*/
       85 	Ptemp			ptr,		/* a temporary ptr.				*/
       86 	Schase_links		fixed bin(1),	/* chase switch.				*/
       87 	author			char(33),		/* author of a link (33 chars so guaranteed to	*/
       88 						/*  end with a space).			*/
       89 	bit_count			fixed bin(24),	/* a segment or archive component bit count.	*/
       90 	call_id			bit(70) aligned,	/* unique identifier of each logical call to	*/
       91 						/* hcs_$star_ or hcs_$status_long.		*/
       92 	char32			char(32),		/* character temporary.			*/
       93 	clock			fixed bin(71),	/* a binary clock value.			*/
       94 	code			fixed bin(35),	/* a status code.				*/
       95 	count			fixed bin,	/* number of matching entries in a dir.		*/
       96 	e			fixed bin,	/* entry switch:  1-$lib_root_node, 2-$root_node 	*/
       97 	ent			char(32),		/* entry part of a path name.			*/
       98 	error			label local,	/* address of current error handler.		*/
       99 	1 flags			aligned,
      100 	  2 archive		bit(1),		/* segment is an archive.			*/
      101 	  2 object_seg		bit(1),		/* segment is an object segment.		*/
      102 	  2 ascii			bit(1),		/* segment contains only ascii characters.	*/
      103 	i			fixed bin,	/* a do-group index and integer temporary.	*/
      104 	1 iacl_info,				/* information structure req'd by list_inacl_all.	*/
      105 	  2 seg,					/*   information about segment IACLs.		*/
      106 	    3 offsets (0:7)		bit(18) aligned,	/*     per ring offset of first ACLe in array.	*/
      107 	    3 counts  (0:7)		fixed bin,	/*     per ring count of ACL entries.		*/
      108 	  2 dir,					/*   information about directory IACLs.		*/
      109 	    3 offsets (0:7)		bit(18) aligned,	/*     per ring offset of first ACLe in array.	*/
      110 	    3 counts  (0:7)		fixed bin,	/*     per ring count of ACL entries.		*/
      111 	j			fixed bin,	/* a do-group index.			*/
      112 	k			fixed bin,	/* a do-group index.			*/
      113 	msf_dir			char(168),	/* pathname of MSF directory.			*/
      114 	n_components		fixed bin,	/* number of archive components		*/
      115 	type			fixed bin;	/* a temporary containing node type of parent to	*/
      116 						/* the node array we're creating.		*/
      117 
  2     1 /* --------------- BEGIN include file status_for_backup.incl.pl1 --------------- */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-05-20,Lippard), approve(86-06-02,MCR7427),
  2     6*     audit(86-06-17,Farley), install(86-06-17,MR12.0-1077):
  2     7*      Change non-returned information into pad fields.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 dcl 1 status_for_backup aligned based,
  2    12     2 version fixed bin,
  2    13     2 pad1 bit (108),
  2    14     2 switches unaligned,
  2    15       3 safety bit (1) unaligned,
  2    16       3 entrypt bit (1) unaligned,
  2    17       3 security_oosw bit (1) unaligned,
  2    18       3 audit_flag bit (1) unaligned,
  2    19       3 multiple_class bit (1) unaligned,
  2    20       3 pad2 bit (2) unaligned,
  2    21       3 master_dir bit (1) unaligned,
  2    22       3 tpd bit (1) unaligned,
  2    23       3 pad13 bit (13) unaligned,
  2    24     2 entrypt_bound bit (14) unaligned,
  2    25     2 access_class bit (72),
  2    26     2 spad bit (36),
  2    27     2 author char (32),
  2    28     2 bc_author char (32),
  2    29     2 lvid bit (36),
  2    30     2 pvid bit (36),
  2    31     2 pad3 bit (216);
  2    32 
  2    33 dcl  status_for_backup_version_2 fixed bin initial (2) static options (constant);
  2    34 
  2    35 /* ---------------- END include file status_for_backup.incl.pl1 ---------------- */
      118 
      119 
      120 declare 1 sfb automatic aligned like status_for_backup;
      121 
      122      dcl						/*	based variables			*/
      123 	1 Darch			aligned based (PDarch),
      124 						/* an archive component descriptor.		*/
      125 	  2 Pnext			ptr unal,		/* ptr to the next descriptor in the chain.	*/
      126 	  2 Parch			ptr unal,		/* ptr to the archive component.		*/
      127 	  2 Smode			bit(3) unal,	/* mode from archive component.		*/
      128 	  2 pad			bit(8) unal,
      129 	  2 bit_count		fixed bin(24) unal,	/* bit count from archive component.		*/
      130 	  2 dtm			bit(36) aligned,	/* date-time modified for archive component.	*/
      131 	  2 dtupdated		bit(36) aligned,	/* date-time component last updated.		*/
      132 	  2 name			char(32) aligned,	/* component name.				*/
      133 	1 acl (Nacls)		based (Pacl) like Dacl.acls,
      134 						/* a segment ACL structure.			*/
      135 	1 arch			based (Parch),	/* an archive component header.		*/
      136 	  2 header_begin		char(8),		/* start-of-archive-header identification field.	*/
      137 	  2 pad1			char(4),
      138 	  2 name			char(32),		/* name of the archive component.		*/
      139 	  2 dtem			char(16),		/* date-time component updated.		*/
      140 	  2 mode			char(4),		/* user's access mode to segment when archived.	*/
      141 	  2 dtm			char(16),		/* date-time segment last modified before it was	*/
      142 	  2 pad2			char(4),		/*     archived.				*/
      143 	  2 bit_count		char(8),		/* length of archive component (minus header), in	*/
      144 						/* bits).					*/
      145 	  2 header_end		char(8),		/* end-of-archive-header identification field.	*/
      146 	area_var			area based (Parea),	/* area where tree is to be allocated.		*/
      147 	clock_string		bit(72) aligned based (addr (clock)),
      148 						/* bit string overlay for a binary clock value.	*/
      149 	1 dir_acl (Ndir_acls)	based (Pdir_acl) like Ddir_acl.acls,
      150 						/* a directory ACL structure.			*/
      151 	node_string		bit(Lnode_string) aligned based (Pnode),
      152 						/* overlay for the storage occupied by a node.	*/
      153 	stop_search		label local,	/* where to go if search is being stopped	*/
      154 	string_			char(Lstring_) based (Pstring_);
      155 
      156      dcl						/*	builtin functions			*/
      157          (addr, addrel, binary, divide, length, min, mod, null, pointer, rel,
      158           reverse, rtrim, size, string, substr, sum, verify)
      159 				builtin;
      160 
      161 
      162      dcl						/*	entries				*/
      163 	area			condition,	/* a condition name.			*/
      164 	cleanup			condition,	/* a condition name.			*/
      165 	archive_$list_components	entry (ptr, fixed bin(24), fixed bin, ptr, ptr, fixed bin, fixed bin(35)),
      166 	find_char_$first_in_table	entry (char(*), char(512) aligned) returns (fixed bin(21)) reducible,
      167 	get_ring_			entry returns (fixed bin(5)),
      168 	hcs_$get_author		entry (char(*), char(*), fixed bin(1), char(*), fixed bin(35)),
      169 	hcs_$get_max_length		entry (char(*), char(*), fixed bin(35), fixed bin(35)),
      170 	hcs_$get_safety_sw		entry (char(*), char(*), bit(1), fixed bin(35)),
      171 	hcs_$initiate		entry (char(*), char(*), char(*), fixed bin(1),
      172 				       fixed bin(2), ptr, fixed bin(35)),
      173 	hcs_$list_acl		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
      174 	hcs_$list_dir_acl		entry (char(*), char(*), ptr, ptr, ptr, fixed bin, fixed bin(35)),
      175 	hcs_$list_inacl_all		entry (char(*), ptr, ptr, ptr, fixed bin(35)),
      176          (hcs_$dir_quota_read,
      177 	hcs_$quota_read)		entry (char(*), fixed bin(35), fixed bin(71), bit(36), fixed bin(35),
      178 				       fixed bin(1), fixed bin(35), fixed bin(35)),
      179 	hcs_$star_		entry (char(*), char(*), fixed bin(2), ptr, fixed bin,
      180 				       ptr, ptr, fixed bin(35)),
      181 	hcs_$status_for_backup	entry (char(*), char(*), ptr, fixed bin(35)),
      182 	hcs_$status_long		entry (char(*), char(*), fixed bin(1), ptr, ptr,
      183 				       fixed bin(35)),
      184 	hcs_$terminate_noname	entry (ptr, fixed bin(35)),
      185 	lib_free_node_$array	entry (ptr),
      186 	lib_free_node_$descriptors	entry (ptr),
      187 	lib_ptr_and_bc_		entry (ptr, fixed bin, ptr, ptr, fixed bin(24), fixed bin(35)),
      188 	match_star_name_		entry (char(*), char(*)) returns (fixed bin(35)),
      189 	msf_manager_$acl_list	entry (ptr, ptr, ptr, ptr, fixed bin, fixed bin (35)),
      190 	msf_manager_$close		entry (ptr),
      191 	msf_manager_$open		entry (char(*), char(*), ptr, fixed bin(35)),
      192 	object_info_$display	entry (ptr, fixed bin(24), ptr, fixed bin(35)),
      193 	smart_alloc_$area_full	entry (fixed bin, ptr, bit(70) aligned);
      194 
      195      dcl						/*	static variables			*/
      196 						/* length of an archive component header (in bits)*/
      197 	Lnode_string		fixed bin int static init (0),
      198 						/* length of a node (in bits).		*/
      199 	Lrecord			fixed bin(35) int static init (0),
      200 						/* length of a record (in bits).		*/
      201 	NO_MATCH			fixed bin(2) unsigned int static options(constant) init(3),
      202          (Svalid_added_status, Svalid_archive, Svalid_archive_comp, Svalid_directory, Svalid_link, Svalid_msf, 
      203 	Svalid_msf_comp, Svalid_object_info, Svalid_root init(""b), Svalid_segment)
      204 				bit(72) aligned int static,
      205          (archive_data_$header_begin,
      206 	archive_data_$header_end,
      207 	archive_data_$ident)	char(8) aligned ext static,
      208          (error_table_$archive_fmt_err,
      209 	error_table_$logical_volume_not_connected,
      210 	error_table_$noalloc,
      211 	error_table_$nomatch,
      212 	error_table_$notalloc,
      213 	error_table_$out_of_bounds,
      214 	error_table_$process_stopped,
      215 	error_table_$toomanylinks,
      216 	error_table_$typename_not_found)
      217 				fixed bin(35) ext static,
      218 	find_char_$not_ascii_table	char(512) aligned external static,
      219 	ring			fixed bin(5) int static init(8),
      220 						/* current validation level.			*/
      221 	sys_info$maxlinks		fixed bin(35) ext static,
      222 	sys_info$page_size		fixed bin(35) ext static;
      223 
      224 
      225 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      226 
      227 
      228 	Acode = 0;
      229 	if Svalid_root = ""b then call init_Svalid();
      230 	if ring > 7 then ring = get_ring_();
      231 	if Lnode_string = 0 then do;
      232 	     Lnode_string = size(node) * 36;
      233 	     Lrecord = sys_info$page_size * 36;
      234 	     end;
      235 	Schase_links = 0;
      236 	Pparent = APparent;				/* copy input argument for use by internal subr.	*/
      237 	Pnodes = null;				/* initialize output arguments.		*/
      238 	PDnodes = null;				/* initialize node structure ptr.		*/
      239 	Parch = null;				/* initialize temporary pointer so that cleanup	*/
      240 						/* can see if segment must be terminated.	*/
      241 	on cleanup call terminate_archive;		/* cleanup by terminating any archive.		*/
      242 
      243 	type = Pparent -> node.T;			/* get parent's node type.			*/
      244 	go to proc_node(type);			/* process each node, according to its type.	*/
      245 
      246 proc_node(1):					/* don't process nodes whose parents are	*/
      247 proc_node(4):					/*    segments, archive components, or msf	*/
      248 proc_node(6):					/*    components any further.			*/
      249 	return;
      250 
      251 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      252 
      253 
      254 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      255 
      256 
      257 proc_node(0):
      258 	error = fatal;				/* processing used when parent is a link.  Any 	*/
      259 						/* error is fatal.				*/
      260 	if link_level > sys_info$maxlinks then do;	/* too many consecutive links can get us into a	*/
      261 	     code = error_table_$toomanylinks;		/* loop.  Use the system-defined limit for	*/
      262 	     go to error;				/* consecutive links to prevent this.		*/
      263 	     end;
      264 
      265 	ent = "";					/* use path as entire path name of link.	*/
      266 	call get_node_array (1);			/* get a node array containing only a single node.*/
      267 	call init_node;				/* initialize this node.			*/
      268 	Schase_links = binary (Sc.chase, 1);		/* interpret link chase switch here.		*/
      269 	call status_long ((path), ent);		/* get status info about the item linked to.	*/
      270 						/* store this information in the node.		*/
      271 	stop_search = end_search;
      272 	call director_caller;			/* let director have a chance to validate node.	*/
      273 end_search:
      274 	Pnodes = PDnodes;				/* return ptr to the node array descriptor.	*/
      275 	return;
      276 
      277 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      278 
      279 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      280 
      281 
      282 proc_node(2):					/* processing used when parent is a directory.	*/
      283 	if starname.N > 1 then			/* process multiple starnames in outer ring.	*/
      284 	     ent = "**";
      285 	else					/* let ring 0 process single starname.		*/
      286 	     ent = starname(1).V;
      287 	go to call_star;
      288 
      289 proc_node(3):					/* processing used when parent is an msf.	*/
      290 	ent = "**";				/* return information about all msf components.	*/
      291 
      292 call_star:
      293 	call_id = "0"b;				/* initialize call id, so that it will be set the	*/
      294 						/* first time smart_alloc_$area_full is called.	*/
      295 call_again:
      296 	call hcs_$star_ ((path), ent, star_ALL_ENTRIES, Parea,
      297 	   star_entry_count, star_entry_ptr, star_names_ptr, code);
      298 						/* get the name and type of each matching entry 	*/
      299 						/* in the directory.			*/
      300 	if code = error_table_$notalloc then do;	/* if the current SSA of the MSA is full, 	*/
      301 	     call smart_alloc_$area_full (0, Parea, call_id);
      302 	     go to call_again;			/* get another SSA in the MSA, and try again.	*/
      303 	     end;
      304 	else if code ^= 0 then			/* treat any other status code as a fatal error.	*/
      305 	     go to fatal;
      306 
      307 	count = star_entry_count;			/* find out how many entries match any starname.	*/
      308 	go to star_test(type);			/* no checking needed for msfs.		*/
      309 
      310 star_test(2):
      311 	if starname.N > 1 then do;			/* compare entry names with starnames.  Flag	*/
      312 	     do i = 1 to star_entry_count;		/*    entry type with "11"b for non-matches.	*/
      313 		do j = star_entries(i).nindex  to  star_entries(i).nindex + star_entries(i).nnames - 1;
      314 		     do k = 1 to starname.N;
      315 			go to dir_test(starname(k).C);
      316 
      317 dir_test(0):		if star_names(j) = starname(k).V then go to dir_match;
      318 			go to dir_nomatch;
      319 
      320 dir_test(1):		if match_star_name_(star_names(j), starname(k).V) = 0 then go to dir_match;
      321 
      322 dir_nomatch:		end;
      323 		     end;
      324 		star_entries(i).type = NO_MATCH;	/* Flag entry as non-matching.		*/
      325 		count = count - 1;			/* Exclude it from entry count.		*/
      326 dir_test(2):
      327 dir_match:	end;
      328 
      329 	     if count = 0 then do;
      330 		code = error_table_$nomatch;
      331 		go to fatal;
      332 		end;
      333 	     end;
      334 
      335 star_test(3):
      336 	call get_node_array (count);			/* get a node array with 1 node for each matching	*/
      337 						/* entry in the directory.			*/
      338 	error = record_and_skip;			/* record any errors returned by status.	*/
      339 
      340 	stop_search = star_test_stop;
      341 	do i = star_entry_count to 1 by -1;		/* fill in nodes, one by one, most recently	*/
      342 						/*   created first.				*/
      343 	     if star_entries(i).type = NO_MATCH then go to next_entry;
      344 						/* Ignore this entry.  It didn't match.		*/
      345 						/* then discard the erring entry, and continue.	*/
      346 	     call init_node;			/* initialize this node.			*/
      347 	     call status_long ((path), star_names (star_entries(i).nindex));
      348 						/* fill status of this entry into the node.	*/
      349 
      350 	     call director_caller;			/* the director has his chance at the node now.	*/
      351 	     go to next_entry;			/* if director OKed node, then fill in next one.	*/
      352 
      353 record_and_skip:
      354 	     if Dnodes.C ^= error_table_$logical_volume_not_connected then
      355 		Dnodes.C = code;			/* remember what the last code was from status.	*/
      356 	     call lib_free_node_$descriptors (Pnode);	/* free any node descriptors.			*/
      357 	     Inode = Inode - 1;			/* reuse this node for the next entry.		*/
      358 
      359 next_entry:    end;
      360 
      361 star_test_stop:
      362 	free star_names in (area_var),		/* free name list returned by star_.		*/
      363 	     star_entries in (area_var);		/* free entry array returned by star_.		*/
      364 	Dnodes.N = Inode;				/* store count of nodes we've filled into descr.	*/
      365 	if Inode = 0 then do;			/* if no nodes were filled (because of bad status	*/
      366 	     if Dnodes.C ^= 0 then code = Dnodes.C;
      367 	     else code = error_table_$nomatch;		/* or director rejection), then tell parent node.	*/
      368 	     go to fatal;
      369 	     end;
      370 	else Dnodes.C = 0;
      371 	Pnodes = PDnodes;				/* return ptr to the node array descriptor.	*/
      372 	return;
      373 
      374 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      375 
      376 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      377 
      378 
      379 proc_node(5):					/* processing used when parent node is an archive	*/
      380 	error = terminate_arch;			/* terminate the archive if an error occurs.	*/
      381 
      382 	call lib_ptr_and_bc_ (Pparent, 0, null, Parch, bit_count, code);
      383 	if code ^= 0 then go to error;		/* get ptr to, and bit count of, parent archive.	*/
      384 	PDarch = addr (PBDarch);			/* make PBDarch point to the first archive	*/
      385 						/* descriptor (Darch) we create.		*/
      386 	PBDarch = null;				/* to start with, there are no descriptors.	*/
      387 	Nentries = 0;
      388 
      389 	call_id = "0"b;
      390 
      391 get_components:
      392 	on area go to arch_expand_area;
      393 
      394 	call archive_$list_components (Parch, bit_count, ARCHIVE_COMPONENT_INFO_VERSION_1,
      395 	     Parea, archive_component_info_ptr, n_components,
      396 	     code);
      397 
      398 	revert area;
      399 
      400 	if code ^= 0 then do;
      401 	     call terminate_archive;
      402 	     go to fatal;
      403 	     end;
      404 
      405 	do j = 1 to n_components;
      406 	     do k = 1 to starname.N;
      407 		go to arch_test(starname(k).C);
      408 
      409 arch_test(0):	if starname (k).V = archive_component_info_array (j).name then go to arch_match;
      410 		go to arch_nomatch;
      411 
      412 arch_test(1):	if match_star_name_ (archive_component_info_array (j).name, starname (k).V) = 0 then
      413 		     go to arch_match;
      414 		go to arch_nomatch;
      415 
      416 arch_test(2):
      417 arch_match:
      418 		Nnames = 1;			/* create a name descriptor; use temporarily as	*/
      419 		allocate Dnames in (area_var) set (Ptemp); /* archive component descriptor until we find out	*/
      420 		Darch.Pnext = Ptemp;
      421 		PDarch = Ptemp;			/* how many matching archive components exist.	*/
      422 		Darch.Pnext = null ();
      423 		Darch.Parch = archive_component_info_array (j).comp_ptr;
      424 		Darch.name = archive_component_info_array (j).name;
      425 		Darch.bit_count = archive_component_info_array (j).comp_bc;
      426 		clock = archive_component_info_array (j).time_modified;
      427 		Darch.dtm = substr (clock_string, 21, 36);
      428 		clock = archive_component_info_array (j).time_updated;
      429 		Darch.dtupdated = substr (clock_string, 21, 36);
      430 		Darch.Smode = substr (archive_component_info_array (j).access, 1, 3);
      431 		Nentries = Nentries + 1;
      432 		if starname.N = 1 then
      433 		     if starname (1).C = 0 then go to arch_test_done;
      434 arch_nomatch:
      435 		end;
      436 	     end;
      437 
      438 	     free archive_component_info_array in (area_var);
      439 
      440 arch_test_done:					/* if a format error occurred, or if we scanned	*/
      441 	if Nentries = 0 then do;			/* thru entire archive, or if no *'s in star name,*/
      442 	     if code = error_table_$archive_fmt_err then;	/* then if no matching components were found,	*/
      443 	     else					/* store an error code in patent node, terminate	*/
      444 		code = error_table_$nomatch;		/* the archive, and return.			*/
      445 terminate_arch:
      446 	     call terminate_archive;
      447 	     go to fatal;
      448 	     end;
      449 
      450 	stop_search = arch_test_stop;
      451 	error = director_reject;			/* errors in this section are caused by the	*/
      452 						/* director's rejection of a node.		*/
      453 	call get_node_array (Nentries);		/* get node array with 1 node for each matching	*/
      454 						/* component.				*/
      455 
      456 	if Dnodes.C ^= error_table_$logical_volume_not_connected then
      457 	     Dnodes.C = code;			/* save any archive format error.		*/
      458 	PDarch = PBDarch;				/* starting at head of descriptor chain,	*/
      459 	do i = 1 to Nentries;			/* scan thru component descriptors, filling	*/
      460 						/* in a node for each matching component.	*/
      461 	     call init_node;			/* initialize the node.			*/
      462 	     node.bit_count = Darch.bit_count;		/* store bit count from descriptor.		*/
      463 	     node.Smode = Darch.Smode;		/* store mode.				*/
      464 	     node.dtm = Darch.dtm;			/* store dtm.				*/
      465 	     node.dtem = Darch.dtupdated;		/* store dtem.				*/
      466 	     PDnames = PDarch;			/* use archive descriptor as name descriptor.	*/
      467 	     Parch = Darch.Parch;			/* but first, save ptr to archive component.	*/
      468 	     PDarch  = Darch.Pnext;			/* Also, save ptr to next descriptor.		*/
      469 	     Dnames.N = 1;				/* set number of names in descriptor to 1.	*/
      470 	     Dnames.length = size (Dnames);		/* store length of descriptor.		*/
      471 	     Dnames.version = Vnames_1;		/* and version number.			*/
      472 	     Dnames.Pnext = node.PD;			/* chain descriptor to node.			*/
      473 	     node.PD = PDnames;
      474 	     Dnames.T = Tnames;			/* specify this is a name descriptor.		*/
      475 
      476 	     node.current_length = divide (node.bit_count + Lrecord - 1, Lrecord, 35, 0);
      477 						/* compute current length (in records) from	*/
      478 						/* component's bit count.			*/
      479 	     node.offset = binary (rel (Parch), 18);
      480 						/* fill in component's offset from base of segment*/
      481 						/* containing the archive.  This works		*/
      482 						/* for archived archives, too.		*/
      483 
      484 	     node.Svalid = Svalid_archive_comp;		/* indicate which basic node fields are valid.	*/
      485 	     if Sc.check_ascii then do;		/* see if component contents is printable.	*/
      486 		call test_ascii (Parch, node.bit_count, flags.ascii);
      487 		Svalid.not_ascii = ^flags.ascii;
      488 		end;
      489 	     else do;
      490 		flags.ascii = "0"b;
      491 		end;
      492 	     flags.archive = "0"b;			/* assume component is not an archived archive.	*/
      493 	     if Sc.check_archive then
      494 	          flags.archive = test_archive (node.bit_count);
      495 	     if flags.archive then
      496 		node.T = Tarchive;
      497 	     else do;
      498 		node.T = Tarchive_comp;
      499 		if flags.ascii & Sc.check_ascii then;
      500 		else if Sc.object_info then do;	/* see if component is an object component.	*/
      501 		     flags.object_seg = object_seg_ (Parch, node.bit_count);
      502 		     if flags.object_seg then
      503 			node.Svalid = node.Svalid | Svalid_object_info;
      504 		     end;
      505 		end;
      506 	     node.Sreq = node.Svalid & Srequirements;	/* say which fields are required for output.	*/
      507 	     call director_caller;			/* let the director validate this node.		*/
      508 	     go to end_component;			/* all done for this component.		*/
      509 
      510 director_reject:					/* if director rejected this node, then		*/
      511 	     call lib_free_node_$descriptors (Pnode);	/* free node's descriptors.			*/
      512 	     Inode = Inode - 1;			/* reuse this node for next component.		*/
      513 end_component: end;
      514 
      515 arch_test_stop:
      516 	Dnodes.N = Inode;				/* record number of filled nodes in node array.	*/
      517 	call terminate_archive;			/* terminate the archive.			*/
      518 	if Inode = 0 then do;			/* if no acceptable components were found,	*/
      519 	     if code = error_table_$archive_fmt_err then;	/* set error code in a null node array descriptor.*/
      520 	     else
      521 		code = error_table_$nomatch;
      522 	     go to fatal;
      523 	     end;
      524 	Pnodes = PDnodes;				/* return ptr to the node array descriptor.	*/
      525 	return;
      526 
      527 arch_expand_area:					/* let msa_manager_ expand the area		*/
      528 	revert area;
      529 	call smart_alloc_$area_full (0, Parea, call_id);
      530 	go to get_components;
      531 
      532 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      533 
      534 
      535 fatal:						/* this is the global exit for errors which are	*/
      536 						/* fatal to the process of getting a node array.	*/
      537 	if PDnodes ^= null then do;			/* if a node array was allocated, free it.	*/
      538 	     Dnodes.N = Inode;			/* store count of number of filled node in descr.	*/
      539 	     call lib_free_node_$array (PDnodes);
      540 	     end;
      541 	call get_node_array (0);			/* get a node descriptor with zero nodes.	*/
      542 	if Dnodes.C ^= error_table_$logical_volume_not_connected then
      543 	     Dnodes.C = code;			/* fill in its error code.			*/
      544 	Pnodes = PDnodes;				/* return this error code descriptor.		*/
      545 	return;					/* You lose, buddy.  Too bad.			*/
      546 
      547 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      548 
      549 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      550 	/*									*/
      551 	/*	A  D  D  I  T  I  O  N  A  L     E  N  T  R  Y     P  O  I  N  T  S		*/
      552 	/*									*/
      553 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      554 
      555 
      556 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      557 
      558 
      559 root_array:	entry	(MNnodes, Parea, Pnodes, Acode);
      560 
      561 	call get_node_array(MNnodes);			/* get a node array of specified length.	*/
      562 	Dnodes.N = 0;				/* record current length of node array.		*/
      563 	Pnodes = PDnodes;				/* return pointer to node array.		*/
      564 	Acode = 0;
      565 	return;
      566 
      567 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      568 
      569 
      570 root_array_info:	entry	(Pnodes, MNnodes, Acode);
      571 
      572 	PDnodes = Pnodes;				/* address the specified node array.		*/
      573 	MNnodes = Dnodes.N;				/* return current dimension of array, and any	*/
      574 	Acode = Dnodes.C;				/*    error code returned while getting array.	*/
      575 	return;
      576 
      577 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      578 
      579 
      580 lib_root_node:	entry	(Proot_names, root_type, path, root_search_proc, Pstarname, Pexclude, Srequirements,
      581 			 Scontrol, Parea, director, Pdirector_args, Pnodes, MNnodes, Acode);
      582 
      583 	e = 1;
      584 	go to COMMON;
      585 
      586 
      587 root_node:	entry	(Proot_names, root_type, path, Pstarname, Pexclude, Srequirements, Scontrol,
      588 			 Parea, director, Pdirector_args, Pnodes, MNnodes, Acode);
      589 
      590 	e = 2;
      591 
      592 COMMON:	if Svalid_root = ""b then call init_Svalid();	/* initialize internal static variables.	*/
      593 	Pparent = null;				/* a root node has no parent node.		*/
      594 	PDnodes = Pnodes;				/* address the root node array.		*/
      595 	if Dnodes.N = MNnodes then do;		/* make sure array isn't full.		*/
      596 	     Acode = error_table_$out_of_bounds;
      597 	     return;
      598 	     end;
      599 	if root_type ^= Tdirectory then if root_type ^= Tarchive then do;
      600 	     Acode = error_table_$typename_not_found;
      601 	     return;
      602 	     end;
      603 
      604 	Inode = Dnodes.N;				/* address the last filled node of array.	*/
      605 	Dnodes.N = Dnodes.N + 1;			/* extend current length of array.		*/
      606 	call init_node;				/* initialize new node.			*/
      607 	link_node.T = root_type;			/* fill in root type.			*/
      608 	link_node.Svalid = Svalid_root;		/*	      valid fields.			*/
      609 	Nnames = root_names.N;			/*	      names.			*/
      610 	if Nnames > 0 then do;
      611 	     allocate Dnames in (area_var);
      612 	     Dnames.length = size (Dnames);
      613 	     Dnames.version = Vnames_1;
      614 	     Dnames.Pnext = link_node.PD;
      615 	     link_node.PD = PDnames;
      616 	     Dnames.T = Tnames;
      617 	     Dnames.names(*) = root_names.root_name(*);
      618 	     end;
      619 	else do;
      620 	     Svalid.primary_name = "0"b;
      621 	     Svalid.matching_names = "0"b;
      622 	     Svalid.names = "0"b;
      623 	     end;
      624 	link_node.link_target = path;			/* 	      path.			*/
      625 	if e = 1 then if length(root_search_proc) > 0 then do;
      626 	     allocate Dsearch_proc in (area_var);
      627 	     Dsearch_proc.length = size(Dsearch_proc);
      628 	     Dsearch_proc.version = Vsearch_proc_1;
      629 	     Dsearch_proc.Pnext = link_node.PD;
      630 	     link_node.PD = PDsearch_proc;
      631 	     Dsearch_proc.T = Tsearch_proc;
      632 	     Dsearch_proc.search_proc = root_search_proc;
      633 	     Svalid.root_search_proc = "1"b;
      634 	     end;
      635 	node.Sreq = node.Svalid & Srequirements;	/*              required fields.		*/
      636 
      637 	Acode = 0;				/* no more errors from here on can affect code.	*/
      638 	error = root_error;
      639 	stop_search = root_stop;
      640 	call director_caller;			/* search this root for entries matching starname.*/
      641 root_stop:
      642 	return;
      643 
      644 root_error:
      645 	if Dnodes.C ^= error_table_$logical_volume_not_connected then
      646 	     Dnodes.C = code;			/* remember last root error code.		*/
      647 	call lib_free_node_$descriptors (Pnode);
      648 	Dnodes.N = Dnodes.N - 1;			/* remove node from array.			*/
      649 	return;
      650 
      651 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      652 
      653 
      654 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      655 	/*									*/
      656 	/*	     I  N  T  E  R  N  A  L          P  R  O  C  E  D  U  R  E  S		*/
      657 	/*									*/
      658 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      659 
      660 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      661 
      662 
      663 cv_num:	proc (n) returns (char(32));			/* procedure to convert integer to char string.	*/
      664 
      665      dcl	n			fixed bin,	/* number to be converted. (In)		*/
      666 	char32			char(32),		/* the result.				*/
      667 	i			fixed bin,
      668 	pic			pic "zzzzzzzzzzzz9";
      669 
      670 	pic = n;
      671 	i = verify (pic, " ");
      672 	char32 = substr(pic,i);
      673 	return (char32);
      674 
      675 	end cv_num;
      676 
      677 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      678 /*  *  * 
      679* *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      680 
      681 
      682 director_caller:	procedure;			/* This internal procedure is called in order to	*/
      683 						/* have the director validate each node after it	*/
      684 						/* has been filled, but before the next node	*/
      685 						/* in the array is filled.  If the director	*/
      686 						/* rejects the node, then this procedure	*/
      687 						/* branches to the caller's error handler.	*/
      688 
      689 	code = 0;					/* initialize search director's return code 	*/
      690 	PD = null;				/* and output node ptr.			*/
      691 	if node.Pparent = null then			/* for a root node, pass the root path, tree level*/
      692 						/* 1, link level 0.				*/
      693 	     call director (Pnode, link_node.link_target, Pstarname, Pexclude, Srequirements, Scontrol, 1, 0, 
      694 			Parea, director, Pdirector_args, PD, code);
      695 	else if node.T = Tlink then			/* for the first link in a chain, pass the link 	*/
      696 	     if link_level = 0 then			/* path and increment both tree and link level.	*/
      697 		call director (Pnode, link_node.link_target, Pstarname, Pexclude, Srequirements, Scontrol,
      698 			     tree_level+1, link_level+1, Parea, director, Pdirector_args, PD, code);
      699 	     else					/* for succeeding links in a chain, pass the link	*/
      700 						/* path and increment just the link level.	*/
      701 		call director (Pnode, link_node.link_target, Pstarname, Pexclude, Srequirements, Scontrol,
      702 			     tree_level, link_level+1, Parea, director, Pdirector_args, PD, code);
      703 	else if link_level > 0 then			/* for the target of a link, pass on the target	*/
      704 						/* path, zero the link level, and pass on the	*/
      705 						/* current tree level.			*/
      706 	     call director (Pnode, path, Pstarname, Pexclude, Srequirements, Scontrol,
      707 			tree_level, 0, Parea, director, Pdirector_args, PD, code);
      708 	else do;					/* otherwise, compute path by adding node's 1st	*/
      709 						/* name to path we rec'd as input, increment	*/
      710 						/* the tree level, and zero the link level.	*/
      711 	     j = min(32, 33-verify(reverse(Dnames.names(1)), " "));
      712 	     if path = ">" then
      713 		call director (Pnode, path || substr (Dnames.names(1), 1, j), Pstarname, Pexclude,
      714 			     Srequirements, Scontrol, tree_level+1, 0, Parea, director, Pdirector_args, PD, code);
      715 	     else call director (Pnode, path || ">" || substr (Dnames.names(1), 1, j), Pstarname, Pexclude,
      716 			     Srequirements, Scontrol, tree_level+1, 0, Parea, director, Pdirector_args, PD, code);
      717 	     end;
      718 
      719 	if PD ^= null then do;			/* if the director created a node descriptor,	*/
      720 	     D.Pnext = node.PD;			/* attach it to the node.			*/
      721 	     node.PD = PD;
      722 	     Svalid.kids = "1"b;
      723 	     if PD -> Dnodes.C ^= 0 then do;		/* validate the error code, if there was one.	*/
      724 		Svalid.kids_error = "1"b;
      725 		Sreq.kids_error = S.kids_error;
      726 		Sreq.primary_name = Sreq.primary_name | S.kids_error;
      727 		end;
      728 	     end;
      729 	if code = error_table_$process_stopped then
      730 	     go to stop_search;
      731 	else if code ^= 0 then			/* if the director rejected the node for any	*/
      732 	     go to error;				/* reason, then go to the caller's error handler.	*/
      733 
      734 	end director_caller;
      735 
      736 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      737 
      738 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      739 
      740 
      741 get_acl:		procedure (dir, ent);		/* Internal procedure called to get ACL for a	*/
      742 						/* segment, and store it in a segment ACL	*/
      743 						/* descriptor.				*/
      744      dcl	dir			char(*),		/* dir part of segment's path name. (In)	*/
      745 	ent			char(*);		/* ent part of segment's path name. (In)	*/
      746 
      747 	call_id = "0"b;				/* initialize id used for smart_alloc_.		*/
      748 acl_again:
      749 	call hcs_$list_acl (dir, ent, Parea, Pacl, null, Nacls, code);
      750 	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another one.	*/
      751 	     call smart_alloc_$area_full (0, Parea, call_id);
      752 	     go to acl_again;
      753 	     end;
      754 	else if code ^= 0 then Nacls = 0;		/* fake it if there is no ACL.		*/
      755 						/* if no trouble getting ACL, get access class.	*/
      756 	allocate Dacl in (area_var);
      757 	Dacl.length = size(Dacl);
      758 	Dacl.version = Vacl_1;
      759 	Dacl.Pnext = node.PD;			/* chain ACL descriptor to the node.		*/
      760 	node.PD = PDacl;
      761 	Dacl.T = Tacl;
      762 	Dacl.C = code;
      763 	Dacl.N = Nacls;
      764 	if Dacl.N > 0 then Dacl.acls = acl;		/* copy ACL into descriptor.			*/
      765 
      766 	end get_acl;
      767 
      768 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      769 
      770 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      771 
      772 get_dir_acl:	procedure (dir, ent);		/* Internal procedure to get ACL for a directory	*/
      773 						/* and store it in a directory ACL descriptor.	*/
      774      dcl	dir			char(*),		/* dir part of directory's path name. (In)	*/
      775 	ent			char(*);		/* ent part of directory's path name. (In)	*/
      776 
      777 	call_id = "0"b;				/* initialize id used for smart_alloc_.		*/
      778 dir_acl_again:
      779 	call hcs_$list_dir_acl (dir, ent, Parea, Pdir_acl, null, Ndir_acls, code);
      780 	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another one.	*/
      781 	     call smart_alloc_$area_full (0, Parea, call_id);
      782 	     go to dir_acl_again;
      783 	     end;
      784 	else if code ^= 0 then Ndir_acls = 0;		/* fake it if there is no ACL.		*/
      785 						/* if no trouble getting ACL, get access class.	*/
      786 	allocate Ddir_acl in (area_var);
      787 	Ddir_acl.length = size(Ddir_acl);
      788 	Ddir_acl.version = Vdir_acl_1;
      789 	Ddir_acl.Pnext = node.PD;			/* chain descriptor onto node.		*/
      790 	node.PD = PDdir_acl;
      791 	Ddir_acl.T = Tdir_acl;
      792 	Ddir_acl.C = code;
      793 	Ddir_acl.N = Ndir_acls;
      794 	if Ddir_acl.N > 0 then Ddir_acl.acls = dir_acl;	/* copy ACL into descriptor.			*/
      795 
      796 	end get_dir_acl;
      797 
      798 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      799 
      800 
      801 get_iacls:	procedure (dir, ent);		/* Internal procedure to get all IACLs for a	*/
      802 						/* directory and store them in an IACL descriptor.*/
      803      dcl	dir			char(*),		/* dir part of directory's path name. (In)	*/
      804 	ent			char(*),		/* ent part of directory's path name. (In)	*/
      805 	i			fixed bin,	/* a do-group index.			*/
      806 	path			char(168);	/* directory's path name.			*/
      807 
      808 	path = dir || ">" || ent;
      809 	call_id = "0"b;				/* initialize id used for smart_alloc_.		*/
      810 iacl_again:
      811 	call hcs_$list_inacl_all (path, Parea, Piacl, addr(iacl_info), code);
      812 	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another one.	*/
      813 	     call smart_alloc_$area_full (0, Parea, call_id);
      814 	     go to iacl_again;
      815 	     end;
      816 	else if code ^= 0 then			/* fake it if a fatal error occurred.		*/
      817 	     do i = 0 to 7;
      818 		iacl_info.seg.counts(i) = 0;
      819 		iacl_info.dir.counts(i) = 0;
      820 		end;
      821 	Niacls, Ndir_iacls = 0;
      822 	do i = 0 to 7;				/* add up counts of IACL entries.		*/
      823 	     Niacls = Niacls + iacl_info.seg.counts(i);
      824 	     Ndir_iacls = Ndir_iacls + iacl_info.dir.counts(i);
      825 	     end;
      826 
      827 	allocate Diacl in (area_var);			/* fill in the segment IACL descriptor.		*/
      828 	Diacl.length = size(Diacl);
      829 	Diacl.version = Viacl_1;
      830 	Diacl.Pnext = node.PD;			/* chain descriptor onto node.		*/
      831 	node.PD = PDiacl;
      832 	Diacl.T = Tiacl;
      833 	Diacl.C = code;
      834 	Diacl.N = Niacls;
      835 	Diacl.N = 1;				/* copy IACLs into descriptor.		*/
      836 	do i = 0 to 7;
      837 	     Diacl.Iring(i) = Diacl.N;
      838 	     Diacl.Nring(i) = iacl_info.seg.counts(i);
      839 	     if iacl_info.seg.counts(i) > 0 then do;
      840 		Pacl = addrel(Piacl, iacl_info.seg.offsets(i));
      841 		Nacls = iacl_info.seg.counts(i);
      842 		addr(Diacl.acls(Diacl.N)) -> acl = acl;
      843 		Diacl.N = Diacl.N + Nacls;
      844 		end;
      845 	     end;
      846 	Diacl.N = Diacl.N - 1;
      847 	allocate Ddir_iacl in (area_var);			/* fill in the directory IACL descriptor.	*/
      848 	Ddir_iacl.length = size(Ddir_iacl);
      849 	Ddir_iacl.version = Vdir_iacl_1;
      850 	Ddir_iacl.Pnext = node.PD;			/* chain descriptor onto node.		*/
      851 	node.PD = PDdir_iacl;
      852 	Ddir_iacl.T = Tdir_iacl;
      853 	Ddir_iacl.C = code;
      854 	Ddir_iacl.N = Ndir_iacls;
      855 	Ddir_iacl.N = 1;				/* copy IACLs into descriptor.		*/
      856 	do i = 0 to 7;
      857 	     Ddir_iacl.Iring(i) = Ddir_iacl.N;
      858 	     Ddir_iacl.Nring(i) = iacl_info.dir.counts(i);
      859 	     if iacl_info.dir.counts(i) > 0 then do;
      860 		Pdir_acl = addrel(Piacl, iacl_info.dir.offsets(i));
      861 		Ndir_acls = iacl_info.dir.counts(i);
      862 		addr(Ddir_iacl.acls(Ddir_iacl.N)) -> dir_acl = dir_acl;
      863 		Ddir_iacl.N = Ddir_iacl.N + Ndir_acls;
      864 		end;
      865 	     end;
      866 	Ddir_iacl.N = Ddir_iacl.N - 1;
      867 
      868 	end get_iacls;
      869 
      870 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      871 
      872 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      873 
      874 
      875 get_msf_acl:	procedure (dir, ent);		/* Internal procedure to get ACL for an MSF,	*/
      876 						/* and store it in a segment ACL descriptor.	*/
      877      dcl	dir			char(*),		/* dir part of MSF's path name. (In)		*/
      878 	ent			char(*);		/* ent part of MSF's path name. (In)		*/
      879 
      880 	call msf_manager_$open (dir, ent, Ptemp, code);	/* open the MSF.				*/
      881 	if code = 0 then do;
      882 	     call_id = "0"b;			/* initialize id used for smart_alloc_.		*/
      883 msf_acl_again: call msf_manager_$acl_list (Ptemp, Parea, Pacl, null, Nacls, code);
      884 	     if code = error_table_$noalloc then do;	/* if our SSA of MSA is full, get another one.	*/
      885 		call smart_alloc_$area_full (0, Parea, call_id);
      886 		go to msf_acl_again;
      887 		end;
      888 	     end;
      889 	if code ^= 0 then Nacls = 0;			/* fake it if there is no ACL.		*/
      890 						/* if no trouble getting ACL, get access class.	*/
      891 	allocate Dacl in (area_var);
      892 	Dacl.length = size(Dacl);
      893 	Dacl.version = Vacl_1;
      894 	Dacl.Pnext = node.PD;			/* chain descriptor onto the node.		*/
      895 	node.PD = PDacl;
      896 	Dacl.T = Tacl;
      897 	Dacl.C = code;
      898 	Dacl.N = Nacls;
      899 	if Dacl.N > 0 then Dacl.acls = acl;		/* copy ACL into descriptor.			*/
      900 	call msf_manager_$close (Ptemp);		/* close the MSF.				*/
      901 
      902 	end get_msf_acl;
      903 
      904 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      905 
      906 
      907 get_node_array:	procedure (N);			/* This internal procedure allocates a node array	*/
      908 						/* and initializes its header.		*/
      909 
      910      dcl	N			fixed bin;	/* Number of nodes to be allocated in the array.	*/
      911 
      912 	Nnodes = N;				/* set variable which controls number of nodes	*/
      913 						/* which get allocated in our adjustable based	*/
      914 						/* array.					*/
      915 	allocate Dnodes in (area_var);		/* allocate the node array descriptor.		*/
      916 	Dnodes.length = size (Dnodes);		/* fill in its size,			*/
      917 	Dnodes.version = Vnodes_1;			/*	     version,			*/
      918 	Dnodes.Pnext = null;			/*	     next descriptor ptr, and		*/
      919 	Dnodes.header.T = Tnodes;			/*	     type.			*/
      920 	Dnodes.C = 0;				/* clear its error code.			*/
      921 
      922 	Inode = 0;				/* initialize number of filled nodes to zero.	*/
      923 
      924 	end get_node_array;
      925 
      926 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      927 
      928 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      929 
      930 
      931 init_Svalid:	procedure;			/* Internal procedure which initializes the 	*/
      932 						/* internal static constants defining which of	*/
      933 						/* the basic node fields are valid for each type	*/
      934      dcl	Srequirements		bit(72) aligned,	/* of node.				*/
      935 	1 S			like Svalid_req based (addr(Srequirements));
      936 
      937 	string(S) = ""b;
      938 	S.primary_name = "1"b;
      939 	S.matching_names = "1"b;
      940 	S.names = "1"b;
      941 	S.type = "1"b;
      942 	S.pathname = "1"b;
      943 	S.dtem = "1"b;
      944 	S.dtd = "1"b;
      945 	S.link_target = "1"b;
      946 	S.new_line = "1"b;
      947 	S.level = "1"b;
      948 	S.cross_ref = "1"b;
      949 	Svalid_link = Srequirements;
      950 
      951 	string(S) = ""b;
      952  	S.primary_name = "1"b;
      953 	S.matching_names = "1"b;
      954 	S.names = "1"b;
      955 	S.type = "1"b;
      956 	S.pathname = "1"b;
      957 	S.dtm = "1"b;
      958 	S.dtu = "1"b;
      959 	S.dtem = "1"b;
      960 	S.dtd = "1"b;
      961 	S.current_length = "1"b;
      962 	S.records_used = "1"b;
      963 	S.bit_count = "1"b;
      964 	S.max_length = "1"b;
      965 	S.lvid = "1"b;
      966 	S.mode = "1"b;
      967 	S.rb = "1"b;
      968 	S.copy = "1"b;
      969 	S.safety = "1"b;
      970 	S.unique_id = "1"b;
      971 	S.new_line = "1"b;
      972 	S.level = "1"b;
      973 	S.cross_ref = "1"b;
      974 	Svalid_segment = Srequirements;
      975 	Svalid_msf_comp = Srequirements;
      976 	Svalid_archive = Srequirements;
      977 	S.max_length = "0"b;
      978 	S.copy = "0"b;
      979 	S.msf_indicator = "1"b;
      980 	Svalid_msf = Srequirements;
      981 	S.bit_count = "0"b;
      982 	S.msf_indicator = "0"b;
      983 	Svalid_directory = Srequirements;
      984 
      985 	string(S) = ""b;
      986 	S.dtc = "1"b;
      987 	S.compiler_name = "1"b;
      988 	S.compiler_version = "1"b;
      989 	S.compiler_options = "1"b;
      990 	S.object_info = "1"b;
      991 	Svalid_object_info = Srequirements;
      992 
      993 	string(S) = ""b;
      994 	S.primary_name = "1"b;
      995 	S.matching_names = "1"b;
      996 	S.names = "1"b;
      997 	S.type = "1"b;
      998 	S.pathname = "1"b;
      999 	S.dtm = "1"b;
     1000 	S.dtem = "1"b;
     1001 	S.current_length = "1"b;
     1002 	S.bit_count = "1"b;
     1003 	S.offset = "1"b;
     1004 	S.mode = "1"b;
     1005 	S.new_line = "1"b;
     1006 	S.level = "1"b;
     1007 	S.cross_ref = "1"b;
     1008 	Svalid_archive_comp = Srequirements;
     1009 
     1010 	string(S) = ""b;
     1011 	S.primary_name = "1"b;
     1012 	S.matching_names = "1"b;
     1013 	S.names = "1"b;
     1014 	S.type = "1"b;
     1015 	S.pathname = "1"b;
     1016 	S.new_line = "1"b;
     1017 	S.level = "1"b;
     1018 	S.cross_ref = "1"b;
     1019 	Svalid_root = Srequirements;
     1020 
     1021 	string(S) = ""b;
     1022 	S.access_class = "1"b;
     1023 	S.aim = "1"b;
     1024 	S.author = "1"b;
     1025 	S.bit_count_author = "1"b;
     1026 	S.entry_bound = "1"b;
     1027 	S.pvid = "1"b;
     1028 	Svalid_added_status = Srequirements;
     1029 
     1030 	end init_Svalid;
     1031 
     1032 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1033 
     1034 
     1035 init_node:	procedure;			/* This internal procedure initializes a node.	*/
     1036 
     1037 	Inode = Inode + 1;				/* increment the filled node count to get the next*/
     1038 						/* available node.				*/
     1039 	Pnode = addr (Dnodes.nodes (Inode));		/* access the node.				*/
     1040 	node_string = ""b;				/* zero out storage occupied by node.		*/
     1041 	node.Pparent = Pparent;
     1042 	node.PD = null;				/* initialize the node's pointers.		*/
     1043 
     1044 	end init_node;
     1045 
     1046 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1047 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1048 
     1049 
     1050 object_seg_:	procedure (Pseg, bit_count)		/* This internal procedure checks to see if a	*/
     1051 		returns	(bit(1) aligned);		/* segment is an object segment and, if so, it	*/
     1052 						/* appends an object_info_ descriptor to the node	*/
     1053 						/* which represents the segment.		*/
     1054 
     1055      dcl	Pseg			ptr,		/* ptr to the segment.			*/
     1056 	bit_count			fixed bin(35);	/* bit count of the segment.			*/
     1057 						/* overlay for object segment strings.		*/
     1058 
     1059 	oi.version_number = object_info_version_2;	/* initialize the object_info_ structure.	*/
     1060 	call object_info_$display (Pseg, binary(bit_count, 24), addr(oi), code);
     1061 	if code ^= 0 then				/* let object_info_ decide if this is an obj seg.	*/
     1062 	     return ("0"b);
     1063 	allocate Dobj in (area_var);			/* create an object_info_ descriptor.		*/
     1064 	Dobj.version = Vobj_1;			/* initialize its header.			*/
     1065 	Dobj.length = size (Dobj);
     1066 	Dobj.T = Tobj;
     1067 	Dobj.Pnext = node.PD;
     1068 	node.PD = PDobj;
     1069 
     1070 
     1071 	Dobj.info.Otext = binary (rel (oi.textp), 18);	/* fill in the structure, converting pointers	*/
     1072 	Dobj.info.Odefinitions = binary (rel (oi.defp),18);/* to offsets.				*/
     1073 	Dobj.info.Olink = binary (rel (oi.linkp), 18);
     1074 	Dobj.info.Ostatic = binary (rel (oi.statp), 18);
     1075 	Dobj.info.Osymbols = binary (rel (oi.symbp), 18);
     1076 	Dobj.info.Obreaks = binary (rel (oi.bmapp), 18);
     1077 	Dobj.info.Ltext = oi.tlng;
     1078 	Dobj.info.Ldefinitions = oi.dlng;
     1079 	Dobj.info.Llink = oi.llng;
     1080 	Dobj.info.Lstatic = oi.ilng;
     1081 	Dobj.info.Lsymbols = oi.slng;
     1082 	Dobj.info.Lbreaks = oi.blng;
     1083 	string (Dobj.info.format) = string (oi.format);
     1084 	Dobj.info.entry_bound = oi.entry_bound;
     1085 	Dobj.info.Otext_links = binary (rel (oi.textlinkp), 18);
     1086 	Dobj.info.compiler = oi.compiler;
     1087 	Dobj.info.compile_time = oi.compile_time;
     1088 	Dobj.info.userid = oi.userid;
     1089 	Dobj.info.cversion.O = Dobj.info.Osymbols +  binary (oi.cvers.offset, 18);
     1090 	Dobj.info.cversion.L = binary (oi.cvers.length, 18);
     1091 	Dobj.info.comment.O = Dobj.info.Osymbols + binary (oi.comment.offset, 18);
     1092 	Dobj.info.comment.L = binary (oi.comment.length, 18);
     1093 	Dobj.info.Osource = Dobj.info.Osymbols + oi.source_map;
     1094 	Pstring_ = pointer (Pseg, Dobj.info.cversion.O);
     1095 	Lstring_ = Dobj.info.cversion.L;
     1096 	Dobj.cversion = string_;
     1097 	Pstring_ = pointer (Pseg, Dobj.info.comment.O);
     1098 	Lstring_ = Dobj.info.comment.L;
     1099 	Dobj.comment = string_;
     1100 
     1101 	return ("1"b);
     1102 
     1103 	end object_seg_;
     1104 
     1105 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1106 
     1107 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1108 
     1109 status_long:	procedure (dir, ent);		/* This procedure calls hcs_$status_long to get	*/
     1110 						/* status information for dir>ent, and fills this	*/
     1111 						/* information in the node.			*/
     1112 
     1113      dcl	dir			char(*),		/* dir part of path of entry to get status of.(In)*/
     1114 	ent			char(*);		/* ent path of path of entry to get status of.(In)*/
     1115 
     1116      dcl	i			fixed bin;	/* do-group index.				*/
     1117 
     1118 	call_id = "0"b;				/* initialize call id so that it will be set on	*/
     1119 						/* our first call to smart_alloc_$area_full.	*/
     1120 	status_ptr = addr (auto_status_branch);
     1121 call_again:
     1122 	status_area_ptr = Parea;
     1123 	call hcs_$status_long (dir, ent, Schase_links, addr (status_branch),
     1124 	   Parea, code);
     1125 	if code = error_table_$noalloc then do;		/* if our SSA of MSA was full, get another SSA by	*/
     1126 						/* calling smart_alloc_$area_full.		*/
     1127 	     call smart_alloc_$area_full (0, Parea, call_id);
     1128 	     go to call_again;			/* try getting status info again.		*/
     1129 	     end;
     1130 	else if code ^= 0 then			/* return to caller's error handler for any other	*/
     1131 	     go to error;				/* error.					*/
     1132 
     1133 	Nnames = status_branch.nnames;		/* compute number of names.			*/
     1134 	allocate Dnames in (area_var);		/* store them in a name descriptor, attached to	*/
     1135 	Dnames.length = size (Dnames);		/* the node.				*/
     1136 	Dnames.version = Vnames_1;
     1137 	Dnames.T = Tnames;
     1138 	addr(Dnames.names)->status_entry_names = status_entry_names;
     1139 	free status_entry_names in (area_var);		/* copy names into the descriptor.		*/
     1140 
     1141 	go to type (status_branch.type);		/* do rest of processing according to type of 	*/
     1142 						/* entry we got the status of.		*/
     1143 
     1144 type(0):	link_node.T = Tlink;			/* this is a link!				*/
     1145 	link_node.link_target = status_pathname;
     1146 	free status_pathname in (area_var);		/* free the link path name status returned.	*/
     1147 	link_node.dtem = status_link.dtem;		/* fill in the dates.			*/
     1148 	link_node.dtd = status_link.dtd;
     1149 	link_node.Svalid = Svalid_link;		/* record which attributes of link_node are valid.*/
     1150 	if Sc.all_status then do;
     1151 	     call hcs_$get_author (dir, ent, 0, author, 0);
     1152 	     link_node.author = rtrim(author);
     1153 	     Svalid.author = "1"b;
     1154 	     end;
     1155 	link_node.Sreq = link_node.Svalid & Srequirements;/* record which are required for output.	*/
     1156 	Dnames.Pnext = node.PD;			/* make name descriptor first in the chain of	*/
     1157 	node.PD = PDnames;				/*   descriptors off node.  It's referenced most.	*/
     1158 	return;					/* not much processing for a link node.		*/
     1159 
     1160 type(1):						/* this is a segment!			*/
     1161 	node.Smode = substr (status_branch.mode, 2, 3);	/* map "xrewx" into "rew".			*/
     1162 	node.rb = status_branch.ring_brackets;		/* copy ring brackets into node.		*/
     1163 	node.records_used = status_branch.records_used;
     1164 	node.current_length = status_branch.current_length;
     1165 						/* copy the current length.			*/
     1166 	node.bit_count = status_branch.bit_count;	/* copy the bit count.			*/
     1167 	call hcs_$get_max_length (dir, ent, node.max_length, code);
     1168 
     1169 	call test_segment (dir, ent, flags);		/* find out about segment.			*/
     1170 	if Pparent -> node.T = Tmsf then do;		/* is it an msf component?			*/
     1171 	     node.T = Tmsf_comp;			/* yes.					*/
     1172 	     node.Svalid = Svalid_msf_comp;
     1173 	     if flags.archive then			/* MSF component is also an archive. Hum!	*/
     1174 		go to process_archive;
     1175 	     else 				/* process flags further, and set requirements	*/
     1176 		go to process_segment;		/* switches in node.			*/
     1177 	     end;
     1178 	else if flags.archive then do;		/* is it an archive?			*/
     1179 	     node.Svalid = Svalid_archive;
     1180 process_archive:
     1181 	     node.T = Tarchive;
     1182 	     Svalid.not_ascii = ^flags.ascii;
     1183 	     end;
     1184 	else do;	 				/* otherwise, it's just a plain segment.	*/
     1185 	     node.T = Tsegment;
     1186 	     node.Svalid = Svalid_segment;
     1187 process_segment:
     1188 	     if flags.object_seg then			/* if an object segment, say so.		*/
     1189 		node.Svalid = node.Svalid | Svalid_object_info;
     1190 	     Svalid.not_ascii = ^flags.ascii;		/* say whether segment is printable or not.	*/
     1191 	     end;
     1192 	if Sc.acl & (node.T ^= Tmsf_comp) then do;	/* get ACL for segment or archive.		*/
     1193 	     call get_acl (dir, ent);			/*   This call automatically chains ACL to node.	*/
     1194 	     Svalid.acl = "1"b;
     1195 	     end;
     1196 	go to fill_node;				/* fill remainder of node from status block.	*/
     1197 
     1198 type(2):						/* this is a directory!			*/
     1199 	node.records_used = status_branch.records_used;
     1200 	node.current_length = status_branch.current_length;
     1201 	if status_branch.bit_count = 0 then do;		/* is it a directory?			*/
     1202 	     node.T = Tdirectory;			/*  yes, it is.				*/
     1203 	     node.Svalid = Svalid_directory;
     1204 	     substr (node.Smode, 1, 1) = substr (status_branch.mode, 2, 1);
     1205 	     substr (node.Smode, 2, 2) = substr (status_branch.mode, 4, 2);
     1206 						/* map "xsxma" into "sma".			*/
     1207 	     node.rb = status_branch.ring_brackets;
     1208 	     if Sc.acl then do;			/* get acl of directory.			*/
     1209 		call get_dir_acl (dir, ent);		/*   This call automatically chains ACL to node.	*/
     1210 		Svalid.acl = "1"b;
     1211 		end;
     1212 	     if Sc.iacl then do;			/* get initial ACLs associated with directory.	*/
     1213 		call get_iacls (dir, ent);		/*   This call automatically chains IACLs to node.*/
     1214 		Svalid.iacl = "1"b;
     1215 		end;
     1216 	     end;
     1217 	else do;					/* is it an MSF?				*/
     1218 	     node.T = Tmsf;				/* yes, it is.				*/
     1219 	     node.Svalid = Svalid_msf;
     1220 	     substr (node.Smode, 1, 1) = substr (status_branch.mode, 2, 1);
     1221 	     substr (node.Smode, 2, 1) = "0"b;		/* map "xsxmx" dir mode into "rxw" seg mode.	*/
     1222 	     substr (node.Smode, 3, 1) = substr (status_branch.mode, 4, 1);
     1223 	     node.rb(1) = status_branch.ring_brackets(1);
     1224 	     node.rb(2) = status_branch.ring_brackets(2);
     1225 	     node.rb(3) = status_branch.ring_brackets(2); /* map dir rb's into seg rb's.		*/
     1226 	     node.msf_indicator = status_branch.bit_count;
     1227 	     if dir = ">" then
     1228 		msf_dir = dir || ent;
     1229 	     else msf_dir = dir || ">" || ent;
     1230 	     do i = 0  to  node.msf_indicator - 1;	/* get aggregate records_used, current_length,	*/
     1231 		char32 = cv_num(i);			/*  and bit_count for MSF dir and components.	*/
     1232 		call hcs_$status_long (msf_dir, char32, 1, addr(msf_comp), null, code);
     1233 		if code = 0 then do;
     1234 		     node.records_used = node.records_used + msf_comp.records_used;
     1235 		     node.current_length = node.current_length + msf_comp.current_length;
     1236 		     node.bit_count = node.bit_count + msf_comp.bit_count;
     1237 		     end;
     1238 		end;
     1239 	     if Sc.acl then do;			/* get acl of MSF.				*/
     1240 		call get_msf_acl (dir, ent);		/*   This call automatically chains ACL to node.	*/
     1241 		Svalid.acl = "1"b;
     1242 		end;
     1243 	     end;
     1244 	if Sc.quota then do;			/* get quota information for MSFs and directories.*/
     1245 	     call hcs_$quota_read (dir||">"||ent, node.segment.quota, node.segment.trp,
     1246 		node.segment.dttrp, node.segment.Ninf_quota,
     1247 		Nterminal_account, node.segment.quota_used, code);
     1248 	     if code ^= 0 then go to error;
     1249 	     if Nterminal_account > 0 then node.Sterminal_account = "1"b;
     1250 	     call hcs_$dir_quota_read (dir||">"||ent, node.directory.quota, node.directory.trp,
     1251 		node.directory.dttrp, node.directory.Ninf_quota,
     1252 		Nterminal_account, node.directory.quota_used, code);
     1253 	     if code ^= 0 then go to error;
     1254 	     if Nterminal_account > 0 then node.Sterminal_account_dir = "1"b;
     1255 	     Svalid.quota = "1"b;
     1256 	     end;
     1257 
     1258 fill_node:					/* fill in node values from entry status.	*/
     1259 	node.Scopy = status_branch.copy_switch;
     1260 	node.Stpd = status_branch.tpd_switch;		/* NEED TO ADD SUPPORT FOR OTHER SWITCHES.	*/
     1261 	call hcs_$get_safety_sw (dir, ent, node.Ssafety, code);
     1262 	node.unique_id = status_branch.uid;
     1263 	node.lvid = status_branch.lvid;
     1264 	node.dtem = status_branch.dtem;
     1265 	node.dtd = status_branch.dtd;
     1266 	node.dtm = status_branch.dtcm;
     1267 	node.dtu = status_branch.dtu;
     1268 	if Sc.all_status then do;			/* get additional information about branches.	*/
     1269 	     sfb.version = status_for_backup_version_2;
     1270 	     call hcs_$status_for_backup (dir, ent, addr(sfb), code);
     1271 	     if code ^= 0 then go to error;
     1272 	     node.Smaster_dir = sfb.master_dir;
     1273 	     node.Saim_security_oos = sfb.security_oosw;
     1274 	     node.Saim_audit = sfb.audit_flag;
     1275 	     node.Saim_multiple_class = sfb.multiple_class;
     1276 	     i = min (32, 33-verify(reverse(sfb.author)," "));
     1277 	     node.author = substr(sfb.author,1,i);
     1278 	     node.access_class = sfb.access_class;
     1279 	     i = min (32, 33-verify(reverse(sfb.bc_author), " "));
     1280 	     node.bit_count_author = substr(sfb.bc_author,1,i);
     1281 	     node.entry_bound = binary (sfb.entrypt_bound,14);
     1282 	     node.pvid = sfb.pvid;
     1283 	     node.Svalid = node.Svalid | Svalid_added_status;
     1284 	     if ^sfb.entrypt then do;
     1285 		node.entry_bound = 0;
     1286 		Svalid.entry_bound = "0"b;
     1287 		end;
     1288 	     end;
     1289 	Dnames.Pnext = node.PD;			/* make name descriptor first in the chain of	*/
     1290 	node.PD = PDnames;				/*   descriptors off node.  It's referenced most.	*/
     1291 	node.Sreq = node.Svalid & Srequirements;
     1292 
     1293 	end status_long;
     1294 
     1295 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1296 
     1297 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1298 
     1299 
     1300 terminate_archive:	procedure;			/* This internal procedure terminates an archive	*/
     1301 						/* if one has been initiated.			*/
     1302      dcl	code			fixed bin(35);	/* a dummy status code.			*/
     1303 
     1304 	if Parch ^= null then do;
     1305 	     call hcs_$terminate_noname (Parch, code);
     1306 	     Parch = null;
     1307 	     end;
     1308 
     1309 	end terminate_archive;
     1310 
     1311 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1312 
     1313 
     1314 test_archive:	procedure (bit_count)		/* This internal procedure determines if a segment*/
     1315 		returns (bit(1) aligned);		/* is an archive.				*/
     1316      dcl	bit_count			fixed bin(35);
     1317 
     1318 	if bit_count >= 900 then
     1319 	     if arch.header_begin = archive_data_$header_begin then
     1320 		if arch.header_end = archive_data_$header_end then
     1321 		     return ("1"b);
     1322 		else;
     1323 	    else if arch.header_begin = archive_data_$ident then
     1324 		return ("1"b);
     1325 	return ("0"b);
     1326 
     1327 	end test_archive;
     1328 
     1329 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1330 
     1331 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1332 
     1333 
     1334 test_ascii:	procedure (Pseg, bit_count, Sascii);	/* This internal procedure checks the contents of	*/
     1335 						/* a segment to see if it is completely ascii	*/
     1336      dcl	Pseg			ptr,		/* ptr to base of segment.(In)		*/
     1337 	bit_count			fixed bin(35),	/* segment's bit count.(In)			*/
     1338 	Sascii			bit(1) aligned;	/* on, if ascii segment. (Out)		*/
     1339      dcl	Inon_ascii		fixed bin(21);	/* index of first non-ascii character of segment.	*/
     1340 
     1341 	if bit_count = 0 then go to not_ascii;
     1342 	if mod (bit_count, 9) ^= 0 then do;		/* segment can't contain chars if bit count bad.	*/
     1343 not_ascii:     Sascii = "0"b;
     1344 	     return;
     1345 	     end;
     1346 	Pstring_ = Pseg;				/* overlay segment with character string.	*/
     1347 	Lstring_ = divide (bit_count, 9, 24, 0);	/* compute character length of segment.		*/
     1348 	Inon_ascii = find_char_$first_in_table (string_, find_char_$not_ascii_table);
     1349 						/* search for a non-ascii character in the string.*/
     1350 	if Inon_ascii = 0 then			/* if none found, its an ascii segment.		*/
     1351 	     Sascii = "1"b;
     1352 	else Sascii = "0"b;
     1353 
     1354 	end test_ascii;
     1355 
     1356 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1357 
     1358 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1359 
     1360 
     1361 test_segment:	procedure (dir, ent, flags);		/* This internal procedure examines a segment to	*/
     1362 						/* determine if it is an archive or an object 	*/
     1363 						/* segment.				*/
     1364      dcl (dir, ent)			char(*),		/* dir/ent of segment to be tested.		*/
     1365 	1 flags			aligned,
     1366 	  2 archive		bit(1),		/* segment is an archive.			*/
     1367 	  2 object_seg		bit(1),		/* segment is an object segment.		*/
     1368 	  2 ascii			bit(1);		/* segment is composed only of ascii characters.	*/
     1369 
     1370 	flags.archive = "0"b;			/* initialize output flags.			*/
     1371 	flags.object_seg = "0"b;
     1372 	flags.ascii = "1"b;				/* assume segment is ascii until check made.	*/
     1373 	if node.rb(2) < ring then;			/* if segment is readable from our ring,	*/
     1374 	else if ^substr(node.Smode,1,1) then;
     1375 	else if node.bit_count <= 0 then; 		/* and it has a non-zero bit count, 		*/
     1376 	else if divide(node.bit_count + Lrecord - 1, Lrecord, 35, 0) > node.current_length then;
     1377 	else if (Sc.check_archive & node.bit_count >= 900) | Sc.check_ascii | Sc.object_info then do;
     1378 						/* if caller requests archive/ascii/object info,	*/
     1379 	     call hcs_$initiate (dir, ent, "", 0, 0, Parch, code);
     1380 	     if Parch = null then return;		/* initiate the segment.			*/
     1381 	     if Sc.check_ascii then			/* check for ascii segments.			*/
     1382 		call test_ascii (Parch, node.bit_count, flags.ascii);
     1383 	     if Sc.check_archive then			/* check for archives.			*/
     1384 		flags.archive = test_archive (node.bit_count);
     1385 	     if flags.archive then;
     1386 	     else if flags.ascii & Sc.check_ascii then;
     1387 	     else if Sc.object_info then		/* check for object segment.			*/
     1388 		flags.object_seg = object_seg_ (Parch, node.bit_count);
     1389 	     call terminate_archive;			/* terminate the segment.			*/
     1390 	     end;
     1391 
     1392 	end test_segment;
     1393 
     1394 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1395 
     1396 
  3     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  3     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  3     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  3    10 	/* called the node target.							*/
  3    11 	/*									*/
  3    12 	/* S__t_a_t_u_s									*/
  3    13 	/*									*/
  3    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  3    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  3    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  3    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  3    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  3    19 	/*									*/
  3    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    21 
  3    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    23 	/*									*/
  3    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  3    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  3    26 	/* both types of nodes are the same length.					*/
  3    27 	/*									*/
  3    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    29 
  3    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  3    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  3    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  3    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  3    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  3    35 						/*             (= node.Svalid & Srequirements)	*/
  3    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  3    37 	  2 switches		unaligned,
  3    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  3    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  3    40 						/* 	     entry before lib_access_mode_$set.	*/
  3    41 	    3 pad			bit(22),
  3    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  3    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  3    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  3    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  3    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  3    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  3    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  3    49 						/*	     in this directory;  if off, records*/
  3    50 						/*	     charged against 1st superior	*/
  3    51 						/*	     directory with switch on.	*/
  3    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  3    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  3    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  3    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  3    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  3    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  3    58 
  3    59 						/* From here on, link_nodes differ from nodes	*/
  3    60 						/*  for other types of node targets.		*/
  3    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  3    62 
  3    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    64 	/*									*/
  3    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  3    66 	/*									*/
  3    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    68 
  3    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  3    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  3    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  3    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  3    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  3    74 						/*             (= node.Svalid & Srequirements)	*/
  3    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  3    76 	  2 switches		unaligned,
  3    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  3    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  3    79 						/* 	     entry before lib_access_mode_$set.	*/
  3    80 	    3 pad			bit(22),
  3    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  3    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  3    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  3    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  3    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  3    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  3    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  3    88 						/*	     in this directory;  if off, records*/
  3    89 						/*	     charged against 1st superior	*/
  3    90 						/*	     directory with switch on.	*/
  3    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  3    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  3    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  3    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  3    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  3    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  3    97 
  3    98 						/* From here on, other nodes differ from	*/
  3    99 						/*  link_nodes.				*/
  3   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  3   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  3   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  3   103 	  2 pad1 (1)		fixed bin,
  3   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  3   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  3   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  3   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  3   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  3   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  3   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  3   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  3   112 						/*             component from the base of archive.*/
  3   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  3   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  3   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  3   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  3   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  3   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  3   119 						/*	     updated.			*/
  3   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  3   121 						/*	     directories with Sterminal_account	*/
  3   122 						/*	     on.				*/
  3   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  3   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  3   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  3   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  3   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  3   128 						/*	     updated.			*/
  3   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  3   130 						/*	     directories with Sterminal_account	*/
  3   131 						/*	     on.				*/
  3   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  3   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  3   134 	  2 pad2 (5)		fixed bin,
  3   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  3   136 
  3   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3   138 	/*									*/
  3   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  3   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  3   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  3   142 	/* descriptors are the only ones that have been defined.				*/
  3   143 	/*									*/
  3   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3   145 
  3   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  3   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  3   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  3   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  3   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  3   152 
  3   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  3   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  3   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  3   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  3   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  3   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  3   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  3   163 	    3 zero_pad		bit(36),
  3   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  3   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  3   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  3   167 	Vacl_1			fixed bin int static options(constant) init (1),
  3   168 						/* version:   version of ACL descriptor.	*/
  3   169 	Tacl			fixed bin int static options(constant) init (7);
  3   170 						/* attribute: type of a segment ACL descriptor.	*/
  3   171 
  3   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  3   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  3   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  3   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  3   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  3   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  3   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  3   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  3   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  3   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  3   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  3   186 						/* version:   version of directory ACL descriptor.*/
  3   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  3   188 						/* attribute: type of a directory ACL descriptor.	*/
  3   189 
  3   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  3   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  3   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  3   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  3   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  3   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  3   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  3   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  3   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  3   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  3   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  3   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  3   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  3   206 						/* version:   version of dir IACL descriptor.	*/
  3   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  3   208 
  3   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  3   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  3   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  3   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  3   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  3   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  3   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  3   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  3   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  3   221 	    3 zero_pad		bit(36),
  3   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  3   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  3   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  3   225 	Viacl_1			fixed bin int static options(constant) init (1),
  3   226 						/* version:   version of segment IACL descriptor.	*/
  3   227 	Tiacl			fixed bin int static options(constant) init (10);
  3   228 						/* attribute: type of a segment IACL descriptor.	*/
  3   229 
  3   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  3   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  3   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  3   236 	  2 names (Nnames refer (Dnames.N))
  3   237 				char(32),		/* attribute: names.			*/
  3   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  3   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  3   240 	Vnames_1			fixed bin int static options(constant) init (1),
  3   241 						/* version:   version of names descriptor.	*/
  3   242 	Tnames			fixed bin int static options(constant) init (1);
  3   243 						/* attribute: type of a name descriptor.	*/
  3   244 
  3   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  3   246 						/* nodes.					*/
  3   247 	  2 header,
  3   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  3   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  3   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  3   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  3   255 				like node,
  3   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  3   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  3   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  3   259 						/* version:   version of nodes descriptor.	*/
  3   260 	Tnodes			fixed bin int static options(constant) init (2);
  3   261 						/* attribute: type of a node descriptor.	*/
  3   262 
  3   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  3   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  3   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   268 	  2 info,
  3   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  3   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  3   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  3   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  3   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  3   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  3   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  3   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  3   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  3   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  3   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  3   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  3   281 	    3 format		aligned,
  3   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  3   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  3   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  3   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  3   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  3   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  3   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  3   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  3   290 	      4 pad		bit(28) unal,
  3   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  3   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  3   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  3   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  3   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  3   296 	    3 cversion,				/* attribite: compiler version string.		*/
  3   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  3   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  3   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  3   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  3   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  3   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  3   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  3   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  3   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  3   306 	Vobj_1			fixed bin int static options(constant) init (1),
  3   307 						/* version:   version of object_info_ descriptor.	*/
  3   308 	Tobj			fixed bin int static options(constant) init (3);
  3   309 						/* attribute: type of a node descriptor.	*/
  3   310 
  3   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  3   312 						/* library root search_proc attribute descriptor.	*/
  3   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  3   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  3   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  3   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  3   320 						/* version:   version of search_proc info descrip.*/
  3   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  3   322 						/* attribute: type of a search_proc descriptor.	*/
  3   323 
  3   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  3   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  3   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  3   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  3   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  3   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  3   330 						/*            output.			*/
  3   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  3   332 	  2 info			char(Luser refer (Duser.L)),
  3   333 						/* attribute: user info string.		*/
  3   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  3   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  3   336 	Vuser_1			fixed bin int static options(constant) init (1),
  3   337 						/* version:   version of user info descriptor.	*/
  3   338 	Tuser			fixed bin int static options(constant) init (6);
  3   339 						/* attribute: type of a user descriptor.	*/
  3   340 
  4     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4     4 	/*									*/
  4     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  4     6 	/*									*/
  4     7 	/*      This include segment defines the switches which request/validate the fields	*/
  4     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  4     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  4    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  4    11 	/* descriptor commands to obtain information about entries in a library.		*/
  4    12 	/*									*/
  4    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  4    14 	/* is requested for output.							*/
  4    15 	/*									*/
  4    16 	/* S__t_a_t_u_s									*/
  4    17 	/*									*/
  4    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  4    19 	/*									*/
  4    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    21 
  4    22 
  4    23      dcl	1 Svalid_req		aligned based,
  4    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  4    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  4    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  4    27 
  4    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  4    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  4    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  4    31 
  4    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  4    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  4    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  4    35 
  4    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  4    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  4    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  4    39 
  4    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  4    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  4    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  4    43 
  4    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  4    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  4    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  4    47 
  4    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  4    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  4    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  4    51 
  4    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  4    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  4    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  4    55 
  4    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  4    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  4    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  4    59 
  4    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  4    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  4    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  4    63 
  4    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  4    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  4    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  4    67 
  4    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  4    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  4    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  4    71 
  4    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  4    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  4    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  4    75 
  4    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  4    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  4    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  4    79 	  2 pad			bit(26) unal,
  4    80 
  4    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  4    82 
  4    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  4    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  4    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  4    86 
  4    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    88 	/*									*/
  4    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  4    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  4    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  4    92 	/*									*/
  4    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  4    94 
  4    95 
  4    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  4    97 	Srequirements		bit(72) aligned;
  4    98 
  4    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3   341 
  3   342 
  3   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  3   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  3   345 
  5     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  5     6 	/*									*/
  5     7 	/*      This include segment defines the control switches used by library descriptor	*/
  5     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  5     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  5    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  5    11 	/* to the lib_descriptor_ subroutine.						*/
  5    12 	/*									*/
  5    13 	/* S__t_a_t_u_s									*/
  5    14 	/*									*/
  5    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  5    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  5    17 	/*									*/
  5    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    19 
  5    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  5    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  5    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  5    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  5    24 
  5    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  5    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  5    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  5    28 						/*         nodes of the tree, and about all the	*/
  5    29 						/*	 nodes below the parent.		*/
  5    30 
  5    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  5    32 						/*         nodes of the tree.			*/
  5    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  5    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  5    35 
  5    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  5    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  5    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  5    39 						/*         deletion.			*/
  5    40 
  5    41 	  2 pad			bit(10) unal,
  5    42 
  5    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  5    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  5    45 
  5    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  5    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  5    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  5    49 
  5    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  5    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  5    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  5    53 
  5    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  5    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  5    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  5    57 
  5    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  5    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  5    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  5    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  5    62 
  5    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3   346 
  3   347 
  3   348 
  3   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3   350 	/*									*/
  3   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  3   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  3   353 	/* that:		mod (type, 2) = 1;						*/
  3   354 	/*									*/
  3   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3   356 
  3   357 
  3   358      dcl (Tlink			init (0),
  3   359 	Tsegment			init (1),
  3   360 	Tdirectory		init (2),
  3   361 	Tmsf			init (3),
  3   362 	Tmsf_comp			init (4),
  3   363 	Tarchive			init (5),
  3   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  3   365 
  3   366 
  3   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3   368 	/*									*/
  3   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  3   370 	/* Both brief and long string arrays are provided.				*/
  3   371 	/*									*/
  3   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3   373 
  3   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  3   375 				"link",
  3   376 				"segment",
  3   377 				"directory",
  3   378 				"multisegment file",
  3   379 				"multi-segment file component",
  3   380 				"archive",
  3   381 				"archive component"),
  3   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  3   383 				"link",
  3   384 				"segment",
  3   385 				"directory",
  3   386 				"msf",
  3   387 				"msf comp",
  3   388 				"archive",
  3   389 				"arch comp");
  3   390 
  3   391 
  3   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1397 
     1398 
  6     1 /* BEGIN INCLUDE FILE ... archive_component_info.incl.pl1 ... WOS 01/13/81 */
  6     2 /* Structure describing an archive component, used by archive_ */
  6     3 
  6     4 dcl  archive_component_info_ptr pointer;
  6     5 
  6     6 dcl 1 archive_component_info aligned based (archive_component_info_ptr),
  6     7     2 version fixed bin,
  6     8     2 comp_bc fixed bin (24),
  6     9     2 comp_ptr pointer,
  6    10     2 name char (32) unaligned,
  6    11     2 time_modified fixed bin (71),
  6    12     2 time_updated fixed bin (71),
  6    13     2 comp_lth fixed bin (19),
  6    14     2 access bit (36) unaligned;
  6    15 
  6    16 dcl  ARCHIVE_COMPONENT_INFO_VERSION_1 fixed bin internal static options (constant) init (1);
  6    17 
  6    18 /* BEGIN INCLUDE FILE ... archive_component_info.incl.pl1 ... WOS 01/13/81 */
     1399 
     1400 
     1401      dcl	1 archive_component_info_array (n_components)
     1402 				aligned like archive_component_info based (archive_component_info_ptr);
     1403 
  7     1 /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  7     2*coded February 8, 1972 by Michael J. Spier	*/
  7     3 /* modified May 26, 1972 by M. Weaver */
  7     4 /* modified 15 April, 1975 by M. Weaver */
  7     5 
  7     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  7     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  7     8 	2 textp pointer,			/* pointer to beginning of text section */
  7     9 	2 defp pointer,			/* pointer to beginning of definition section */
  7    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  7    11 	2 statp pointer,			/* pointer to beginning of static section */
  7    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  7    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  7    14 	2 tlng fixed bin,			/* length in words of text section */
  7    15 	2 dlng fixed bin,			/* length in words of definition section */
  7    16 	2 llng fixed bin,			/* length in words of linkage section */
  7    17 	2 ilng fixed bin,			/* length in words of static section */
  7    18 	2 slng fixed bin,			/* length in words of symbol section */
  7    19 	2 blng fixed bin,			/* length in words of break map */
  7    20 	2 format,				/* word containing bit flags about object type */
  7    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  7    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  7    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  7    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  7    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  7    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  7    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  7    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  7    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  7    30 	  3 pad bit(27) unaligned,
  7    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  7    32 	2 textlinkp pointer,		/* ptr to first link in text */
  7    33 
  7    34 	/* LIMIT OF BRIEF STRUCTURE */
  7    35 
  7    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  7    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  7    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  7    39 	2 cvers aligned,			/* generator version name in printable char string form */
  7    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  7    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  7    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  7    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  7    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  7    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  7    46 
  7    47 	/* LIMIT OF DISPLAY STRUCTURE */
  7    48 
  7    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  7    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  7    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  7    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  7    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  7    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  7    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  7    56 					/* currently not used by system */
  7    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  7    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  7    59 
  7    60 declare	object_info_version_2 fixed bin int static init(2);
  7    61 
  7    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
     1404 
     1405 
     1406      dcl	1 oi			aligned like object_info;
     1407 
  8     1 /* BEGIN INCLUDE FILE . . . star_structures.incl.pl1 */
  8     2 
  8     3 /* This include file contains structures for the hcs_$star_,
  8     4*   hcs_$star_list_ and hcs_$star_dir_list_ entry points.
  8     5*
  8     6*   Written 23 October 1978 by Monte Davidoff.
  8     7*   Modified January 1979 by Michael R. Jordan to use unsigned and different pointers for different structures.
  8     8*   Modified June 1981 by C. Hornig to count link pathnames more efficiently.
  8     9**/
  8    10 
  8    11 /* automatic */
  8    12 
  8    13 declare  star_branch_count fixed binary;		/* hcs_$star_list_, hcs_$star_dir_list_: matching branch count */
  8    14 declare  star_entry_count fixed binary;			/* hcs_$star_: number of matching entries */
  8    15 declare  star_entry_ptr pointer;			/* hcs_$star_: pointer to array of entry information */
  8    16 declare  star_list_branch_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to array of info */
  8    17 declare  star_link_count fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: matching link count */
  8    18 declare  star_linkx fixed binary;			/* hcs_$star_list_, hcs_$star_dir_list_: index into star_links */
  8    19 declare  star_names_ptr pointer;			/* hcs_$star_: pointer to array of entry names */
  8    20 declare  star_list_names_ptr pointer;			/* hcs_$star_list_, hcs_$star_dir_list_: ptr to entry names */
  8    21 declare  star_select_sw fixed binary (3);		/* hcs_$star_list_, hcs_$star_dir_list_: what info to return */
  8    22 
  8    23 /* based */
  8    24 
  8    25 /* hcs_$star_ entry structure */
  8    26 
  8    27 declare 1 star_entries (star_entry_count) aligned based (star_entry_ptr),
  8    28         2 type fixed binary (2) unsigned unaligned,
  8    29 						/* storage system type */
  8    30         2 nnames fixed binary (16) unsigned unaligned,
  8    31 						/* number of names of entry that match star_name */
  8    32         2 nindex fixed binary (18) unsigned unaligned;
  8    33 						/* index of first name in star_names */
  8    34 
  8    35 /* hcs_$star_ name structure */
  8    36 
  8    37 declare  star_names (sum (star_entries (*).nnames)) char (32) based (star_names_ptr);
  8    38 
  8    39 /* hcs_$star_list_ branch structure */
  8    40 
  8    41 declare 1 star_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  8    42         2 type fixed binary (2) unsigned unaligned,
  8    43 						/* storage system type */
  8    44         2 nnames fixed binary (16) unsigned unaligned,
  8    45 						/* number of names of entry that match star_name */
  8    46         2 nindex fixed binary (18) unsigned unaligned,
  8    47 						/* index of first name in star_list_names */
  8    48         2 dtcm bit (36) unaligned,			/* date-time contents of branch were last modified */
  8    49         2 dtu bit (36) unaligned,			/* date-time branch was last used */
  8    50         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  8    51         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  8    52         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  8    53         2 pad bit (7) unaligned,
  8    54         2 records fixed binary (18) unsigned unaligned;
  8    55 						/* records used by branch */
  8    56 
  8    57 /* hcs_$star_dir_list_ branch structure */
  8    58 
  8    59 declare 1 star_dir_list_branch (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  8    60         2 type fixed binary (2) unsigned unaligned,
  8    61 						/* storage system type */
  8    62         2 nnames fixed binary (16) unsigned unaligned,
  8    63 						/* number of names of entry that match star_name */
  8    64         2 nindex fixed binary (18) unsigned unaligned,
  8    65 						/* index of first name in star_list_names */
  8    66         2 dtem bit (36) unaligned,			/* date-time directory entry of branch was last modified */
  8    67         2 pad bit (36) unaligned,
  8    68         2 mode bit (5) unaligned,			/* user's access mode to the branch */
  8    69         2 raw_mode bit (5) unaligned,			/* user's ACL access mode */
  8    70         2 master_dir bit (1) unaligned,			/* is branch a master directory */
  8    71         2 bit_count fixed binary (24) unaligned;
  8    72 						/* bit count of the branch */
  8    73 
  8    74 /* hcs_$star_list_ and hcs_$star_dir_list_ link structure */
  8    75 
  8    76 declare 1 star_links (star_branch_count + star_link_count) aligned based (star_list_branch_ptr),
  8    77         2 type fixed binary (2) unsigned unaligned,
  8    78 						/* storage system type */
  8    79         2 nnames fixed binary (16) unsigned unaligned,
  8    80 						/* number of names of entry that match star_name */
  8    81         2 nindex fixed binary (18) unsigned unaligned,
  8    82 						/* index of first name in star_list_names */
  8    83         2 dtem bit (36) unaligned,			/* date-time link was last modified */
  8    84         2 dtd bit (36) unaligned,			/* date-time the link was last dumped */
  8    85         2 pathname_len fixed binary (18) unsigned unaligned,
  8    86 						/* length of the pathname of the link */
  8    87         2 pathname_index fixed binary (18) unsigned unaligned;
  8    88 						/* index of start of pathname in star_list_names */
  8    89 
  8    90 /* hcs_$star_list_ and hcs_$star_dir_list_ name array */
  8    91 
  8    92 declare  star_list_names char (32) based (star_list_names_ptr)
  8    93 	dimension (star_links (star_branch_count + star_link_count).nindex
  8    94 	 + star_links (star_branch_count + star_link_count).nnames
  8    95 	 + divide (star_links (star_branch_count + star_link_count).pathname_len + 31, 32, 17, 0)
  8    96 	   * binary (
  8    97 	     (star_links (star_branch_count + star_link_count).type = star_LINK)
  8    98 	     & (star_select_sw >= star_LINKS_ONLY_WITH_LINK_PATHS), 1));
  8    99 
  8   100 /* hcs_$star_list_ and hcs_$star_dir_list_ link pathname */
  8   101 
  8   102 declare  star_link_pathname char (star_links (star_linkx).pathname_len)
  8   103          based (addr (star_list_names (star_links (star_linkx).pathname_index)));
  8   104 
  8   105 /* internal static */
  8   106 
  8   107 /* star_select_sw values */
  8   108 
  8   109 declare  star_LINKS_ONLY fixed binary (2) internal static options (constant) initial (1);
  8   110 declare  star_BRANCHES_ONLY fixed binary (2) internal static options (constant) initial (2);
  8   111 declare  star_ALL_ENTRIES fixed binary (2) internal static options (constant) initial (3);
  8   112 declare  star_LINKS_ONLY_WITH_LINK_PATHS
  8   113          fixed binary (3) internal static options (constant) initial (5);
  8   114 declare  star_ALL_ENTRIES_WITH_LINK_PATHS
  8   115          fixed binary (3) internal static options (constant) initial (7);
  8   116 
  8   117 /* storage system types */
  8   118 
  8   119 declare  star_LINK fixed binary (2) unsigned internal static options (constant) initial (0);
  8   120 declare  star_SEGMENT fixed binary (2) unsigned internal static options (constant) initial (1);
  8   121 declare  star_DIRECTORY fixed binary (2) unsigned internal static options (constant) initial (2);
  8   122 
  8   123 /* END INCLUDE FILE . . . star_structures.incl.pl1 */
     1408 
     1409 
  9     1 /* --------------- BEGIN include file status_structures.incl.pl1 --------------- */
  9     2 
  9     3 /* Revised from existing include files 09/26/78 by C. D. Tavares */
  9     4 
  9     5 /* This include file contains branch and link structures returned by
  9     6*   hcs_$status_ and hcs_$status_long. */
  9     7 
  9     8 dcl 1 status_branch aligned based (status_ptr),
  9     9     2 short aligned,
  9    10       3 type fixed bin (2) unaligned unsigned,		/* seg, dir, or link */
  9    11       3 nnames fixed bin (16) unaligned unsigned,		/* number of names */
  9    12       3 names_relp bit (18) unaligned,			/* see entry_names dcl */
  9    13       3 dtcm bit (36) unaligned,			/* date/time contents last modified */
  9    14       3 dtu bit (36) unaligned,			/* date/time last used */
  9    15       3 mode bit (5) unaligned,			/* caller's effective access */
  9    16       3 raw_mode bit (5) unaligned,			/* caller's raw "rew" modes */
  9    17       3 pad1 bit (8) unaligned,
  9    18       3 records_used fixed bin (18) unaligned unsigned,	/* number of NONZERO pages used */
  9    19 
  9    20 /* Limit of information returned by hcs_$status_ */
  9    21 
  9    22     2 long aligned,
  9    23       3 dtd bit (36) unaligned,			/* date/time last dumped */
  9    24       3 dtem bit (36) unaligned,			/* date/time branch last modified */
  9    25       3 lvid bit (36) unaligned,			/* logical volume ID */
  9    26       3 current_length fixed bin (12) unaligned unsigned,	/* number of last page used */
  9    27       3 bit_count fixed bin (24) unaligned unsigned,	/* reported length in bits */
  9    28       3 pad2 bit (8) unaligned,
  9    29       3 copy_switch bit (1) unaligned,			/* copy switch */
  9    30       3 tpd_switch bit (1) unaligned,			/* transparent to paging device switch */
  9    31       3 mdir_switch bit (1) unaligned,			/* is a master dir */
  9    32       3 damaged_switch bit (1) unaligned,		/* salvager warned of possible damage */
  9    33       3 synchronized_switch bit (1) unaligned,		/* DM synchronized file */
  9    34       3 pad3 bit (5) unaligned,
  9    35       3 ring_brackets (0:2) fixed bin (6) unaligned unsigned, 
  9    36       3 uid bit (36) unaligned;			/* unique ID */
  9    37 
  9    38 dcl 1 status_link aligned based (status_ptr),
  9    39     2 type fixed bin (2) unaligned unsigned,		/* as above */
  9    40     2 nnames fixed bin (16) unaligned unsigned,
  9    41     2 names_relp bit (18) unaligned,
  9    42     2 dtem bit (36) unaligned,
  9    43     2 dtd bit (36) unaligned,
  9    44     2 pathname_length fixed bin (17) unaligned,		/* see pathname */
  9    45     2 pathname_relp bit (18) unaligned;			/* see pathname */
  9    46 
  9    47 dcl  status_entry_names (status_branch.nnames) character (32) aligned
  9    48 	based (pointer (status_area_ptr, status_branch.names_relp)),
  9    49 						/* array of names returned */
  9    50      status_pathname character (status_link.pathname_length) aligned
  9    51 	based (pointer (status_area_ptr, status_link.pathname_relp)),
  9    52 						/* link target path */
  9    53      status_area_ptr pointer,
  9    54      status_ptr pointer;
  9    55 
  9    56 dcl (Link initial (0),
  9    57      Segment initial (1),
  9    58      Directory initial (2)) fixed bin internal static options (constant);
  9    59 						/* values for type fields declared above */
  9    60 
  9    61 /* ---------------- END include file status_structures.incl.pl1 ---------------- */
     1410 
     1411 
     1412      dcl	1 auto_status_branch	aligned like status_branch,
     1413 	1 msf_comp		aligned like status_branch;
     1414 
     1415 	end lib_get_tree_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/18/86  1235.1  lib_get_tree_.pl1                 >spec>install>1098>lib_get_tree_.pl1
46           1    02/16/84  0928.6  lib_based_args_.incl.pl1          >ldd>include>lib_based_args_.incl.pl1
118          2    06/17/86  1513.1  status_for_backup.incl.pl1        >ldd>include>status_for_backup.incl.pl1
1397         3    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
3-341        4    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
3-346        5    02/16/84  0928.6  lib_Scontrol_.incl.pl1            >ldd>include>lib_Scontrol_.incl.pl1
1399         6    04/16/81  0942.6  archive_component_info.incl.pl1   >ldd>include>archive_component_info.incl.pl1
1404         7    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
1408         8    06/10/82  1045.5  star_structures.incl.pl1          >ldd>include>star_structures.incl.pl1
1410         9    11/22/82  0955.7  status_structures.incl.pl1        >ldd>include>status_structures.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APparent                               parameter       pointer                  dcl 42 ref 38 236
ARCHIVE_COMPONENT_INFO_VERSION_1
                                000052 constant        fixed bin(17,0)          initial dcl 6-16 set ref 394*
Acode                                  parameter       fixed bin(35,0)          dcl 47 set ref 38 228* 559 564* 570 574* 580 587
                                                                                  596* 600* 637*
C                        11            based           fixed bin(35,0)          array level 3 in structure "starname" dcl 1-32
                                                                                  in procedure "lib_get_tree_" ref 315 407 432
C                         4            based           fixed bin(35,0)          level 3 in structure "Dnodes" dcl 3-245 in procedure
                                                                                  "lib_get_tree_" set ref 353 353* 366 366 370* 456
                                                                                  456* 542 542* 574 644 644* 723 920*
C                         4            based           fixed bin(35,0)          level 2 in structure "Ddir_acl" dcl 3-172
                                                                                  in procedure "lib_get_tree_" set ref 792*
C                         4            based           fixed bin(35,0)          level 2 in structure "Diacl" dcl 3-209 in procedure
                                                                                  "lib_get_tree_" set ref 833*
C                         4            based           fixed bin(35,0)          level 2 in structure "Dacl" dcl 3-153 in procedure
                                                                                  "lib_get_tree_" set ref 762* 897*
C                         4            based           fixed bin(35,0)          level 2 in structure "Ddir_iacl" dcl 3-190
                                                                                  in procedure "lib_get_tree_" set ref 853*
D                                      based           structure                level 1 unaligned dcl 3-146
Dacl                                   based           structure                level 1 unaligned dcl 3-153 set ref 756 757 891 892
Darch                                  based           structure                level 1 dcl 122
Ddir_acl                               based           structure                level 1 unaligned dcl 3-172 set ref 786 787
Ddir_iacl                              based           structure                level 1 unaligned dcl 3-190 set ref 847 848
Diacl                                  based           structure                level 1 unaligned dcl 3-209 set ref 827 828
Dnames                                 based           structure                level 1 unaligned dcl 3-230 set ref 419 470 611 612
                                                                                  1134 1135
Dnodes                                 based           structure                level 1 unaligned dcl 3-245 set ref 915 916
Dobj                                   based           structure                level 1 unaligned dcl 3-263 set ref 1063 1065
Dsearch_proc                           based           structure                level 1 unaligned dcl 3-311 set ref 626 627
Inode                           000100 automatic       fixed bin(17,0)          dcl 71 set ref 357* 357 364 365 512* 512 515 518 538
                                                                                  604* 922* 1037* 1037 1039
Inon_ascii                      000100 automatic       fixed bin(21,0)          dcl 1339 set ref 1348* 1350
Iring                     6            based           fixed bin(17,0)          array level 2 in structure "Diacl" dcl 3-209
                                                                                  in procedure "lib_get_tree_" set ref 837*
Iring                     6            based           fixed bin(17,0)          array level 2 in structure "Ddir_iacl" dcl 3-190
                                                                                  in procedure "lib_get_tree_" set ref 857*
L                        41(18)        based           fixed bin(17,0)          level 4 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1092* 1098
L                        40(18)        based           fixed bin(17,0)          level 4 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1090* 1095
Lbreaks                  17            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1082*
Ldefinitions             13            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1078*
Llink                    14            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1079*
Lnode_string                    000010 internal static fixed bin(17,0)          initial dcl 195 set ref 231 232* 1040
Lrecord                         000011 internal static fixed bin(35,0)          initial dcl 195 set ref 233* 476 476 1376 1376
Lstatic                  15            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1080*
Lstring_                        000101 automatic       fixed bin(35,0)          dcl 71 set ref 1095* 1096 1098* 1099 1347* 1348 1348
Lsymbols                 16            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1081*
Ltext                    12            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1077*
MNnodes                                parameter       fixed bin(17,0)          dcl 47 set ref 559 561* 570 573* 580 587 595
N                         5            based           fixed bin(17,0)          level 2 in structure "Diacl" dcl 3-209 in procedure
                                                                                  "lib_get_tree_" set ref 827* 834* 835* 837 842
                                                                                  843* 843 846* 846
N                         5            based           fixed bin(17,0)          level 2 in structure "Dacl" dcl 3-153 in procedure
                                                                                  "lib_get_tree_" set ref 756* 763* 764 764 891*
                                                                                  898* 899 899
N                                      parameter       fixed bin(17,0)          dcl 910 in procedure "get_node_array" ref 907 912
N                         4            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 3-230 in procedure
                                                                                  "lib_get_tree_" set ref 419* 469* 611* 617 1134*
N                         5            based           fixed bin(17,0)          level 2 in structure "Ddir_acl" dcl 3-172
                                                                                  in procedure "lib_get_tree_" set ref 786* 793* 794
                                                                                  794
N                                      based           fixed bin(17,0)          level 2 in structure "root_names" dcl 47
                                                                                  in procedure "lib_get_tree_" ref 609 617 617 617
                                                                                  617
N                         5            based           fixed bin(17,0)          level 2 in structure "Ddir_iacl" dcl 3-190
                                                                                  in procedure "lib_get_tree_" set ref 847* 854*
                                                                                  855* 857 862 863* 863 866* 866
N                         5            based           fixed bin(17,0)          level 3 in structure "Dnodes" dcl 3-245 in procedure
                                                                                  "lib_get_tree_" set ref 364* 515* 538* 562* 573
                                                                                  595 604 605* 605 648* 648 915*
N                                      based           fixed bin(17,0)          level 2 in structure "starname" dcl 1-32
                                                                                  in procedure "lib_get_tree_" ref 282 310 314 406
                                                                                  432
NO_MATCH                               constant        fixed bin(2,0)           initial unsigned dcl 195 ref 324 343
Nacls                           000404 automatic       fixed bin(17,0)          dcl 3-153 set ref 748* 754* 756 756 757 763 764 841*
                                                                                  842 843 883* 889* 891 891 892 898 899
Ndir_acls                       000410 automatic       fixed bin(17,0)          dcl 3-172 set ref 778* 784* 786 786 787 793 794 861*
                                                                                  862 863
Ndir_iacls                      000414 automatic       fixed bin(17,0)          dcl 3-190 set ref 821* 824* 824 847 847 848 854
Nentries                        000102 automatic       fixed bin(17,0)          dcl 71 set ref 387* 431* 431 440 453* 459
Niacls                          000420 automatic       fixed bin(17,0)          dcl 3-209 set ref 821* 823* 823 827 827 828 834
Ninf_quota               65            based           fixed bin(35,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1245*
Ninf_quota               73            based           fixed bin(35,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1250*
Nnames                          000424 automatic       fixed bin(17,0)          dcl 3-230 set ref 416* 419 419 470 609* 610 611 611
                                                                                  612 1133* 1134 1134 1135
Nnodes                          000430 automatic       fixed bin(17,0)          dcl 3-245 set ref 912* 915 915 916
Nring                    16            based           fixed bin(17,0)          array level 2 in structure "Diacl" dcl 3-209
                                                                                  in procedure "lib_get_tree_" set ref 838*
Nring                    16            based           fixed bin(17,0)          array level 2 in structure "Ddir_iacl" dcl 3-190
                                                                                  in procedure "lib_get_tree_" set ref 858*
Nterminal_account               000103 automatic       fixed bin(1,0)           dcl 71 set ref 1245* 1249 1250* 1254
O                        40            based           fixed bin(17,0)          level 4 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1089* 1094
O                        41            based           fixed bin(17,0)          level 4 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1091* 1097
Obreaks                  11            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1076*
Odefinitions              5            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1072*
Olink                     6            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1073*
Osource                  42            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1093*
Ostatic                   7            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1074*
Osymbols                 10            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1075* 1089 1091 1093
Otext                     4            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1071*
Otext_links              22            based           fixed bin(35,0)          level 3 dcl 3-263 set ref 1085*
PBDarch                         000104 automatic       pointer                  unaligned dcl 71 set ref 384 386* 458
PD                        2            based           pointer                  level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 472 473* 720 721* 759 760*
                                                                                  789 790* 830 831* 850 851* 894 895* 1042* 1067
                                                                                  1068* 1156 1157* 1289 1290*
PD                              000402 automatic       pointer                  dcl 3-146 in procedure "lib_get_tree_" set ref 690*
                                                                                  691* 695* 699* 703* 712* 715* 719 720 721 723
PD                        2            based           pointer                  level 2 in structure "link_node" dcl 3-30
                                                                                  in procedure "lib_get_tree_" set ref 614 615* 629
                                                                                  630*
PDacl                           000406 automatic       pointer                  dcl 3-153 set ref 756* 757 757 758 759 760 761 762
                                                                                  763 764 764 891* 892 892 893 894 895 896 897 898
                                                                                  899 899
PDarch                          000106 automatic       pointer                  dcl 71 set ref 384* 420 421* 422 423 424 425 427 429
                                                                                  430 458* 462 463 464 465 466 467 468* 468
PDdir_acl                       000412 automatic       pointer                  dcl 3-172 set ref 786* 787 787 788 789 790 791 792
                                                                                  793 794 794
PDdir_iacl                      000416 automatic       pointer                  dcl 3-190 set ref 847* 848 848 849 850 851 852 853
                                                                                  854 855 857 857 858 862 862 863 863 866 866
PDiacl                          000422 automatic       pointer                  dcl 3-209 set ref 827* 828 828 829 830 831 832 833
                                                                                  834 835 837 837 838 842 842 843 843 846 846
PDnames                         000426 automatic       pointer                  dcl 3-230 set ref 466* 469 470 470 471 472 473 474
                                                                                  611* 612 612 613 614 615 616 617 711 712 715 1134*
                                                                                  1135 1135 1136 1137 1138 1156 1157 1289 1290
PDnodes                         000432 automatic       pointer                  dcl 3-245 set ref 238* 273 353 353 364 366 366 370
                                                                                  371 456 456 515 524 535 538 539* 542 542 544 562
                                                                                  563 572* 573 574 594* 595 604 605 605 644 644 648
                                                                                  648 915* 916 916 917 918 919 920 1039
PDobj                           000434 automatic       pointer                  dcl 3-263 set ref 1063* 1064 1065 1065 1066 1067
                                                                                  1068 1071 1072 1073 1074 1075 1076 1077 1078 1079
                                                                                  1080 1081 1082 1083 1084 1085 1086 1087 1088 1089
                                                                                  1089 1090 1091 1091 1092 1093 1093 1094 1095 1096
                                                                                  1097 1098 1099
PDsearch_proc                   000436 automatic       pointer                  dcl 3-311 set ref 626* 627 627 628 629 630 631 632
Pacl                            000110 automatic       pointer                  dcl 71 set ref 748* 764 840* 842 883* 899
Parch                     1            based           pointer                  level 2 in structure "Darch" packed unaligned
                                                                                  dcl 122 in procedure "lib_get_tree_" set ref 423*
                                                                                  467
Parch                           000112 automatic       pointer                  dcl 71 in procedure "lib_get_tree_" set ref 239*
                                                                                  382* 394* 467* 479 486* 501* 1304 1305* 1306* 1318
                                                                                  1318 1323 1379* 1380 1381* 1387*
Parea                                  parameter       pointer                  dcl 47 set ref 38 295* 301* 361 361 394* 419 438
                                                                                  529* 559 580 587 611 626 691* 695* 699* 703* 712*
                                                                                  715* 748* 751* 756 778* 781* 786 810* 813* 827 847
                                                                                  883* 885* 891 915 1063 1121 1123* 1127* 1134 1139
                                                                                  1146
Pdir_acl                        000114 automatic       pointer                  dcl 71 set ref 778* 794 860* 862
Pdirector_args                         parameter       pointer                  dcl 47 set ref 38 580 587 691* 695* 699* 703* 712*
                                                                                  715*
Pexclude                               parameter       pointer                  dcl 1-50 set ref 38 580 587 691* 695* 699* 703* 712*
                                                                                  715*
Piacl                           000116 automatic       pointer                  dcl 71 set ref 810* 840 860
Pnext                     2            based           pointer                  level 2 in structure "Dnames" dcl 3-230 in procedure
                                                                                  "lib_get_tree_" set ref 472* 614* 1156* 1289*
Pnext                     2            based           pointer                  level 2 in structure "Diacl" dcl 3-209 in procedure
                                                                                  "lib_get_tree_" set ref 830*
Pnext                     2            based           pointer                  level 2 in structure "D" dcl 3-146 in procedure
                                                                                  "lib_get_tree_" set ref 720*
Pnext                     2            based           pointer                  level 3 in structure "Dnodes" dcl 3-245 in procedure
                                                                                  "lib_get_tree_" set ref 918*
Pnext                     2            based           pointer                  level 2 in structure "Ddir_acl" dcl 3-172
                                                                                  in procedure "lib_get_tree_" set ref 789*
Pnext                     2            based           pointer                  level 2 in structure "Dsearch_proc" dcl 3-311
                                                                                  in procedure "lib_get_tree_" set ref 629*
Pnext                     2            based           pointer                  level 2 in structure "Ddir_iacl" dcl 3-190
                                                                                  in procedure "lib_get_tree_" set ref 850*
Pnext                     2            based           pointer                  level 2 in structure "Dacl" dcl 3-153 in procedure
                                                                                  "lib_get_tree_" set ref 759* 894*
Pnext                                  based           pointer                  level 2 in structure "Darch" packed unaligned
                                                                                  dcl 122 in procedure "lib_get_tree_" set ref 420*
                                                                                  422* 468
Pnext                     2            based           pointer                  level 2 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1067*
Pnode                           000400 automatic       pointer                  dcl 3-69 set ref 232 356* 462 463 464 465 472 473
                                                                                  476 476 479 484 486 487 493 495 498 501 502 502
                                                                                  506 506 510* 607 608 614 615 620 621 622 624 629
                                                                                  630 633 635 635 647* 691 691* 691 695 695* 695
                                                                                  699* 699 703* 712* 715* 720 721 722 724 725 726
                                                                                  726 759 760 789 790 830 831 850 851 894 895 1039*
                                                                                  1040 1041 1042 1067 1068 1144 1145 1147 1148 1149
                                                                                  1152 1153 1155 1155 1156 1157 1160 1162 1163 1164
                                                                                  1166 1167 1171 1172 1179 1180 1182 1185 1186 1187
                                                                                  1187 1190 1192 1194 1198 1200 1202 1203 1204 1205
                                                                                  1207 1210 1214 1218 1219 1220 1221 1222 1223 1224
                                                                                  1225 1226 1230 1234 1234 1235 1235 1236 1236 1241
                                                                                  1245 1245 1245 1245 1245 1249 1250 1250 1250 1250
                                                                                  1250 1254 1255 1258 1260 1261 1262 1263 1264 1265
                                                                                  1266 1267 1272 1273 1274 1275 1277 1278 1280 1281
                                                                                  1282 1283 1283 1285 1286 1289 1290 1291 1291 1373
                                                                                  1374 1375 1376 1376 1377 1381 1383 1387
Pnodes                                 parameter       pointer                  dcl 47 set ref 38 237* 273* 371* 524* 544* 559 563*
                                                                                  570 572 580 587 594
Pparent                         000120 automatic       pointer                  dcl 71 in procedure "lib_get_tree_" set ref 236* 243
                                                                                  382* 593* 1041 1170
Pparent                                based           pointer                  level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 691 1041*
Proot_names                            parameter       pointer                  dcl 47 ref 580 587 609 617
Pseg                                   parameter       pointer                  dcl 1336 in procedure "test_ascii" ref 1334 1346
Pseg                                   parameter       pointer                  dcl 1055 in procedure "object_seg_" set ref 1050
                                                                                  1060* 1094 1097
Pstarname                              parameter       pointer                  dcl 1-40 set ref 38 282 285 310 314 315 317 320 406
                                                                                  407 409 412 432 432 580 587 691* 695* 699* 703*
                                                                                  712* 715*
Pstring_                        000122 automatic       pointer                  dcl 71 set ref 1094* 1096 1097* 1099 1346* 1348
Ptemp                           000124 automatic       pointer                  dcl 71 set ref 419* 420 421 880* 883* 900*
S                                      based           structure                level 1 packed unaligned dcl 934 in procedure
                                                                                  "init_Svalid" set ref 937* 951* 985* 993* 1010*
                                                                                  1021*
S                                      based           structure                level 1 dcl 4-96 in procedure "lib_get_tree_"
Saim_audit               11(32)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1274*
Saim_multiple_class      11(33)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1275*
Saim_security_oos        11(31)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1273*
Sascii                                 parameter       bit(1)                   dcl 1336 set ref 1334 1343* 1350* 1352*
Sc                                     based           structure                level 1 dcl 5-20
Schase_links                    000126 automatic       fixed bin(1,0)           dcl 71 set ref 235* 268* 1123*
Scontrol                               parameter       bit(36)                  dcl 5-20 set ref 38 268 485 493 499 500 580 587 691*
                                                                                  695* 699* 703* 712* 715* 1150 1192 1208 1212 1239
                                                                                  1244 1268 1377 1377 1377 1381 1383 1386 1387
Scopy                    12            based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1258*
Smaster_dir              11(28)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1272*
Smode                    11            based           bit(3)                   level 3 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref 463*
                                                                                  1160* 1204* 1205* 1220* 1221* 1222* 1374
Smode                     2            based           bit(3)                   level 2 in structure "Darch" packed unaligned
                                                                                  dcl 122 in procedure "lib_get_tree_" set ref 430*
                                                                                  463
Sreq                      6            based           bit(72)                  level 2 in structure "link_node" dcl 3-30
                                                                                  in procedure "lib_get_tree_" set ref 1155*
Sreq                                   based           structure                level 1 dcl 3-343 in procedure "lib_get_tree_"
Sreq                      6            based           bit(72)                  level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 506* 635* 725 726 726
                                                                                  1291*
Srequirements                          parameter       bit(72)                  dcl 4-96 in procedure "lib_get_tree_" set ref 38 506
                                                                                  580 587 635 691* 695* 699* 703* 712* 715* 725 726
                                                                                  1155 1291
Srequirements                   000650 automatic       bit(72)                  dcl 934 in procedure "init_Svalid" set ref 937 938
                                                                                  939 940 941 942 943 944 945 946 947 948 949 951
                                                                                  952 953 954 955 956 957 958 959 960 961 962 963
                                                                                  964 965 966 967 968 969 970 971 972 973 974 975
                                                                                  976 977 978 979 980 981 982 983 985 986 987 988
                                                                                  989 990 991 993 994 995 996 997 998 999 1000 1001
                                                                                  1002 1003 1004 1005 1006 1007 1008 1010 1011 1012
                                                                                  1013 1014 1015 1016 1017 1018 1019 1021 1022 1023
                                                                                  1024 1025 1026 1027 1028
Ssafety                  11(30)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1261*
Sterminal_account        11(34)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1249*
Sterminal_account_dir
                         11(35)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1254*
Stpd                     11(29)        based           bit(1)                   level 3 packed unaligned dcl 3-69 set ref 1260*
Svalid                                 based           structure                level 1 dcl 3-343 in procedure "lib_get_tree_"
Svalid                    4            based           bit(72)                  level 2 in structure "link_node" dcl 3-30
                                                                                  in procedure "lib_get_tree_" set ref 608* 1149*
                                                                                  1155
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 484* 487 502* 502 506 620
                                                                                  621 622 633 635 722 724 1153 1172* 1179* 1182
                                                                                  1186* 1187* 1187 1190 1194 1203* 1210 1214 1219*
                                                                                  1241 1255 1283* 1283 1286 1291
Svalid_added_status             000012 internal static bit(72)                  dcl 195 set ref 1028* 1283
Svalid_archive                  000014 internal static bit(72)                  dcl 195 set ref 976* 1179
Svalid_archive_comp             000016 internal static bit(72)                  dcl 195 set ref 484 1008*
Svalid_directory                000020 internal static bit(72)                  dcl 195 set ref 983* 1203
Svalid_link                     000022 internal static bit(72)                  dcl 195 set ref 949* 1149
Svalid_msf                      000024 internal static bit(72)                  dcl 195 set ref 980* 1219
Svalid_msf_comp                 000026 internal static bit(72)                  dcl 195 set ref 975* 1172
Svalid_object_info              000030 internal static bit(72)                  dcl 195 set ref 502 991* 1187
Svalid_req                             based           structure                level 1 dcl 4-23
Svalid_root                     000032 internal static bit(72)                  initial dcl 195 set ref 229 592 608 1019*
Svalid_segment                  000034 internal static bit(72)                  dcl 195 set ref 974* 1186
T                         1            based           fixed bin(17,0)          level 2 in structure "Ddir_iacl" dcl 3-190
                                                                                  in procedure "lib_get_tree_" set ref 852*
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 243 495* 498* 695 1170
                                                                                  1171* 1180* 1185* 1192 1202* 1218*
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 3-230 in procedure
                                                                                  "lib_get_tree_" set ref 474* 616* 1137*
T                         1            based           fixed bin(17,0)          level 2 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1066*
T                         1            based           fixed bin(17,0)          level 3 in structure "Dnodes" dcl 3-245 in procedure
                                                                                  "lib_get_tree_" set ref 919*
T                         1            based           fixed bin(17,0)          level 2 in structure "Dsearch_proc" dcl 3-311
                                                                                  in procedure "lib_get_tree_" set ref 631*
T                         1            based           fixed bin(17,0)          level 2 in structure "Dacl" dcl 3-153 in procedure
                                                                                  "lib_get_tree_" set ref 761* 896*
T                         1            based           fixed bin(17,0)          level 2 in structure "Ddir_acl" dcl 3-172
                                                                                  in procedure "lib_get_tree_" set ref 791*
T                        10            based           fixed bin(35,0)          level 2 in structure "link_node" dcl 3-30
                                                                                  in procedure "lib_get_tree_" set ref 607* 1144*
T                         1            based           fixed bin(17,0)          level 2 in structure "Diacl" dcl 3-209 in procedure
                                                                                  "lib_get_tree_" set ref 832*
Tacl                                   constant        fixed bin(17,0)          initial dcl 3-153 ref 761 896
Tarchive                               constant        fixed bin(17,0)          initial dcl 3-358 ref 495 599 1180
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 3-358 ref 498
Tdir_acl                               constant        fixed bin(17,0)          initial dcl 3-172 ref 791
Tdir_iacl                              constant        fixed bin(17,0)          initial dcl 3-190 ref 852
Tdirectory                             constant        fixed bin(17,0)          initial dcl 3-358 ref 599 1202
Tiacl                                  constant        fixed bin(17,0)          initial dcl 3-209 ref 832
Tlink                                  constant        fixed bin(17,0)          initial dcl 3-358 ref 695 1144
Tmsf                                   constant        fixed bin(17,0)          initial dcl 3-358 ref 1170 1218
Tmsf_comp                              constant        fixed bin(17,0)          initial dcl 3-358 ref 1171 1192
Tnames                                 constant        fixed bin(17,0)          initial dcl 3-230 ref 474 616 1137
Tnodes                                 constant        fixed bin(17,0)          initial dcl 3-245 ref 919
Tobj                                   constant        fixed bin(17,0)          initial dcl 3-263 ref 1066
Tsearch_proc                           constant        fixed bin(17,0)          initial dcl 3-311 ref 631
Tsegment                               constant        fixed bin(17,0)          initial dcl 3-358 ref 1185
V                         1            based           char(32)                 array level 3 packed unaligned dcl 1-32 set ref 285
                                                                                  317 320* 409 412*
Vacl_1                                 constant        fixed bin(17,0)          initial dcl 3-153 ref 758 893
Vdir_acl_1                             constant        fixed bin(17,0)          initial dcl 3-172 ref 788
Vdir_iacl_1                            constant        fixed bin(17,0)          initial dcl 3-190 ref 849
Viacl_1                                constant        fixed bin(17,0)          initial dcl 3-209 ref 829
Vnames_1                               constant        fixed bin(17,0)          initial dcl 3-230 ref 471 613 1136
Vnodes_1                               constant        fixed bin(17,0)          initial dcl 3-245 ref 917
Vobj_1                                 constant        fixed bin(17,0)          initial dcl 3-263 ref 1064
Vsearch_proc_1                         constant        fixed bin(17,0)          initial dcl 3-311 ref 628
access                   21            based           bit(36)                  array level 2 packed unaligned dcl 1401 ref 430
access_class              5     000320 automatic       bit(72)                  level 2 in structure "sfb" dcl 120 in procedure
                                                                                  "lib_get_tree_" set ref 1278
access_class              0(19)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 1022*
access_class             35            based           bit(72)                  level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1278*
acl                                    based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 5-20
                                                                                  in procedure "lib_get_tree_" ref 1192 1208 1239
acl                       0(31)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  1194* 1210* 1241*
acl                                    based           structure                array level 1 unaligned dcl 122 in procedure
                                                                                  "lib_get_tree_" set ref 764 842* 842 899
acls                     26            based           structure                array level 2 in structure "Diacl" unaligned
                                                                                  dcl 3-209 in procedure "lib_get_tree_" set ref 842
acls                      6            based           structure                array level 2 in structure "Dacl" unaligned
                                                                                  dcl 3-153 in procedure "lib_get_tree_" set ref
                                                                                  764* 899*
acls                     26            based           structure                array level 2 in structure "Ddir_iacl" unaligned
                                                                                  dcl 3-190 in procedure "lib_get_tree_" set ref 862
acls                      6            based           structure                array level 2 in structure "Ddir_acl" unaligned
                                                                                  dcl 3-172 in procedure "lib_get_tree_" set ref
                                                                                  794*
addr                                                   builtin function         dcl 156 ref 268 384 427 429 485 487 493 499 500 620
                                                                                  621 622 633 722 724 725 725 726 726 726 810 810
                                                                                  842 862 937 938 939 940 941 942 943 944 945 946
                                                                                  947 948 951 952 953 954 955 956 957 958 959 960
                                                                                  961 962 963 964 965 966 967 968 969 970 971 972
                                                                                  973 977 978 979 981 982 985 986 987 988 989 990
                                                                                  993 994 995 996 997 998 999 1000 1001 1002 1003
                                                                                  1004 1005 1006 1007 1010 1011 1012 1013 1014 1015
                                                                                  1016 1017 1018 1021 1022 1023 1024 1025 1026 1027
                                                                                  1039 1060 1060 1120 1123 1123 1138 1150 1153 1182
                                                                                  1190 1192 1194 1208 1210 1212 1214 1232 1232 1239
                                                                                  1241 1244 1255 1268 1270 1270 1286 1377 1377 1377
                                                                                  1381 1383 1386 1387
addrel                                                 builtin function         dcl 156 ref 840 860
aim                       0(09)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 1023*
all_status                0(01)        based           bit(1)                   level 2 packed unaligned dcl 5-20 ref 1150 1268
arch                                   based           structure                level 1 packed unaligned dcl 122
archive                         000176 automatic       bit(1)                   level 2 in structure "flags" dcl 71 in procedure
                                                                                  "lib_get_tree_" set ref 492* 493* 495 1173 1178
archive                                parameter       bit(1)                   level 2 in structure "flags" dcl 1364 in procedure
                                                                                  "test_segment" set ref 1370* 1383* 1385
archive_$list_components        000044 constant        entry                    external dcl 162 ref 394
archive_component_info                 based           structure                level 1 dcl 6-6
archive_component_info_array           based           structure                array level 1 dcl 1401 set ref 438
archive_component_info_ptr      000440 automatic       pointer                  dcl 6-4 set ref 394* 409 412 423 424 425 426 428 430
                                                                                  438
archive_data_$header_begin      000126 external static char(8)                  dcl 195 ref 1318
archive_data_$header_end        000130 external static char(8)                  dcl 195 ref 1318
archive_data_$ident             000132 external static char(8)                  dcl 195 ref 1323
area                            000364 stack reference condition                dcl 162 ref 391 398 527
area_var                               based           area(1024)               dcl 122 ref 361 361 419 438 611 626 756 786 827 847
                                                                                  891 915 1063 1134 1139 1146
ascii                     2     000176 automatic       bit(1)                   level 2 in structure "flags" dcl 71 in procedure
                                                                                  "lib_get_tree_" set ref 486* 487 490* 499 1182
                                                                                  1190
ascii                     2            parameter       bit(1)                   level 2 in structure "flags" dcl 1364 in procedure
                                                                                  "test_segment" set ref 1372* 1381* 1386
audit_flag                4(03) 000320 automatic       bit(1)                   level 3 packed unaligned dcl 120 set ref 1274
author                          000127 automatic       char(33)                 unaligned dcl 71 in procedure "lib_get_tree_" set
                                                                                  ref 1151* 1152
author                    0(12)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  1153*
author                    0(12)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 1024*
author                   14            based           varying char(32)         level 2 in structure "link_node" dcl 3-30
                                                                                  in procedure "lib_get_tree_" set ref 1152*
author                   14            based           varying char(32)         level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1277*
author                   10     000320 automatic       char(32)                 level 2 in structure "sfb" dcl 120 in procedure
                                                                                  "lib_get_tree_" set ref 1276 1277
auto_status_branch              000542 automatic       structure                level 1 dcl 1412 set ref 1120
bc_author                20     000320 automatic       char(32)                 level 2 dcl 120 set ref 1279 1280
binary                                                 builtin function         dcl 156 ref 268 479 1060 1060 1071 1072 1073 1074
                                                                                  1075 1076 1085 1089 1090 1091 1092 1281
bit_count                              parameter       fixed bin(35,0)          dcl 1055 in procedure "object_seg_" ref 1050 1060
                                                                                  1060
bit_count                 0(24)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 963* 981* 1002*
bit_count                              parameter       fixed bin(35,0)          dcl 1316 in procedure "test_archive" ref 1314 1318
bit_count                              parameter       fixed bin(35,0)          dcl 1336 in procedure "test_ascii" ref 1334 1341
                                                                                  1342 1347
bit_count                       000140 automatic       fixed bin(24,0)          dcl 71 in procedure "lib_get_tree_" set ref 382*
                                                                                  394*
bit_count                 7(12)        based           fixed bin(24,0)          level 3 in structure "status_branch" packed unsigned
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1166 1201 1226
bit_count                 2(11)        based           fixed bin(24,0)          level 2 in structure "Darch" packed unaligned
                                                                                  dcl 122 in procedure "lib_get_tree_" set ref 425*
                                                                                  462
bit_count                43            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 462* 476 486* 493* 501*
                                                                                  1166* 1236* 1236 1375 1376 1377 1381* 1383* 1387*
bit_count_author         44            based           varying char(32)         level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1280*
bit_count_author          0(25)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 1025*
blng                     23     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1082
bmapp                    14     000442 automatic       pointer                  level 2 dcl 1406 set ref 1076
call_id                         000142 automatic       bit(70)                  dcl 71 set ref 292* 301* 389* 529* 747* 751* 777*
                                                                                  781* 809* 813* 882* 885* 1118* 1127*
char32                          000106 automatic       char(32)                 unaligned dcl 665 in procedure "cv_num" set ref 672*
                                                                                  673
char32                          000144 automatic       char(32)                 unaligned dcl 71 in procedure "lib_get_tree_" set
                                                                                  ref 1231* 1232*
chase                     0(02)        based           bit(1)                   level 2 packed unaligned dcl 5-20 ref 268
check_archive             0(03)        based           bit(1)                   level 2 packed unaligned dcl 5-20 ref 493 1377 1383
check_ascii               0(04)        based           bit(1)                   level 2 packed unaligned dcl 5-20 ref 485 499 1377
                                                                                  1381 1386
cleanup                         000372 stack reference condition                dcl 162 ref 241
clock                           000154 automatic       fixed bin(71,0)          dcl 71 set ref 426* 427 428* 429
clock_string                           based           bit(72)                  dcl 122 ref 427 429
code                            000156 automatic       fixed bin(35,0)          dcl 71 in procedure "lib_get_tree_" set ref 261*
                                                                                  295* 300 304 330* 353 366* 367* 382* 383 394* 400
                                                                                  442 443* 456 519 520* 542 644 689* 691* 695* 699*
                                                                                  703* 712* 715* 729 731 748* 750 754 762 778* 780
                                                                                  784 792 810* 812 816 833 853 880* 881 883* 884 889
                                                                                  897 1060* 1061 1123* 1125 1130 1167* 1232* 1233
                                                                                  1245* 1248 1250* 1253 1261* 1270* 1271 1379*
code                            000100 automatic       fixed bin(35,0)          dcl 1302 in procedure "terminate_archive" set ref
                                                                                  1305*
comment                  45     000442 automatic       structure                level 2 in structure "oi" dcl 1406 in procedure
                                                                                  "lib_get_tree_"
comment                  64            based           varying char(64)         level 2 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1099*
comment                  41            based           structure                level 3 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_"
comp_bc                   1            based           fixed bin(24,0)          array level 2 dcl 1401 ref 425
comp_ptr                  2            based           pointer                  array level 2 dcl 1401 ref 423
compile_time             26            based           fixed bin(71,0)          level 3 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1087*
compile_time             32     000442 automatic       fixed bin(71,0)          level 2 in structure "oi" dcl 1406 in procedure
                                                                                  "lib_get_tree_" set ref 1087
compiler                 23            based           char(8)                  level 3 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1086*
compiler                 30     000442 automatic       char(8)                  level 2 in structure "oi" dcl 1406 in procedure
                                                                                  "lib_get_tree_" set ref 1086
compiler_name             0(34)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 987*
compiler_options          1            based           bit(1)                   level 2 packed unaligned dcl 934 set ref 989*
compiler_version          0(35)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 988*
copy                      0(10)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 968* 978*
copy_switch              10(08)        based           bit(1)                   level 3 packed unaligned dcl 9-8 set ref 1258
count                           000157 automatic       fixed bin(17,0)          dcl 71 set ref 307* 325* 325 329 335*
counts                   10     000202 automatic       fixed bin(17,0)          array level 3 in structure "iacl_info" dcl 71
                                                                                  in procedure "lib_get_tree_" set ref 818* 823 838
                                                                                  839 841
counts                   30     000202 automatic       fixed bin(17,0)          array level 3 in structure "iacl_info" dcl 71
                                                                                  in procedure "lib_get_tree_" set ref 819* 824 858
                                                                                  859 861
cross_ref                 1(33)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 948* 973*
                                                                                  1007* 1018*
current_length            0(21)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 961* 1001*
current_length            7            based           fixed bin(12,0)          level 3 in structure "status_branch" packed unsigned
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1164 1200
current_length           40            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 476* 1164* 1200* 1235*
                                                                                  1235 1376
cvers                    44     000442 automatic       structure                level 2 dcl 1406
cversion                 43            based           varying char(64)         level 2 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1096*
cversion                 40            based           structure                level 3 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_"
defp                      4     000442 automatic       pointer                  level 2 dcl 1406 set ref 1072
dir                      20     000202 automatic       structure                level 2 in structure "iacl_info" unaligned dcl 71
                                                                                  in procedure "lib_get_tree_"
dir                                    parameter       char                     unaligned dcl 877 in procedure "get_msf_acl" set ref
                                                                                  875 880*
dir                                    parameter       char                     unaligned dcl 1364 in procedure "test_segment" set
                                                                                  ref 1361 1379*
dir                                    parameter       char                     unaligned dcl 803 in procedure "get_iacls" ref 801
                                                                                  808
dir                                    parameter       char                     unaligned dcl 744 in procedure "get_acl" set ref 741
                                                                                  748*
dir                                    parameter       char                     unaligned dcl 774 in procedure "get_dir_acl" set ref
                                                                                  772 778*
dir                                    parameter       char                     unaligned dcl 1113 in procedure "status_long" set
                                                                                  ref 1109 1123* 1151* 1167* 1169* 1193* 1209* 1213*
                                                                                  1227 1227 1229 1240* 1245 1250 1261* 1270*
dir_acl                                based           structure                array level 1 unaligned dcl 122 set ref 794 862* 862
director                               parameter       entry variable           dcl 47 set ref 38 580 587 691 691* 695 695* 699 699*
                                                                                  703 703* 712 712* 715 715*
directory                66            based           structure                level 2 unaligned dcl 3-69
divide                                                 builtin function         dcl 156 ref 476 1347 1376
dlng                     17     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1078
dtc                       0(33)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 986*
dtcm                      1            based           bit(36)                  level 3 packed unaligned dcl 9-8 set ref 1266
dtd                       2            based           bit(36)                  level 2 in structure "status_link" packed unaligned
                                                                                  dcl 9-38 in procedure "lib_get_tree_" ref 1148
dtd                       4            based           bit(36)                  level 3 in structure "status_branch" packed
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1265
dtd                      26            based           bit(36)                  level 2 in structure "link_node" packed unaligned
                                                                                  dcl 3-30 in procedure "lib_get_tree_" set ref
                                                                                  1148*
dtd                      26            based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1265*
dtd                       0(14)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 944* 960*
dtem                      0(13)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 943* 959* 1000*
dtem                     25            based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref 465*
                                                                                  1264*
dtem                     25            based           bit(36)                  level 2 in structure "link_node" packed unaligned
                                                                                  dcl 3-30 in procedure "lib_get_tree_" set ref
                                                                                  1147*
dtem                      1            based           bit(36)                  level 2 in structure "status_link" packed unaligned
                                                                                  dcl 9-38 in procedure "lib_get_tree_" ref 1147
dtem                      5            based           bit(36)                  level 3 in structure "status_branch" packed
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1264
dtm                      27            based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref 464*
                                                                                  1266*
dtm                       3            based           bit(36)                  level 2 in structure "Darch" dcl 122 in procedure
                                                                                  "lib_get_tree_" set ref 427* 464
dtm                       0(16)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 957* 999*
dttrp                    64            based           bit(36)                  level 3 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1245*
dttrp                    72            based           bit(36)                  level 3 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1250*
dtu                      30            based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1267*
dtu                       2            based           bit(36)                  level 3 in structure "status_branch" packed
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1267
dtu                       0(17)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 958*
dtupdated                 4            based           bit(36)                  level 2 dcl 122 set ref 429* 465
e                               000160 automatic       fixed bin(17,0)          dcl 71 set ref 583* 590* 625
ent                                    parameter       char                     unaligned dcl 744 in procedure "get_acl" set ref 741
                                                                                  748*
ent                                    parameter       char                     unaligned dcl 877 in procedure "get_msf_acl" set ref
                                                                                  875 880*
ent                                    parameter       char                     unaligned dcl 1113 in procedure "status_long" set
                                                                                  ref 1109 1123* 1151* 1167* 1169* 1193* 1209* 1213*
                                                                                  1227 1229 1240* 1245 1250 1261* 1270*
ent                                    parameter       char                     unaligned dcl 803 in procedure "get_iacls" ref 801
                                                                                  808
ent                                    parameter       char                     unaligned dcl 1364 in procedure "test_segment" set
                                                                                  ref 1361 1379*
ent                                    parameter       char                     unaligned dcl 774 in procedure "get_dir_acl" set ref
                                                                                  772 778*
ent                             000161 automatic       char(32)                 unaligned dcl 71 in procedure "lib_get_tree_" set
                                                                                  ref 265* 269* 282* 285* 289* 295*
entry_bound              56            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1281* 1285*
entry_bound              21            based           fixed bin(35,0)          level 3 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1084*
entry_bound              25     000442 automatic       fixed bin(17,0)          level 2 in structure "oi" dcl 1406 in procedure
                                                                                  "lib_get_tree_" set ref 1084
entry_bound               0(27)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  1286*
entry_bound               0(27)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 1026*
entrypt                   4(01) 000320 automatic       bit(1)                   level 3 packed unaligned dcl 120 set ref 1284
entrypt_bound             4(22) 000320 automatic       bit(14)                  level 2 packed unaligned dcl 120 set ref 1281
error                           000172 automatic       label variable           local dcl 71 set ref 257* 262 338* 379* 383 451*
                                                                                  638* 731 1130 1248 1253 1271
error_table_$archive_fmt_err    000134 external static fixed bin(35,0)          dcl 195 ref 442 519
error_table_$logical_volume_not_connected
                                000136 external static fixed bin(35,0)          dcl 195 ref 353 456 542 644
error_table_$noalloc            000140 external static fixed bin(35,0)          dcl 195 ref 750 780 812 884 1125
error_table_$nomatch            000142 external static fixed bin(35,0)          dcl 195 ref 330 367 443 520
error_table_$notalloc           000144 external static fixed bin(35,0)          dcl 195 ref 300
error_table_$out_of_bounds      000146 external static fixed bin(35,0)          dcl 195 ref 596
error_table_$process_stopped    000150 external static fixed bin(35,0)          dcl 195 ref 729
error_table_$toomanylinks       000152 external static fixed bin(35,0)          dcl 195 ref 261
error_table_$typename_not_found 000154 external static fixed bin(35,0)          dcl 195 ref 600
find_char_$first_in_table       000046 constant        entry                    external dcl 162 ref 1348
find_char_$not_ascii_table      000156 external static char(512)                dcl 195 set ref 1348*
flags                                  parameter       structure                level 1 dcl 1364 in procedure "test_segment" set ref
                                                                                  1361
flags                           000176 automatic       structure                level 1 dcl 71 in procedure "lib_get_tree_" set ref
                                                                                  1169*
format                   24     000442 automatic       structure                level 2 in structure "oi" dcl 1406 in procedure
                                                                                  "lib_get_tree_" set ref 1083
format                   20            based           structure                level 3 in structure "Dobj" dcl 3-263 in procedure
                                                                                  "lib_get_tree_" set ref 1083*
get_ring_                       000050 constant        entry                    external dcl 162 ref 230
group                     1            based           structure                array level 2 dcl 1-32
hcs_$dir_quota_read             000070 constant        entry                    external dcl 162 ref 1250
hcs_$get_author                 000052 constant        entry                    external dcl 162 ref 1151
hcs_$get_max_length             000054 constant        entry                    external dcl 162 ref 1167
hcs_$get_safety_sw              000056 constant        entry                    external dcl 162 ref 1261
hcs_$initiate                   000060 constant        entry                    external dcl 162 ref 1379
hcs_$list_acl                   000062 constant        entry                    external dcl 162 ref 748
hcs_$list_dir_acl               000064 constant        entry                    external dcl 162 ref 778
hcs_$list_inacl_all             000066 constant        entry                    external dcl 162 ref 810
hcs_$quota_read                 000072 constant        entry                    external dcl 162 ref 1245
hcs_$star_                      000074 constant        entry                    external dcl 162 ref 295
hcs_$status_for_backup          000076 constant        entry                    external dcl 162 ref 1270
hcs_$status_long                000100 constant        entry                    external dcl 162 ref 1123 1232
hcs_$terminate_noname           000102 constant        entry                    external dcl 162 ref 1305
header                                 based           structure                level 2 unaligned dcl 3-245
header_begin                           based           char(8)                  level 2 packed unaligned dcl 122 ref 1318 1323
header_end               27            based           char(8)                  level 2 packed unaligned dcl 122 ref 1318
i                               000235 automatic       fixed bin(17,0)          dcl 1116 in procedure "status_long" set ref 1230*
                                                                                  1231* 1276* 1277 1279* 1280
i                               000152 automatic       fixed bin(17,0)          dcl 803 in procedure "get_iacls" set ref 816* 818
                                                                                  819* 822* 823 824* 836* 837 838 838 839 840 841*
                                                                                  856* 857 858 858 859 860 861*
i                               000201 automatic       fixed bin(17,0)          dcl 71 in procedure "lib_get_tree_" set ref 312* 313
                                                                                  313 313 324* 341* 343 347* 459*
i                               000116 automatic       fixed bin(17,0)          dcl 665 in procedure "cv_num" set ref 671* 672
iacl                      0(08)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 5-20
                                                                                  in procedure "lib_get_tree_" ref 1212
iacl                      0(32)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  1214*
iacl_info                       000202 automatic       structure                level 1 unaligned dcl 71 set ref 810 810
ilng                     21     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1080
info                      4            based           structure                level 2 unaligned dcl 3-263
j                               000242 automatic       fixed bin(17,0)          dcl 71 set ref 313* 317 320* 405* 409 412 423 424
                                                                                  425 426 428 430* 711* 712 715
k                               000243 automatic       fixed bin(17,0)          dcl 71 set ref 314* 315 317 320* 406* 407 409 412*
kids                      0(04)        based           bit(1)                   level 2 packed unaligned dcl 3-343 set ref 722*
kids_error                0(05)        based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  725*
kids_error                0(05)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 4-96
                                                                                  in procedure "lib_get_tree_" ref 725 726
kids_error                0(05)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  724*
length                                 based           fixed bin(17,0)          level 2 in structure "Diacl" packed unaligned
                                                                                  dcl 3-209 in procedure "lib_get_tree_" set ref
                                                                                  828*
length                                 based           fixed bin(17,0)          level 2 in structure "Dacl" packed unaligned
                                                                                  dcl 3-153 in procedure "lib_get_tree_" set ref
                                                                                  757* 892*
length                                 based           fixed bin(17,0)          level 2 in structure "Dsearch_proc" packed unaligned
                                                                                  dcl 3-311 in procedure "lib_get_tree_" set ref
                                                                                  627*
length                                 based           fixed bin(17,0)          level 3 in structure "Dnodes" packed unaligned
                                                                                  dcl 3-245 in procedure "lib_get_tree_" set ref
                                                                                  916*
length                                 based           fixed bin(17,0)          level 2 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1065*
length                                 based           fixed bin(17,0)          level 2 in structure "Dnames" packed unaligned
                                                                                  dcl 3-230 in procedure "lib_get_tree_" set ref
                                                                                  470* 612* 1135*
length                                                 builtin function         dcl 156 in procedure "lib_get_tree_" ref 625
length                   45(18) 000442 automatic       bit(18)                  level 3 in structure "oi" packed unaligned dcl 1406
                                                                                  in procedure "lib_get_tree_" set ref 1092
length                                 based           fixed bin(17,0)          level 2 in structure "Ddir_acl" packed unaligned
                                                                                  dcl 3-172 in procedure "lib_get_tree_" set ref
                                                                                  787*
length                                 based           fixed bin(17,0)          level 2 in structure "Ddir_iacl" packed unaligned
                                                                                  dcl 3-190 in procedure "lib_get_tree_" set ref
                                                                                  848*
length                   44(18) 000442 automatic       bit(18)                  level 3 in structure "oi" packed unaligned dcl 1406
                                                                                  in procedure "lib_get_tree_" set ref 1090
level                     1(34)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 947* 972*
                                                                                  1006* 1017*
lib_free_node_$array            000104 constant        entry                    external dcl 162 ref 539
lib_free_node_$descriptors      000106 constant        entry                    external dcl 162 ref 356 510 647
lib_ptr_and_bc_                 000110 constant        entry                    external dcl 162 ref 382
link_level                             parameter       fixed bin(17,0)          dcl 47 ref 38 260 695 695 699 703
link_node                              based           structure                level 1 unaligned dcl 3-30
link_target              27            based           varying char(168)        level 2 in structure "link_node" dcl 3-30
                                                                                  in procedure "lib_get_tree_" set ref 624* 691*
                                                                                  695* 699* 1145*
link_target               0(15)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 945*
linkp                     6     000442 automatic       pointer                  level 2 dcl 1406 set ref 1073
llng                     20     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1079
long                      4            based           structure                level 2 dcl 9-8
lvid                     75            based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1263*
lvid                      0(28)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 965*
lvid                      6            based           bit(36)                  level 3 in structure "status_branch" packed
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1263
master_dir                4(07) 000320 automatic       bit(1)                   level 3 packed unaligned dcl 120 set ref 1272
match_star_name_                000112 constant        entry                    external dcl 162 ref 320 412
matching_names            0(01)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  621*
matching_names            0(01)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 939* 953* 995*
                                                                                  1012*
max_length                0(22)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 964* 977*
max_length               41            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1167*
min                                                    builtin function         dcl 156 ref 711 1276 1279
mod                                                    builtin function         dcl 156 ref 1342
mode                      3            based           bit(5)                   level 3 in structure "status_branch" packed
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1160 1204 1205 1220 1222
mode                      0(07)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 966* 1004*
msf_comp                        000554 automatic       structure                level 1 dcl 1412 set ref 1232 1232
msf_dir                         000244 automatic       char(168)                unaligned dcl 71 set ref 1227* 1229* 1232*
msf_indicator             0(23)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 979* 982*
msf_indicator            42            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1226* 1230
msf_manager_$acl_list           000114 constant        entry                    external dcl 162 ref 883
msf_manager_$close              000116 constant        entry                    external dcl 162 ref 900
msf_manager_$open               000120 constant        entry                    external dcl 162 ref 880
multiple_class            4(04) 000320 automatic       bit(1)                   level 3 packed unaligned dcl 120 set ref 1275
n                                      parameter       fixed bin(17,0)          dcl 665 ref 663 670
n_components                    000316 automatic       fixed bin(17,0)          dcl 71 set ref 394* 405 438
name                      5            based           char(32)                 level 2 in structure "Darch" dcl 122 in procedure
                                                                                  "lib_get_tree_" set ref 424*
name                      4            based           char(32)                 array level 2 in structure
                                                                                  "archive_component_info_array" packed unaligned
                                                                                  dcl 1401 in procedure "lib_get_tree_" set ref 409
                                                                                  412* 424
names                     0(02)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 940* 954* 996*
                                                                                  1013*
names                     5            based           char(32)                 array level 2 in structure "Dnames" packed unaligned
                                                                                  dcl 3-230 in procedure "lib_get_tree_" set ref
                                                                                  617* 711 712 715 1138
names                     0(02)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  622*
names_relp                0(18)        based           bit(18)                  level 3 packed unaligned dcl 9-8 set ref 1138 1139
new_line                  1(35)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 946* 971*
                                                                                  1005* 1016*
nindex                    0(18)        based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 8-27 ref
                                                                                  313 313 347
nnames                    0(02)        based           fixed bin(16,0)          array level 2 in structure "star_entries" packed
                                                                                  unsigned unaligned dcl 8-27 in procedure
                                                                                  "lib_get_tree_" ref 313 361
nnames                    0(02)        based           fixed bin(16,0)          level 3 in structure "status_branch" packed unsigned
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1133 1138 1139
node                                   based           structure                level 1 unaligned dcl 3-69 set ref 232
node_string                            based           bit                      dcl 122 set ref 1040*
nodes                     6            based           structure                array level 2 unaligned dcl 3-245 set ref 1039
not_ascii                 1(02)        based           bit(1)                   level 2 packed unaligned dcl 3-343 set ref 487*
                                                                                  1182* 1190*
null                                                   builtin function         dcl 156 ref 237 238 239 382 382 386 422 535 593 690
                                                                                  691 719 748 748 778 778 883 883 918 1042 1232 1232
                                                                                  1304 1306 1380
object_info               1(01)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 990*
object_info               0(09)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 5-20
                                                                                  in procedure "lib_get_tree_" ref 500 1377 1387
object_info                            based           structure                level 1 dcl 7-6 in procedure "lib_get_tree_"
object_info_$display            000122 constant        entry                    external dcl 162 ref 1060
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 7-60 ref 1059
object_seg                1     000176 automatic       bit(1)                   level 2 in structure "flags" dcl 71 in procedure
                                                                                  "lib_get_tree_" set ref 501* 502 1187
object_seg                1            parameter       bit(1)                   level 2 in structure "flags" dcl 1364 in procedure
                                                                                  "test_segment" set ref 1371* 1387*
offset                   55            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 479*
offset                   44     000442 automatic       bit(18)                  level 3 in structure "oi" packed unaligned dcl 1406
                                                                                  in procedure "lib_get_tree_" set ref 1089
offset                    0(26)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 1003*
offset                   45     000442 automatic       bit(18)                  level 3 in structure "oi" packed unaligned dcl 1406
                                                                                  in procedure "lib_get_tree_" set ref 1091
offsets                  20     000202 automatic       bit(18)                  array level 3 in structure "iacl_info" dcl 71
                                                                                  in procedure "lib_get_tree_" set ref 860
offsets                         000202 automatic       bit(18)                  array level 3 in structure "iacl_info" dcl 71
                                                                                  in procedure "lib_get_tree_" set ref 840
oi                              000442 automatic       structure                level 1 dcl 1406 set ref 1060 1060
path                                   parameter       varying char(168)        dcl 42 in procedure "lib_get_tree_" set ref 38 269
                                                                                  295 347 580 587 624 703* 712 712 715
path                            000153 automatic       char(168)                unaligned dcl 803 in procedure "get_iacls" set ref
                                                                                  808* 810*
pathname                  0(03)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 942* 956*
                                                                                  998* 1015*
pathname_length           3            based           fixed bin(17,0)          level 2 packed unaligned dcl 9-38 ref 1145 1146 1146
pathname_relp             3(18)        based           bit(18)                  level 2 packed unaligned dcl 9-38 ref 1145 1146
pic                             000117 automatic       picture(13)              unaligned dcl 665 set ref 670* 671 672
pointer                                                builtin function         dcl 156 ref 1094 1097 1138 1139 1145 1146
primary_name                           based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 938* 952* 994*
                                                                                  1011*
primary_name                           based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  620*
primary_name                           based           bit(1)                   level 2 in structure "Sreq" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  726* 726
pvid                     74            based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1282*
pvid                     31     000320 automatic       bit(36)                  level 2 in structure "sfb" dcl 120 in procedure
                                                                                  "lib_get_tree_" set ref 1282
pvid                      0(29)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 1027*
quota                    66            based           fixed bin(35,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1250*
quota                     0(10)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 5-20
                                                                                  in procedure "lib_get_tree_" ref 1244
quota                    60            based           fixed bin(35,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1245*
quota                     0(30)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  1255*
quota_used               61            based           fixed bin(35,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1245*
quota_used               67            based           fixed bin(35,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1250*
rb                        0(18)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 967*
rb                       31            based           fixed bin(3,0)           array level 2 in structure "node" dcl 3-69
                                                                                  in procedure "lib_get_tree_" set ref 1162* 1207*
                                                                                  1223* 1224* 1225* 1373
records_used              0(20)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 962*
records_used              3(18)        based           fixed bin(18,0)          level 3 in structure "status_branch" packed unsigned
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1163 1198
records_used             37            based           fixed bin(35,0)          level 2 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1163* 1198* 1234* 1234
rel                                                    builtin function         dcl 156 ref 479 1071 1072 1073 1074 1075 1076 1085
reverse                                                builtin function         dcl 156 ref 711 1276 1279
ring                            000036 internal static fixed bin(5,0)           initial dcl 195 set ref 230 230* 1373
ring_brackets            10(18)        based           fixed bin(6,0)           array level 3 packed unsigned unaligned dcl 9-8 set
                                                                                  ref 1162 1207 1223 1224 1225
root_name                 1            based           char(32)                 array level 2 packed unaligned dcl 47 ref 617
root_names                             based           structure                level 1 unaligned dcl 47
root_search_proc          1(04)        based           bit(1)                   level 2 in structure "Svalid" packed unaligned
                                                                                  dcl 3-343 in procedure "lib_get_tree_" set ref
                                                                                  633*
root_search_proc                       parameter       varying char(65)         dcl 47 in procedure "lib_get_tree_" ref 580 625 632
root_type                              parameter       fixed bin(17,0)          dcl 47 ref 580 587 599 599 607
rtrim                                                  builtin function         dcl 156 ref 1152
safety                    0(08)        based           bit(1)                   level 2 packed unaligned dcl 934 set ref 969*
search_proc               4            based           varying char(65)         level 2 dcl 3-311 set ref 632*
security_oosw             4(02) 000320 automatic       bit(1)                   level 3 packed unaligned dcl 120 set ref 1273
seg                             000202 automatic       structure                level 2 unaligned dcl 71
segment                  60            based           structure                level 2 unaligned dcl 3-69
sfb                             000320 automatic       structure                level 1 dcl 120 set ref 1270 1270
short                                  based           structure                level 2 dcl 9-8
size                                                   builtin function         dcl 156 ref 232 470 612 627 757 787 828 848 892 916
                                                                                  1065 1135
slng                     22     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1081
smart_alloc_$area_full          000124 constant        entry                    external dcl 162 ref 301 529 751 781 813 885 1127
source_map               46     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1093
star_ALL_ENTRIES                000035 constant        fixed bin(2,0)           initial dcl 8-111 set ref 295*
star_entries                           based           structure                array level 1 dcl 8-27 set ref 361
star_entry_count                000530 automatic       fixed bin(17,0)          dcl 8-14 set ref 295* 307 312 341 361 361
star_entry_ptr                  000532 automatic       pointer                  dcl 8-15 set ref 295* 313 313 313 324 343 347 361
                                                                                  361
star_names                             based           char(32)                 array unaligned dcl 8-37 set ref 317 320* 347* 361
star_names_ptr                  000534 automatic       pointer                  dcl 8-19 set ref 295* 317 320 347 361
starname                               based           structure                level 1 dcl 1-32
statp                    10     000442 automatic       pointer                  level 2 dcl 1406 set ref 1074
status_area_ptr                 000536 automatic       pointer                  dcl 9-47 set ref 1121* 1138 1139 1145 1146
status_branch                          based           structure                level 1 dcl 9-8 set ref 1123 1123
status_entry_names                     based           char(32)                 array dcl 9-47 set ref 1138* 1138 1139
status_for_backup                      based           structure                level 1 dcl 2-11
status_for_backup_version_2            constant        fixed bin(17,0)          initial dcl 2-33 ref 1269
status_link                            based           structure                level 1 dcl 9-38
status_pathname                        based           char                     dcl 9-47 ref 1145 1146
status_ptr                      000540 automatic       pointer                  dcl 9-47 set ref 1120* 1123 1123 1133 1138 1138 1139
                                                                                  1139 1141 1145 1145 1146 1146 1146 1147 1148 1160
                                                                                  1162 1163 1164 1166 1198 1200 1201 1204 1205 1207
                                                                                  1220 1222 1223 1224 1225 1226 1258 1260 1262 1263
                                                                                  1264 1265 1266 1267
stop_search                     000360 automatic       label variable           local dcl 122 set ref 271* 340* 450* 639* 729
string                                                 builtin function         dcl 156 set ref 937* 951* 985* 993* 1010* 1021*
                                                                                  1083* 1083
string_                                based           char                     unaligned dcl 122 set ref 1096 1099 1348*
substr                                                 builtin function         dcl 156 set ref 427 429 430 672 712 715 1160 1204*
                                                                                  1204 1205* 1205 1220* 1220 1221* 1222* 1222 1277
                                                                                  1280 1374
sum                                                    builtin function         dcl 156 ref 361
switches                 11            based           structure                level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_"
switches                  4     000320 automatic       structure                level 2 in structure "sfb" packed unaligned dcl 120
                                                                                  in procedure "lib_get_tree_"
symbp                    12     000442 automatic       pointer                  level 2 dcl 1406 set ref 1075
sys_info$maxlinks               000160 external static fixed bin(35,0)          dcl 195 ref 260
sys_info$page_size              000162 external static fixed bin(35,0)          dcl 195 ref 233
textlinkp                26     000442 automatic       pointer                  level 2 dcl 1406 set ref 1085
textp                     2     000442 automatic       pointer                  level 2 dcl 1406 set ref 1071
time_modified            14            based           fixed bin(71,0)          array level 2 dcl 1401 ref 426
time_updated             16            based           fixed bin(71,0)          array level 2 dcl 1401 ref 428
tlng                     16     000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1077
tpd_switch               10(09)        based           bit(1)                   level 3 packed unaligned dcl 9-8 set ref 1260
tree_level                             parameter       fixed bin(17,0)          dcl 47 set ref 38 695 699* 703* 712 715
trp                      70            based           fixed bin(71,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1250*
trp                      62            based           fixed bin(71,0)          level 3 in structure "node" dcl 3-69 in procedure
                                                                                  "lib_get_tree_" set ref 1245*
type                      0(06)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 941* 955* 997*
                                                                                  1014*
type                            000317 automatic       fixed bin(17,0)          dcl 71 in procedure "lib_get_tree_" set ref 243* 244
                                                                                  308
type                                   based           fixed bin(2,0)           level 3 in structure "status_branch" packed unsigned
                                                                                  unaligned dcl 9-8 in procedure "lib_get_tree_" set
                                                                                  ref 1141
type                                   based           fixed bin(2,0)           array level 2 in structure "star_entries" packed
                                                                                  unsigned unaligned dcl 8-27 in procedure
                                                                                  "lib_get_tree_" set ref 324* 343
uid                      11            based           bit(36)                  level 3 packed unaligned dcl 9-8 set ref 1262
unique_id                12(01)        based           bit(36)                  level 2 in structure "node" packed unaligned
                                                                                  dcl 3-69 in procedure "lib_get_tree_" set ref
                                                                                  1262*
unique_id                 0(11)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 934
                                                                                  in procedure "init_Svalid" set ref 970*
userid                   34     000442 automatic       char(32)                 level 2 in structure "oi" dcl 1406 in procedure
                                                                                  "lib_get_tree_" set ref 1088
userid                   30            based           char(32)                 level 3 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1088*
verify                                                 builtin function         dcl 156 ref 671 711 1276 1279
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Dobj" packed unaligned
                                                                                  dcl 3-263 in procedure "lib_get_tree_" set ref
                                                                                  1064*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Dsearch_proc" packed unaligned
                                                                                  dcl 3-311 in procedure "lib_get_tree_" set ref
                                                                                  628*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Dnames" packed unaligned
                                                                                  dcl 3-230 in procedure "lib_get_tree_" set ref
                                                                                  471* 613* 1136*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Ddir_iacl" packed unaligned
                                                                                  dcl 3-190 in procedure "lib_get_tree_" set ref
                                                                                  849*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Ddir_acl" packed unaligned
                                                                                  dcl 3-172 in procedure "lib_get_tree_" set ref
                                                                                  788*
version                         000320 automatic       fixed bin(17,0)          level 2 in structure "sfb" dcl 120 in procedure
                                                                                  "lib_get_tree_" set ref 1269*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Diacl" packed unaligned
                                                                                  dcl 3-209 in procedure "lib_get_tree_" set ref
                                                                                  829*
version                   0(18)        based           fixed bin(17,0)          level 3 in structure "Dnodes" packed unaligned
                                                                                  dcl 3-245 in procedure "lib_get_tree_" set ref
                                                                                  917*
version                   0(18)        based           fixed bin(17,0)          level 2 in structure "Dacl" packed unaligned
                                                                                  dcl 3-153 in procedure "lib_get_tree_" set ref
                                                                                  758* 893*
version_number                  000442 automatic       fixed bin(17,0)          level 2 dcl 1406 set ref 1059*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Directory                              internal static fixed bin(17,0)          initial dcl 9-56
Duser                                  based           structure                level 1 unaligned dcl 3-324
Link                                   internal static fixed bin(17,0)          initial dcl 9-56
Luser                                  automatic       fixed bin(17,0)          dcl 3-324
PDuser                                 automatic       pointer                  dcl 3-324
Plibrary                               automatic       pointer                  dcl 1-29
Segment                                internal static fixed bin(17,0)          initial dcl 9-56
Tuser                                  internal static fixed bin(17,0)          initial dcl 3-324
Vuser_1                                internal static fixed bin(17,0)          initial dcl 3-324
brief_node_type                        internal static varying char(12)         initial array dcl 3-374
exclude                                based           structure                level 1 dcl 1-42
library                                based           structure                level 1 dcl 1-22
node_type                              internal static varying char(32)         initial array dcl 3-374
star_ALL_ENTRIES_WITH_LINK_PATHS       internal static fixed bin(3,0)           initial dcl 8-114
star_BRANCHES_ONLY                     internal static fixed bin(2,0)           initial dcl 8-110
star_DIRECTORY                         internal static fixed bin(2,0)           initial unsigned dcl 8-121
star_LINK                              internal static fixed bin(2,0)           initial unsigned dcl 8-119
star_LINKS_ONLY                        internal static fixed bin(2,0)           initial dcl 8-109
star_LINKS_ONLY_WITH_LINK_PATHS        internal static fixed bin(3,0)           initial dcl 8-112
star_SEGMENT                           internal static fixed bin(2,0)           initial unsigned dcl 8-120
star_branch_count                      automatic       fixed bin(17,0)          dcl 8-13
star_dir_list_branch                   based           structure                array level 1 dcl 8-59
star_link_count                        automatic       fixed bin(17,0)          dcl 8-17
star_link_pathname                     based           char                     unaligned dcl 8-102
star_links                             based           structure                array level 1 dcl 8-76
star_linkx                             automatic       fixed bin(17,0)          dcl 8-18
star_list_branch                       based           structure                array level 1 dcl 8-41
star_list_branch_ptr                   automatic       pointer                  dcl 8-16
star_list_names                        based           char(32)                 array unaligned dcl 8-92
star_list_names_ptr                    automatic       pointer                  dcl 8-20
star_select_sw                         automatic       fixed bin(3,0)           dcl 8-21

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          002140 constant        label                    dcl 592 ref 584
acl_again                       003262 constant        label                    dcl 748 ref 752
arch_expand_area                001662 constant        label                    dcl 527 ref 391
arch_match                      001214 constant        label                    dcl 416 ref 409 412
arch_nomatch                    001315 constant        label                    dcl 434 ref 410 414
arch_test                       000014 constant        label                    array(0:2) dcl 409 ref 407
arch_test_done                  001342 constant        label                    dcl 440 ref 432
arch_test_stop                  001636 constant        label                    dcl 515 ref 450
call_again                      005436 constant        label                    dcl 1121 in procedure "status_long" ref 1128
call_again                      000325 constant        label                    dcl 295 in procedure "lib_get_tree_" ref 302
call_star                       000323 constant        label                    dcl 292 ref 287
cv_num                          002466 constant        entry                    internal dcl 663 ref 1231
dir_acl_again                   003504 constant        label                    dcl 778 ref 782
dir_match                       000565 constant        label                    dcl 326 ref 317 320
dir_nomatch                     000551 constant        label                    dcl 322 ref 318
dir_test                        000011 constant        label                    array(0:2) dcl 317 ref 315
director_caller                 002527 constant        entry                    internal dcl 682 ref 272 350 507 640
director_reject                 001623 constant        label                    dcl 510 ref 451
end_component                   001634 constant        label                    dcl 513 ref 508
end_search                      000300 constant        label                    dcl 273 ref 271
fatal                           001700 constant        label                    dcl 535 ref 257 304 331 368 402 447 522
fill_node                       007125 constant        label                    dcl 1258 ref 1196
get_acl                         003241 constant        entry                    internal dcl 741 ref 1193
get_components                  001045 constant        label                    dcl 391 ref 530
get_dir_acl                     003463 constant        entry                    internal dcl 772 ref 1209
get_iacls                       003703 constant        entry                    internal dcl 801 ref 1213
get_msf_acl                     004323 constant        entry                    internal dcl 875 ref 1240
get_node_array                  004567 constant        entry                    internal dcl 907 ref 266 335 453 541 561
iacl_again                      003757 constant        label                    dcl 810 ref 814
init_Svalid                     004635 constant        entry                    internal dcl 931 ref 229 592
init_node                       005114 constant        entry                    internal dcl 1035 ref 267 346 461 606
lib_get_tree_                   000077 constant        entry                    external dcl 38
lib_root_node                   002032 constant        entry                    external dcl 580
msf_acl_again                   004376 constant        label                    dcl 883 ref 886
next_entry                      000700 constant        label                    dcl 359 ref 343 351
not_ascii                       007544 constant        label                    dcl 1343 ref 1341
object_seg_                     005141 constant        entry                    internal dcl 1050 ref 501 1387
proc_node                       000000 constant        label                    array(0:6) dcl 246 ref 244
process_archive                 006170 constant        label                    dcl 1180 ref 1173
process_segment                 006211 constant        label                    dcl 1187 ref 1175
record_and_skip                 000661 constant        label                    dcl 353 ref 338
root_array                      001737 constant        entry                    external dcl 559
root_array_info                 001774 constant        entry                    external dcl 570
root_error                      002445 constant        label                    dcl 644 ref 638
root_node                       002102 constant        entry                    external dcl 587
root_stop                       002444 constant        label                    dcl 641 ref 639
star_test                       000007 constant        label                    array(2:3) dcl 310 ref 308
star_test_stop                  000703 constant        label                    dcl 361 ref 340
status_long                     005411 constant        entry                    internal dcl 1109 ref 269 347
terminate_arch                  001353 constant        label                    dcl 445 ref 379
terminate_archive               007431 constant        entry                    internal dcl 1300 ref 241 401 445 517 1389
test_archive                    007460 constant        entry                    internal dcl 1314 ref 493 1383
test_ascii                      007531 constant        entry                    internal dcl 1334 ref 486 1381
test_segment                    007610 constant        entry                    internal dcl 1361 ref 1169
type                            000017 constant        label                    array(0:2) dcl 1144 ref 1141

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10732       11116   10123       10742
Length     11650   10123       164         515     606          30

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_get_tree_                       584 external procedure  is an external procedure.  
on unit on line 241                  64 on unit               
on unit on line 391                  64 on unit               
cv_num                                  internal procedure  shares stack frame of internal procedure status_long.  
director_caller                         internal procedure  shares stack frame of external procedure lib_get_tree_.  
get_acl                                 internal procedure  shares stack frame of internal procedure status_long.  
get_dir_acl                             internal procedure  shares stack frame of internal procedure status_long.  
get_iacls                               internal procedure  shares stack frame of internal procedure status_long.  
get_msf_acl                             internal procedure  shares stack frame of internal procedure status_long.  
get_node_array                          internal procedure  shares stack frame of external procedure lib_get_tree_.  
init_Svalid                             internal procedure  shares stack frame of external procedure lib_get_tree_.  
init_node                               internal procedure  shares stack frame of external procedure lib_get_tree_.  
object_seg_                          78 internal procedure  is called by several nonquick procedures.  
status_long                         418 internal procedure  is called during a stack extension.  
terminate_archive                    72 internal procedure  is called by several nonquick procedures.  
test_archive                         66 internal procedure  is called by several nonquick procedures.  
test_ascii                           80 internal procedure  is called by several nonquick procedures.  
test_segment                            internal procedure  shares stack frame of internal procedure status_long.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 Lnode_string                lib_get_tree_
000011 Lrecord                     lib_get_tree_
000012 Svalid_added_status         lib_get_tree_
000014 Svalid_archive              lib_get_tree_
000016 Svalid_archive_comp         lib_get_tree_
000020 Svalid_directory            lib_get_tree_
000022 Svalid_link                 lib_get_tree_
000024 Svalid_msf                  lib_get_tree_
000026 Svalid_msf_comp             lib_get_tree_
000030 Svalid_object_info          lib_get_tree_
000032 Svalid_root                 lib_get_tree_
000034 Svalid_segment              lib_get_tree_
000036 ring                        lib_get_tree_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_get_tree_            000100 Inode                       lib_get_tree_
                         000101 Lstring_                    lib_get_tree_
                         000102 Nentries                    lib_get_tree_
                         000103 Nterminal_account           lib_get_tree_
                         000104 PBDarch                     lib_get_tree_
                         000106 PDarch                      lib_get_tree_
                         000110 Pacl                        lib_get_tree_
                         000112 Parch                       lib_get_tree_
                         000114 Pdir_acl                    lib_get_tree_
                         000116 Piacl                       lib_get_tree_
                         000120 Pparent                     lib_get_tree_
                         000122 Pstring_                    lib_get_tree_
                         000124 Ptemp                       lib_get_tree_
                         000126 Schase_links                lib_get_tree_
                         000127 author                      lib_get_tree_
                         000140 bit_count                   lib_get_tree_
                         000142 call_id                     lib_get_tree_
                         000144 char32                      lib_get_tree_
                         000154 clock                       lib_get_tree_
                         000156 code                        lib_get_tree_
                         000157 count                       lib_get_tree_
                         000160 e                           lib_get_tree_
                         000161 ent                         lib_get_tree_
                         000172 error                       lib_get_tree_
                         000176 flags                       lib_get_tree_
                         000201 i                           lib_get_tree_
                         000202 iacl_info                   lib_get_tree_
                         000242 j                           lib_get_tree_
                         000243 k                           lib_get_tree_
                         000244 msf_dir                     lib_get_tree_
                         000316 n_components                lib_get_tree_
                         000317 type                        lib_get_tree_
                         000320 sfb                         lib_get_tree_
                         000360 stop_search                 lib_get_tree_
                         000400 Pnode                       lib_get_tree_
                         000402 PD                          lib_get_tree_
                         000404 Nacls                       lib_get_tree_
                         000406 PDacl                       lib_get_tree_
                         000410 Ndir_acls                   lib_get_tree_
                         000412 PDdir_acl                   lib_get_tree_
                         000414 Ndir_iacls                  lib_get_tree_
                         000416 PDdir_iacl                  lib_get_tree_
                         000420 Niacls                      lib_get_tree_
                         000422 PDiacl                      lib_get_tree_
                         000424 Nnames                      lib_get_tree_
                         000426 PDnames                     lib_get_tree_
                         000430 Nnodes                      lib_get_tree_
                         000432 PDnodes                     lib_get_tree_
                         000434 PDobj                       lib_get_tree_
                         000436 PDsearch_proc               lib_get_tree_
                         000440 archive_component_info_ptr  lib_get_tree_
                         000442 oi                          lib_get_tree_
                         000530 star_entry_count            lib_get_tree_
                         000532 star_entry_ptr              lib_get_tree_
                         000534 star_names_ptr              lib_get_tree_
                         000536 status_area_ptr             lib_get_tree_
                         000540 status_ptr                  lib_get_tree_
                         000542 auto_status_branch          lib_get_tree_
                         000554 msf_comp                    lib_get_tree_
                         000650 Srequirements               init_Svalid
status_long              000106 char32                      cv_num
                         000116 i                           cv_num
                         000117 pic                         cv_num
                         000152 i                           get_iacls
                         000153 path                        get_iacls
                         000235 i                           status_long
terminate_archive        000100 code                        terminate_archive
test_ascii               000100 Inon_ascii                  test_ascii

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            alloc_temp          cat_realloc_cs      call_var            call_ext_out_desc   call_ext_out
call_int_this_desc  call_int_this       call_int_other      return              tra_ext             tra_label_var
bound_check_signal  mpfx2               mod_fx1             enable              shorten_stack       ext_entry
int_entry           int_entry_desc      divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
archive_$list_components      find_char_$first_in_table     freen_                        get_ring_
hcs_$dir_quota_read           hcs_$get_author               hcs_$get_max_length           hcs_$get_safety_sw
hcs_$initiate                 hcs_$list_acl                 hcs_$list_dir_acl             hcs_$list_inacl_all
hcs_$quota_read               hcs_$star_                    hcs_$status_for_backup        hcs_$status_long
hcs_$terminate_noname         lib_free_node_$array          lib_free_node_$descriptors    lib_ptr_and_bc_
match_star_name_              msf_manager_$acl_list         msf_manager_$close            msf_manager_$open
object_info_$display          smart_alloc_                  smart_alloc_$area_full

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
archive_data_$header_begin    archive_data_$header_end      archive_data_$ident           error_table_$archive_fmt_err
error_table_$logical_volume_not_connected                   error_table_$noalloc          error_table_$nomatch
error_table_$notalloc         error_table_$out_of_bounds    error_table_$process_stopped  error_table_$toomanylinks
error_table_$typename_not_found                             find_char_$not_ascii_table    sys_info$maxlinks
sys_info$page_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 000066       228 000131       229 000132       230 000135       231 000147       232 000152       233 000154
    235 000157       236 000160       237 000164       238 000166       239 000167       241 000170       243 000212
    244 000215       246 000216       257 000217       260 000222       261 000227       262 000231       265 000232
    266 000235       267 000241       268 000242       269 000246       271 000273       272 000277       273 000300
    275 000302       282 000303       285 000313       287 000317       289 000320       292 000323       295 000325
    300 000401       301 000406       302 000421       304 000422       307 000424       308 000426       310 000430
    312 000434       313 000443       314 000465       315 000475       317 000502       318 000515       320 000516
    322 000551       323 000553       324 000555       325 000563       326 000565       329 000567       330 000571
    331 000574       335 000575       338 000577       340 000602       341 000605       343 000613       346 000620
    347 000621       350 000656       351 000660       353 000661       356 000670       357 000676       359 000700
    361 000703       364 000765       365 000770       366 000771       367 000775       368 001000       370 001001
    371 001002       372 001003       379 001004       382 001007       383 001033       384 001036       386 001040
    387 001042       389 001043       391 001045       394 001064       398 001107       400 001110       401 001112
    402 001116       405 001117       406 001127       407 001137       409 001144       410 001157       412 001160
    414 001213       416 001214       419 001216       420 001242       421 001243       422 001244       423 001246
    424 001254       425 001261       426 001267       427 001271       428 001274       429 001276       430 001301
    431 001305       432 001306       434 001315       436 001317       438 001321       440 001342       442 001344
    443 001351       445 001353       447 001357       450 001360       451 001363       453 001366       456 001370
    458 001377       459 001401       461 001411       462 001412       463 001420       464 001424       465 001426
    466 001430       467 001431       468 001433       469 001435       470 001440       471 001445       472 001447
    473 001451       474 001452       476 001454       479 001467       484 001472       485 001475       486 001500
    487 001512       488 001522       490 001523       492 001524       493 001525       495 001541       498 001550
    499 001553       500 001564       501 001567       502 001601       506 001611       507 001621       508 001622
    510 001623       512 001632       513 001634       515 001636       517 001641       518 001645       519 001647
    520 001654       522 001656       524 001657       525 001661       527 001662       529 001663       530 001677
    535 001700       538 001704       539 001707       541 001716       542 001721       544 001730       545 001731
    559 001732       561 001755       562 001763       563 001765       564 001766       565 001767       570 001770
    572 002010       573 002013       574 002015       575 002017       580 002020       583 002066       584 002070
    587 002071       590 002136       592 002140       593 002144       594 002146       595 002151       596 002154
    597 002157       599 002160       600 002166       601 002171       604 002172       605 002174       606 002175
    607 002176       608 002202       609 002206       610 002211       611 002212       612 002235       613 002241
    614 002243       615 002246       616 002250       617 002252       618 002331       620 002333       621 002335
    622 002337       624 002341       625 002350       626 002357       627 002375       628 002400       629 002403
    630 002407       631 002411       632 002413       633 002422       635 002424       637 002434       638 002435
    639 002440       640 002443       641 002444       644 002445       647 002454       648 002462       649 002465
    663 002466       670 002470       671 002500       672 002512       673 002522       682 002527       689 002530
    690 002531       691 002533       695 002601       699 002654       703 002715       711 002760       712 003001
    715 003074       717 003174       719 003175       720 003201       721 003205       722 003210       723 003213
    724 003216       725 003220       726 003224       729 003230       731 003235       734 003240       741 003241
    747 003257       748 003262       750 003326       751 003333       752 003346       754 003347       756 003352
    757 003377       758 003404       759 003406       760 003411       761 003413       762 003415       763 003417
    764 003421       766 003462       772 003463       777 003501       778 003504       780 003550       781 003555
    782 003570       784 003571       786 003574       787 003621       788 003626       789 003630       790 003633
    791 003635       792 003637       793 003641       794 003643       796 003702       801 003703       808 003721
    809 003753       810 003757       812 004012       813 004017       814 004032       816 004033       818 004041
    819 004043       820 004044       821 004046       822 004051       823 004055       824 004060       825 004063
    827 004065       828 004114       829 004120       830 004122       831 004125       832 004127       833 004131
    834 004133       835 004135       836 004137       837 004143       838 004150       839 004152       840 004154
    841 004160       842 004161       843 004173       844 004175       845 004176       846 004200       847 004204
    848 004232       849 004236       850 004240       851 004243       852 004245       853 004247       854 004251
    855 004253       856 004255       857 004261       858 004266       859 004270       860 004272       861 004276
    862 004277       863 004311       864 004313       865 004314       866 004316       868 004322       875 004323
    880 004341       881 004371       882 004374       883 004376       884 004422       885 004427       886 004442
    889 004443       891 004446       892 004474       893 004501       894 004503       895 004506       896 004510
    897 004512       898 004514       899 004516       900 004556       902 004566       907 004567       912 004571
    915 004573       916 004617       917 004623       918 004625       919 004627       920 004632       922 004633
    924 004634       931 004635       937 004636       938 004640       939 004642       940 004644       941 004646
    942 004650       943 004652       944 004654       945 004656       946 004660       947 004662       948 004664
    949 004666       951 004671       952 004673       953 004675       954 004677       955 004701       956 004703
    957 004705       958 004707       959 004711       960 004713       961 004715       962 004717       963 004721
    964 004723       965 004725       966 004727       967 004731       968 004733       969 004735       970 004737
    971 004741       972 004743       973 004745       974 004747       975 004751       976 004752       977 004753
    978 004755       979 004757       980 004761       981 004763       982 004765       983 004767       985 004771
    986 004773       987 004775       988 004777       989 005001       990 005003       991 005005       993 005007
    994 005011       995 005013       996 005015       997 005017       998 005021       999 005023      1000 005025
   1001 005027      1002 005031      1003 005033      1004 005035      1005 005037      1006 005041      1007 005043
   1008 005045      1010 005047      1011 005051      1012 005053      1013 005055      1014 005057      1015 005061
   1016 005063      1017 005065      1018 005067      1019 005071      1021 005073      1022 005075      1023 005077
   1024 005101      1025 005103      1026 005105      1027 005107      1028 005111      1030 005113      1035 005114
   1037 005115      1039 005116      1040 005123      1041 005132      1042 005134      1044 005137      1050 005140
   1059 005146      1060 005151      1061 005172      1063 005200      1064 005216      1065 005222      1066 005225
   1067 005230      1068 005233      1071 005235      1072 005240      1073 005243      1074 005246      1075 005251
   1076 005254      1077 005257      1078 005261      1079 005263      1080 005265      1081 005267      1082 005271
   1083 005273      1084 005275      1085 005277      1086 005302      1087 005305      1088 005307      1089 005312
   1090 005321      1091 005324      1092 005333      1093 005336      1094 005342      1095 005351      1096 005355
   1097 005364      1098 005372      1099 005376      1101 005405      1109 005410      1118 005431      1120 005434
   1121 005436      1123 005443      1125 005503      1127 005510      1128 005523      1130 005524      1133 005531
   1134 005536      1135 005563      1136 005567      1137 005571      1138 005573      1139 005610      1141 005635
   1144 005641      1145 005644      1146 005663      1147 005711      1148 005716      1149 005720      1150 005724
   1151 005727      1152 005763      1153 006005      1155 006007      1156 006017      1157 006022      1158 006024
   1160 006025      1162 006034      1163 006056      1164 006061      1166 006064      1167 006067      1169 006115
   1170 006140      1171 006145      1172 006150      1173 006154      1175 006157      1178 006160      1179 006163
   1180 006170      1182 006172      1183 006201      1185 006202      1186 006205      1187 006211      1190 006217
   1192 006226      1193 006234      1194 006252      1196 006256      1198 006257      1200 006264      1201 006267
   1202 006273      1203 006275      1204 006301      1205 006306      1207 006313      1208 006336      1209 006341
   1210 006357      1212 006363      1213 006366      1214 006404      1216 006410      1218 006411      1219 006413
   1220 006417      1221 006424      1222 006426      1223 006433      1224 006437      1225 006442      1226 006443
   1227 006445      1229 006476      1230 006530      1231 006546      1232 006557      1233 006623      1234 006626
   1235 006635      1236 006643      1238 006651      1239 006653      1240 006657      1241 006675      1244 006701
   1245 006704      1248 007000      1249 007007      1250 007015      1253 007105      1254 007114      1255 007122
   1258 007125      1260 007134      1261 007141      1262 007172      1263 007204      1264 007206      1265 007210
   1266 007212      1267 007214      1268 007216      1269 007221      1270 007223      1271 007254      1272 007262
   1273 007271      1274 007276      1275 007303      1276 007310      1277 007330      1278 007337      1279 007343
   1280 007363      1281 007372      1282 007375      1283 007377      1284 007403      1285 007406      1286 007407
   1289 007411      1290 007415      1291 007417      1293 007427      1300 007430      1304 007436      1305 007443
   1306 007453      1309 007456      1314 007457      1318 007465      1322 007514      1323 007515      1325 007525
   1334 007530      1341 007536      1342 007541      1343 007544      1344 007545      1346 007546      1347 007552
   1348 007555      1350 007577      1352 007605      1354 007607      1361 007610      1370 007626      1371 007630
   1372 007632      1373 007634      1374 007643      1375 007647      1376 007652      1377 007666      1379 007701
   1380 007744      1381 007752      1383 007773      1385 010012      1386 010017      1387 010032      1389 010052
   1392 010057


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
