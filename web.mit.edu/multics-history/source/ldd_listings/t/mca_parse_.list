	COMPILATION LISTING OF SEGMENT mca_parse_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 10/30/86  1144.1 mst Thu
	    Options: optimize map

        1 
        2 
        3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
        4 	/*							*/
        5 	/* COMPILED OUTPUT OF SEGMENT  mca_parse_.rd                   	*/
        6 	/* Compiled by:  reduction_compiler, Version 2.5 of Oct 21, 1985      */
        7 	/* Compiled on:  10/30/86  1144.1 mst Thu                             */
        8 	/*							*/
        9 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       10 
       11 /* ***********************************************************
       12*   *                                                         *
       13*   * Copyright, (C) Honeywell Information Systems Inc., 1984 *
       14*   *                                                         *
       15*   *********************************************************** */
       16 
       17 /* HISTORY COMMENTS:
       18*  1) change(86-01-14,Fawcett), approve(86-03-19,MCR7374),
       19*     audit(86-05-05,Lippard), install(86-09-16,MR12.0-1159):
       20*     Created to check the MCA command set to the MCA via the tandd gates.
       21*  2) change(86-10-21,Fawcett), approve(86-10-21,PBF7374),
       22*     audit(86-10-23,Farley), install(86-10-30,MR12.0-1203):
       23*     Change the decimal-number reduction to decimal-integer.
       24*                                                   END HISTORY COMMENTS */
       25 
       26 /* format: style4 */
       27 /* Created Nov 1984 by R. A. Fawcett */
       28 mca_parse_:
       29 	proc (a_data_ptr,a_data_len,a_mcad_ptr,a_user_level,a_code);
       30 /*++
       31*BEGIN 
       32*main           
       33*
       34*\"   Fist word MUST be load, reset, rload, trace, or test;
       35*		/ load		/  LEX (1)				/ load_rest_tar \
       36*2		/ reset		/  LEX (1)				/ load_rest_tar \
       37*3		/ rload		/  LEX (1)				/ load_rest_tar \
       38*4		/ test		/  LEX (1)				/ target_verb   \
       39*5		/ read		/  LEX (1)				/ read_verb     \
       40*6		/ <no-token>	/ [a_code = error_table_$noarg]		/ RETURN \
       41*7		/ <any-token>	/ [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       42*
       43*\" Reset targets;
       44*
       45*load_rest_tar	/ ipc		/ LEX (1)					/ ft_ipc      \
       46*9		/ ipcs		/				/ all_ipcs    \
       47*10		/ mca		/ LEX (1)					/ do_mca	    \
       48*11		/ <no-token>        / [a_code = error_table_$noarg]		/ RETURN \
       49*12		/ <any-token>	/ [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       50*
       51*ft_ipc		/ <ipc_num_att>	/ LEX (1)					/ next_ipc \
       52*14		/ <decimal-integer>	  / [a_code = error_table_$io_not_assigned]	/ AUDIT_RET \
       53*15		/ <any-token>	  / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       54*16		/ <no-token>	  / [a_code = error_table_$noarg]		/ RETURN \
       55*next_ipc		/ <no-token>	  /					/ exit        \
       56*18		/ <ipc_num_att>	  / LEX (1)				/ next_ipc    \
       57*19		/ <decimal-integer>	    / [a_code = error_table_$io_not_assigned]	/ AUDIT_RET \
       58*20		/ <any-token>	    / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       59*all_ipcs		/ <all_ipc_att>	    / LEX (1)				/ exit  \
       60*22		/		 / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       61*do_mca		/		 / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       62*
       63*read_verb		/ config		 / LEX (1)				/ exit \
       64*25		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       65*26		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       66*
       67*target_verb	/ ipc		   / LEX (1)				/ ck_ipc_att \
       68*28		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       69*29		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       70*
       71*ck_ipc_att	/ <ipc_num_att>	   / LEX (1)				/ ck_via \
       72*31		/ <decimal-integer>	   / [a_code = error_table_$io_not_assigned]	/ AUDIT_RET \
       73*32		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       74*33		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       75*
       76*ck_via		/ via		   / LEX (1)				/ ck_imu \
       77*35		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       78*36		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       79*
       80*ck_imu		/ imu		   / LEX (1)				/ ck_imu_num \
       81*38		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       82*39		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       83*
       84*ck_imu_num	/ <valid_imu>	   / LEX(1)				/ ck_using \
       85*41		/ <any-token>	   / [a_code = code]			/ AUDIT_RET \
       86*42		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       87*
       88*ck_using		/ using		   / LEX (1)				/ ck_technique \
       89*44		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
       90*45		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
       91*
       92*\" Parse the <technique>
       93*ck_technique 	/ diag		   / LEX (1)				/ ck_options  \
       94*47		/ disp		   / LEX (1)				/ ck_options  \
       95*48		/ qry		   / LEX (1)				/ ck_options  \
       96*49		/ dpm		   / LEX (1)				/ ck_options  \
       97*50		/ mdr		   / LEX (1)				/ ck_options  \
       98*51		/ nft		   / LEX (1)				/ ck_options  \
       99*52		/ self		   / LEX (1)				/ ck_options  \
      100*53		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
      101*54		/ <no-token>	   / [a_code = error_table_$noarg]		/ RETURN \
      102*
      103*ck_options	/ <no-token>	   / [a_code = 0]				/ RETURN \
      104*56		/ options		   / LEX (1)				/ exit \
      105*57		/ <any-token>	   / [a_code = error_table_$bad_arg]		/ AUDIT_RET \
      106*
      107*exit		/ <no-token>	   / [a_code = 0]				/ RETURN \
      108*59		/ <any-token>	   / [a_code = error_table_$too_many_args]	/ AUDIT_RET \
      109*AUDIT_RET		/		 / audit_err				/ RETURN \
      110*++*/
      111 
      112 /* Externial Entries */
      113 
      114 dcl  access_audit_r1_$log_general	entry options (variable);
      115 dcl  cv_dec_check_ 	entry (char(*), fixed bin(35)) returns(fixed bin(35));
      116 dcl  get_process_id_ entry() returns(bit(36));
      117 dcl  lex_string_$init_lex_delims entry (char (*), char (*), char (*), char (*), char (*), bit (*),
      118 		     char (*) var, char (*) var, char (*) var, char (*) var);
      119 dcl  lex_string_$lex entry (ptr, fixed bin, fixed bin, ptr, bit(*), char(*),
      120                         char(*), char(*), char(*), char(*), char(*) var, char(*) var,
      121 		    char(*) var, char(*) var, ptr, ptr, fixed bin(35));
      122 dcl translator_temp_$get_segment entry (char(*) aligned, ptr, fixed bin(35));
      123 dcl translator_temp_$release_all_segments entry (ptr, fixed bin (35));
      124 
      125 dcl cleanup condition;
      126 
      127 /* Error_table */
      128 
      129 dcl error_table_$bad_arg fixed bin(35) ext static;
      130 dcl error_table_$too_many_args fixed bin(35) ext static;
      131 dcl error_table_$noarg fixed bin(35) ext static;
      132 dcl error_table_$not_attached fixed bin(35) ext static;
      133 dcl error_table_$io_not_assigned fixed bin(35) ext static;
      134 dcl error_table_$io_no_path fixed bin(35) ext static;
      135 
      136 /* Ext static var */
      137 
      138 dcl  access_operations_$invalid_mca bit (36) aligned ext static;
      139 
      140 /* Automatic */
      141 
      142 dcl (APstmt, APtoken) ptr;
      143 dcl (LEXDLM,LEXCTL) char (32) var aligned;
      144 dcl a_code fixed bin (35);
      145 dcl a_data_ptr ptr;
      146 dcl a_data_len fixed bin;
      147 dcl a_mcad_ptr ptr;
      148 dcl a_user_level fixed bin;
      149 dcl audit_eventflags bit (36);
      150 dcl areap ptr;
      151 dcl code fixed bin (35);
      152 dcl  data char (data_len) based (data_ptr);
      153 dcl  command char (data_len) based (command_ptr);
      154 dcl command_ptr ptr;
      155 dcl data_ptr ptr;
      156 dcl data_len fixed bin;
      157 dcl imu_path_num fixed bin;
      158 dcl ipc_att_num fixed bin init (0);
      159 dcl my_pid bit (36);
      160 dcl user_level fixed bin;
      161 
      162 /* Builtins */
      163 
      164 dcl (addr, hbound, lbound, null, translate) builtin;
      165 
      166 /* Constants */
      167 dcl  lower char (26) static options (constant)
      168 	init ("abcdefghijklmnopqrstuvwxyz");
      169 dcl  UPPER char (26) static options (constant)
      170 	init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
      171 dcl TRUE bit (1) init ("1"b) static options (constant);
      172 dcl FALSE bit (1) init ("0"b) static options (constant);
      173 dcl myname char (10) aligned init ("mca_parse_") static options (constant);
      174 
      175 
      176 	my_pid = get_process_id_ ();
      177 	mcad_ptr = a_mcad_ptr;
      178 	if my_pid ^= mcad.attach_pid then do;
      179 	   a_code = error_table_$not_attached;
      180 	   return;
      181 	   end;
      182 	data_ptr = a_data_ptr;
      183 	data_len = a_data_len;
      184           user_level = a_user_level;
      185 	areap = null ();
      186 	command_ptr = null ();
      187 
      188 	on cleanup begin;
      189 	    if areap ^= null () then call translator_temp_$release_all_segments (areap, (0));
      190 	end;
      191 
      192 	call translator_temp_$get_segment (myname, areap, code);
      193 	if areap = null () then do;
      194 	   a_code = code;
      195 	   return;
      196 	   end;
      197 
      198 
      199 
      200 	command_ptr = allocate (areap,data_len);          
      201 
      202           command = translate (data,lower,UPPER);
      203 
      204 	call lex_string_$init_lex_delims
      205 	   ("", "", "", "","", "11"b," ", " ", LEXDLM, LEXCTL);
      206 
      207 	call lex_string_$lex (command_ptr, data_len, 0, areap, "0110"b,
      208 	   "", "", "", "","", " ", " ",
      209 	   LEXDLM, LEXCTL, APstmt, APtoken, code);
      210 
      211 	if code ^= 0 then do;
      212 	   a_code = code;
      213 	   return;
      214 	   end;
      215 	Pstmt = APstmt;
      216 	Pthis_token = APtoken;
      217 
      218 	a_code = 0;
      219 	call SEMANTIC_ANALYSIS ();
      220 
      221 error_ret:
      222           if areap ^= null () then call translator_temp_$release_all_segments (areap, (0));
      223 
      224           return;
      225 
      226 
      227 all_ipc_att:
      228 	proc () returns (bit (1));
      229 dcl ret_bit bit (1);
      230 	ret_bit = "1"b;
      231 	do ipc_att_num = lbound(mcad.ipcd_array,1) to hbound(mcad.ipcd_array,1) while (ret_bit = "1"b);
      232 	   if mcad.ipcd_array(ipc_att_num).level_1_state >
      233 	      PH_NOT_PRESENT then ret_bit = ipc_is_att ();
      234 	   end;
      235 	return (ret_bit);
      236 	end all_ipc_att;
      237 
      238 ipc_num_att:
      239           proc () returns (bit (1));
      240           ipc_att_num = cv_dec_check_ (token_value,code);
      241 	if code ^= 0 then return (FALSE);
      242           token.Nvalue = ipc_att_num;
      243 	return (ipc_is_att());
      244 end ipc_num_att;	      
      245 
      246 ipc_is_att:
      247 	proc () returns (bit (1));
      248           if mcad.ipcd_array (ipc_att_num).state >= IPC_ATTACHED
      249              then return (TRUE);
      250 	else
      251 	   return (FALSE);
      252 	end ipc_is_att;
      253  
      254 
      255 valid_imu:
      256        proc () returns (bit (1));
      257        imu_path_num =  cv_dec_check_ (token_value,code) + 1;
      258        if code ^= 0 then do;
      259 	 code = error_table_$bad_arg;
      260 	 return (FALSE);
      261        end;
      262        else do;
      263 	if imu_path_num ^= mcad.imu_number then do;
      264 	   a_code = error_table_$io_no_path;
      265 	   return (FALSE);
      266 	   end;
      267 	return (TRUE);
      268 	end;
      269        end valid_imu;
      270 
      271 
      272 
      273 audit_err: proc;
      274 
      275 	audit_eventflags = "0"b;
      276 	addr (audit_eventflags) -> audit_event_flags.special_op = "1"b;
      277 	addr (audit_eventflags) -> audit_event_flags.grant = "0"b;
      278 	call access_audit_r1_$log_general (myname,user_level,
      279 	     audit_eventflags,access_operations_$invalid_mca,"",a_code,
      280                null (),0,"^a", data);
      281 end audit_err;
      282 
  1     1 /* BEGINNING OF:	translator_temp_alloc.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  translator_temp_alloc.incl.pl1					*/
  1     6 	/*									*/
  1     7 	/*      This include segment allocates space in a translator's temporary segment.  It 	*/
  1     8 	/* contains a complete space allocation function 'allocate' which can be a quick PL/I	*/
  1     9 	/* internal procedure in the program which includes this include segment.  The temporary	*/
  1    10 	/* segment should be one obtained by using the translator_temp_ subroutine.		*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created by:  G. C. Dixon  in  January, 1975.				*/
  1    15 	/* 1) Modified by: G. C. Dixon  in  February, 1981 - use limit area structure.		*/
  1    16 	/*									*/
  1    17 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    18 
  1    19 
  1    20 
  1    21 allocate:	procedure (Parea, ANwords) returns (ptr);
  1    22 
  1    23      dcl	Parea			ptr,		/* ptr to the temporary segment. (In)		*/
  1    24 	ANwords			fixed bin;	/* number of words to be allocated. (In)	*/
  1    25 
  1    26      dcl	Nwords			fixed bin,	/* number of words to be allocated, rounded up	*/
  1    27 						/* to a 0 mod 2 quantity.			*/
  1    28 	P			ptr,		/* a temporary pointer.			*/
  1    29 	code			fixed bin(35),	/* a status code.				*/
  1    30          (mod, null, ptr)		builtin;
  1    31 
  1    32      dcl	1 area			based (Parea),
  1    33 	  2 Pfirst_temp_seg		ptr unal,		/*   ptr to first temp seg of a group.		*/
  1    34 	  2 Ofree			fixed bin(35),	/*   offset of next free word in temp seg.	*/
  1    35 	  2 Lfree			fixed bin(35);	/*   length of remaining free space in temp seg.	*/
  1    36 
  1    37      dcl	translator_temp_$get_next_segment
  1    38 				entry (ptr, ptr, fixed bin(35));
  1    39 
  1    40 	Nwords = ANwords + mod (ANwords, 2);		/* round up word count to 0 + mod 2 quantity.	*/
  1    41 	if Nwords > Lfree then do;			/* handle area overflow.			*/
  1    42 	     call translator_temp_$get_next_segment (Parea, P, code);
  1    43 	     if P = null then return (null);
  1    44 	     Parea = P;
  1    45 	     if Nwords > area.Lfree then return (null);
  1    46 	     end;
  1    47 	P = ptr (Parea, area.Ofree);			/* get pointer to next free word of area.	*/
  1    48 	area.Ofree = area.Ofree + Nwords;		/* increase offset of remaining free space.	*/
  1    49 	area.Lfree = area.Lfree - Nwords;		/* decrease length of remaining free space.	*/
  1    50 	return (P);
  1    51 
  1    52 	end allocate;
  1    53 
  1    54 /* END OF:	translator_temp_alloc.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      283 
      284 
  2     1 /* begin include file - access_audit_eventflags.incl.pl1 */
  2     2 /* NOTE: This include file has an ALM counterpart made with cif.
  2     3*Keep it up to date. */
  2     4 
  2     5 dcl 1 audit_event_flags	based aligned,
  2     6       2 special_op	bit (1) unal,  /* special sys operation */
  2     7       2 grant	bit (1) unal,  /* operation was successful */
  2     8       2 admin_op	bit (1) unal,  /* administrative operation */
  2     9       2 priv_op	bit (1) unal,  /* privileged operation */
  2    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  2    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  2    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  2    13       2 pad	bit (29) unal;
  2    14 
  2    15 /* end include file - access_audit_eventflags.incl.pl1 */
      285 
      286 
  3     1 /*	Begin  include file ... mca_data.incl.pl1
  3     2*   *
  3     3*   *	Created on 09/14/84 by Paul Farley.
  3     4*   *      Modified by R. A. Fawcett 10/25/84
  3     5**/
  3     6 
  3     7 /****^  HISTORY COMMENTS:
  3     8*  1) change(85-09-11,Fawcett), approve(85-09-11,MCR6979),
  3     9*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  3    10*     Created for MCA
  3    11*     support
  3    12*  2) change(86-08-19,Fawcett), approve(86-08-19,MCR7374),
  3    13*     audit(86-08-26,Lippard), install(86-09-16,MR12.0-1159):
  3    14*     Fix problems found in audit of the Online manager code.
  3    15*                                                   END HISTORY COMMENTS */
  3    16 
  3    17 dcl  MCA_data_version_1 char (8) int static options
  3    18 	(constant) init ("MCA00001");
  3    19 
  3    20 dcl  mca_data_seg_ptr ptr static init (null ());
  3    21 
  3    22 dcl  mcad_ptr ptr;
  3    23 
  3    24 dcl  ipcd_ptr ptr;
  3    25 
  3    26 dcl  1 mca_data_seg based (mca_data_seg_ptr),
  3    27        2 version char (8),
  3    28        2 array (1:4) like mcad;
  3    29 
  3    30 
  3    31 dcl  1 mcad based (mcad_ptr) aligned,
  3    32        2 lock bit (36),				/* The mca write lock. */
  3    33        2 state fixed bin,				/* Current mca state */
  3    34        2 attach_time fixed bin (71),			/* DT/time of attach */
  3    35        2 attach_pid bit (36),				/* PID of attaching process */
  3    36        2 name char (1),				/* name of this mca (a b c d) */
  3    37        2 imu_number fixed bin (17),			/* number of the IMU */
  3    38        2 ioi_idx fixed bin,				/* value to use with ioi_ */
  3    39        2 event_chn fixed bin (71),			/* ipc channel for IO processing ring_1 */
  3    40        2 ioi_wks_ptr ptr,				/* pointer to IOI Workspace */
  3    41        2 max_ws_size fixed bin (19),
  3    42        2 pad fixed bin,
  3    43        2 user_ptr ptr,				/* used for async_io */
  3    44        2 return_data_ptr ptr,				/* user for async_io */
  3    45        2 io_param_ptr ptr,				/* pointer to the io_parameter_block for mca returned data */
  3    46        2 entry_to_return_data entry (ptr, fixed bin (21), fixed bin (35)),
  3    47 						/* entry that will return the data to the user for async_io */
  3    48        2 status_offset fixed bin,			/* offset into work space for status */
  3    49        2 current_ws_size fixed bin (18),		/* current work_space */
  3    50        2 rcp_id bit (36),
  3    51        2 flags unaligned,
  3    52          3 async_io bit (1),				/* 1 = outer ring will catch IO events */
  3    53 						/* 0 = ring 1 will go blocked and wait for IO to complete */
  3    54          3 config_data_requested bit (1),		/* used during mca attachment */
  3    55          3 pad bit (34),
  3    56        2 max_time_out fixed bin (71),			/* maximum time for time out */
  3    57        2 last_status bit (71),			/* most recent MCA status return */
  3    58 
  3    59        2 ipcd_array (0:15) like ipcd aligned;
  3    60 
  3    61 dcl  1 ipcd based (ipcd_ptr) aligned,
  3    62        2 ipc_name char (8),				/* "ipcXX" */
  3    63        2 channel fixed bin (17) unaligned,		/* base channel */
  3    64        2 nchan fixed bin (17) unaligned,		/* number of channels */
  3    65        2 type_info,					/* type of IPC */
  3    66          3 no_level_2_info bit (1) unaligned,
  3    67          3 is_micro_cont bit (1) unaligned,
  3    68          3 fbus_disable_latch bit (1) unaligned,
  3    69          3 pad bit (6) unaligned,
  3    70          3 type_index fixed bin (8) unaligned,
  3    71        2 state fixed bin (17) unaligned,		/* current state */
  3    72        2 level_1_state fixed bin (17),			/* LVL-1_STATE  */
  3    73        2 prph_attachments fixed bin (17),		/* # of RCP attachments */
  3    74        2 attach_data (8),
  3    75          3 prph_name char (4),			/* Multics prph name */
  3    76          3 flags unaligned,
  3    77 	 4 attached_thru_rcp bit (1),			/* must detach when done */
  3    78 	 4 io_suspended bit (1),			/* must resume IO when done */
  3    79 	 4 pad (34) bit (1),
  3    80          3 attach_time fixed bin (71),			/* DT/time of attach */
  3    81          3 ipc_rcp_id bit (36),			/* rcp id */
  3    82          3 ipc_ioi_idx fixed bin;			/* index from rcp */
  3    83 
  3    84 dcl  SYSTEM_DIR char (17) init (">system_library_1") static options (constant);
  3    85 dcl  DATA_SEG char (12) init ("mca_data_seg") static options (constant);
  3    86 
  3    87 
  3    88 dcl  (MCA_NOT_CONFIGURED init (0),			/* possible mcad.state values */
  3    89      MCA_FREE init (1),
  3    90      MCA_ATTACHING init (2),
  3    91      MCA_ATTACHED init (3),
  3    92      MAINT_SESSION init (10)) fixed bin internal static options (constant);
  3    93 
  3    94 dcl  (IPC_NOT_CONFIGURED init (0),			/* possible ipcd.state values */
  3    95      IPC_FREE init (1),
  3    96      IPC_ATTACHED init (2)) fixed bin internal static options (constant);
  3    97 
  3    98 /*	End of include file ... mca_data.incl.pl1	*/
      287 
      288 
  4     1 /* Begin mca_constants.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 
  4     6 /****^  HISTORY COMMENTS:
  4     7*  1) change(86-03-19,Fawcett), approve(86-03-19,MCR7374),
  4     8*     audit(86-04-28,Lippard), install(86-09-16,MR12.0-1159):
  4     9*     Constants used for values returned from MCA.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 dcl  NO_CONFIG_PRESENT fixed bin init (0) static options (constant);
  4    13 dcl  NOT_CONFIGED fixed bin init (1) static options (constant);
  4    14 dcl  PH_NOT_PRESENT fixed bin init (2) static options (constant);
  4    15 dcl  BASIC_ROM_FAILED fixed bin init (3) static options (constant);
  4    16 dcl  JAM_FAILED fixed bin init (4) static options (constant);
  4    17 dcl  SELF_FAILED fixed bin init (5) static options (constant);
  4    18 dcl  HW_ID_NO_MATCH fixed bin init (6) static options (constant);
  4    19 dcl  CON_SET_UP_FAILED fixed bin init (7) static options (constant);
  4    20 dcl  RSO_FAILED fixed bin init (8) static options (constant);
  4    21 dcl  FW_NOT_FOUND fixed bin init (9) static options (constant);
  4    22 dcl  FW_LOAD_FAILED fixed bin init (10) static options (constant);
  4    23 dcl  ALTER_NOT_FOUND fixed bin init (11) static options (constant);
  4    24 dcl  ALTER_LOAD_FAILED fixed bin init (12) static options (constant);
  4    25 dcl  FW_EXEC_FAILED fixed bin init (13) static options (constant);
  4    26 dcl  OPERATIONAL fixed bin init (14) static options (constant);
  4    27 dcl  STOP_ON_COND fixed bin init (15) static options (constant);
  4    28 
  4    29 dcl  PSIA_2_TRIP fixed bin init (1) static options (constant);
  4    30 dcl  IPC_PDSI fixed bin init (2) static options (constant);
  4    31 dcl  IPC_CONS_2 fixed bin init (3) static options (constant);
  4    32 dcl  IPC_DAI fixed bin init (4) static options (constant);
  4    33 dcl  IPC_IDI fixed bin init (5) static options (constant);
  4    34 dcl  IPC_TAPE_FIPS fixed bin init (6) static options (constant);
  4    35 dcl  IPC_DISK_FIPS fixed bin init (7) static options (constant);
  4    36 dcl  NDIC fixed bin init (9) static options (constant);
  4    37 dcl  PSIA_4_TRIP fixed bin init (15) static options (constant);
  4    38  
  4    39 dcl TYPE (0:15) char (9) init ("N/A","psia_2","ur-pdsi","cons_2","ur-dai",
  4    40 			"idi","fips","fips","N/A","ndic",
  4    41 			"N/A","N/A","N/A","N/A","N/A","psia_4");
  4    42 	
  4    43 
  4    44 /* End mca_constants.incl.pl1 */
      290 
      291 
      292      dcl	TRACING			bit(1) aligned int static init("0"b);
      293 
      294 
  5     1 	/* START OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     4 	/*							*/
  5     5 	/* N__a_m_e:  rdc_start_.incl.pl1					*/
  5     6 	/*							*/
  5     7 	/*      This include segment is used by compilers generated by the	*/
  5     8 	/* reduction_compiler.  Such compilers include a SEMANTIC_ANALYSIS	*/
  5     9 	/* subroutine generated by the reduction_compiler.  This subroutine	*/
  5    10 	/* compares a chain of input tokens with token requirements		*/
  5    11 	/* specified in reductions.  This include segment declares the 	*/
  5    12 	/* structure of the input tokens (which are generated by lex_string_),*/
  5    13 	/* defines the beginning of the SEMANTIC_ANALYSIS procedure, and	*/
  5    14 	/* declares Pthis_token, a global pointer variable which points to	*/
  5    15 	/* the "current" token being referenced by SEMANTIC_ANALYSIS.	*/
  5    16 	/*							*/
  5    17 	/* S__t_a_t_u_s							*/
  5    18 	/*							*/
  5    19 	/* 0) Created:  April, 1974 by G. C. Dixon			*/
  5    20 	/*							*/
  5    21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    22 
  5    23      dcl	Pthis_token		ptr;		/* ptr to the "current" token being acted upon.	*/
  5    24 
  6     1 	/*  START OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  6     2 	
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     4 	/*							*/
  6     5 	/* Name:  lex_descriptors_.incl.pl1				*/
  6     6 	/*							*/
  6     7 	/*      This include segment defines the structure of the token	*/
  6     8 	/* descriptor, statement descriptor, and comment descriptor created	*/
  6     9 	/* by the lex_string_ program.				*/
  6    10 	/*							*/
  6    11 	/* Status:						*/
  6    12 	/*							*/
  6    13 	/* 0) Created:  Dec, 1973 by G. C. Dixon			*/
  6    14 	/*							*/
  6    15 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6    16 	
  6    17 	
  6    18 	
  6    19 	
  6    20      dcl	
  6    21 	1 comment			aligned based (Pcomment),
  6    22 						/* descriptor for a comment.			*/
  6    23 	  2 group1		unaligned,
  6    24 	    3 version		fixed bin(17),	/* comment descriptor version.		*/
  6    25 	    3 size		fixed bin(17),	/* comment descriptor size (in words).		*/
  6    26 	  2 Pnext			ptr unal,		/* ptr to next comment descriptor.		*/
  6    27 	  2 Plast			ptr unal,		/* ptr to last comment descriptor.		*/
  6    28 	  2 Pvalue		ptr unal,		/* ptr to comment.				*/
  6    29 	  2 Lvalue		fixed bin(18),	/* length of comment.			*/
  6    30 	  2 group2		unaligned,
  6    31 	    3 line_no		fixed bin(17),	/* line no of line containing comment.		*/
  6    32 	    3 S,					/* switches:				*/
  6    33 	      4 before_stmt		bit(1),		/* comment is before 1st token of stmt.		*/
  6    34 	      4 contiguous		bit(1),		/* no tokens between this and last comment.	*/
  6    35 	      4 pad		bit(16),
  6    36 	comment_value		char(comment.Lvalue) based (comment.Pvalue),
  6    37 						/* body of comment.				*/
  6    38 	Pcomment			ptr;		/* ptr to comment descriptor.			*/
  6    39 	
  6    40      dcl	
  6    41 	1 stmt			aligned based (Pstmt),
  6    42 						/* descriptor for a statement.		*/
  6    43 	  2 group1		unaligned,
  6    44 	    3 version		fixed bin(17),	/* statement descriptor version.		*/
  6    45 	    3 size		fixed bin(17),	/* statement descriptor size (in words).	*/
  6    46 	  2 Pnext			ptr unal,		/* ptr to next statement descriptor.		*/
  6    47 	  2 Plast			ptr unal,		/* ptr to last statement descriptor.		*/
  6    48 	  2 Pvalue		ptr unal,		/* ptr to statement.			*/
  6    49 	  2 Lvalue		fixed bin(18),	/* length of statement.			*/
  6    50 	  2 Pfirst_token		ptr unal,		/* ptr to 1st token of statement.		*/
  6    51 	  2 Plast_token		ptr unal,		/* ptr to last token of statement.		*/
  6    52 	  2 Pcomments		ptr unal,		/* ptr to comments in statement.		*/
  6    53 	  2 Puser			ptr unal,		/* user-defined ptr.			*/
  6    54 	  2 group2		unaligned,
  6    55 	    3 Ntokens		fixed bin(17),	/* number of tokens in statement.		*/
  6    56 	    3 line_no		fixed bin(17),	/* line no of line on which statement begins.	*/
  6    57 	    3 Istmt_in_line		fixed bin(17),	/* number of stmts in line containing this stmt.	*/
  6    58 						/* (the number includes this stmt.)		*/
  6    59 	    3 semant_type		fixed bin(17),	/* semantic type of the statement.		*/
  6    60 	    3 S,					/* switches:				*/
  6    61 	      4 error_in_stmt	bit(1),		/* stmt contains a syntactic error.		*/
  6    62 	      4 output_in_err_msg	bit(1),		/* stmt has been output in previous error message.*/
  6    63 	      4 pad		bit(34),
  6    64 	stmt_value		char(stmt.Lvalue) based (stmt.Pvalue),
  6    65 						/* text of the statement.			*/
  6    66 	Pstmt			ptr;		/* ptr to a stmt descriptor. 			*/
  6    67 	
  6    68      dcl	
  6    69 	1 token			aligned based (Ptoken),
  6    70 						/* descriptor for a token.			*/
  6    71 	  2 group1		unaligned,
  6    72 	    3 version		fixed bin(17),	/* token descriptor version.			*/
  6    73 	    3 size		fixed bin(17),	/* token descriptor size (in words).		*/
  6    74 	  2 Pnext			ptr unal,		/* ptr to next token descriptor.		*/
  6    75 	  2 Plast			ptr unal,		/* ptr to last token descriptor.		*/
  6    76 	  2 Pvalue		ptr unal,		/* ptr to token.				*/
  6    77 	  2 Lvalue		fixed bin(18),	/* length of token.				*/
  6    78 	  2 Pstmt			ptr unal,		/* ptr to descriptor of stmt containing token.	*/
  6    79 	  2 Psemant		ptr unal,		/* ptr to descriptor(s) of token's semantic value.*/
  6    80 	  2 group2		unaligned,
  6    81 	    3 Itoken_in_stmt	fixed bin(17),	/* position of token within its statement.	*/
  6    82 	    3 line_no		fixed bin(17),	/* line number of the line containing the token.	*/
  6    83 	    3 Nvalue		fixed bin(35),	/* numeric value of decimal-integer tokens.	*/
  6    84 	    3 S,					/* switches:				*/
  6    85 	      4 end_of_stmt		bit(1),		/* token is an end-of-stmt token.		*/
  6    86 	      4 quoted_string	bit(1),		/* token is a quoted string.			*/
  6    87 	      4 quotes_in_string	bit(1),		/* on if quote-close delimiters appear in quoted	*/
  6    88 						/* string (as doubled quotes on input.)		*/
  6    89 	      4 quotes_doubled	bit(1),		/* on if quotes in the string are doubled after	*/
  6    90 						/* string has been lexed into a token.		*/
  6    91 	      4 pad2		bit(32),
  6    92 	token_value		char(token.Lvalue) based (token.Pvalue),
  6    93 						/* value of the token.			*/
  6    94 	Ptoken			ptr;		/* ptr to a token descriptor.			*/
  6    95 
  6    96 	/*  END OF:	lex_descriptors_.incl.pl1	  *  *  *  *  *  *  */
  5    25 
  5    26 
  5    27 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5    28 
  5    29 
  5    30 SEMANTIC_ANALYSIS:	procedure;			/* procedure which analyzes the syntax and	*/
  5    31 						/* semantics of the tokens in the input list.	*/
  5    32 
  5    33      dcl						/*	automatic variables			*/
  5    34 	LTOKEN_REQD_VALUE		fixed bin(18),	/* length of a token requirement.		*/
  5    35 	NRED			fixed bin,	/* number of the reduction tokens are being	*/
  5    36 						/* compared to.				*/
  5    37 	PRED			ptr,		/* ptr to the reduction tokens are being	*/
  5    38 						/* compared to.				*/
  5    39 	PTOKEN_REQD		ptr,		/* ptr to token requirement descriptor associated	*/
  5    40 						/* with reduction tokens are being compared to.	*/
  5    41 	PTOKEN_REQD_VALUE		ptr,		/* ptr to a token requirement.		*/
  5    42 	STOKEN_FCN		bit(1) aligned,	/* return value from a relative syntax function.	*/
  5    43 	CODE			fixed bin(35),	/* an error code.				*/
  5    44 	I			fixed bin,	/* a do-group index.			*/
  5    45 	NUMBER			fixed bin(35);	/* fixed binary representation of a decimal 	*/
  5    46 						/* number character string.			*/
  5    47 
  5    48      dcl						/*	based variables			*/
  5    49 	1 RED			aligned based (PRED),
  5    50 						/* descriptor for reduction tokens are being 	*/
  5    51 						/* compared to.				*/
  5    52 	  2 TOKEN_REQD		unaligned,
  5    53 	    3 IFIRST		fixed bin(17) unal,	/* index of first token requirement.		*/
  5    54 	    3 ILAST		fixed bin(17) unal,	/* index of last  token requirement associated	*/
  5    55 						/* with this reduction.			*/
  5    56 	1 TOKEN_REQD		aligned based (PTOKEN_REQD),
  5    57 						/* a token requirement descriptor.		*/
  5    58 	  2 FORM			fixed bin(17) unal,	/* form of the token requirement:		*/
  5    59 						/*  -1 = relative token requirement function;	*/
  5    60 						/*       TYPE = index of the particular token	*/
  5    61 						/*	      function in the token_fcn array.	*/
  5    62 						/*   0 = built-in token requirement function;	*/
  5    63 						/*       TYPE = as defined below.		*/
  5    64 						/*  >0 = absolute token requirement:		*/
  5    65 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
  5    66 						/*       TYPE = length(TOKEN_REQD);		*/
  5    67 	  2 TYPE			fixed bin(17) unal,	/* TYPE of built-in token requirement function:	*/
  5    68 						/*   1 = compile test to see if input token 	*/
  5    69 						/*       chain is exhausted (<no-token>).	*/
  5    70 						/*   2 = compile test for any token value	*/
  5    71 						/*       (<any-token>).			*/
  5    72 						/*   3 = compile test for a PL/I identifier	*/
  5    73 						/*       (<name>) of 32 or fewer characters.	*/
  5    74 						/*   4 = compile test for token which is a	*/
  5    75 						/*       <decimal-integer>.			*/
  5    76 						/*   5 = compile test for token which is a single	*/
  5    77 						/*       backspace character (<BS>).		*/
  5    78 						/*   6 = compile test for a token which is a	*/
  5    79 						/*       <quoted-string>.			*/
  5    80 
  5    81 	1 TOKEN_REQD_STRING		aligned based (PTOKEN_REQD),
  5    82 						/* overlay for an absolute token requirement	*/
  5    83 						/* descriptor.				*/
  5    84 	  2 I			fixed bin(17) unal,	/* index into list of token strings of the	*/
  5    85 						/* absolute token string assoc w/ descriptor.	*/
  5    86 	  2 L			fixed bin(17) unal,	/* length of the absolute token string.		*/
  5    87 	TOKEN_REQD_VALUE		char(LTOKEN_REQD_VALUE) based (PTOKEN_REQD_VALUE);
  5    88 						/* absolute token string which token is reqd	*/
  5    89 						/* to match in order for tokens which are	*/
  5    90 						/* "current" on the list to match the reduction.	*/
  5    91 
  5    92      dcl						/*	builtin functions			*/
  5    93          (addr, max, null, search, substr, verify)
  5    94 				builtin;
  5    95 
  5    96      dcl						/*	entries				*/
  5    97 	cv_dec_check_		entry (char(*), fixed bin(35)) returns (fixed bin(35));
  5    98 
  5    99      dcl						/*	static variables			*/
  5   100 	BACKSPACE			char(1) aligned int static init ("");
  5   101 
  5   102 	/* END OF:	rdc_start_.incl.pl1		  *  *  *  *  *  *  */
      295 
      296 
      297      dcl	DIRECTION			fixed bin init(+1);	/* direction in which tokens compared.		*/
      298 
      299 
      300      dcl	1 REDUCTION (60)		unaligned based (addr (REDUCTIONS)),
      301 						/* object reductions.			*/
      302 	  2 TOKEN_REQD,
      303 	    3 IFIRST		fixed bin(17),	/* index of first required token.		*/
      304 	    3 ILAST		fixed bin(17),	/* index of last required token.		*/
      305 
      306 	REDUCTIONS  (120)		fixed bin(17) unaligned internal static options(constant) initial (
      307 	         1,     1,	/*     1/  load                                                                 */
      308 	         2,     2,	/*     2/  reset                                                                */
      309 	         3,     3,	/*     3/  rload                                                                */
      310 	         4,     4,	/*     4/  test                                                                 */
      311 	         5,     5,	/*     5/  read                                                                 */
      312 	         6,     6,	/*     6/  <no-token>                                                           */
      313 	         7,     7,	/*     7/  <any-token>                                                          */
      314 	         8,     8,	/*     8/  ipc                                                                  */
      315 	         9,     9,	/*     9/  ipcs                                                                 */
      316 	        10,    10,	/*    10/  mca                                                                  */
      317 	         6,     6,	/*    11/  <no-token>                                                           */
      318 	         7,     7,	/*    12/  <any-token>                                                          */
      319 	        11,    11,	/*    13/  <ipc_num_att>                                                        */
      320 	        12,    12,	/*    14/  <decimal-integer>                                                    */
      321 	         7,     7,	/*    15/  <any-token>                                                          */
      322 	         6,     6,	/*    16/  <no-token>                                                           */
      323 	         6,     6,	/*    17/  <no-token>                                                           */
      324 	        11,    11,	/*    18/  <ipc_num_att>                                                        */
      325 	        12,    12,	/*    19/  <decimal-integer>                                                    */
      326 	         7,     7,	/*    20/  <any-token>                                                          */
      327 	        13,    13,	/*    21/  <all_ipc_att>                                                        */
      328 	        14,    13,	/*    22/                                                                       */
      329 	        14,    13,	/*    23/                                                                       */
      330 	        14,    14,	/*    24/  config                                                               */
      331 	         7,     7,	/*    25/  <any-token>                                                          */
      332 	         6,     6,	/*    26/  <no-token>                                                           */
      333 	         8,     8,	/*    27/  ipc                                                                  */
      334 	         7,     7,	/*    28/  <any-token>                                                          */
      335 	         6,     6,	/*    29/  <no-token>                                                           */
      336 	        11,    11,	/*    30/  <ipc_num_att>                                                        */
      337 	        12,    12,	/*    31/  <decimal-integer>                                                    */
      338 	         7,     7,	/*    32/  <any-token>                                                          */
      339 	         6,     6,	/*    33/  <no-token>                                                           */
      340 	        15,    15,	/*    34/  via                                                                  */
      341 	         7,     7,	/*    35/  <any-token>                                                          */
      342 	         6,     6,	/*    36/  <no-token>                                                           */
      343 	        16,    16,	/*    37/  imu                                                                  */
      344 	         7,     7,	/*    38/  <any-token>                                                          */
      345 	         6,     6,	/*    39/  <no-token>                                                           */
      346 	        17,    17,	/*    40/  <valid_imu>                                                          */
      347 	         7,     7,	/*    41/  <any-token>                                                          */
      348 	         6,     6,	/*    42/  <no-token>                                                           */
      349 	        18,    18,	/*    43/  using                                                                */
      350 	         7,     7,	/*    44/  <any-token>                                                          */
      351 	         6,     6,	/*    45/  <no-token>                                                           */
      352 	        19,    19,	/*    46/  diag                                                                 */
      353 	        20,    20,	/*    47/  disp                                                                 */
      354 	        21,    21,	/*    48/  qry                                                                  */
      355 	        22,    22,	/*    49/  dpm                                                                  */
      356 	        23,    23,	/*    50/  mdr                                                                  */
      357 	        24,    24,	/*    51/  nft                                                                  */
      358 	        25,    25,	/*    52/  self                                                                 */
      359 	         7,     7,	/*    53/  <any-token>                                                          */
      360 	         6,     6,	/*    54/  <no-token>                                                           */
      361 	         6,     6,	/*    55/  <no-token>                                                           */
      362 	        26,    26,	/*    56/  options                                                              */
      363 	         7,     7,	/*    57/  <any-token>                                                          */
      364 	         6,     6,	/*    58/  <no-token>                                                           */
      365 	         7,     7,	/*    59/  <any-token>                                                          */
      366 	        27,    26);	/*    60/                                                                       */
      367 
      368      dcl	1 TOKEN_REQUIREMENT (26)	unaligned based (addr (TOKEN_REQUIREMENTS)),
      369 						/* object token requirements.			*/
      370 	  2 FORM			fixed bin(17),	/* form of the token requirement:		*/
      371 						/*  -1 = relative token requirement function;	*/
      372 						/*       TYPE = index of the particular token	*/
      373 						/*	      function in the token_fcn array.	*/
      374 						/*   0 = built-in token requirement function;	*/
      375 						/*       TYPE = as defined below.		*/
      376 						/*  >0 = absolute token requirement:		*/
      377 						/*       FORM = index(TOKEN_STRINGS,TOKEN_REQD);	*/
      378 						/*       TYPE = length(TOKEN_REQD);		*/
      379 	  2 TYPE			fixed bin(17) unal,	/* type of the built-in token requirement	*/
      380 						/* function:				*/
      381 						/*   1 = compile test to see if input token 	*/
      382 						/*       chain is exhausted (<no-token>).	*/
      383 						/*   2 = compile test for any token value	*/
      384 						/*       (<any-token>).			*/
      385 						/*   3 = compile test for a PL/I identifier	*/
      386 						/*       (<name>) of 32 or fewer characters.	*/
      387 						/*   4 = compile test for token which is a	*/
      388 						/*       <decimal-integer>.			*/
      389 						/*   5 = compile test for token which is a single	*/
      390 						/*       backspace character (<BS>).		*/
      391 						/*   6 = compile test for a token which is a	*/
      392 						/*       <quoted-string>.			*/
      393 
      394 	TOKEN_REQUIREMENTS  (52)	fixed bin(17) unaligned internal static options(constant) initial (
      395 	         1,    4,       5,    5,      10,    5,      15,    4,      19,    4,       0,    1,       0,    2,   
      396 	        23,    3,      26,    4,      30,    3,      -1,    1,       0,    4,      -1,    2,      33,    6,   
      397 	        39,    3,      42,    3,      -1,    3,      45,    5,      50,    4,      54,    4,      58,    3,   
      398 	        61,    3,      64,    3,      67,    3,      70,    4,      74,    7);
      399 
      400 
      401      dcl	TOKEN_STRINGS		char(80) aligned based (addr (TOKEN_STRING_ARRAYS)),
      402 						/* object token values.			*/
      403 	TOKEN_STRING_ARRAYS (1)	char(100) aligned internal static options(constant) initial (
      404 	     "loadresetrloadtestreadipcipcsmcaconfigviaimuusingdiagdispqrydpmmdrnftselfoptions");
      405 
      406 	/* START OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(86-02-14,GWMay), approve(), audit(), install():
  7     6*     old history comments:
  7     7*      0) Created: April, 1974 by G. C. Dixon
  7     8*      1) Modified: Feb, 1975  by G. C. Dixon
  7     9*         a) support for Version 2.0 of reduction_compiler.
  7    10*      2) Modified: Feb, 1981  by G. C. Dixon
  7    11*         a) support for Version  2.2 of reduction_compiler
  7    12*      3) Modified: Aug, 1983  by G. C. Dixon - support for Version 2.3 of
  7    13*                        reductions command.
  7    14*  2) change(86-03-04,GDixon), approve(86-03-04,MCR7362), audit(86-03-17,GWMay),
  7    15*     install(86-03-17,MR12.0-1032):
  7    16*     Changed how the PUSH DOWN LANGUAGE (SPDL) definition of <no-token> is
  7    17*     implemented to avoid references through a null pointer.  The two
  7    18*     accepted uses are:
  7    19*     
  7    20*        / <no-token>               / ... / ... \
  7    21*                    A
  7    22*                    |
  7    23*           Pthis_token (points to top of push down stack)
  7    24*     
  7    25*     which checks to see if the push down stack is totally exhausted (ie,
  7    26*     Ptoken = null); and:
  7    27*     
  7    28*        / SPEC1 ... SPECN <no-token>         / ... / ... \
  7    29*                           A
  7    30*                           |
  7    31*                 Pthis_token (points to top of push down stack)
  7    32*     
  7    33*     which checks to see whether SPECN is topmost on the push down stack
  7    34*     AND is the final token in the input list.
  7    35*                                                   END HISTORY COMMENTS */
  7    36 
  7    37 
  7    38 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    39 	/*									*/
  7    40 	/* NAME:  rdc_end_.incl.pl1							*/
  7    41 	/*									*/
  7    42 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  7    43 	/* Such compilers include a SEMANTIC_ANALYSIS subroutine generated by the		*/
  7    44 	/* reduction_compiler.  This subroutine compares a chain of input tokens with token	*/
  7    45 	/* requirements specified in reductions.  The code in this include segment performs the	*/
  7    46 	/* actual comparisons.  This code is the middle part of the SEMANTIC_ANALYSIS procedure.	*/
  7    47 	/*									*/
  7    48 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    49 
  7    50 	TRACING = TRACING;				/* Kludge to prevent pl1 from making TRACING	*/
  7    51 						/*   options(constant) because it is never set.	*/
  7    52 	NRED = 1;
  7    53 	go to RD_TEST_REDUCTION;
  7    54 
  7    55 RD_NEXT_REDUCTION:
  7    56 	NRED = NRED + 1;
  7    57 
  7    58 RD_TEST_REDUCTION:
  7    59 	PRED = addr(REDUCTION(NRED));
  7    60 	Ptoken = Pthis_token;
  7    61 
  7    62 	do I = RED.TOKEN_REQD.IFIRST to RED.TOKEN_REQD.ILAST by DIRECTION;
  7    63 	     PTOKEN_REQD = addr(TOKEN_REQUIREMENT(I));
  7    64 	     if Ptoken = null then do;
  7    65 		if TOKEN_REQD.FORM = 0 then		/* No more tokens.  Only matches <no-token> spec.	*/
  7    66 		     if TOKEN_REQD.TYPE = 1 then
  7    67 			go to RD_TEST_TOKEN(1);
  7    68 		go to RD_NEXT_REDUCTION;
  7    69 		end;
  7    70 	     if TOKEN_REQD.FORM = 0 then do;		/* built-in syntax function.			*/
  7    71 		go to RD_TEST_TOKEN(TOKEN_REQD.TYPE);
  7    72 
  7    73 RD_TEST_TOKEN(1):   if SPDL then			/* <no-token>				*/
  7    74 						/* In push-down-language, there are 2 		*/
  7    75 						/*   interpretations of <no-token>.		*/
  7    76 		     if      RED.TOKEN_REQD.IFIRST = RED.TOKEN_REQD.ILAST &
  7    77 			   Ptoken = null then	/* When <no-token> is only spec, the spec asks 	*/
  7    78 			go to RD_MATCH_NO_TOKEN;	/* "Is push down stack empty (all input gone)?"   */
  7    79 		     else if RED.TOKEN_REQD.IFIRST^= RED.TOKEN_REQD.ILAST &
  7    80 			   RED.TOKEN_REQD.IFIRST = I &
  7    81 			   token.Pnext = null then	/* For SPEC1 ... SPECN <no-token>, the spec asks  */
  7    82 			go to RD_MATCH_NO_TOKEN;	/* "Are the topmost tokens on stack SPEC1 - SPECN,*/
  7    83 						/*  and is SPECN the final input token?"	*/
  7    84 		     else go to RD_NEXT_REDUCTION;	/* Those are the only two defs allowed in push	*/
  7    85 						/* down language mode for <no-token>.		*/
  7    86 		else if Ptoken = null then
  7    87 		     go to RD_MATCH_NO_TOKEN;
  7    88 		go to RD_NEXT_REDUCTION;
  7    89 
  7    90 RD_TEST_TOKEN(2):	go to RD_MATCH;			/* <any-token>				*/
  7    91 
  7    92 RD_TEST_TOKEN(3):	if token.Lvalue > 0 &		/* <name>					*/
  7    93 		   token.Lvalue <= 32 & ^token.S.quoted_string then
  7    94 		     if search(substr(token_value,1,1),"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
  7    95 		     > 0 then
  7    96 			if verify(token_value,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_$")
  7    97 			= 0 then
  7    98 			     go to RD_MATCH;
  7    99 		go to RD_NEXT_REDUCTION;
  7   100 
  7   101 RD_TEST_TOKEN(4):					/* <decimal-integer>			*/
  7   102 		if token.Nvalue ^= 0 then		/* token already determined to be a number.	*/
  7   103 		     go to RD_MATCH;
  7   104 		if token.S.quoted_string then
  7   105 		     go to RD_NEXT_REDUCTION;
  7   106 		NUMBER = cv_dec_check_ (token_value, CODE);
  7   107 		if CODE = 0 then do;
  7   108 		     token.Nvalue = NUMBER;
  7   109 		     go to RD_MATCH;
  7   110 		     end;
  7   111 		go to RD_NEXT_REDUCTION;
  7   112 
  7   113 RD_TEST_TOKEN(5):	if token.Lvalue = 1 then		/* <BS>					*/
  7   114 		     if token_value = BACKSPACE & ^token.S.quoted_string then
  7   115 			go to RD_MATCH;
  7   116 		go to RD_NEXT_REDUCTION;
  7   117 
  7   118 RD_TEST_TOKEN(6):	if token.S.quoted_string then		/* <quoted-string>				*/
  7   119 		     go to RD_MATCH;
  7   120 		go to RD_NEXT_REDUCTION;
  7   121 		end;
  7   122 
  7   123 	     else if TOKEN_REQD.FORM > 0 then do;	/* absolute syntax specification.		*/
  7   124 		if token.S.quoted_string then
  7   125 		     go to RD_NEXT_REDUCTION;
  7   126 		PTOKEN_REQD_VALUE = addr(substr(TOKEN_STRINGS,TOKEN_REQD_STRING.I));
  7   127 		LTOKEN_REQD_VALUE = TOKEN_REQD_STRING.L;
  7   128 		if token_value = TOKEN_REQD_VALUE then
  7   129 		     go to RD_MATCH;
  7   130 		go to RD_NEXT_REDUCTION;
  7   131 		end;
  7   132 
  7   133 	/* END OF:	rdc_end_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      406 
      407 
      408 	     else do;				/* relative syntax function.			*/
      409 		go to RD_TOKEN_FCN(TOKEN_REQD.TYPE);
      410 
      411 RD_TOKEN_FCN(1):	STOKEN_FCN = ipc_num_att();
      412 		go to RD_TEST_RESULT;
      413 RD_TOKEN_FCN(2):	STOKEN_FCN = all_ipc_att();
      414 		go to RD_TEST_RESULT;
      415 RD_TOKEN_FCN(3):	STOKEN_FCN = valid_imu();
      416 		go to RD_TEST_RESULT;
      417 
      418 RD_TEST_RESULT:	if STOKEN_FCN then go to RD_MATCH;
      419 		else go to RD_NEXT_REDUCTION;
      420 		end;
      421 
      422 RD_MATCH:      Ptoken = token.Pnext;
      423 RD_MATCH_NO_TOKEN:
      424 	     end;
      425 	Ptoken = Pthis_token;
      426 	go to RD_ACTION(NRED);
      427 
      428 
      429 RD_ACTION(1):					/* /					*/
      430 	call 					     LEX ( 1 );
      431 	NRED = 8;
      432 	go to RD_TEST_REDUCTION;			/* / load_rest_tar \                   		*/
      433 
      434 RD_ACTION(2):					/* /					*/
      435 	call 					     LEX ( 1 );
      436 	NRED = 8;
      437 	go to RD_TEST_REDUCTION;			/* / load_rest_tar \                   		*/
      438 
      439 RD_ACTION(3):					/* /					*/
      440 	call 					     LEX ( 1 );
      441 	NRED = 8;
      442 	go to RD_TEST_REDUCTION;			/* / load_rest_tar \                   		*/
      443 
      444 RD_ACTION(4):					/* /					*/
      445 	call 					     LEX ( 1 );
      446 	NRED = 27;
      447 	go to RD_TEST_REDUCTION;			/* / target_verb \                     		*/
      448 
      449 RD_ACTION(5):					/* /					*/
      450 	call 					     LEX ( 1 );
      451 	NRED = 24;
      452 	go to RD_TEST_REDUCTION;			/* / read_verb \                       		*/
      453 
      454 RD_ACTION(6):					/* /					*/
      455 						     a_code = error_table_$noarg;
      456 	return;					/* / RETURN	\			*/
      457 
      458 RD_ACTION(7):					/* /					*/
      459 						     a_code = error_table_$bad_arg;
      460 	NRED = 60;
      461 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      462 
      463 RD_ACTION(8):					/* /					*/
      464 	call 					     LEX ( 1 );
      465 	NRED = 13;
      466 	go to RD_TEST_REDUCTION;			/* / ft_ipc \                          		*/
      467 
      468 RD_ACTION(9):					/* /					*/
      469 	NRED = 21;
      470 	go to RD_TEST_REDUCTION;			/* / all_ipcs \                        		*/
      471 
      472 RD_ACTION(10):					/* /					*/
      473 	call 					     LEX ( 1 );
      474 	NRED = 23;
      475 	go to RD_TEST_REDUCTION;			/* / do_mca \                          		*/
      476 
      477 RD_ACTION(11):					/* /					*/
      478 						     a_code = error_table_$noarg;
      479 	return;					/* / RETURN	\			*/
      480 
      481 RD_ACTION(12):					/* /					*/
      482 						     a_code = error_table_$bad_arg;
      483 	NRED = 60;
      484 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      485 
      486 RD_ACTION(13):					/* /					*/
      487 	call 					     LEX ( 1 );
      488 	NRED = 17;
      489 	go to RD_TEST_REDUCTION;			/* / next_ipc \                        		*/
      490 
      491 RD_ACTION(14):					/* /					*/
      492 						     a_code = error_table_$io_not_assigned;
      493 	NRED = 60;
      494 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      495 
      496 RD_ACTION(15):					/* /					*/
      497 						     a_code = error_table_$bad_arg;
      498 	NRED = 60;
      499 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      500 
      501 RD_ACTION(16):					/* /					*/
      502 						     a_code = error_table_$noarg;
      503 	return;					/* / RETURN	\			*/
      504 
      505 RD_ACTION(17):					/* /					*/
      506 	NRED = 58;
      507 	go to RD_TEST_REDUCTION;			/* / exit \                            		*/
      508 
      509 RD_ACTION(18):					/* /					*/
      510 	call 					     LEX ( 1 );
      511 	NRED = 17;
      512 	go to RD_TEST_REDUCTION;			/* / next_ipc \                        		*/
      513 
      514 RD_ACTION(19):					/* /					*/
      515 						     a_code = error_table_$io_not_assigned;
      516 	NRED = 60;
      517 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      518 
      519 RD_ACTION(20):					/* /					*/
      520 						     a_code = error_table_$bad_arg;
      521 	NRED = 60;
      522 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      523 
      524 RD_ACTION(21):					/* /					*/
      525 	call 					     LEX ( 1 );
      526 	NRED = 58;
      527 	go to RD_TEST_REDUCTION;			/* / exit \                            		*/
      528 
      529 RD_ACTION(22):					/* /					*/
      530 						     a_code = error_table_$bad_arg;
      531 	NRED = 60;
      532 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      533 
      534 RD_ACTION(23):					/* /					*/
      535 						     a_code = error_table_$bad_arg;
      536 	NRED = 60;
      537 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      538 
      539 RD_ACTION(24):					/* /					*/
      540 	call 					     LEX ( 1 );
      541 	NRED = 58;
      542 	go to RD_TEST_REDUCTION;			/* / exit \                            		*/
      543 
      544 RD_ACTION(25):					/* /					*/
      545 						     a_code = error_table_$bad_arg;
      546 	NRED = 60;
      547 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      548 
      549 RD_ACTION(26):					/* /					*/
      550 						     a_code = error_table_$noarg;
      551 	return;					/* / RETURN	\			*/
      552 
      553 RD_ACTION(27):					/* /					*/
      554 	call 					     LEX ( 1 );
      555 	NRED = 30;
      556 	go to RD_TEST_REDUCTION;			/* / ck_ipc_att \                      		*/
      557 
      558 RD_ACTION(28):					/* /					*/
      559 						     a_code = error_table_$bad_arg;
      560 	NRED = 60;
      561 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      562 
      563 RD_ACTION(29):					/* /					*/
      564 						     a_code = error_table_$noarg;
      565 	return;					/* / RETURN	\			*/
      566 
      567 RD_ACTION(30):					/* /					*/
      568 	call 					     LEX ( 1 );
      569 	NRED = 34;
      570 	go to RD_TEST_REDUCTION;			/* / ck_via \                          		*/
      571 
      572 RD_ACTION(31):					/* /					*/
      573 						     a_code = error_table_$io_not_assigned;
      574 	NRED = 60;
      575 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      576 
      577 RD_ACTION(32):					/* /					*/
      578 						     a_code = error_table_$bad_arg;
      579 	NRED = 60;
      580 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      581 
      582 RD_ACTION(33):					/* /					*/
      583 						     a_code = error_table_$noarg;
      584 	return;					/* / RETURN	\			*/
      585 
      586 RD_ACTION(34):					/* /					*/
      587 	call 					     LEX ( 1 );
      588 	NRED = 37;
      589 	go to RD_TEST_REDUCTION;			/* / ck_imu \                          		*/
      590 
      591 RD_ACTION(35):					/* /					*/
      592 						     a_code = error_table_$bad_arg;
      593 	NRED = 60;
      594 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      595 
      596 RD_ACTION(36):					/* /					*/
      597 						     a_code = error_table_$noarg;
      598 	return;					/* / RETURN	\			*/
      599 
      600 RD_ACTION(37):					/* /					*/
      601 	call 					     LEX ( 1 );
      602 	NRED = 40;
      603 	go to RD_TEST_REDUCTION;			/* / ck_imu_num \                      		*/
      604 
      605 RD_ACTION(38):					/* /					*/
      606 						     a_code = error_table_$bad_arg;
      607 	NRED = 60;
      608 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      609 
      610 RD_ACTION(39):					/* /					*/
      611 						     a_code = error_table_$noarg;
      612 	return;					/* / RETURN	\			*/
      613 
      614 RD_ACTION(40):					/* /					*/
      615 	call 					     LEX ( 1 );
      616 	NRED = 43;
      617 	go to RD_TEST_REDUCTION;			/* / ck_using \                        		*/
      618 
      619 RD_ACTION(41):					/* /					*/
      620 						     a_code = code;
      621 	NRED = 60;
      622 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      623 
      624 RD_ACTION(42):					/* /					*/
      625 						     a_code = error_table_$noarg;
      626 	return;					/* / RETURN	\			*/
      627 
      628 RD_ACTION(43):					/* /					*/
      629 	call 					     LEX ( 1 );
      630 	NRED = 46;
      631 	go to RD_TEST_REDUCTION;			/* / ck_technique \                    		*/
      632 
      633 RD_ACTION(44):					/* /					*/
      634 						     a_code = error_table_$bad_arg;
      635 	NRED = 60;
      636 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      637 
      638 RD_ACTION(45):					/* /					*/
      639 						     a_code = error_table_$noarg;
      640 	return;					/* / RETURN	\			*/
      641 
      642 RD_ACTION(46):					/* /					*/
      643 	call 					     LEX ( 1 );
      644 	NRED = 55;
      645 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      646 
      647 RD_ACTION(47):					/* /					*/
      648 	call 					     LEX ( 1 );
      649 	NRED = 55;
      650 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      651 
      652 RD_ACTION(48):					/* /					*/
      653 	call 					     LEX ( 1 );
      654 	NRED = 55;
      655 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      656 
      657 RD_ACTION(49):					/* /					*/
      658 	call 					     LEX ( 1 );
      659 	NRED = 55;
      660 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      661 
      662 RD_ACTION(50):					/* /					*/
      663 	call 					     LEX ( 1 );
      664 	NRED = 55;
      665 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      666 
      667 RD_ACTION(51):					/* /					*/
      668 	call 					     LEX ( 1 );
      669 	NRED = 55;
      670 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      671 
      672 RD_ACTION(52):					/* /					*/
      673 	call 					     LEX ( 1 );
      674 	NRED = 55;
      675 	go to RD_TEST_REDUCTION;			/* / ck_options \                      		*/
      676 
      677 RD_ACTION(53):					/* /					*/
      678 						     a_code = error_table_$bad_arg;
      679 	NRED = 60;
      680 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      681 
      682 RD_ACTION(54):					/* /					*/
      683 						     a_code = error_table_$noarg;
      684 	return;					/* / RETURN	\			*/
      685 
      686 RD_ACTION(55):					/* /					*/
      687 						     a_code = 0;
      688 	return;					/* / RETURN	\			*/
      689 
      690 RD_ACTION(56):					/* /					*/
      691 	call 					     LEX ( 1 );
      692 	NRED = 58;
      693 	go to RD_TEST_REDUCTION;			/* / exit \                            		*/
      694 
      695 RD_ACTION(57):					/* /					*/
      696 						     a_code = error_table_$bad_arg;
      697 	NRED = 60;
      698 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      699 
      700 RD_ACTION(58):					/* /					*/
      701 						     a_code = 0;
      702 	return;					/* / RETURN	\			*/
      703 
      704 RD_ACTION(59):					/* /					*/
      705 						     a_code = error_table_$too_many_args;
      706 	NRED = 60;
      707 	go to RD_TEST_REDUCTION;			/* / AUDIT_RET \                       		*/
      708 
      709 RD_ACTION(60):					/* /					*/
      710 	call					     audit_err();
      711 	return;					/* / RETURN	\			*/
      712 
      713 
      714 	end SEMANTIC_ANALYSIS;
      715 
      716 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      717 
      718      dcl	SPDL			bit(1) aligned init ("0"b);
      719 						/* off: This compiler parses a non-PUSH DOWN	*/
      720 						/*      LANGUAGE.				*/
      721 	/* START OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8     4 	/*									*/
  8     5 	/* N__a_m_e:  rdc_lex_.incl.pl1							*/
  8     6 	/*									*/
  8     7 	/*      This include segment is used by compilers generated by the reduction_compiler.	*/
  8     8 	/* It contains the LEX subroutine which is used to manipulate the pointer to the	*/
  8     9 	/* "current" token, Pthis_token.						*/
  8    10 	/*									*/
  8    11 	/* E__n_t_r_y:  LEX								*/
  8    12 	/*									*/
  8    13 	/*      This entry makes the |_nth|-next (or -preceding) token the "current" token, where	*/
  8    14 	/* _n is its positive (or negative) input argument.				*/
  8    15 	/*									*/
  8    16 	/* U__s_a_g_e									*/
  8    17 	/*									*/
  8    18 	/*      call LEX(n);							*/
  8    19 	/*									*/
  8    20 	/* 1) n   is the number of the token to be made the "current" token, relative to the	*/
  8    21 	/*        token identified by Pthis_token (the present "current" token).  If n is	*/
  8    22 	/*        positive, the nth token following the "current" token made "current".  If n	*/
  8    23 	/*        is negative, the nth token preceding the "current" token is made "current".	*/
  8    24 	/*									*/
  8    25 	/* S__t_a_t_u_s									*/
  8    26 	/*									*/
  8    27 	/* 0) Created by:  G. C. Dixon  in  February, 1975				*/
  8    28 	/*									*/
  8    29 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    30 
  8    31 LEX:	procedure (n);
  8    32 
  8    33      dcl	n			fixed bin,
  8    34 	i			fixed bin;
  8    35 
  8    36 	Ptoken = Pthis_token;			/* do everything relative to "current" token.	*/
  8    37 	if Ptoken = null then return;			/* can't lex if token list exhausted.		*/
  8    38 	if n >= 0 then do;				/* new "current" token will follow present one.	*/
  8    39 	     do i = 1 to n while (token.Pnext ^= null);	/* find new "current" token, taking care not to	*/
  8    40 		Ptoken = token.Pnext;		/*   run off end of token list.		*/
  8    41 		end;
  8    42 	     if ^SPDL then if i <= n then Ptoken = null;	/* if not in 'PUSH DOWN LANGUAGE' mode, allow	*/
  8    43 						/*   running off end of token list.		*/
  8    44 	     end;
  8    45 	else					/* new "current" token precedes present one.	*/
  8    46 	     do i = -1 to n by -1 while (token.Plast ^= null);
  8    47 		Ptoken = token.Plast;
  8    48 		end;
  8    49 	Pthis_token = Ptoken;			/* simple wasn't it.			*/
  8    50 
  8    51 	end LEX;
  8    52 
  8    53 /* END OF:	rdc_lex_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      721 
      722 
      723 	end mca_parse_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/30/86  1144.1  mca_parse_.pl1                    >spec>install>1203>mca_parse_.pl1
283          1    07/22/81  2045.0  translator_temp_alloc.incl.pl1    >ldd>include>translator_temp_alloc.incl.pl1
285          2    01/30/85  1523.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
287          3    09/18/86  1317.5  mca_data.incl.pl1                 >ldd>include>mca_data.incl.pl1
289          4    09/18/86  1317.5  mca_constants.incl.pl1            >ldd>include>mca_constants.incl.pl1
295          5    04/18/75  1242.4  rdc_start_.incl.pl1               >ldd>include>rdc_start_.incl.pl1
5-25         6    04/18/75  1242.4  lex_descriptors_.incl.pl1         >ldd>include>lex_descriptors_.incl.pl1
406          7    03/17/86  1534.3  rdc_end_.incl.pl1                 >ldd>include>rdc_end_.incl.pl1
721          8    04/18/75  1242.4  rdc_lex_.incl.pl1                 >ldd>include>rdc_lex_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ANwords                                parameter       fixed bin(17,0)          dcl 1-23 ref 1-21 1-40 1-40
APstmt                          000106 automatic       pointer                  dcl 142 set ref 207* 215
APtoken                         000110 automatic       pointer                  dcl 142 set ref 207* 216
BACKSPACE                       003430 constant        char(1)                  initial dcl 5-99 ref 7-113
CODE                            000325 automatic       fixed bin(35,0)          dcl 5-33 set ref 7-106* 7-107
DIRECTION                       000330 automatic       fixed bin(17,0)          initial dcl 297 set ref 7-62 297*
FALSE                                  constant        bit(1)                   initial unaligned dcl 172 ref 241 250 260 265
FORM                                   based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-65 7-70
                                                                                  7-123
I                                      based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD_STRING" packed
                                                                                  unaligned dcl 5-48 in procedure
                                                                                  "SEMANTIC_ANALYSIS" ref 7-126
I                               000326 automatic       fixed bin(17,0)          dcl 5-33 in procedure "SEMANTIC_ANALYSIS" set ref
                                                                                  7-62* 7-63 7-79*
IFIRST                                 based           fixed bin(17,0)          level 3 packed unaligned dcl 5-48 ref 7-62 7-73 7-79
                                                                                  7-79
ILAST                     0(18)        based           fixed bin(17,0)          level 3 packed unaligned dcl 5-48 ref 7-62 7-73 7-79
IPC_ATTACHED                           constant        fixed bin(17,0)          initial dcl 3-94 ref 248
L                         0(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-48 ref 7-127
LEXCTL                          000123 automatic       varying char(32)         dcl 143 set ref 204* 207*
LEXDLM                          000112 automatic       varying char(32)         dcl 143 set ref 204* 207*
LTOKEN_REQD_VALUE               000314 automatic       fixed bin(18,0)          dcl 5-33 set ref 7-127* 7-128
Lfree                     2            based           fixed bin(35,0)          level 2 dcl 1-32 set ref 1-41 1-45 1-49* 1-49
Lvalue                    4            based           fixed bin(18,0)          level 2 dcl 6-68 ref 240 240 257 257 7-92 7-92 7-92
                                                                                  7-92 7-106 7-106 7-113 7-113 7-128
NRED                            000315 automatic       fixed bin(17,0)          dcl 5-33 set ref 7-52* 7-55* 7-55 7-58 426 431* 436*
                                                                                  441* 446* 451* 460* 465* 468* 474* 483* 488* 493*
                                                                                  498* 505* 511* 516* 521* 526* 531* 536* 541* 546*
                                                                                  555* 560* 569* 574* 579* 588* 593* 602* 607* 616*
                                                                                  621* 630* 635* 644* 649* 654* 659* 664* 669* 674*
                                                                                  679* 692* 697* 706*
NUMBER                          000327 automatic       fixed bin(35,0)          dcl 5-33 set ref 7-106* 7-108
Nvalue                   10            based           fixed bin(35,0)          level 3 packed unaligned dcl 6-68 set ref 242* 7-101
                                                                                  7-108*
Nwords                          000300 automatic       fixed bin(17,0)          dcl 1-26 set ref 1-40* 1-41 1-45 1-48 1-49
Ofree                     1            based           fixed bin(35,0)          level 2 dcl 1-32 set ref 1-47 1-48* 1-48
P                               000302 automatic       pointer                  dcl 1-26 set ref 1-42* 1-43 1-44 1-47* 1-50
PH_NOT_PRESENT                         constant        fixed bin(17,0)          initial dcl 4-14 ref 232
PRED                            000316 automatic       pointer                  dcl 5-33 set ref 7-58* 7-62 7-62 7-73 7-73 7-79 7-79
                                                                                  7-79
PTOKEN_REQD                     000320 automatic       pointer                  dcl 5-33 set ref 7-63* 7-65 7-65 7-70 7-71 7-123
                                                                                  7-126 7-127 409
PTOKEN_REQD_VALUE               000322 automatic       pointer                  dcl 5-33 set ref 7-126* 7-128
Parea                                  parameter       pointer                  dcl 1-23 set ref 1-21 1-41 1-42* 1-44* 1-45 1-47
                                                                                  1-47 1-48 1-48 1-49 1-49
Plast                     2            based           pointer                  level 2 packed unaligned dcl 6-68 ref 8-45 8-47
Pnext                     1            based           pointer                  level 2 packed unaligned dcl 6-68 ref 7-79 422 8-39
                                                                                  8-40
Pstmt                           000224 automatic       pointer                  dcl 6-40 set ref 215*
Pthis_token                     000222 automatic       pointer                  dcl 5-23 set ref 216* 7-60 425 8-36 8-49*
Ptoken                          000226 automatic       pointer                  dcl 6-68 set ref 240 240 240 242 257 257 257 7-60*
                                                                                  7-64 7-73 7-79 7-86 7-92 7-92 7-92 7-92 7-92 7-92
                                                                                  7-92 7-101 7-104 7-106 7-106 7-106 7-108 7-113
                                                                                  7-113 7-113 7-113 7-118 7-124 7-128 7-128 422* 422
                                                                                  425* 8-36* 8-37 8-39 8-40* 8-40 8-42* 8-45 8-47*
                                                                                  8-47 8-49
Pvalue                    3            based           pointer                  level 2 packed unaligned dcl 6-68 ref 240 257 7-92
                                                                                  7-92 7-106 7-113 7-128
RED                                    based           structure                level 1 dcl 5-48
REDUCTION                              based           structure                array level 1 packed unaligned dcl 300 set ref 7-58
REDUCTIONS                      000170 constant        fixed bin(17,0)          initial array unaligned dcl 300 set ref 7-58
S                        11            based           structure                level 3 packed unaligned dcl 6-68
SPDL                            000230 automatic       bit(1)                   initial dcl 718 set ref 718* 7-73 8-42
STOKEN_FCN                      000324 automatic       bit(1)                   dcl 5-33 set ref 411* 413* 415* 418
TOKEN_REQD                             based           structure                level 1 dcl 5-48 in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD                             based           structure                level 2 in structure "RED" packed unaligned dcl 5-48
                                                                                  in procedure "SEMANTIC_ANALYSIS"
TOKEN_REQD_STRING                      based           structure                level 1 dcl 5-48
TOKEN_REQD_VALUE                       based           char                     unaligned dcl 5-48 ref 7-128
TOKEN_REQUIREMENT                      based           structure                array level 1 packed unaligned dcl 368 set ref 7-63
TOKEN_REQUIREMENTS              000136 constant        fixed bin(17,0)          initial array unaligned dcl 368 set ref 7-63
TOKEN_STRINGS                          based           char(80)                 dcl 401 set ref 7-126
TOKEN_STRING_ARRAYS             000105 constant        char(100)                initial array dcl 401 set ref 7-126
TRACING                         000010 internal static bit(1)                   initial dcl 292 set ref 7-50* 7-50
TRUE                                   constant        bit(1)                   initial unaligned dcl 171 ref 248 267
TYPE                      0(18)        based           fixed bin(17,0)          level 2 in structure "TOKEN_REQD" packed unaligned
                                                                                  dcl 5-48 in procedure "SEMANTIC_ANALYSIS" ref 7-65
                                                                                  7-71 409
TYPE                            000156 automatic       char(9)                  initial array unaligned dcl 4-39 in procedure
                                                                                  "mca_parse_" set ref 4-39* 4-39* 4-39* 4-39* 4-39*
                                                                                  4-39* 4-39* 4-39* 4-39* 4-39* 4-39* 4-39* 4-39*
                                                                                  4-39* 4-39* 4-39*
UPPER                           000267 constant        char(26)                 initial unaligned dcl 169 ref 202
a_code                                 parameter       fixed bin(35,0)          dcl 144 set ref 28 179* 194* 212* 218* 264* 278*
                                                                                  454* 458* 477* 481* 491* 496* 501* 514* 519* 529*
                                                                                  534* 544* 549* 558* 563* 572* 577* 582* 591* 596*
                                                                                  605* 610* 619* 624* 633* 638* 677* 682* 686* 695*
                                                                                  700* 704*
a_data_len                             parameter       fixed bin(17,0)          dcl 146 ref 28 183
a_data_ptr                             parameter       pointer                  dcl 145 ref 28 182
a_mcad_ptr                             parameter       pointer                  dcl 147 ref 28 177
a_user_level                           parameter       fixed bin(17,0)          dcl 148 ref 28 184
access_audit_r1_$log_general    000012 constant        entry                    external dcl 114 ref 278
access_operations_$invalid_mca  000044 external static bit(36)                  dcl 138 set ref 278*
addr                                                   builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-58
                                                                                  7-58 7-63 7-63 7-126 7-126
addr                                                   builtin function         dcl 164 in procedure "mca_parse_" ref 276 277
area                                   based           structure                level 1 unaligned dcl 1-32
areap                           000136 automatic       pointer                  dcl 150 set ref 185* 189 189* 192* 193 200* 207* 221
                                                                                  221*
attach_pid                4            based           bit(36)                  level 2 dcl 3-31 ref 178
audit_event_flags                      based           structure                level 1 dcl 2-5
audit_eventflags                000134 automatic       bit(36)                  unaligned dcl 149 set ref 275* 276 277 278*
cleanup                         000100 stack reference condition                dcl 125 ref 188
code                            000304 automatic       fixed bin(35,0)          dcl 1-26 in procedure "allocate" set ref 1-42*
code                            000140 automatic       fixed bin(35,0)          dcl 151 in procedure "mca_parse_" set ref 192* 194
                                                                                  207* 211 212 240* 241 257* 258 259* 619
command                                based           char                     unaligned dcl 153 set ref 202*
command_ptr                     000142 automatic       pointer                  dcl 154 set ref 186* 200* 202 207*
cv_dec_check_                   000050 constant        entry                    external dcl 5-96 in procedure "SEMANTIC_ANALYSIS"
                                                                                  ref 7-106
cv_dec_check_                   000014 constant        entry                    external dcl 115 in procedure "mca_parse_" ref 240
                                                                                  257
data                                   based           char                     unaligned dcl 152 set ref 202 278*
data_len                        000146 automatic       fixed bin(17,0)          dcl 156 set ref 183* 200* 202 202 207* 278 278
data_ptr                        000144 automatic       pointer                  dcl 155 set ref 182* 202 278
error_table_$bad_arg            000030 external static fixed bin(35,0)          dcl 129 ref 259 458 481 496 519 529 534 544 558 577
                                                                                  591 605 633 677 695
error_table_$io_no_path         000042 external static fixed bin(35,0)          dcl 134 ref 264
error_table_$io_not_assigned    000040 external static fixed bin(35,0)          dcl 133 ref 491 514 572
error_table_$noarg              000034 external static fixed bin(35,0)          dcl 131 ref 454 477 501 549 563 582 596 610 624 638
                                                                                  682
error_table_$not_attached       000036 external static fixed bin(35,0)          dcl 132 ref 179
error_table_$too_many_args      000032 external static fixed bin(35,0)          dcl 130 ref 704
get_process_id_                 000016 constant        entry                    external dcl 116 ref 176
grant                     0(01)        based           bit(1)                   level 2 packed unaligned dcl 2-5 set ref 277*
group2                    7            based           structure                level 2 packed unaligned dcl 6-68
hbound                                                 builtin function         dcl 164 ref 231
i                               000362 automatic       fixed bin(17,0)          dcl 8-33 set ref 8-39* 8-42 8-45*
imu_number                6            based           fixed bin(17,0)          level 2 dcl 3-31 ref 263
imu_path_num                    000147 automatic       fixed bin(17,0)          dcl 157 set ref 257* 263
ipc_att_num                     000150 automatic       fixed bin(17,0)          initial dcl 158 set ref 158* 231* 232* 240* 242 248
ipcd                                   based           structure                level 1 dcl 3-61
ipcd_array               40            based           structure                array level 2 dcl 3-31 ref 231 231
lbound                                                 builtin function         dcl 164 ref 231
level_1_state            45            based           fixed bin(17,0)          array level 3 dcl 3-31 ref 232
lex_string_$init_lex_delims     000020 constant        entry                    external dcl 117 ref 204
lex_string_$lex                 000022 constant        entry                    external dcl 119 ref 207
lower                           000276 constant        char(26)                 initial unaligned dcl 167 ref 202
mcad                                   based           structure                level 1 dcl 3-31
mcad_ptr                        000154 automatic       pointer                  dcl 3-22 set ref 177* 178 231 231 232 248 263
mod                                                    builtin function         dcl 1-26 ref 1-40
my_pid                          000151 automatic       bit(36)                  unaligned dcl 159 set ref 176* 178
myname                          000264 constant        char(10)                 initial dcl 173 set ref 192* 278*
n                                      parameter       fixed bin(17,0)          dcl 8-33 ref 8-31 8-38 8-39 8-42 8-45
null                                                   builtin function         dcl 1-26 in procedure "allocate" ref 1-43 1-43 1-45
null                                                   builtin function         dcl 164 in procedure "mca_parse_" ref 185 186 189
                                                                                  193 221 278 278 8-37 8-39 8-42 8-45
null                                                   builtin function         dcl 5-92 in procedure "SEMANTIC_ANALYSIS" ref 7-64
                                                                                  7-73 7-79 7-86
ptr                                                    builtin function         dcl 1-26 ref 1-47
quoted_string            11(01)        based           bit(1)                   level 4 packed unaligned dcl 6-68 ref 7-92 7-104
                                                                                  7-113 7-118 7-124
ret_bit                         000240 automatic       bit(1)                   unaligned dcl 229 set ref 230* 231 232* 235
search                                                 builtin function         dcl 5-92 ref 7-92
special_op                             based           bit(1)                   level 2 packed unaligned dcl 2-5 set ref 276*
state                    44            based           fixed bin(17,0)          array level 3 packed unaligned dcl 3-31 ref 248
substr                                                 builtin function         dcl 5-92 ref 7-92 7-126
token                                  based           structure                level 1 dcl 6-68
token_value                            based           char                     unaligned dcl 6-68 set ref 240* 257* 7-92 7-92
                                                                                  7-106* 7-113 7-128
translate                                              builtin function         dcl 164 ref 202
translator_temp_$get_next_segment
                                000046 constant        entry                    external dcl 1-37 ref 1-42
translator_temp_$get_segment    000024 constant        entry                    external dcl 122 ref 192
translator_temp_$release_all_segments
                                000026 constant        entry                    external dcl 123 ref 189 221
user_level                      000152 automatic       fixed bin(17,0)          dcl 160 set ref 184* 278*
verify                                                 builtin function         dcl 5-92 ref 7-92

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ALTER_LOAD_FAILED                      internal static fixed bin(17,0)          initial dcl 4-24
ALTER_NOT_FOUND                        internal static fixed bin(17,0)          initial dcl 4-23
BASIC_ROM_FAILED                       internal static fixed bin(17,0)          initial dcl 4-15
CON_SET_UP_FAILED                      internal static fixed bin(17,0)          initial dcl 4-19
DATA_SEG                               internal static char(12)                 initial unaligned dcl 3-85
FW_EXEC_FAILED                         internal static fixed bin(17,0)          initial dcl 4-25
FW_LOAD_FAILED                         internal static fixed bin(17,0)          initial dcl 4-22
FW_NOT_FOUND                           internal static fixed bin(17,0)          initial dcl 4-21
HW_ID_NO_MATCH                         internal static fixed bin(17,0)          initial dcl 4-18
IPC_CONS_2                             internal static fixed bin(17,0)          initial dcl 4-31
IPC_DAI                                internal static fixed bin(17,0)          initial dcl 4-32
IPC_DISK_FIPS                          internal static fixed bin(17,0)          initial dcl 4-35
IPC_FREE                               internal static fixed bin(17,0)          initial dcl 3-94
IPC_IDI                                internal static fixed bin(17,0)          initial dcl 4-33
IPC_NOT_CONFIGURED                     internal static fixed bin(17,0)          initial dcl 3-94
IPC_PDSI                               internal static fixed bin(17,0)          initial dcl 4-30
IPC_TAPE_FIPS                          internal static fixed bin(17,0)          initial dcl 4-34
JAM_FAILED                             internal static fixed bin(17,0)          initial dcl 4-16
MAINT_SESSION                          internal static fixed bin(17,0)          initial dcl 3-88
MCA_ATTACHED                           internal static fixed bin(17,0)          initial dcl 3-88
MCA_ATTACHING                          internal static fixed bin(17,0)          initial dcl 3-88
MCA_FREE                               internal static fixed bin(17,0)          initial dcl 3-88
MCA_NOT_CONFIGURED                     internal static fixed bin(17,0)          initial dcl 3-88
MCA_data_version_1                     internal static char(8)                  initial unaligned dcl 3-17
NDIC                                   internal static fixed bin(17,0)          initial dcl 4-36
NOT_CONFIGED                           internal static fixed bin(17,0)          initial dcl 4-13
NO_CONFIG_PRESENT                      internal static fixed bin(17,0)          initial dcl 4-12
OPERATIONAL                            internal static fixed bin(17,0)          initial dcl 4-26
PSIA_2_TRIP                            internal static fixed bin(17,0)          initial dcl 4-29
PSIA_4_TRIP                            internal static fixed bin(17,0)          initial dcl 4-37
Pcomment                               automatic       pointer                  dcl 6-20
RSO_FAILED                             internal static fixed bin(17,0)          initial dcl 4-20
SELF_FAILED                            internal static fixed bin(17,0)          initial dcl 4-17
STOP_ON_COND                           internal static fixed bin(17,0)          initial dcl 4-27
SYSTEM_DIR                             internal static char(17)                 initial unaligned dcl 3-84
comment                                based           structure                level 1 dcl 6-20
comment_value                          based           char                     unaligned dcl 6-20
ipcd_ptr                               automatic       pointer                  dcl 3-24
max                                                    builtin function         dcl 5-92
mca_data_seg                           based           structure                level 1 unaligned dcl 3-26
mca_data_seg_ptr                       internal static pointer                  initial dcl 3-20
stmt                                   based           structure                level 1 dcl 6-40
stmt_value                             based           char                     unaligned dcl 6-40

NAMES DECLARED BY EXPLICIT CONTEXT.
LEX                             002714 constant        entry                    internal dcl 8-31 ref 429 434 439 444 449 463 472
                                                                                  486 509 524 539 553 567 586 600 614 628 642 647
                                                                                  652 657 662 667 672 690
RD_ACTION                       000011 constant        label                    array(60) dcl 429 ref 426
RD_MATCH                        002112 constant        label                    dcl 422 ref 7-90 7-92 7-101 7-109 7-113 7-118 7-128
                                                                                  418
RD_MATCH_NO_TOKEN               002115 constant        label                    dcl 423 ref 7-73 7-79 7-86
RD_NEXT_REDUCTION               001601 constant        label                    dcl 7-55 ref 7-68 7-84 7-88 7-99 7-104 7-111 7-116
                                                                                  7-120 7-124 7-130 419
RD_TEST_REDUCTION               001602 constant        label                    dcl 7-58 ref 7-53 432 437 442 447 452 461 466 470
                                                                                  475 484 489 494 499 507 512 517 522 527 532 537
                                                                                  542 547 556 561 570 575 580 589 594 603 608 617
                                                                                  622 631 636 645 650 655 660 665 670 675 680 693
                                                                                  698 707
RD_TEST_RESULT                  002110 constant        label                    dcl 418 ref 412 414 416
RD_TEST_TOKEN                   000000 constant        label                    array(6) dcl 7-73 ref 7-65 7-71
RD_TOKEN_FCN                    000006 constant        label                    array(3) dcl 411 ref 409
SEMANTIC_ANALYSIS               001571 constant        entry                    internal dcl 5-30 ref 219
all_ipc_att                     001146 constant        entry                    internal dcl 227 ref 413
allocate                        001474 constant        entry                    internal dcl 1-21 ref 200
audit_err                       001377 constant        entry                    internal dcl 273 ref 709
error_ret                       001127 constant        label                    dcl 221
ipc_is_att                      001262 constant        entry                    internal dcl 246 ref 232 243
ipc_num_att                     001203 constant        entry                    internal dcl 238 ref 411
mca_parse_                      000416 constant        entry                    external dcl 28
valid_imu                       001305 constant        entry                    internal dcl 255 ref 415

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3656        3730    3432        3666
Length      4320    3432        52         353     224           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mca_parse_                          492 external procedure  is an external procedure.  
on unit on line 188                  72 on unit               
all_ipc_att                             internal procedure  shares stack frame of external procedure mca_parse_.  
ipc_num_att                             internal procedure  shares stack frame of external procedure mca_parse_.  
ipc_is_att                              internal procedure  shares stack frame of external procedure mca_parse_.  
valid_imu                               internal procedure  shares stack frame of external procedure mca_parse_.  
audit_err                               internal procedure  shares stack frame of external procedure mca_parse_.  
allocate                                internal procedure  shares stack frame of external procedure mca_parse_.  
SEMANTIC_ANALYSIS                       internal procedure  shares stack frame of external procedure mca_parse_.  
LEX                                     internal procedure  shares stack frame of external procedure mca_parse_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 TRACING                     mca_parse_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
mca_parse_               000106 APstmt                      mca_parse_
                         000110 APtoken                     mca_parse_
                         000112 LEXDLM                      mca_parse_
                         000123 LEXCTL                      mca_parse_
                         000134 audit_eventflags            mca_parse_
                         000136 areap                       mca_parse_
                         000140 code                        mca_parse_
                         000142 command_ptr                 mca_parse_
                         000144 data_ptr                    mca_parse_
                         000146 data_len                    mca_parse_
                         000147 imu_path_num                mca_parse_
                         000150 ipc_att_num                 mca_parse_
                         000151 my_pid                      mca_parse_
                         000152 user_level                  mca_parse_
                         000154 mcad_ptr                    mca_parse_
                         000156 TYPE                        mca_parse_
                         000222 Pthis_token                 mca_parse_
                         000224 Pstmt                       mca_parse_
                         000226 Ptoken                      mca_parse_
                         000230 SPDL                        mca_parse_
                         000240 ret_bit                     all_ipc_att
                         000300 Nwords                      allocate
                         000302 P                           allocate
                         000304 code                        allocate
                         000314 LTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000315 NRED                        SEMANTIC_ANALYSIS
                         000316 PRED                        SEMANTIC_ANALYSIS
                         000320 PTOKEN_REQD                 SEMANTIC_ANALYSIS
                         000322 PTOKEN_REQD_VALUE           SEMANTIC_ANALYSIS
                         000324 STOKEN_FCN                  SEMANTIC_ANALYSIS
                         000325 CODE                        SEMANTIC_ANALYSIS
                         000326 I                           SEMANTIC_ANALYSIS
                         000327 NUMBER                      SEMANTIC_ANALYSIS
                         000330 DIRECTION                   SEMANTIC_ANALYSIS
                         000362 i                           LEX

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac          mdfx1               enable_op
shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_r1_$log_general  cv_dec_check_                 cv_dec_check_                 get_process_id_
lex_string_$init_lex_delims   lex_string_$lex               translator_temp_$get_next_segment
translator_temp_$get_segment  translator_temp_$release_all_segments

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$invalid_mca                              error_table_$bad_arg          error_table_$io_no_path
error_table_$io_not_assigned  error_table_$noarg            error_table_$not_attached     error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     28 000411       158 000423    4   39 000424       718 000566       176 000567       177 000575       178 000601
    179 000604       180 000607       182 000610       183 000613       184 000615       185 000617       186 000621
    188 000622       189 000636       190 000654       192 000655       193 000676       194 000702       195 000705
    200 000706       202 000710       204 000723       207 001003       211 001113       212 001115       213 001117
    215 001120       216 001122       218 001124       219 001126       221 001127       224 001145       227 001146
    230 001150       231 001152       232 001163       234 001173       235 001175       238 001203       240 001205
    241 001234       242 001244       243 001247       246 001262       248 001264       250 001300       255 001305
    257 001307       258 001340       259 001342       260 001345       263 001353       264 001357       265 001363
    267 001371       273 001377       275 001400       276 001401       277 001403       278 001405       281 001473
 1   21 001474    1   40 001476    1   41 001504    1   42 001510    1   43 001523    1   44 001533    1   45 001536
 1   47 001546    1   48 001555    1   49 001561    1   50 001567    5   30 001571       297 001572    7   50 001574
 7   52 001577    7   53 001600    7   55 001601    7   58 001602    7   60 001605    7   62 001607    7   63 001632
 7   64 001635    7   65 001641    7   68 001651    7   70 001652    7   71 001656    7   73 001660    7   79 001677
 7   84 001710    7   86 001711    7   88 001715    7   90 001716    7   92 001717    7   99 001753    7  101 001754
 7  104 001757    7  106 001762    7  107 002006    7  108 002010    7  109 002013    7  111 002014    7  113 002015
 7  116 002031    7  118 002032    7  120 002036    7  123 002037    7  124 002040    7  126 002044    7  127 002051
 7  128 002055    7  130 002063       409 002064       411 002066       412 002073       413 002074       414 002101
    415 002102       416 002107       418 002110       419 002111       422 002112       423 002115       425 002120
    426 002122       429 002124       431 002130       432 002132       434 002133       436 002137       437 002141
    439 002142       441 002146       442 002150       444 002151       446 002155       447 002157       449 002160
    451 002164       452 002166       454 002167       456 002173       458 002174       460 002200       461 002202
    463 002203       465 002207       466 002211       468 002212       470 002214       472 002215       474 002221
    475 002223       477 002224       479 002230       481 002231       483 002235       484 002237       486 002240
    488 002244       489 002246       491 002247       493 002253       494 002255       496 002256       498 002262
    499 002264       501 002265       503 002271       505 002272       507 002274       509 002275       511 002301
    512 002303       514 002304       516 002310       517 002312       519 002313       521 002317       522 002321
    524 002322       526 002326       527 002330       529 002331       531 002335       532 002337       534 002340
    536 002344       537 002346       539 002347       541 002353       542 002355       544 002356       546 002362
    547 002364       549 002365       551 002371       553 002372       555 002376       556 002400       558 002401
    560 002405       561 002407       563 002410       565 002414       567 002415       569 002421       570 002423
    572 002424       574 002430       575 002432       577 002433       579 002437       580 002441       582 002442
    584 002446       586 002447       588 002453       589 002455       591 002456       593 002462       594 002464
    596 002465       598 002471       600 002472       602 002476       603 002500       605 002501       607 002505
    608 002507       610 002510       612 002514       614 002515       616 002521       617 002523       619 002524
    621 002527       622 002531       624 002532       626 002536       628 002537       630 002543       631 002545
    633 002546       635 002552       636 002554       638 002555       640 002561       642 002562       644 002566
    645 002570       647 002571       649 002575       650 002577       652 002600       654 002604       655 002606
    657 002607       659 002613       660 002615       662 002616       664 002622       665 002624       667 002625
    669 002631       670 002633       672 002634       674 002640       675 002642       677 002643       679 002647
    680 002651       682 002652       684 002656       686 002657       688 002661       690 002662       692 002666
    693 002670       695 002671       697 002675       698 002677       700 002700       702 002702       704 002703
    706 002707       707 002711       709 002712       711 002713    8   31 002714    8   36 002716    8   37 002720
 8   38 002725    8   39 002727    8   40 002741    8   41 002743    8   42 002745    8   44 002755    8   45 002756
 8   47 002771    8   48 002773    8   49 002776    8   51 003000


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
