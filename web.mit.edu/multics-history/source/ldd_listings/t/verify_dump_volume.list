	COMPILATION LISTING OF SEGMENT verify_dump_volume
	Compiled by: Multics PL/I Compiler, Release 32f, of October 9, 1989
	Compiled at: Bull HN, Phoenix AZ, System-M   
	Compiled on: 10/10/89  1418.4 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       14 
       15 verify_dump_volume: vdv: proc;
       16 
       17 /* This command utility can be used to verify the contents of a dump volume produced by the volume dumper.
       18*   In addition it can also be used to produce a long or short form of a map/table of contents of what
       19*   is written on the dump volume.
       20**/
       21 /* Coded 11/4/77 by Dave Vinograd */
       22 /* Modified 5/79 by D. Vinograd to make program check error count befor detaching
       23*   so that proc does not go OOB. Also corrected logig that checked
       24*   pattern at beginning of logical record */
       25 /* Modified: 4/27/82 by GA Texada to change error handling on reads.	   */
       26 /* Modified: 8/82 by GA Texada to fix phx13702			   */
       27 /* Modified: 8/82 by GA Texada to fix phx13702			   */
       28 /* Modified 03/12/85 by Greg Texada to fix phx19165, don't give up so soon when resynching (D. Kitson)	*/
       29 
       30 
       31 /****^  HISTORY COMMENTS:
       32*  1) change(88-10-10,Farley), approve(88-10-10,MCR8005),
       33*     audit(88-10-15,Beattie), install(88-10-17,MR12.2-1173):
       34*     Added new read routine and associated surrounding code to support the
       35*     version 2 volume dump tapes.  These tapes have a pair of unique strings
       36*     that delimit the object data of vtoce_type records.
       37*                                                   END HISTORY COMMENTS */
       38 
       39 
       40 dcl input_volume_desc    char (256);
       41 dcl stop_vtocx	     fixed bin;
       42 dcl vtocx		     fixed bin;
       43 dcl resynch_retry_count  fixed bin;
       44 dcl resynching	     bit (1);
       45 dcl input_buf	     (divide (nelt, CHARS_PER_WORD, 17, 0)) bit (36) based (recordp);
       46 dcl pattern_match_label  label;
       47 dcl volname	     char (32);
       48 dcl att_desc	     char (256);
       49 dcl ignore	     fixed bin (35);
       50 dcl code		     fixed bin (35);
       51 dcl arg		     char (argl) based (argp);
       52 dcl argl		     fixed bin;
       53 dcl argp		     ptr;
       54 dcl brief		     bit (1);
       55 dcl long		     bit (1);
       56 dcl delimited	     bit (1) aligned;		/* ON = reading object data delimited by unique matching strings */
       57 dcl comment	     char (128) var;
       58 dcl type		     char (10) var;
       59 dcl name		     char (168) var;
       60 dcl i		     fixed bin;
       61 dcl iocbp		     ptr;
       62 dcl nelt		     fixed bin (21);
       63 dcl nel		     fixed bin (21);
       64 dcl objectp	     ptr;
       65 dcl input_buffer_ptr     ptr;
       66 dcl input_buffer_start   fixed bin;
       67 dcl input_buffer_len     fixed bin (21);
       68 dcl old_256K_switch	     bit (2) aligned;
       69 dcl tp		     (3) ptr;
       70 
       71 dcl cleanup	     condition;
       72 
       73 dcl word		     (size (backup_volume_header)) bit (36) based (recordp);
       74 dcl string	     bit (BITS_PER_WORD * size (backup_volume_header)) based (recordp);
       75 dcl words_skipped	     fixed bin;
       76 
       77 dcl (error_table_$improper_data_format,
       78   error_table_$data_loss,
       79   error_table_$device_end,
       80   error_table_$end_of_info,
       81   error_table_$bad_arg,
       82   error_table_$badopt,
       83   error_table_$inconsistent,
       84   error_table_$root)     fixed bin (35) ext static;
       85 dcl sys_info$seg_size_256K fixed bin (19) ext static;
       86 dcl sys_info$max_seg_size fixed bin (18) ext static;
       87 
       88 dcl myname	     char (32) static init ("verify_dump_volume") options (constant);
       89 dcl DELIMITED	     bit (1) aligned internal static options (constant)
       90 		     init ("1"b);
       91 dcl FORWARD_CHAR_POSITIONING fixed bin int static init (3) options (constant);
       92 
       93 dcl com_err_	     entry options (variable);
       94 dcl cu_$arg_count	     entry returns (fixed bin);
       95 dcl cu_$arg_ptr	     entry (fixed bin, ptr, fixed bin, fixed bin (35));
       96 dcl cv_oct_check_	     entry (char (*), fixed bin (35)) returns (fixed bin (35));
       97 dcl debug		     entry;
       98 dcl get_temp_segments_   entry (char (*), (*) ptr, fixed bin (35));
       99 dcl hc_backup_$decode_uidpath entry ((0:15) bit (36), char (*), char (*), fixed bin (35));
      100 dcl hcs_$set_256K_switch entry (bit (2) aligned, bit (2) aligned, fixed bin (35));
      101 dcl hcs_$set_max_length_seg entry (ptr, fixed bin (19), fixed bin (35));
      102 dcl hcs_$truncate_seg    entry (ptr, fixed bin (19), fixed bin (35));
      103 dcl ioa_		     entry options (variable);
      104 dcl ioa_$rsnnl	     entry options (variable);
      105 dcl iox_$attach_ioname   entry (char (*), ptr, char (*), fixed bin (35));
      106 dcl release_temp_segments_ entry (char (*), (*) ptr, fixed bin (35));
      107 
      108 dcl (addcharno, addr, divide, index, length, min, null, ptr, rtrim, size, substr) builtin;
      109 
      110 /**** init local control variables */
      111 
      112     stop_vtocx = -1;
      113     brief, long = "0"b;
      114     resynching = "0"b;
      115     input_volume_desc = "";
      116     old_256K_switch = ""b;
      117     tp (*) = null;
      118     iocbp = null;
      119     code = 0;
      120 						/* set up cleanup handler */
      121     on cleanup call finish_;
      122 						/* get name of volume log  - pvname */
      123     call cu_$arg_ptr (1, argp, argl, code);
      124     if code ^= 0 then do;
      125         call ioa_ ("^a: USAGE: ^a volname [-input_volume_desc alternate_attach_description] [-brief|-bf] [-long|-lg] [-stop_vtocx vtocx]", myname, myname);
      126         return;
      127       end;
      128     volname = arg;
      129 						/* get control args */
      130     i = 2;
      131     do while (i <= cu_$arg_count ());
      132       call cu_$arg_ptr (i, argp, argl, code);
      133       if code ^= 0 then goto err;
      134       if arg = "-input_volume_desc" then do;
      135 	i = i + 1;
      136 	call cu_$arg_ptr (i, argp, argl, code);
      137 	if code ^= 0 then goto err;
      138 	input_volume_desc = arg;
      139         end;
      140       else if arg = "-brief" | arg = "-bf" then brief = "1"b;
      141       else if arg = "-long" | arg = "-lg" then long = "1"b;
      142       else if arg = "-stop_vtocx" then do;
      143 	i = i + 1;
      144 	call cu_$arg_ptr (i, argp, argl, code);
      145 	if code ^= 0 then goto err;
      146 	stop_vtocx = cv_oct_check_ (arg, code);
      147 	if code ^= 0 then goto bad_num;
      148         end;
      149       else do;
      150 badopt:	call com_err_ (error_table_$badopt, myname, "^a", arg);
      151 	goto finish;
      152         end;
      153       i = i + 1;
      154     end;
      155 						/* create temp segs */
      156     if brief & long then do;
      157         call com_err_ (error_table_$inconsistent, myname, "-brief & -long");
      158         return;
      159       end;
      160 
      161     call setup_data_segments;
      162     if code ^= 0 then goto err;
      163 
      164     call attach;
      165     if code ^= 0 then goto err;
      166 
      167 /* The search loop  reads successive records from the dump volume until it encounters a volume log with the name
      168*   that matches pvname.  It then creates a segment, if one does not already exist and copies the data into it. The
      169*   dump volume is read until the end of tape is reached. */
      170 
      171 search_loop:
      172     do while (code = 0);
      173       call read_volume_record;
      174     end;
      175 finish:
      176     call finish_;
      177     return;
      178 
      179 err:
      180     call com_err_ (code, myname);
      181     goto finish;
      182 bad_num:
      183     call com_err_ (error_table_$bad_arg, myname, "^a is not an octal number.", arg);
      184     goto finish;
      185 
      186 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      187 
      188 
      189 setup_data_segments: proc;
      190 
      191 /* This proc sets up the data segments used during the verify. */
      192 
      193     call get_temp_segments_ (myname, tp, code);
      194     if code ^= 0 then return;
      195 
      196     recordp = tp (1);
      197     objectp = tp (2);
      198     input_buffer_ptr = tp (3);
      199     call hcs_$set_256K_switch ("11"b, (""b), code);
      200     if code ^= 0 then return;
      201     call hcs_$set_max_length_seg (objectp, sys_info$seg_size_256K, code);
      202     if code ^= 0 then return;
      203     call hcs_$set_max_length_seg (input_buffer_ptr, sys_info$seg_size_256K, code);
      204     if code ^= 0 then return;
      205     input_buffer_start = 1;
      206     input_buffer_len = 0;
      207     return;
      208 
      209   end setup_data_segments;
      210 
      211 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      212 
      213 
      214 attach: proc;
      215 
      216 /* This proc queries the caller for the dump volume name, attaches to it and opens it. */
      217 
      218     if input_volume_desc ^= "" then
      219       call ioa_$rsnnl (input_volume_desc, att_desc, (0), volname);
      220     else call ioa_$rsnnl ("tape_mult_ ^a -system", att_desc, (0), volname);
      221 
      222     call iox_$attach_ioname ("input_volume", iocbp, att_desc, code);
      223     if code ^= 0 then return;
      224 
      225     call iox_$open (iocbp, Stream_input, "0"b, code);
      226     if code ^= 0 then return;
      227 
      228   end attach;
      229 
      230 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      231 
      232 
      233 detach: proc;
      234 
      235 /* This proc closes and detaches the dump volume. */
      236 
      237 
      238     call iox_$close (iocbp, ignore);
      239     call iox_$detach_iocb (iocbp, ignore);
      240     iocbp = null;					/* be sure */
      241 
      242   end detach;
      243 
      244 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      245 
      246 
      247 resynch_volume: proc;
      248 
      249 /* This proc is used for error recovery. It reads the dump volume word by word looking for a match on the
      250*   3 words which are part of the header of the logical dump record. When it gets a match it returns to specified label.
      251*   While resynchronization is in progress , io error handling is suppressed except if we reach the end of a dump
      252*   volume. This code is freely adapted from the volume reloader. */
      253 
      254     resynching = "1"b;
      255     input_buf (*) = "0"b;
      256     nel = CHARS_PER_WORD * size (backup_volume_header);
      257     call read (recordp, nel, nelt, ^DELIMITED, code);
      258     call check_input_error;
      259 
      260     words_skipped = 0;
      261     do while (^(word (1) = pattern1 & word (4) = pattern2 & word (7) = pattern3));
      262 
      263       string = substr (string, 37, (size (backup_volume_header) - 1) * BITS_PER_WORD);
      264       nel = CHARS_PER_WORD;
      265       call read (addr (word (size (backup_volume_header))),
      266 	 nel, nelt, ^DELIMITED, code);
      267       call check_input_error;
      268 
      269       words_skipped = words_skipped + 1;
      270       if words_skipped > 256 * WORDS_PER_PAGE then do;	/* put a limit on it */
      271 	call ioa_ ("^a: resynchronization failed", myname);
      272 	code = error_table_$end_of_info;
      273 	call check_input_error;
      274         end;
      275     end;
      276     call ioa_ ("^a: synchronization completed ^d words skipped", myname,
      277          words_skipped);
      278     resynching = "0"b;
      279     delimited = "0"b;
      280     code = 0;
      281     goto pattern_match_label;
      282 
      283   end resynch_volume;
      284 
      285 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      286 
      287 
      288 skip_chars: proc;
      289 
      290 /* This proc skips forward on a dump volume. */
      291 
      292     nelt = nel;
      293     call read (objectp, nel, nelt, delimited, code);
      294     call check_input_error;
      295 
      296   end skip_chars;
      297 
      298 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      299 
      300 
      301 check_input_error: proc;
      302 
      303 /* This proc is used to check all io errors after a read request.  If no error we return.
      304*   If we are at the end of the dump volume, then it is detached. If a volume log has not been found, a new dump volume is
      305*   requested. Otherwise we are done. If the error is the result of a bad read we start resynchronization.
      306*   If it has already been started we just return. */
      307 
      308     if nel ^= nelt | code ^= 0 then do;
      309         if (code = error_table_$end_of_info | code = error_table_$device_end) then do;
      310 	  if resynching then call com_err_ (code, myname, "Resynching terminated.");
      311 	  call detach;
      312 	  goto finish;
      313 	end;
      314         else if ^resynching then do;
      315 	  if nel ^= nelt then do;
      316 	      if code = error_table_$data_loss then
      317 	        call com_err_ (code, myname, "Incomplete object detected.");
      318 	      else do;
      319 		if code = 0 then call com_err_ (code, myname, "Read did not complete.");
      320 		else call com_err_ (code, myname, "Reading input volume");
      321 	        end;
      322 	    end;
      323 	  else call com_err_ (code, myname, "Reading input volume");
      324 	  call ioa_ ("^a: Resynching started", myname);
      325 	  resynch_retry_count = 0;
      326 	  call resynch_volume;
      327 	end;
      328         else do;
      329 	  resynch_retry_count = resynch_retry_count + 1;	/* keep track so we don't do this forever	*/
      330 	  if resynch_retry_count > 64 then do;
      331 	      call com_err_ (code, myname, "I/O error during resynching.");
      332 	      call detach;
      333 	      goto finish;
      334 	    end;
      335 	end;
      336       end;
      337   end check_input_error;
      338 
      339 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      340 
      341 
      342 read_volume_record: proc;
      343 
      344 /* This proc reads volume dump records and interprets which type they are and
      345*   displays info about them if requested. */
      346 
      347     pattern_match_label = pattern_match;
      348     delimited = "0"b;
      349     nel = CHARS_PER_WORD * size (backup_volume_header);
      350     call read (recordp, nel, nelt, delimited, code);
      351     call check_input_error;
      352 
      353     if backup_volume_record.pattern1 ^= pattern1
      354          | backup_volume_record.pattern2 ^= pattern2
      355          | backup_volume_record.pattern3 ^= pattern3 then do;
      356         code = error_table_$improper_data_format;
      357         call check_input_error;
      358       end;
      359 
      360 pattern_match:
      361     nel = backup_volume_record.rec1_len - size (backup_volume_header) * CHARS_PER_WORD;
      362     call read (ptr (recordp, size (backup_volume_header)),
      363          nel, nelt, delimited, code);
      364     call check_input_error;
      365 
      366     if backup_volume_record.rec2_len > 0 then do;
      367         if backup_volume_record.rec1_type ^= vtoce_type then do;
      368 	  call ioa_ ("Invalid record header");
      369 	  call debug_it ("Volume record at ^p", recordp);
      370 	end;
      371       end;
      372 
      373     comment = "";
      374     vtocx = 0;
      375     if backup_volume_record.rec1_type = vtoce_type then do;
      376         vtocx = backup_volume_record.vtocx;
      377         if stop_vtocx = vtocx then
      378 	call debug_it ("vtoce at ^p", addr (backup_volume_record.vtoce));
      379         if (long | brief) then name = convert_puid_ ();
      380         if backup_volume_record.dirsw then type = "dir";
      381         else type = "seg";
      382         if backup_volume_record.uid = "0"b then comment = "deleted";
      383         if backup_volume_record.damaged then comment = comment || " damaged";
      384         if backup_volume_record.version > backup_volume_record_version_1
      385 	   then delimited = "1"b;			/* object data is delimited */
      386       end;
      387     else if backup_volume_record.rec1_type = volume_log_type then do;
      388         bvlp = recordp;
      389         name = rtrim (backup_volume_log.pvname) || ".volog";
      390         type = "volog";
      391       end;
      392     else if backup_volume_record.rec1_type = contents_type then do;
      393         contentsp = recordp;
      394         name = rtrim (backup_volume_contents.volname) || ".contents";
      395         type = "contents";
      396       end;
      397     else if backup_volume_record.rec1_type = info_type then do;
      398         infop = recordp;
      399         name = rtrim (backup_info.dump_volname) || "[info data]";
      400         type = "info_seg";
      401       end;
      402     else do;
      403         call ioa_ ("Unknown record type ^d", backup_volume_record.rec1_type);
      404         call debug_it ("Volume record at ^p", recordp);
      405         goto skip;
      406       end;
      407 
      408     if brief then call ioa_ ("^a", name);
      409     if long then call ioa_ ("^o ^80a^-^a^-^a", vtocx, name, type, comment);
      410 
      411 skip: nel = backup_volume_record.rec2_len;
      412     call skip_chars;
      413 
      414   end read_volume_record;
      415 
      416 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      417 
      418 read: proc (return_buffer_ptr,
      419        Nrequested_chars,
      420        Nreturned_chars,
      421        Sdelimited,
      422        code);
      423 
      424 dcl return_buffer_ptr    ptr,
      425   Nrequested_chars	     fixed bin (21),
      426   Nreturned_chars	     fixed bin (21),
      427   Sdelimited	     bit (1) aligned,
      428   code		     fixed bin (35);
      429 
      430 dcl input_buffer	     char (256 * CHARS_PER_PAGE)
      431 		     based (input_buffer_ptr);
      432 
      433 dcl return_string	     char (Nrequested_chars)
      434 		     based (return_buffer_ptr);
      435 
      436 dcl Nassign_chars	     fixed bin (21),
      437   Nread_chars	     fixed bin (21),
      438   end_of_record	     fixed bin,
      439   tape_check1 /* bit (72) */ char (8),
      440   tape_check2 /* bit (72) */ char (8);
      441 
      442     Nreturned_chars, Nread_chars, code = 0;
      443 
      444     do while (Nreturned_chars < Nrequested_chars & code = 0);
      445       if input_buffer_len = 0 then do;
      446 	input_buffer_start = 1;
      447 
      448 	if Sdelimited & Nreturned_chars = 0 then do;
      449 	    call iox_$get_chars (iocbp,
      450 	         addr (tape_check1), length (tape_check1), Nread_chars, code);
      451 	    if code ^= 0 then return;
      452 	  end;
      453 
      454 	if return_buffer_ptr = null then do;
      455 	    call iox_$position (iocbp, FORWARD_CHAR_POSITIONING,
      456 	         Nrequested_chars - Nreturned_chars, code);
      457 	    Nreturned_chars = Nreturned_chars + Nrequested_chars;
      458 	  end;
      459 	else do;
      460 	    call iox_$get_chars (iocbp,
      461 	         addcharno (return_buffer_ptr, Nreturned_chars),
      462 	         Nrequested_chars - Nreturned_chars, Nread_chars, code);
      463 	    Nreturned_chars = Nreturned_chars + Nread_chars;
      464 	  end;
      465 	if code ^= 0 then return;
      466 
      467 	if Sdelimited then do;
      468 	    call iox_$get_chars (iocbp,
      469 	         addr (tape_check2), length (tape_check2), Nread_chars, code);
      470 	    if code ^= 0 then
      471 	      return;
      472 
      473 	    if tape_check1 ^= tape_check2 then do;
      474 						/* found a short segment, move       */
      475 						/* return string into the temp input */
      476 						/* buffer and start parsing          */
      477 	        input_buffer_len = Nreturned_chars;
      478 	        substr (input_buffer, 1, input_buffer_len) =
      479 		   return_string;
      480 	      end;
      481 	  end;
      482         end;
      483 
      484       else
      485 	 if Sdelimited then do;
      486 	tape_check1 = substr (input_buffer,
      487 	     input_buffer_start, length (tape_check1));
      488 	tape_check2 = "";
      489 	input_buffer_start =
      490 	     input_buffer_start + length (tape_check1);
      491 	input_buffer_len =
      492 	     input_buffer_len - length (tape_check1);
      493         end;
      494 
      495       if input_buffer_len > 0 then do;
      496 	Nassign_chars =
      497 	     min (input_buffer_len, Nrequested_chars);
      498 
      499 	if Sdelimited then do;
      500 	    if tape_check1 ^= tape_check2 then do;
      501 	        end_of_record = index (substr (input_buffer, input_buffer_start,
      502 		   input_buffer_len), tape_check1);
      503 	        if end_of_record > 0 then do;
      504 		  Nassign_chars = end_of_record - 1;
      505 		  if Nrequested_chars ^= Nassign_chars then
      506 		    code = error_table_$data_loss;
      507 		end;
      508 	      end;
      509 	  end;
      510 
      511 	if return_buffer_ptr ^= null then
      512 	  return_string = substr (input_buffer,
      513 	       input_buffer_start, Nassign_chars);
      514 	Nreturned_chars = Nassign_chars;
      515 
      516 	input_buffer_start =
      517 	     input_buffer_start + Nassign_chars;
      518 	input_buffer_len =
      519 	     input_buffer_len - Nassign_chars;
      520 
      521 	if Sdelimited & input_buffer_len > 0 then do;
      522 	    input_buffer_start =
      523 	         input_buffer_start + length (tape_check2);
      524 	    substr (input_buffer, 1, input_buffer_len) =
      525 	         substr (input_buffer, input_buffer_start,
      526 	         input_buffer_len - length (tape_check2))
      527 	         || tape_check2;
      528 	    input_buffer_start = 1;
      529 	  end;
      530         end;
      531     end;
      532 
      533     return;
      534   end read;
      535 
      536 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      537 
      538 
      539 finish_: proc;
      540     if iocbp ^= null then call detach;
      541     if tp (1) ^= null then do;
      542         call hcs_$truncate_seg (objectp, 0, ignore);	/* clean up our 256K segs */
      543         call hcs_$truncate_seg (input_buffer_ptr, 0, ignore);
      544         call hcs_$set_max_length_seg (objectp, (sys_info$max_seg_size), ignore);
      545         call hcs_$set_max_length_seg (input_buffer_ptr, (sys_info$max_seg_size), ignore);
      546         call release_temp_segments_ (myname, tp, ignore);
      547         call hcs_$set_256K_switch (old_256K_switch, (""b), ignore);
      548       end;
      549   end finish_;
      550 
      551 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      552 
      553 
      554 convert_puid_: proc returns (char (168));
      555 
      556 /* This proc is used to convert a unique id pathname to an ascii pathname  */
      557 
      558 dcl dn		     char (168);
      559 dcl en		     char (32);
      560 dcl ret_dn	     char (168);
      561 dcl ec		     fixed bin (35);
      562 dcl seg_fault_error	     condition;
      563     on seg_fault_error goto ret_unk;
      564     call hc_backup_$decode_uidpath (backup_volume_record.uid_path, dn, en, ec);
      565     if ec = error_table_$root then ;
      566     else if ec ^= 0 then
      567 ret_unk: return ("UNKNOWN_PATH>" || rtrim (backup_volume_record.primary_name, "  "));
      568     call ioa_$rsnnl ("^a^[>^]^[^a>^;^s^]^a", ret_dn, (0), dn, dn ^= ">", en ^= "", en, backup_volume_record.primary_name);
      569     return (ret_dn);
      570   end convert_puid_;
      571 
      572 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      573 
      574 
      575 debug_it: proc (string, p);
      576 dcl string	     char (*);
      577 dcl p		     ptr;
      578     call ioa_ (string, p);
      579     call ioa_ ("in debug");
      580     call debug;
      581   end debug_it;
      582  /* BEGIN INCLUDE FILE ... backup_info.incl.pl1 ... June 1976 */
  1     2 
  1     3 dcl  infop ptr;					/* ptr to structure */
  1     4 
  1     5 dcl  backup_info_version_2 fixed bin static init (2) options (constant); /* version number */
  1     6 
  1     7 dcl 1 backup_info based (infop) aligned,
  1     8     2 header like backup_volume_header aligned,
  1     9     2 version fixed bin,				/* version number */
  1    10     2 rpv_pvid bit (36),				/* pvid of rpv */
  1    11     2 rpv_lvid bit (36),				/* lvid of rpv */
  1    12     2 rpv_disk_type fixed bin,			/* disk model index of rpv */
  1    13     2 dump_volid bit (36),				/* dump volume id */
  1    14     2 pad bit (36),
  1    15     2 dump_type fixed bin,				/* type of dump */
  1    16     2 dump_volname char (32),				/* volname of dump volume */
  1    17     2 system_id char (32),				/* system identifier */
  1    18     2 control_file char (168),			/* path name of dump control file */
  1    19     2 operator char (32);				/* operator who started dump */
  1    20 
  1    21 /* END INCLUDE FILE ... backup_info.incl.pl1 */
      582 
      583  /* BEGIN INCLUDE FILE ... backup_pvol_info.incl.pl1 */
  2     2 
  2     3 dcl  bpvip ptr;
  2     4 
  2     5 dcl 1 backup_pvol_info based (bpvip) aligned,
  2     6     2 label like label aligned,
  2     7     2 n_vtoce fixed bin,
  2     8     2 n_free_vtoce fixed bin,
  2     9     2 n_rec fixed bin,
  2    10     2 baseadd fixed bin,
  2    11     2 n_free_rec fixed bin;
  2    12 
  2    13 /* END INCLUDE FILE ... backup_pvol_info.incl.pl1 */
      583 
      584  /* BEGIN INCLUDE FILE ... backup_static_variables.incl.pl1 ... March 1976 */
  3     2 
  3     3 
  3     4 dcl  incr fixed bin init (1) internal static options (constant); /* incremental dump mode */
  3     5 dcl  cons fixed bin init (2) internal static options (constant); /* consolidated dump mode */
  3     6 dcl  comp fixed bin init (3) internal static options (constant); /* complete dump mode */
  3     7 dcl  backup_version_1 fixed bin init (1) static internal options (constant); /* backup_version_1 of input/output structures */
  3     8 
  3     9 
  3    10 
  3    11 /* END INCLUDE FILE ... backup_static_variables.incl.pl1 */
      584 
      585  /* BEGIN INCLUDE FILE backup_volume_contents.incl.pl1 ... May 1976 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(86-11-10,GWMay), approve(86-11-10,MCR7445), audit(86-11-19,GDixon),
  4     7*     install(86-11-21,MR12.0-1223):
  4     8*     increased the size of the offset field to fixed bin (18).
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 
  4    12 dcl  contentsp ptr;					/* ptr to structure */
  4    13 
  4    14 dcl  backup_volume_contents_version_3 fixed bin static init (3) options (constant);
  4    15 
  4    16 
  4    17 dcl 1 v1_backup_volume_contents based (contentsp) aligned,
  4    18     2 header like backup_volume_header aligned,
  4    19     2 version fixed bin,				/* version number of structure */
  4    20     2 volname char (32),				/* volume name */
  4    21     2 volid bit (36),				/* volume id */
  4    22     2 next fixed bin,				/* index of next available slot in uid array */
  4    23     2 array (1: 1 refer (backup_volume_contents.next)),	/* array of arrays of data objects on this output volume */
  4    24       3 uid bit (36);				/* uid */
  4    25 
  4    26 dcl 1 v2_backup_volume_contents based (contentsp) aligned,
  4    27     2 header like backup_volume_header aligned,
  4    28     2 version fixed bin,				/* version number of structure */
  4    29     2 volname char (32),				/* volume name */
  4    30     2 volid bit (36),				/* volume id */
  4    31     2 next fixed bin,				/* index of next available slot in uid array */
  4    32     2 pad (10) bit (36),
  4    33     2 array (1: 1 refer (backup_volume_contents.next)),	/* array of arrays of data objects on this output volume */
  4    34       3 uid bit (36),				/* uid */
  4    35       3 location,					/* offset of name string */
  4    36         4 component fixed bin (17) unal,
  4    37         4 offset fixed bin (17) unal ;
  4    38 
  4    39 dcl 1 backup_volume_contents based (contentsp) aligned,
  4    40     2 header like backup_volume_header aligned,
  4    41     2 version fixed bin,				/* version number of structure */
  4    42     2 volname char (32),				/* volume name */
  4    43     2 volid bit (36),				/* volume id */
  4    44     2 next fixed bin,				/* index of next available slot in uid array */
  4    45     2 pad (10) bit (36),
  4    46     2 array (1: 1 refer (backup_volume_contents.next)),	/* array of arrays of data objects on this output volume */
  4    47       3 uid bit (36),				/* uid */
  4    48       3 tape_loc fixed bin (35),
  4    49       3 pad1 bit (36),
  4    50       3 location,					/* offset of name string */
  4    51         4 component fixed bin (18) unsigned unal,
  4    52         4 offset fixed bin (18) unsigned unal ;
  4    53 
  4    54 dcl  contents_namesp ptr;				/* ptr to optional name seg */
  4    55 
  4    56 dcl 1 backup_volume_contents_names based (contents_namesp) aligned,
  4    57     2 version fixed bin,
  4    58     2 offset fixed bin (18),				/* next free location */
  4    59     2 pad (6) bit (36),
  4    60     2 begin bit (36);
  4    61 
  4    62 
  4    63 /* END INCLUDE FILE backup_volume_contents.incl.pl1 */
      585 
      586  /* BEGIN INCLUDE FILE ... backup_volume_header ... Feb 1976 */
  5     2 
  5     3 dcl  hdp ptr;					/* ptr to header */
  5     4 
  5     5 dcl 1 backup_volume_header based (hdp) aligned,
  5     6     2 pattern1 bit (36),				/* unique  word 1 */
  5     7     2 rec1_type fixed bin,				/* record 1 type */
  5     8     2 rec1_len fixed bin,				/* length in chars */
  5     9     2 pattern2 bit (36),				/* unique word 2 */
  5    10     2 rec2_type fixed bin,				/* record 2 type */
  5    11     2 rec2_len fixed bin,				/* length in chars */
  5    12     2 pattern3 bit (36),				/* unique word 3 */
  5    13     2 time_dumped bit (36);				/* dump time of this record */
  5    14 
  5    15 dcl  vtoce_type fixed bin static init (1) options (constant); /* type code for vtoce */
  5    16 dcl  dir_type fixed bin static init (2) options (constant); /* type code for directory */
  5    17 dcl  seg_type fixed bin static init (3) options (constant); /* type code for segment */
  5    18 dcl  null_type fixed bin static init (4) options (constant); /* type code for null record */
  5    19 dcl  volume_log_type fixed bin static init (5) options (constant); /* type code for volume log */
  5    20 dcl  prev_output_log_type fixed bin static init (6) options (constant); /* type code for prev output log */
  5    21 dcl  contents_type fixed bin static init (7) options (constant); /* type code for contents segment of previous volume */
  5    22 dcl  info_type fixed bin static init (8) options (constant); /* type code for info structure */
  5    23 
  5    24 dcl  pattern1 bit (36) int static init ("110111000011001100011101101010100101"b) options (constant);
  5    25 dcl  pattern2 bit (36) int static init ("101001010101101110001100110000111011"b) options (constant);
  5    26 dcl  pattern3 bit (36) int static init ("001000111100110011100010010101011010"b) options (constant);
  5    27 
  5    28 /* END INCLUDE FILE ... backup_volume_header */
      586 
      587  /* BEGIN INCLUDE FILE ... backup_volume_log.incl.pl1 ... Feb 1976 */
  6     2 
  6     3 
  6     4 /****^  HISTORY COMMENTS:
  6     5*  1) change(88-03-03,GWMay), approve(89-10-03,MCR8135),
  6     6*     audit(89-10-04,Beattie), install(89-10-10,MR12.3-1089):
  6     7*     Added values for storing the number of incremental and consolidated dump
  6     8*     sets to retain in the volume log.  Incremented version number to 3.
  6     9*                                                   END HISTORY COMMENTS */
  6    10 
  6    11 
  6    12 /*     Modified: 3/7/84 by GA Texada to change to version 2						*/
  6    13 dcl  bvlp ptr;
  6    14 dcl  bvlep ptr;
  6    15 
  6    16 dcl  backup_volume_log_version_1 fixed bin static init (1) options (constant);
  6    17 dcl  backup_volume_log_version_2 fixed bin init(2) int static options(constant);
  6    18 dcl  backup_volume_log_version_3 fixed bin init(3) int static options(constant);
  6    19 
  6    20 dcl 1 backup_volume_log based (bvlp) aligned,
  6    21     2 header like backup_volume_header aligned,
  6    22     2 info like backup_pvol_info aligned,
  6    23     2 version fixed bin,				/* version number */
  6    24     2 lock bit (36),				/* shared data base */
  6    25     2 pvname char (32),				/* physical volume name */
  6    26     2 pvid bit (36),				/* physical volume id */
  6    27     2 next fixed bin,				/* next available dump record */
  6    28     2 reload_groups fixed bin,			/* number of reload groups in log */
  6    29     2 purge_control (3),				/* control selective purging by dump type */
  6    30       3 group (36) bit (1) unaligned,			/* up to 36 reload groups */
  6    31     2 disk_type fixed bin unal,			/* type of disk drive			*/	
  6    32     2 half_word_pad bit(18) unal,			/* MBZ					*/
  6    33     2 rpv_pvid bit(36),				/* pvid of this volumes RPV			*/
  6    34     2 Nsaved_incr_sets fixed bin,			/* number of incr cycles to retain */
  6    35     2 Nsaved_cons_sets fixed bin,			/* number of incr cycles to retain */
  6    36     2 pad (31) bit (36),				/* for future expansion (MBZ)			*/
  6    37     2 array (1:1 refer (backup_volume_log.next)) like bvle aligned;
  6    38 
  6    39 dcl 1 bvle based (bvlep) aligned,
  6    40     2 cycle_uid bit (36),				/* uid of this dump cycle */
  6    41     2 dump_type fixed bin,				/* type of dump */
  6    42     2 volname char (32),				/* name of output volume */
  6    43     2 open_time fixed bin (71),			/* opening time of dump pass on this physical volume */
  6    44     2 close_time fixed bin (71),			/* ending time of dump pass */
  6    45     2 volid bit (36),				/* uid of output volume */
  6    46     2 io_module char (32),				/* outer module name that wrote this volume */
  6    47     2 flags,					/* flags */
  6    48       3 purge_scan_logged bit (1) unaligned,		/* if on object looged during purge scan */
  6    49       3 pad1 bit (35) unaligned,
  6    50     2 pad (7) bit (36),				/* for future expansion */
  6    51    (2 dir_num fixed bin,				/* number of dirs dumped on this pass */
  6    52     2 dir_rec fixed bin,				/* number of records of dirs */
  6    53     2 seg_num fixed bin,				/* number of segs dumped on this pass */
  6    54     2 seg_rec fixed bin) unaligned;			/* number of records of segs */
  6    55 
  6    56 /* END INCLUDE FILE ... backup_volume_log */
      587 
      588  /* BEGIN INCLUDE FILE ... backup_volume_record.incl.pl1 ... March 1976 */
  7     2 
  7     3 
  7     4 
  7     5 /****^  HISTORY COMMENTS:
  7     6*  1) change(88-10-05,GWMay), approve(88-10-05,MCR8005), audit(88-10-12,Farley),
  7     7*     install(88-10-17,MR12.2-1173):
  7     8*     Added a version 2 constant
  7     9*                                                   END HISTORY COMMENTS */
  7    10 
  7    11 
  7    12 dcl  recordp ptr;
  7    13 
  7    14 dcl  backup_volume_record_version_1 fixed bin static init (1) options (constant);
  7    15 dcl  backup_volume_record_version_2 fixed bin static init (2) options (constant);
  7    16 
  7    17 dcl 1 backup_volume_record based (recordp) aligned,
  7    18     2 header like backup_volume_header aligned,
  7    19     2 version fixed bin,				/* version number of structure */
  7    20     2 pvid bit (36),				/* physical volume id */
  7    21     2 vtocx fixed bin,				/* vtoc index of returned vtoc entry */
  7    22     2 vtoce like vtoce aligned;			/* vtoc entry */
  7    23 
  7    24 /* END INCLUDE FILE ... backup_volume_record.incl.pl1 */
      588 
      589  /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  8     2 
  8     3 /****^  HISTORY COMMENTS:
  8     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  8     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  8     6*     Add the subvolume info.
  8     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  8     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  8     9*     Added inconsistent_dbm bit used to determine consistency of volume
  8    10*     dumper bit maps.
  8    11*                                                   END HISTORY COMMENTS */
  8    12 
  8    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  8    14 /* Note: fsout_vol clears pad fields before writing the label */
  8    15 
  8    16 dcl  labelp ptr;
  8    17 
  8    18 dcl 1 label based (labelp) aligned,
  8    19 
  8    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  8    21 
  8    22     2 gcos (5*64) fixed bin,
  8    23 
  8    24 /* Now we have the Multics label */
  8    25 
  8    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  8    27     2 version fixed bin,				/* Version 1 */
  8    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  8    29     2 pv_name char (32),				/* Physical volume name. */
  8    30     2 lv_name char (32),				/* Name of logical volume for pack */
  8    31     2 pvid bit (36),				/* Unique ID of this pack */
  8    32     2 lvid bit (36),				/* unique ID of its logical vol */
  8    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  8    34     2 time_registered fixed bin (71),			/* time imported to system */
  8    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  8    36     2 vol_size fixed bin,				/* total size of volume, in records */
  8    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  8    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  8    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  8    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  8    41     2 flagpad bit (33) unal,
  8    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  8    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  8    44     2 password bit (72),				/* not yet used */
  8    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  8    46     2 this_sv fixed bin,				/* what subvolume number it is */
  8    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  8    48     2 pad1 (13) fixed bin,
  8    49     2 time_mounted fixed bin (71),			/* time mounted */
  8    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  8    51 
  8    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  8    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  8    54* */
  8    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  8    56     2 pad6 fixed bin,				
  8    57 
  8    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  8    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  8    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  8    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  8    62     2 pad1a (2) fixed bin,
  8    63     2 err_hist_size fixed bin,			/* size of pack error history */
  8    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  8    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  8    66     2 pad2 (40) fixed bin,
  8    67     2 root,
  8    68       3 here bit (1),				/* TRUE if the root is on this pack */
  8    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  8    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  8    71       3 pad7 bit (1) aligned,				
  8    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  8    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  8    74       3 esd_state fixed bin,				/* State of esd */
  8    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  8    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  8    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  8    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  8    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  8    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  8    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  8    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  8    83     2 pad3 (52) fixed bin,
  8    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  8    85     2 parts (47),
  8    86       3 part char (4),				/* Name of partition */
  8    87       3 frec fixed bin,				/* First record */
  8    88       3 nrec fixed bin,				/* Number of records */
  8    89       3 pad5 fixed bin,
  8    90     2 pad4 (5*64) fixed bin;
  8    91 
  8    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  8    93 
  8    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
      589 
      590  /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  9     2 
  9     3 /* Written 05/04/78 by C. D. Tavares */
  9     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  9     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  9     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  9     7 
  9     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  9     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  9    10      iox_$close entry (pointer, fixed bin (35)),
  9    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  9    12      iox_$delete_record entry (pointer, fixed bin (35)),
  9    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  9    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  9    15      iox_$err_not_attached entry options (variable),
  9    16      iox_$err_not_closed entry options (variable),
  9    17      iox_$err_no_operation entry options (variable),
  9    18      iox_$err_not_open entry options (variable),
  9    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  9    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  9    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  9    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  9    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  9    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  9    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  9    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  9    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  9    28      iox_$propagate entry (pointer),
  9    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  9    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  9    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  9    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  9    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  9    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  9    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  9    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  9    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  9    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  9    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  9    40 
  9    41 dcl (iox_$user_output,
  9    42      iox_$user_input,
  9    43      iox_$user_io,
  9    44      iox_$error_output) external static pointer;
  9    45 
  9    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      590 
      591  /* Begin include file ..... iox_modes.incl.pl1 */
 10     2 
 10     3 /* Written by C. D. Tavares, 03/17/75 */
 10     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
 10     5 
 10     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
 10     7     ("stream_input", "stream_output", "stream_input_output",
 10     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
 10     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
 10    10      "direct_input", "direct_output", "direct_update");
 10    11 
 10    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
 10    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
 10    14 
 10    15 dcl (Stream_input initial (1),
 10    16      Stream_output initial (2),
 10    17      Stream_input_output initial (3),
 10    18      Sequential_input initial (4),
 10    19      Sequential_output initial (5),
 10    20      Sequential_input_output initial (6),
 10    21      Sequential_update initial (7),
 10    22      Keyed_sequential_input initial (8),
 10    23      Keyed_sequential_output initial (9),
 10    24      Keyed_sequential_update initial (10),
 10    25      Direct_input initial (11),
 10    26      Direct_output initial (12),
 10    27      Direct_update initial (13)) fixed bin int static options (constant);
 10    28 
 10    29 /* End include file ..... iox_modes.incl.pl1 */
      591 
      592  /*	BEGIN INCLUDE FILE ...vtoce.incl.pl1 ... last modified September 1982 */
 11     2 /* Template for a VTOC entry. Length = 192 words. (3 * 64). */
 11     3 /* NOTE: vtoc_man clears pad fields before writing a vtoce. */
 11     4 
 11     5 dcl  vtocep ptr;
 11     6 
 11     7 dcl 1 vtoce based (vtocep) aligned,
 11     8 
 11     9 
 11    10     (2 pad_free_vtoce_chain bit (36),			/* Used to be pointer to next free VTOCE */
 11    11 
 11    12     2 uid bit (36),					/* segment's uid - zero if vtoce is free */
 11    13 
 11    14     2 msl bit (9),					/* maximum segment length in 1024 word units */
 11    15     2 csl bit (9),					/* current segment length - in 1024 word units */
 11    16     2 records bit (9),				/* number of records used by the seg in second storage */
 11    17     2 pad2 bit (9),
 11    18 
 11    19     2 dtu bit (36),					/* date and time segment was last used */
 11    20 
 11    21     2 dtm bit (36),					/* date and time segment was last modified */
 11    22 
 11    23     2 nqsw bit (1),					/* no quota switch - no checking for pages of this seg */
 11    24     2 deciduous bit (1),				/* true if hc_sdw */
 11    25     2 nid bit (1),					/* no incremental dump switch */
 11    26     2 dnzp bit (1),					/* Dont null zero pages */
 11    27     2 gtpd bit (1),					/* Global transparent paging device */
 11    28     2 per_process bit (1),				/* Per process segment (deleted every bootload) */
 11    29     2 damaged bit (1),				/* TRUE if contents damaged */
 11    30     2 fm_damaged bit (1),				/* TRUE if filemap checksum bad */
 11    31     2 fm_checksum_valid bit (1),			/* TRUE if the checksum has been computed */
 11    32     2 synchronized bit (1),				/* TRUE if this is a data management synchronized segment */
 11    33     2 pad3 bit (8),
 11    34     2 dirsw bit (1),				/* directory switch */
 11    35     2 master_dir bit (1),				/* master directory - a root for the logical volume */
 11    36     2 pad4 bit (16)) unaligned,			/* not used */
 11    37 
 11    38     2 fm_checksum bit (36) aligned,			/* Checksum of used portion of file map */
 11    39 
 11    40     (2 quota (0:1) fixed bin (18) unsigned,		/* sec storage quota - (0) for non dir pages */
 11    41 
 11    42     2 used (0:1) fixed bin (18) unsigned,		/* sec storage used  - (0) for non dir pages */
 11    43 
 11    44     2 received (0:1) fixed bin (18) unsigned,		/* total amount of storage this dir has received */
 11    45 
 11    46     2 trp (0:1) fixed bin (71),			/* time record product - (0) for non dir pages */
 11    47 
 11    48     2 trp_time (0:1) bit (36),			/* time time_record_product was last calculated */
 11    49 
 11    50 
 11    51 
 11    52 
 11    53 
 11    54     2 fm (0:255) bit (18),				/* file map - 256 entries - 18 bits per entry */
 11    55 
 11    56     2 pad6 (10) bit (36),				/* not used */
 11    57 
 11    58     2 ncd bit (1),					/* no complete dump switch */
 11    59     2 pad7 bit (17),
 11    60     2 pad8 bit (18),
 11    61 
 11    62     2 dtd bit (36),					/* date-time-dumped */
 11    63 
 11    64     2 volid (3) bit (36),				/* volume ids of last incremental, consolidated, and complete dumps */
 11    65 
 11    66     2 master_dir_uid bit (36),			/* superior master directory uid */
 11    67 
 11    68 
 11    69 
 11    70 
 11    71     2 uid_path (0:15) bit (36),			/* uid pathname of all parents starting after the root */
 11    72 
 11    73     2 primary_name char (32),				/* primary name of the segment */
 11    74 
 11    75     2 time_created bit (36),				/* time the segment was created */
 11    76 
 11    77     2 par_pvid bit (36),				/* physical volume id of the parent */
 11    78 
 11    79     2 par_vtocx fixed bin (17),			/* vtoc entry index of the parent */
 11    80     2 branch_rp bit (18)) unaligned,			/* rel pointer of the branch of this segment */
 11    81 
 11    82     2 cn_salv_time bit (36),				/* time branch - vtoce connection checked */
 11    83 
 11    84     2 access_class bit (72),				/* access class in branch */
 11    85     2 perm_flags aligned,
 11    86       3 per_bootload bit (1) unal,			/* ON => deleted each bootload */
 11    87       3 pad9 bit (35) unal,
 11    88     2 owner bit (36);				/* pvid of this volume */
 11    89 
 11    90 dcl  vtoce_parts (3) bit (36 * 64) aligned based (vtocep);
 11    91 
 11    92 dcl 1 seg_vtoce based (vtocep) aligned,			/* Overlay for vtoce of segments, which don't have quota */
 11    93     2 pad1 bit (7*36),
 11    94     2 usage fixed bin (35),				/* page fault count: overlays quota */
 11    95     2 pad2 bit (184*36);
 11    96 
 11    97 /*	END INCLUDE FILE vtoce.incl.pl1 */
      592 
      593  /* BEGIN INCLUDE FILE ... system_constants.incl.pl1 */
 12     2 
 12     3 /****^  HISTORY COMMENTS:
 12     4*  1) change(86-11-12,GWMay), approve(86-11-12,MCR7445), audit(86-11-19,GDixon),
 12     5*     install(86-11-21,MR12.0-1223):
 12     6*     created.
 12     7*                                                   END HISTORY COMMENTS */
 12     8 
 12     9 /* format: off */
 12    10 
 12    11 /* ************************************************************************ */
 12    12 /*							      */
 12    13 /* Function: Provides constants for commonly used Multics system values.    */
 12    14 /*							      */
 12    15 /* Usage: These values are available for use in place of "magic" numbers    */
 12    16 /*        (unexplained numbers) in programming applications.	      */
 12    17 /*							      */
 12    18 /* Definitions:						      */
 12    19 /*							      */
 12    20 /*   PER             bit     character/byte     word     page     segment   */
 12    21 /*		 					      */
 12    22 /*   bits              1            9             36     36864    9400320   */
 12    23 /*   characters/bytes	      1	           4      4096    1044480   */
 12    24 /*   words				 1      1024     261120   */
 12    25 /*   pages				           1        255   */
 12    26 /*   segments						  1   */
 12    27 /*							      */
 12    28 /*  The base values for a bit, char, word and page are determined by the    */
 12    29 /*  Multics hardware implementation.  The other values are calculated from  */
 12    30 /*  their relation to one another as shown in the matrix above.	      */
 12    31 /*							      */
 12    32 /*  BITS_PER_CHAR     = 9 (defined by the hardware)		      */
 12    33 /*  BITS_PER_WORD     = BITS_PER_CHAR * CHARS_PER_WORD		      */
 12    34 /*		  = 9 * 4					      */
 12    35 /*		  = 36					      */
 12    36 /*  BITS_PER_PAGE     = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE     */
 12    37 /*		  = 9 * 4 * 1024				      */
 12    38 /*		  = 36864					      */
 12    39 /*  BITS_PER_SEGMENT  = BITS_PER_CHAR * CHARS_PER_WORD * CHARS_PER_PAGE *   */
 12    40 /*		    PAGES_PER_SEGMENT			      */
 12    41 /*		  = 9 * 4 * 1024 * 255			      */
 12    42 /*		  = 9400320				      */
 12    43 /*							      */
 12    44 /*  CHARS_PER_WORD    = 4 (defined by the hardware)		      */
 12    45 /*  CHARS_PER_PAGE    = CHARS_PER_WORD * WORDS_PER_PAGE		      */
 12    46 /*		  = 4 * 1024				      */
 12    47 /*		  = 4096					      */
 12    48 /*  CHARS_PER_SEGMENT = CHARS_PER_WORD * WORDS_PER_PAGE * PAGES_PER_SEGMENT */
 12    49 /*		  = 4 * 1024 * 255				      */
 12    50 /*		  = 1044480				      */
 12    51 /*							      */
 12    52 /*  WORDS_PER_PAGE    = 1024 (defined by the hardware)		      */
 12    53 /*  WORDS_PER_SEGMENT = WORDS_PER_PAGE * PAGES_PER_SEGMENT		      */
 12    54 /*		  = 1024 * 255				      */
 12    55 /*		  = 261120				      */
 12    56 /*							      */
 12    57 /*  PAGES_PER_SEGMENT = 255 (defined by system standard)		      */
 12    58 /*							      */
 12    59 /* ************************************************************************ */
 12    60 
 12    61        declare BITS_PER_CHAR		fixed bin (4) internal static
 12    62 				options (constant) initial (9);
 12    63 
 12    64        declare BITS_PER_WORD		fixed bin (6) internal static
 12    65 				options (constant) initial (36);
 12    66 
 12    67        declare BITS_PER_PAGE		fixed bin (16) internal static
 12    68 				options (constant) initial (36864);
 12    69 
 12    70        declare BITS_PER_SEGMENT	fixed bin (24) internal static
 12    71 				options (constant) initial (9400320);
 12    72 
 12    73        declare CHARS_PER_WORD		fixed bin (3) internal static
 12    74 				options (constant) initial (4);
 12    75 
 12    76        declare CHARS_PER_PAGE		fixed bin (13) internal static
 12    77 				options (constant) initial (4096);
 12    78 
 12    79        declare CHARS_PER_SEGMENT	fixed bin (21) internal static
 12    80 				options (constant) initial (1044480);
 12    81 
 12    82        /* Note: WORDS_PER_PAGE should be equal to sys_info$max_page_size    */
 12    83 
 12    84        declare WORDS_PER_PAGE		fixed bin (11) internal static
 12    85 				options (constant) initial (1024);
 12    86 
 12    87        /* Note: WORDS_PER_SEGMENT should be equal to sys_info$max_seg_size  */
 12    88 
 12    89        declare WORDS_PER_SEGMENT	fixed bin (21) internal static
 12    90 				options (constant) initial (261120);
 12    91 
 12    92        declare PAGES_PER_SEGMENT	fixed bin (8) internal static
 12    93 				options (constant) initial (255);
 12    94 
 12    95 /* END INCLUDE FILE ... system_constants.incl.pl1 */
 12    96 
      593 
      594 
      595   end verify_dump_volume;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/10/89  1358.7  verify_dump_volume.pl1            >special_ldd>install>MR12.3-1089>verify_dump_volume.pl1
582          1    09/05/80  1136.5  backup_info.incl.pl1              >ldd>include>backup_info.incl.pl1
583          2    06/07/77  1233.6  backup_pvol_info.incl.pl1         >ldd>include>backup_pvol_info.incl.pl1
584          3    09/05/80  1136.5  backup_static_variables.incl.pl1  >ldd>include>backup_static_variables.incl.pl1
585          4    11/24/86  1243.9  backup_volume_contents.incl.pl1   >ldd>include>backup_volume_contents.incl.pl1
586          5    09/05/80  1136.5  backup_volume_header.incl.pl1     >ldd>include>backup_volume_header.incl.pl1
587          6    10/10/89  1357.9  backup_volume_log.incl.pl1        >special_ldd>install>MR12.3-1089>backup_volume_log.incl.pl1
588          7    10/18/88  1215.0  backup_volume_record.incl.pl1     >ldd>include>backup_volume_record.incl.pl1
589          8    07/21/88  2036.0  fs_vol_label.incl.pl1             >ldd>include>fs_vol_label.incl.pl1
590          9    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
591         10    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
592         11    10/04/83  1105.1  vtoce.incl.pl1                    >ldd>include>vtoce.incl.pl1
593         12    11/24/86  1243.9  system_constants.incl.pl1         >ldd>include>system_constants.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BITS_PER_WORD                          constant        fixed bin(6,0)           initial dcl 12-64 ref 263 263 263
CHARS_PER_PAGE                         constant        fixed bin(13,0)          initial dcl 12-76 ref 478 486 501 511 524 524
CHARS_PER_WORD                         constant        fixed bin(3,0)           initial dcl 12-73 ref 255 256 264 349 360
DELIMITED                              constant        bit(1)                   initial dcl 89 ref 257 265
FORWARD_CHAR_POSITIONING        000051 constant        fixed bin(17,0)          initial dcl 91 set ref 455*
Nassign_chars                   000100 automatic       fixed bin(21,0)          dcl 436 set ref 496* 504* 505 511 514 516 518
Nread_chars                     000101 automatic       fixed bin(21,0)          dcl 436 set ref 442* 449* 460* 463 468*
Nrequested_chars                       parameter       fixed bin(21,0)          dcl 424 ref 418 444 455 457 460 478 496 505 511
Nreturned_chars                        parameter       fixed bin(21,0)          dcl 424 set ref 418 442* 444 448 455 457* 457 460
                                                                                  460 460 463* 463 477 514*
Sdelimited                             parameter       bit(1)                   dcl 424 ref 418 448 467 484 499 521
Stream_input                    000055 constant        fixed bin(17,0)          initial dcl 10-15 set ref 225*
WORDS_PER_PAGE                         constant        fixed bin(11,0)          initial dcl 12-84 ref 270
addcharno                                              builtin function         dcl 108 ref 460 460
addr                                                   builtin function         dcl 108 ref 265 265 377 377 449 449 468 468
arg                                    based           char                     packed unaligned dcl 51 set ref 128 134 138 140 140
                                                                                  141 141 142 146* 150* 182*
argl                            000322 automatic       fixed bin(17,0)          dcl 52 set ref 123* 128 132* 134 136* 138 140 140
                                                                                  141 141 142 144* 146 146 150 150 182 182
argp                            000324 automatic       pointer                  dcl 53 set ref 123* 128 132* 134 136* 138 140 140
                                                                                  141 141 142 144* 146 150 182
att_desc                        000220 automatic       char(256)                packed unaligned dcl 48 set ref 218* 220* 222*
backup_info                            based           structure                level 1 dcl 1-7
backup_pvol_info                       based           structure                level 1 dcl 2-5
backup_volume_contents                 based           structure                level 1 dcl 4-39
backup_volume_header                   based           structure                level 1 dcl 5-5 ref 256 263 263 263 265 265 349 360
                                                                                  362 362
backup_volume_log                      based           structure                level 1 dcl 6-20
backup_volume_record                   based           structure                level 1 dcl 7-17
backup_volume_record_version_1         constant        fixed bin(17,0)          initial dcl 7-14 ref 384
brief                           000326 automatic       bit(1)                   packed unaligned dcl 54 set ref 113* 140* 156 379
                                                                                  408
bvle                                   based           structure                level 1 dcl 6-39
bvlp                            000510 automatic       pointer                  dcl 6-13 set ref 388* 389
cleanup                         000474 stack reference condition                dcl 71 ref 121
code                            000321 automatic       fixed bin(35,0)          dcl 50 in procedure "vdv" set ref 119* 123* 124 132*
                                                                                  133 136* 137 144* 145 146* 147 162 165 171 179*
                                                                                  193* 194 199* 200 201* 202 203* 204 222* 223 225*
                                                                                  226 257* 265* 272* 280* 293* 308 309 309 310* 316
                                                                                  316* 319 319* 320* 323* 331* 350* 356* 362*
code                                   parameter       fixed bin(35,0)          dcl 424 in procedure "read" set ref 418 442* 444
                                                                                  449* 451 455* 460* 465 468* 470 505*
com_err_                        000034 constant        entry                    external dcl 93 ref 150 157 179 182 310 316 319 320
                                                                                  323 331
comment                         000331 automatic       varying char(128)        dcl 57 set ref 373* 382* 383* 383 409*
contents_type                          constant        fixed bin(17,0)          initial dcl 5-21 ref 392
contentsp                       000506 automatic       pointer                  dcl 4-12 set ref 393* 394
cu_$arg_count                   000036 constant        entry                    external dcl 94 ref 131
cu_$arg_ptr                     000040 constant        entry                    external dcl 95 ref 123 132 136 144
cv_oct_check_                   000042 constant        entry                    external dcl 96 ref 146
damaged                  20(06)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref 383
debug                           000044 constant        entry                    external dcl 97 ref 580
delimited                       000330 automatic       bit(1)                   dcl 56 set ref 279* 293* 348* 350* 362* 384*
dirsw                    20(18)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref 380
divide                                                 builtin function         dcl 108 ref 255
dn                              000100 automatic       char(168)                packed unaligned dcl 558 set ref 564* 568* 568
dump_volname             17            based           char(32)                 level 2 dcl 1-7 ref 399
ec                              000234 automatic       fixed bin(35,0)          dcl 561 set ref 564* 565 566
en                              000152 automatic       char(32)                 packed unaligned dcl 559 set ref 564* 568 568*
end_of_record                   000102 automatic       fixed bin(17,0)          dcl 436 set ref 501* 503 504
error_table_$bad_arg            000020 external static fixed bin(35,0)          dcl 77 set ref 182*
error_table_$badopt             000022 external static fixed bin(35,0)          dcl 77 set ref 150*
error_table_$data_loss          000012 external static fixed bin(35,0)          dcl 77 ref 316 505
error_table_$device_end         000014 external static fixed bin(35,0)          dcl 77 ref 309
error_table_$end_of_info        000016 external static fixed bin(35,0)          dcl 77 ref 272 309
error_table_$improper_data_format
                                000010 external static fixed bin(35,0)          dcl 77 ref 356
error_table_$inconsistent       000024 external static fixed bin(35,0)          dcl 77 set ref 157*
error_table_$root               000026 external static fixed bin(35,0)          dcl 77 ref 565
get_temp_segments_              000046 constant        entry                    external dcl 98 ref 193
hc_backup_$decode_uidpath       000050 constant        entry                    external dcl 99 ref 564
hcs_$set_256K_switch            000052 constant        entry                    external dcl 100 ref 199 547
hcs_$set_max_length_seg         000054 constant        entry                    external dcl 101 ref 201 203 544 545
hcs_$truncate_seg               000056 constant        entry                    external dcl 102 ref 542 543
hdp                                    automatic       pointer                  dcl 5-3 ref 256 263 263 263 265 265 349 360 362 362
header                                 based           structure                level 2 dcl 7-17
i                               000451 automatic       fixed bin(17,0)          dcl 60 set ref 130* 131 132* 135* 135 136* 143* 143
                                                                                  144* 153* 153
ignore                          000320 automatic       fixed bin(35,0)          dcl 49 set ref 238* 239* 542* 543* 544* 545* 546*
                                                                                  547*
index                                                  builtin function         dcl 108 ref 501
info_type                              constant        fixed bin(17,0)          initial dcl 5-22 ref 397
infop                           000504 automatic       pointer                  dcl 1-3 set ref 398* 399
input_buf                              based           bit(36)                  array packed unaligned dcl 45 set ref 255*
input_buffer                           based           char                     packed unaligned dcl 430 set ref 478* 486 501 511
                                                                                  524* 524
input_buffer_len                000463 automatic       fixed bin(21,0)          dcl 67 set ref 206* 445 477* 478 491* 491 495 496
                                                                                  501 518* 518 521 524 524
input_buffer_ptr                000460 automatic       pointer                  dcl 65 set ref 198* 203* 478 486 501 511 524 524
                                                                                  543* 545*
input_buffer_start              000462 automatic       fixed bin(17,0)          dcl 66 set ref 205* 446* 486 489* 489 501 511 516*
                                                                                  516 522* 522 524 528*
input_volume_desc               000100 automatic       char(256)                packed unaligned dcl 40 set ref 115* 138* 218 218*
ioa_                            000060 constant        entry                    external dcl 103 ref 125 271 276 324 368 403 408 409
                                                                                  578 579
ioa_$rsnnl                      000062 constant        entry                    external dcl 104 ref 218 220 568
iocbp                           000452 automatic       pointer                  dcl 61 set ref 118* 222* 225* 238* 239* 240* 449*
                                                                                  455* 460* 468* 540
iox_$attach_ioname              000064 constant        entry                    external dcl 105 ref 222
iox_$close                      000070 constant        entry                    external dcl 9-8 ref 238
iox_$detach_iocb                000072 constant        entry                    external dcl 9-8 ref 239
iox_$get_chars                  000074 constant        entry                    external dcl 9-8 ref 449 460 468
iox_$open                       000076 constant        entry                    external dcl 9-8 ref 225
iox_$position                   000100 constant        entry                    external dcl 9-8 ref 455
label                                  based           structure                level 1 dcl 8-18
length                                                 builtin function         dcl 108 ref 449 449 468 468 486 489 491 522 524
long                            000327 automatic       bit(1)                   packed unaligned dcl 55 set ref 113* 141* 156 379
                                                                                  409
min                                                    builtin function         dcl 108 ref 496
myname                          000003 constant        char(32)                 initial packed unaligned dcl 88 set ref 125* 125*
                                                                                  150* 157* 179* 182* 193* 271* 276* 310* 316* 319*
                                                                                  320* 323* 324* 331* 546*
name                            000376 automatic       varying char(168)        dcl 59 set ref 379* 389* 394* 399* 408* 409*
nel                             000455 automatic       fixed bin(21,0)          dcl 63 set ref 256* 257* 264* 265* 292 293* 308 315
                                                                                  349* 350* 360* 362* 411*
nelt                            000454 automatic       fixed bin(21,0)          dcl 62 set ref 255 257* 265* 292* 293* 308 315 350*
                                                                                  362*
null                                                   builtin function         dcl 108 ref 117 118 240 454 511 540 541
objectp                         000456 automatic       pointer                  dcl 64 set ref 197* 201* 293* 542* 544*
old_256K_switch                 000464 automatic       bit(2)                   dcl 68 set ref 116* 547*
p                                      parameter       pointer                  dcl 577 set ref 575 578*
pattern1                               based           bit(36)                  level 3 in structure "backup_volume_record" dcl 7-17
                                                                                  in procedure "vdv" ref 353
pattern1                        000002 constant        bit(36)                  initial packed unaligned dcl 5-24 in procedure "vdv"
                                                                                  ref 261 353
pattern2                  3            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 7-17
                                                                                  in procedure "vdv" ref 353
pattern2                        000001 constant        bit(36)                  initial packed unaligned dcl 5-25 in procedure "vdv"
                                                                                  ref 261 353
pattern3                  6            based           bit(36)                  level 3 in structure "backup_volume_record" dcl 7-17
                                                                                  in procedure "vdv" ref 353
pattern3                        000000 constant        bit(36)                  initial packed unaligned dcl 5-26 in procedure "vdv"
                                                                                  ref 261 353
pattern_match_label             000204 automatic       label variable           dcl 46 set ref 281 347*
primary_name            273            based           char(32)                 level 3 packed packed unaligned dcl 7-17 set ref 566
                                                                                  568*
ptr                                                    builtin function         dcl 108 ref 362 362
pvname                 2017            based           char(32)                 level 2 dcl 6-20 ref 389
rec1_len                  2            based           fixed bin(17,0)          level 3 dcl 7-17 ref 360
rec1_type                 1            based           fixed bin(17,0)          level 3 dcl 7-17 set ref 367 375 387 392 397 403*
rec2_len                  5            based           fixed bin(17,0)          level 3 dcl 7-17 ref 366 411
recordp                         000512 automatic       pointer                  dcl 7-12 set ref 196* 255 257* 261 261 261 263 263
                                                                                  265 265 350* 353 353 353 360 362 362 366 367 369*
                                                                                  375 376 377 377 380 382 383 384 387 388 392 393
                                                                                  397 398 403 404* 411 564 566 568
release_temp_segments_          000066 constant        entry                    external dcl 106 ref 546
resynch_retry_count             000202 automatic       fixed bin(17,0)          dcl 43 set ref 325* 329* 329 330
resynching                      000203 automatic       bit(1)                   packed unaligned dcl 44 set ref 114* 254* 278* 310
                                                                                  314
ret_dn                          000162 automatic       char(168)                packed unaligned dcl 560 set ref 568* 569
return_buffer_ptr                      parameter       pointer                  dcl 424 ref 418 454 460 460 478 511 511
return_string                          based           char                     packed unaligned dcl 433 set ref 478 511*
rtrim                                                  builtin function         dcl 108 ref 389 394 399 566
seg_fault_error                 000236 stack reference condition                dcl 562 ref 563
size                                                   builtin function         dcl 108 ref 256 263 263 263 265 265 349 360 362 362
stop_vtocx                      000200 automatic       fixed bin(17,0)          dcl 41 set ref 112* 146* 377
string                                 based           bit                      packed unaligned dcl 74 in procedure "vdv" set ref
                                                                                  263* 263
string                                 parameter       char                     packed unaligned dcl 576 in procedure "debug_it" set
                                                                                  ref 575 578*
substr                                                 builtin function         dcl 108 set ref 263 478* 486 501 511 524* 524
sys_info$max_seg_size           000032 external static fixed bin(18,0)          dcl 86 ref 544 545
sys_info$seg_size_256K          000030 external static fixed bin(19,0)          dcl 85 set ref 201* 203*
tape_check1                     000104 automatic       char(8)                  packed unaligned dcl 436 set ref 449 449 449 449 473
                                                                                  486* 486 489 491 500 501
tape_check2                     000106 automatic       char(8)                  packed unaligned dcl 436 set ref 468 468 468 468 473
                                                                                  488* 500 522 524 524
tp                              000466 automatic       pointer                  array dcl 69 set ref 117* 193* 196 197 198 541 546*
type                            000372 automatic       varying char(10)         dcl 58 set ref 380* 381* 390* 395* 400* 409*
uid                      14            based           bit(36)                  level 3 packed packed unaligned dcl 7-17 set ref 382
uid_path                253            based           bit(36)                  array level 3 packed packed unaligned dcl 7-17 set
                                                                                  ref 564*
version                  10            based           fixed bin(17,0)          level 2 dcl 7-17 ref 384
volname                  11            based           char(32)                 level 2 in structure "backup_volume_contents"
                                                                                  dcl 4-39 in procedure "vdv" ref 394
volname                         000210 automatic       char(32)                 packed unaligned dcl 47 in procedure "vdv" set ref
                                                                                  128* 218* 220*
volume_log_type                        constant        fixed bin(17,0)          initial dcl 5-19 ref 387
vtoce                                  based           structure                level 1 dcl 11-7 in procedure "vdv"
vtoce                    13            based           structure                level 2 in structure "backup_volume_record" dcl 7-17
                                                                                  in procedure "vdv" set ref 377 377
vtoce_type                             constant        fixed bin(17,0)          initial dcl 5-15 ref 367 375
vtocx                           000201 automatic       fixed bin(17,0)          dcl 42 in procedure "vdv" set ref 374* 376* 377 409*
vtocx                    12            based           fixed bin(17,0)          level 2 in structure "backup_volume_record" dcl 7-17
                                                                                  in procedure "vdv" ref 376
word                                   based           bit(36)                  array packed unaligned dcl 73 set ref 261 261 261
                                                                                  265 265
words_skipped                   000502 automatic       fixed bin(17,0)          dcl 75 set ref 260* 269* 269 270 276*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BITS_PER_CHAR                          internal static fixed bin(4,0)           initial dcl 12-61
BITS_PER_PAGE                          internal static fixed bin(16,0)          initial dcl 12-67
BITS_PER_SEGMENT                       internal static fixed bin(24,0)          initial dcl 12-70
CHARS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 12-79
Direct_input                           internal static fixed bin(17,0)          initial dcl 10-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 10-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 10-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 10-15
Multics_ID_String                      internal static char(32)                 initial packed unaligned dcl 8-92
PAGES_PER_SEGMENT                      internal static fixed bin(8,0)           initial dcl 12-92
Sequential_input                       internal static fixed bin(17,0)          initial dcl 10-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 10-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 10-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 10-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 10-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 10-15
WORDS_PER_SEGMENT                      internal static fixed bin(21,0)          initial dcl 12-89
backup_info_version_2                  internal static fixed bin(17,0)          initial dcl 1-5
backup_version_1                       internal static fixed bin(17,0)          initial dcl 3-7
backup_volume_contents_names           based           structure                level 1 dcl 4-56
backup_volume_contents_version_3       internal static fixed bin(17,0)          initial dcl 4-14
backup_volume_log_version_1            internal static fixed bin(17,0)          initial dcl 6-16
backup_volume_log_version_2            internal static fixed bin(17,0)          initial dcl 6-17
backup_volume_log_version_3            internal static fixed bin(17,0)          initial dcl 6-18
backup_volume_record_version_2         internal static fixed bin(17,0)          initial dcl 7-15
bpvip                                  automatic       pointer                  dcl 2-3
bvlep                                  automatic       pointer                  dcl 6-14
comp                                   internal static fixed bin(17,0)          initial dcl 3-6
cons                                   internal static fixed bin(17,0)          initial dcl 3-5
contents_namesp                        automatic       pointer                  dcl 4-54
dir_type                               internal static fixed bin(17,0)          initial dcl 5-16
incr                                   internal static fixed bin(17,0)          initial dcl 3-4
iox_$attach_loud                000000 constant        entry                    external dcl 9-8
iox_$attach_name                000000 constant        entry                    external dcl 9-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 9-8
iox_$close_file                 000000 constant        entry                    external dcl 9-8
iox_$control                    000000 constant        entry                    external dcl 9-8
iox_$delete_record              000000 constant        entry                    external dcl 9-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 9-8
iox_$detach                     000000 constant        entry                    external dcl 9-8
iox_$err_no_operation           000000 constant        entry                    external dcl 9-8
iox_$err_not_attached           000000 constant        entry                    external dcl 9-8
iox_$err_not_closed             000000 constant        entry                    external dcl 9-8
iox_$err_not_open               000000 constant        entry                    external dcl 9-8
iox_$error_output                      external static pointer                  dcl 9-41
iox_$find_iocb                  000000 constant        entry                    external dcl 9-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 9-8
iox_$get_line                   000000 constant        entry                    external dcl 9-8
iox_$look_iocb                  000000 constant        entry                    external dcl 9-8
iox_$modes                      000000 constant        entry                    external dcl 9-8
iox_$move_attach                000000 constant        entry                    external dcl 9-8
iox_$open_file                  000000 constant        entry                    external dcl 9-8
iox_$propagate                  000000 constant        entry                    external dcl 9-8
iox_$put_chars                  000000 constant        entry                    external dcl 9-8
iox_$read_key                   000000 constant        entry                    external dcl 9-8
iox_$read_length                000000 constant        entry                    external dcl 9-8
iox_$read_record                000000 constant        entry                    external dcl 9-8
iox_$rewrite_record             000000 constant        entry                    external dcl 9-8
iox_$seek_key                   000000 constant        entry                    external dcl 9-8
iox_$user_input                        external static pointer                  dcl 9-41
iox_$user_io                           external static pointer                  dcl 9-41
iox_$user_output                       external static pointer                  dcl 9-41
iox_$write_record               000000 constant        entry                    external dcl 9-8
iox_modes                              internal static char(24)                 initial array dcl 10-6
labelp                                 automatic       pointer                  dcl 8-16
null_type                              internal static fixed bin(17,0)          initial dcl 5-18
prev_output_log_type                   internal static fixed bin(17,0)          initial dcl 5-20
seg_type                               internal static fixed bin(17,0)          initial dcl 5-17
seg_vtoce                              based           structure                level 1 dcl 11-92
short_iox_modes                        internal static char(4)                  initial array dcl 10-12
v1_backup_volume_contents              based           structure                level 1 dcl 4-17
v2_backup_volume_contents              based           structure                level 1 dcl 4-26
vtoce_parts                            based           bit(2304)                array dcl 11-90
vtocep                                 automatic       pointer                  dcl 11-5

NAMES DECLARED BY EXPLICIT CONTEXT.
attach                          001202 constant        entry                    internal dcl 214 ref 164
bad_num                         001031 constant        label                    dcl 182 ref 147
badopt                          000703 constant        label                    dcl 150
check_input_error               001665 constant        entry                    internal dcl 301 ref 258 267 273 294 351 357 364
convert_puid_                   003460 constant        entry                    internal dcl 554 ref 379
debug_it                        003664 constant        entry                    internal dcl 575 ref 369 377 404
detach                          001347 constant        entry                    internal dcl 233 ref 311 332 540
err                             001013 constant        label                    dcl 179 ref 133 137 145 162 165
finish                          001006 constant        label                    dcl 175 set ref 151 181 184 312 333
finish_                         003305 constant        entry                    internal dcl 539 ref 121 175
pattern_match                   002231 constant        label                    dcl 360 ref 347
read                            002730 constant        entry                    internal dcl 418 ref 257 265 293 350 362
read_volume_record              002157 constant        entry                    internal dcl 342 ref 173
resynch_volume                  001403 constant        entry                    internal dcl 247 ref 326
ret_unk                         003542 constant        label                    dcl 566 ref 563
search_loop                     001002 constant        label                    dcl 171
setup_data_segments             001065 constant        entry                    internal dcl 189 ref 161
skip                            002722 constant        label                    dcl 411 set ref 405
skip_chars                      001636 constant        entry                    internal dcl 288 ref 412
vdv                             000353 constant        entry                    external dcl 15
verify_dump_volume              000362 constant        entry                    external dcl 15

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4600        4702    4163        4610
Length      5436    4163       102         517     414           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vdv                                 568 external procedure  is an external procedure.  
on unit on line 121                  64 on unit               
setup_data_segments                     internal procedure  shares stack frame of external procedure vdv.  
attach                                  internal procedure  shares stack frame of external procedure vdv.  
detach                               70 internal procedure  is called by several nonquick procedures.  
resynch_volume                          internal procedure  shares stack frame of internal procedure check_input_error.  
skip_chars                              internal procedure  shares stack frame of external procedure vdv.  
check_input_error                   146 internal procedure  calls itself recursively.  
read_volume_record                      internal procedure  shares stack frame of external procedure vdv.  
read                                 88 internal procedure  is called by several nonquick procedures.  
finish_                              88 internal procedure  is called by several nonquick procedures.  
convert_puid_                       220 internal procedure  enables or reverts conditions.  
on unit on line 563                  64 on unit               
debug_it                                internal procedure  shares stack frame of external procedure vdv.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
convert_puid_            000100 dn                          convert_puid_
                         000152 en                          convert_puid_
                         000162 ret_dn                      convert_puid_
                         000234 ec                          convert_puid_
read                     000100 Nassign_chars               read
                         000101 Nread_chars                 read
                         000102 end_of_record               read
                         000104 tape_check1                 read
                         000106 tape_check2                 read
vdv                      000100 input_volume_desc           vdv
                         000200 stop_vtocx                  vdv
                         000201 vtocx                       vdv
                         000202 resynch_retry_count         vdv
                         000203 resynching                  vdv
                         000204 pattern_match_label         vdv
                         000210 volname                     vdv
                         000220 att_desc                    vdv
                         000320 ignore                      vdv
                         000321 code                        vdv
                         000322 argl                        vdv
                         000324 argp                        vdv
                         000326 brief                       vdv
                         000327 long                        vdv
                         000330 delimited                   vdv
                         000331 comment                     vdv
                         000372 type                        vdv
                         000376 name                        vdv
                         000451 i                           vdv
                         000452 iocbp                       vdv
                         000454 nelt                        vdv
                         000455 nel                         vdv
                         000456 objectp                     vdv
                         000460 input_buffer_ptr            vdv
                         000462 input_buffer_start          vdv
                         000463 input_buffer_len            vdv
                         000464 old_256K_switch             vdv
                         000466 tp                          vdv
                         000502 words_skipped               vdv
                         000504 infop                       vdv
                         000506 contentsp                   vdv
                         000510 bvlp                        vdv
                         000512 recordp                     vdv

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           tra_ext_2           enable_op           shorten_stack       ext_entry
int_entry           set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   cv_oct_check_
debug                         get_temp_segments_            hc_backup_$decode_uidpath     hcs_$set_256K_switch
hcs_$set_max_length_seg       hcs_$truncate_seg             ioa_                          ioa_$rsnnl
iox_$attach_ioname            iox_$close                    iox_$detach_iocb              iox_$get_chars
iox_$open                     iox_$position                 release_temp_segments_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$data_loss        error_table_$device_end
error_table_$end_of_info      error_table_$improper_data_format                           error_table_$inconsistent
error_table_$root             sys_info$max_seg_size         sys_info$seg_size_256K




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000352       112 000367       113 000371       114 000373       115 000374       116 000377       117 000400
    118 000413       119 000415       121 000416       123 000440       124 000457       125 000461       126 000503
    128 000504       130 000511       131 000513       132 000526       133 000543       134 000545       135 000553
    136 000554       137 000571       138 000573       139 000600       140 000601       141 000614       142 000627
    143 000633       144 000634       145 000651       146 000653       147 000700       148 000702       150 000703
    151 000735       153 000736       154 000737       156 000740       157 000744       158 000773       161 000774
    162 000775       164 000777       165 001000       171 001002       173 001004       174 001005       175 001006
    177 001012       179 001013       181 001030       182 001031       184 001064       189 001065       193 001066
    194 001107       196 001112       197 001114       198 001116       199 001120       200 001137       201 001142
    202 001155       203 001160       204 001173       205 001176       206 001200       207 001201       214 001202
    218 001203       220 001235       222 001266       223 001320       225 001323       226 001342       228 001345
    233 001346       238 001354       239 001365       240 001377       242 001402       247 001403       254 001404
    255 001407       256 001427       257 001432       258 001454       260 001461       261 001463       263 001502
    264 001511       265 001513       267 001537       269 001544       270 001546       271 001552       272 001572
    273 001576       275 001603       276 001604       278 001630       279 001632       280 001633       281 001634
    288 001636       292 001637       293 001641       294 001657       296 001663       301 001664       308 001672
    309 001700       310 001705       311 001732       312 001737       314 001742       315 001744       316 001747
    319 001776       320 002024       322 002047       323 002050       324 002073       325 002113       326 002115
    327 002116       329 002117       330 002120       331 002123       332 002146       333 002153       337 002156
    342 002157       347 002160       348 002163       349 002164       350 002166       351 002204       353 002210
    356 002222       357 002225       360 002231       362 002237       364 002260       366 002264       367 002267
    368 002272       369 002306       373 002317       374 002320       375 002321       376 002325       377 002327
    379 002342       380 002361       381 002372       382 002376       383 002404       384 002421       386 002426
    387 002427       388 002431       389 002432       390 002465       391 002473       392 002474       393 002476
    394 002477       395 002532       396 002540       397 002541       398 002543       399 002544       400 002577
    401 002605       403 002606       404 002626       405 002637       408 002640       409 002661       411 002722
    412 002725       414 002726       418 002727       442 002735       444 002741       445 002750       446 002753
    448 002755       449 002762       451 003005       454 003010       455 003014       457 003035       458 003040
    460 003041       463 003071       465 003074       467 003076       468 003101       470 003125       473 003130
    477 003133       478 003136       482 003145       484 003146       486 003151       488 003156       489 003160
    491 003162       495 003164       496 003167       499 003173       500 003177       501 003202       503 003215
    504 003216       505 003220       511 003225       514 003242       516 003244       518 003245       521 003247
    522 003253       524 003255       528 003277       531 003302       533 003303       539 003304       540 003312
    541 003324       542 003331       543 003345       544 003362       545 003400       546 003416       547 003440
    549 003456       554 003457       563 003465       564 003504       565 003533       566 003540       568 003575
    569 003656       575 003664       578 003675       579 003714       580 003727       581 003734


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
