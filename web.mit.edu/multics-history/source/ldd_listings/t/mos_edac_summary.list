	COMPILATION LISTING OF SEGMENT mos_edac_summary
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/13/85  1200.5 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* MOS_EDAC_SUMMARY: Command to summarize MOS Memory EDAC errors from the syserr log */
       12 
       13 /* Written June 1979 by Larry Johnson */
       14 /* Most of this program was borrowed from the io_error_summary command. */
       15 /* Completed for installation December 1979 by Rich Coppola */
       16 /* Modified July 1983 by Paul Farley to change call to sys_info_$time_delta,
       17*   which does not exist, to time_data_$time_delta, which also allows for
       18*   per-process time zone selection (phx15295). */
       19 
       20 mos_edac_summary: mes:  proc;
       21 
       22 dcl  name char (17) int static options (constant) init ("mos_edac_summary"); /* Name of procedure */
       23 dcl  code fixed bin (35);				/* Standard system status code */
       24 dcl  open_status bit (36) aligned;			/* Code from syserr_log_util_$open */
       25 dcl  ptr_array (1) ptr;				/* An array of pointers as required by get_temp_segment_ */
       26 dcl  tab_cnt fixed bin init (0);			/* Number of seperate status found */
       27 dcl  mask bit (36) aligned init ("0"b);			/* Mask of significant bits in status word */
       28 dcl  arg_ptr ptr;					/* Pointer to an argument */
       29 dcl  arg_len fixed bin;				/* Length of an argument */
       30 dcl  arg char (arg_len) based (arg_ptr);		/* A command argument */
       31 dcl  arg_count fixed bin;				/* The number of arguments */
       32 dcl  arg_list_ptr ptr;				/* Pointer to commands argument list */
       33 dcl  for_ptr ptr;					/* Saved pointer to the -for argument */
       34 dcl  for_len fixed bin;				/* Saved length of -for argument */
       35 dcl  for_arg char (for_len) based (for_ptr);		/* This is the -for argument */
       36 dcl  from_sw bit (1) init ("0"b);			/* Set if -from used */
       37 dcl  to_sw bit (1) init ("0"b);			/* Set if -to used */
       38 dcl  for_sw bit (1) init ("0"b);			/* Set if -for used */
       39 dcl  more_args bit (1);				/* Set while there are more arguments to scan */
       40 dcl  from_time fixed bin (71);			/* Time specified on -from */
       41 dcl  to_time fixed bin (71);				/* Time specified on -to */
       42 dcl  for_time fixed bin (71);				/* Time specified on -for */
       43 dcl  count_limit fixed bin init (0);			/* Results for -limit arg */
       44 dcl  day_limit fixed bin init (0);			/* Results for -day_limit arg */
       45 dcl  workp ptr;					/* Pointer to work segment */
       46 dcl  arg_no fixed bin init (1);			/* For scanning argument list */
       47 dcl  errentp ptr;					/* Pointer to status table entry */
       48 dcl  msg_time fixed bin (71);				/* Time of syserr message */
       49 dcl  msg_seq fixed bin (35);				/* Sequence number */
       50 dcl  scu_cnt fixed bin init (0);			/* Number of MEMs requested */
       51 dcl  err_cnt fixed bin init (0);			/* Entries in status table */
       52 dcl  segs_allocated bit (1) init ("0"b);		/* Set after work segments created */
       53 dcl  sort_listp ptr;
       54 dcl  us_per_day fixed bin (71);			/* micro-seconds per day */
       55 
       56 dcl 1 work aligned based (workp),			/* Declaration of work segment */
       57     2 scureq (32) char (7) var,			/* Table of requested MEMs */
       58     2 buffer (500) bit (36) aligned,			/* Syserr messages are read here */
       59     2 errentry (err_cnt + 1) like err;			/* Entry for each different error */
       60 
       61 dcl 1 err aligned based (errentp),			/* Entry for each different error syndrome found */
       62     2 mem char (1) unal,
       63     2 store char (2) unal,
       64     2 count fixed bin (35),
       65     2 ZAC_line bit (6) unal,
       66     2 syndrome bit (8) unal,
       67     2 identification bit (4) unal,
       68     2 day_count fixed bin (18) uns unal,
       69     2 day_list (16) fixed bin (18) uns unal;
       70 
       71 dcl 1 sort_list aligned based (sort_listp),
       72     2 count fixed bin,
       73     2 errentp (sort_list.count) ptr unal;
       74 
       75 dcl  sort_items_$general entry (ptr, entry);
       76 dcl  syserr_log_util_$open entry (bit (36) aligned, fixed bin (35));
       77 dcl  print_syserr_msg_$open_err entry (bit (36) aligned, char (*), fixed bin (35));
       78 dcl  com_err_ entry options (variable);
       79 dcl  get_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       80 dcl  syserr_log_util_$read entry (ptr, fixed bin, fixed bin, fixed bin (35));
       81 dcl  syserr_log_util_$close entry (fixed bin (35));
       82 dcl  release_temp_segments_ entry (char (*), dim (*) ptr, fixed bin (35));
       83 dcl  ioa_ entry options (variable);
       84 dcl  syserr_log_util_$search entry (fixed bin (71), fixed bin (71), fixed bin (35), fixed bin (35));
       85 dcl  date_time_ entry (fixed bin (71), char (*));
       86 dcl  cu_$arg_list_ptr entry (ptr);
       87 dcl  cu_$arg_count entry (fixed bin);
       88 dcl  cu_$arg_ptr_rel entry (fixed bin, ptr, fixed bin, fixed bin (35), ptr);
       89 dcl  edit_mos_rscr_$decode entry (ptr, char (*), char (*));
       90 dcl  convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
       91 dcl  convert_date_to_binary_$relative entry (char (*), fixed bin (71), fixed bin (71), fixed bin (35));
       92 
       93 dcl  time_data_$time_delta ext fixed bin (71);
       94 
       95 dcl  error_table_$end_of_info ext fixed bin (35);
       96 dcl  error_table_$badopt ext fixed bin (35);
       97 
       98 dcl (cleanup, conversion) condition;
       99 
      100 dcl (addr, bin, divide, hbound, index, substr) builtin;
      101 
      102 /* Initialization */
      103 
      104 	on cleanup call clean_up;
      105 
      106 	call get_temp_segments_ (name, ptr_array, code);	/* Get a work segment */
      107 	if code ^= 0 then do;
      108 	     call com_err_ (code, name, "Can't get temp segment");
      109 	     go to done;
      110 	end;
      111 	segs_allocated = "1"b;			/* Remember that they are allocated */
      112 	workp = ptr_array (1);			/* Copy pointer to my segment */
      113 
      114 	call cu_$arg_list_ptr (arg_list_ptr);		/* Need pointer to argument list */
      115 	call cu_$arg_count (arg_count);		/* And the length */
      116 	more_args = (arg_count > 0);			/* Set if args to scan */
      117 	call scan_args;				/* Scan the argument list */
      118 
      119 	call syserr_log_util_$open (open_status, code);	/* Open the syserr log */
      120 	if code ^= 0 | substr (open_status, 1, 2) ^= "11"b then do; /* If error */
      121 	     call print_syserr_msg_$open_err (open_status, name, code);
      122 	     if code ^= 0 then go to done;		/* Not recoverable */
      123 	end;
      124 
      125 	if ^from_sw then do;			/* No -from, so start at beginning */
      126 	     call syserr_log_util_$search (0, msg_time, msg_seq, code);
      127 	     if code ^= 0 then do;
      128 		call com_err_ (code, name, "Can't find first message in log.");
      129 		go to done;
      130 	     end;
      131 	     from_time = msg_time;			/* Official starting time */
      132 	end;
      133 	else do;					/* -from used, find right message */
      134 	     call syserr_log_util_$search (from_time, msg_time, msg_seq, code);
      135 	     if code ^= 0 then do;
      136 		call com_err_ (code, name, "Locating first message requested.");
      137 		go to done;
      138 	     end;
      139 	end;
      140 
      141 	if for_sw then do;				/* Now can compute -for limit */
      142 	     call convert_date_to_binary_$relative (for_arg, to_time, from_time, code);
      143 	     if code ^= 0 then do;
      144 		call com_err_ (code, name, "-for ^a", for_arg);
      145 		go to done;
      146 	     end;
      147 	     to_sw = "1"b;				/* Now, just as if -to was specified */
      148 	end;
      149 	if ^to_sw then to_time = from_time;		/* Initialize last message time */
      150 
      151 	syserr_msgp = addr (work.buffer);		/* Read here */
      152 
      153 /* Loop thru the file */
      154 
      155 loop:	call syserr_log_util_$read (syserr_msgp, hbound (buffer, 1), (0), code);
      156 	if code ^= 0 then do;
      157 	     if code = error_table_$end_of_info then go to print;
      158 	     call com_err_ (code, name, "Reading syserr log");
      159 	     go to done;
      160 	end;
      161 
      162 	if to_sw then do;				/* If time limit */
      163 	     if syserr_msg.time > to_time then go to print;
      164 	end;
      165 	else to_time = syserr_msg.time;		/* Save last message time */
      166 
      167 	if syserr_msg.data_code = SB_mos_err & syserr_msg.data_size > 0 then
      168 	     call count_it;
      169 	go to loop;
      170 
      171 /* End of log reached */
      172 
      173 print:	call sort_it;				/* Sort the table */
      174 	call print_it;				/* Print results */
      175 
      176 /* End of command */
      177 
      178 done:	call clean_up;
      179 	return;
      180 
      181 /* Procedure to scan the argument list */
      182 
      183 scan_args: proc;
      184 
      185 	     do while (more_args);			/* Do while thins to look at */
      186 		call get_arg;
      187 		if arg = "-from" | arg = "-fm" then do;		/* Start time */
      188 		     from_sw = "1"b;
      189 		     call time_arg (from_time);
      190 		end;
      191 		else if arg = "-to" then do;		/* Ending time */
      192 		     to_sw = "1"b;
      193 		     call time_arg (to_time);
      194 		end;
      195 		else if arg = "-for" then do;		/* Time limit */
      196 		     for_sw = "1"b;
      197 		     call time_arg (for_time);	/* For syntax checking only */
      198 		     for_len = arg_len;		/* Save pointer to this argument */
      199 		     for_ptr = arg_ptr;
      200 		end;
      201 		else if arg = "-limit" then count_limit = decimal_arg ();
      202 		else if arg = "-day_limit" then do;
      203 		     day_limit = decimal_arg ();
      204 		     if day_limit > 16 then do;
      205 			call com_err_ (0, name, "Maximum value for -day_limit is 16.");
      206 			go to done;
      207 		     end;
      208 		     us_per_day = 24*60*60*1000000;
      209 		end;
      210 		else if arg = "-mem" then do; /* List of MEMs */
      211 		     if ^more_args then do;		/* Need more args */
      212 no_scu:			call com_err_ (0, name, "Argument missing after -MEM");
      213 			go to done;
      214 		     end;
      215 		     call get_arg;
      216 		     if substr (arg, 1, 1) = "-" then go to no_scu; /* Shouldn't be control arg */
      217 new_scu:
      218 		     if (length (arg) > 1) | (index ("abcdefgh", arg) = 0) then do;
      219 			
      220 			call com_err_ (0, name, "Invalid mem specified ""^a""", arg);
      221 			go to done;
      222 		     end;
      223 		     
      224 
      225 		     scu_cnt = scu_cnt + 1;		/* Count MEM found */
      226 		     work.scureq (scu_cnt) = arg;	/* Save name */
      227 		     if more_args then do;		/* If more to scan */
      228 			call get_arg;
      229 			if substr (arg, 1, 1) ^= "-" then do; /* Found another MEM */
      230 			     if scu_cnt < hbound (work.scureq, 1) then go to new_scu;
      231 			     else do;		/* Too many */
      232 				call com_err_ (0, name, "There were more than ^d MEMs specified.",
      233 				     hbound (work.scureq, 1));
      234 				go to done;
      235 			     end;
      236 			end;
      237 			else call put_arg;		/* Went too far, back up 1 */
      238 		     end;
      239 		end;
      240 		else do;				/* Bad arg */
      241 		     call com_err_ (error_table_$badopt, name, "^a", arg);
      242 		     go to done;
      243 		end;
      244 	     end;
      245 
      246 	     if to_sw & for_sw then do;		/* Conflict */
      247 		call com_err_ (0, name, "Conflicting arguments: -to and -for");
      248 		go to done;
      249 	     end;
      250 
      251 	     return;
      252 
      253 	end scan_args;
      254 
      255 /* Procedure to return the next argument from command line */
      256 
      257 get_arg:	proc;
      258 
      259 	     call cu_$arg_ptr_rel (arg_no, arg_ptr, arg_len, code, arg_list_ptr);
      260 	     if code ^= 0 then do;			/* Should never happen */
      261 		call com_err_ (code, name, "Arg ^d", arg_no);
      262 		go to done;
      263 	     end;
      264 	     arg_no = arg_no + 1;			/* For next call */
      265 	     more_args = (arg_no <= arg_count);
      266 	     return;
      267 
      268 put_arg:	     entry;				/* Entry to return argument after scanning too far */
      269 	     arg_no = arg_no - 1;
      270 	     more_args = (arg_no <= arg_count);
      271 	     return;
      272 
      273 	end get_arg;
      274 
      275 /* Procedure to convert a time argument */
      276 
      277 time_arg:	proc (t);
      278 
      279 dcl  t fixed bin (71);				/* The time to ouput */
      280 dcl  arg_copy char (10) var;				/* Save copy of arg here */
      281 
      282 	     arg_copy = arg;
      283 	     if ^more_args then do;			/* Must be more */
      284 		call com_err_ (0, name, "Argument required after ^a.", arg_copy);
      285 		go to done;
      286 	     end;
      287 	     call get_arg;
      288 	     call convert_date_to_binary_ (arg, t, code);
      289 	     if code ^= 0 then do;
      290 		call com_err_ (code, name, "^a ^a", arg_copy, arg);
      291 		go to done;
      292 	     end;
      293 
      294 	     return;
      295 
      296 	end time_arg;
      297 
      298 /* Procedure to convert a decimal argument */
      299 
      300 decimal_arg: proc returns (fixed bin);
      301 
      302 dcl  arg_copy char (10) var;
      303 
      304 	     arg_copy = arg;
      305 	     if ^more_args then do;
      306 		call com_err_ (0, name, "Argument required after ^a.", arg_copy);
      307 		go to done;
      308 	     end;
      309 	     call get_arg;
      310 	     on conversion go to bad_dec_arg;
      311 	     return (bin (arg));
      312 
      313 bad_dec_arg:   call com_err_ (0, name, "Invalid ^a: ^a", arg_copy, arg);
      314 	     go to done;
      315 
      316 	end decimal_arg;
      317 
      318 /* Procedure to count an EDAC */
      319 
      320 count_it:	proc;
      321 
      322 dcl  (i, j) fixed bin;
      323 dcl  found bit (1);
      324 dcl  mem char (1);
      325 dcl  store char (2);
      326 dcl  day_no fixed bin;
      327 
      328 	     found = "0"b;
      329 	     scrp = addr (syserr_msg.data);
      330 	     i = index (syserr_msg.text, " mem ");
      331 	     if i = 0 then do;
      332 unparsable:	call com_err_ (0, name, "Unparsable syserr message. Text: ^a", syserr_msg.text);
      333 		return;
      334 	     end;
      335 	     mem = substr (syserr_msg.text, i + 5, 1);
      336 
      337 	     if scu_cnt > 0 then
      338 		do j = 1 to scu_cnt while (found = "0"b);
      339 		if mem = work.scureq (j) then
      340 		     found = "1"b;
      341 	     end;
      342 
      343 	     if scu_cnt > 0 then
      344 		if ^found then
      345 		return;			/*  don't count this one */
      346 	     else;
      347 	     
      348 
      349 	     i = index (syserr_msg.text, " store ");
      350 	     if i = 0 then go to unparsable;
      351 	     store = substr (syserr_msg.text, i+7, 2);
      352 	     if substr (store, 2, 1) = "." then substr (store, 2, 1) = " ";
      353 
      354 	     do i = 1 to err_cnt;
      355 		errentp = addr (work.errentry (i));
      356 		if err.mem = mem & err.store = store & err.ZAC_line = scr_su.ZAC_line &
      357 		err.syndrome = scr_su.syndrome & err.identification = scr_su.identification then do;
      358 		     err.count = err.count + 1;
      359 		     go to check_day;
      360 		end;
      361 	     end;
      362 
      363 	     err_cnt = err_cnt + 1;
      364 	     errentp = addr (work.errentry (err_cnt));
      365 	     err.mem = mem;
      366 	     err.store = store;
      367 	     err.count = 1;
      368 	     err.day_count = 0;
      369 	     err.ZAC_line = scr_su.ZAC_line;
      370 	     err.syndrome = scr_su.syndrome;
      371 	     err.identification = scr_su.identification;
      372 
      373 check_day:     if day_limit <= 0 then return;
      374 	     day_no = divide (syserr_msg.time - time_data_$time_delta, us_per_day, 17, 0);
      375 	     do i = 1 to err.day_count;
      376 		if err.day_list (i) = day_no then return;
      377 	     end;
      378 	     if err.day_count = hbound (err.day_list, 1) then return;
      379 	     err.day_count = err.day_count + 1;
      380 	     err.day_list (err.day_count) = day_no;
      381 
      382 	     return;
      383 
      384 	end count_it;
      385 
      386 /* Procedure to sort the table */
      387 
      388 sort_it:	proc;
      389 
      390 dcl  i fixed bin;
      391 dcl  sort_count fixed bin;
      392 
      393 	     sort_listp = addr (work.errentry (err_cnt + 1)); /* Use next available word */
      394 	     sort_list.count = err_cnt;		/* TEMP FIX */
      395 	     sort_count = 0;
      396 	     do i = 1 to err_cnt;
      397 		errentp = addr (work.errentry (i));
      398 		if err.count >= count_limit & err.day_count >= day_limit then do;
      399 		     sort_count = sort_count+1;
      400 		     sort_list.errentp (sort_count) = addr (work.errentry (i));
      401 		end;
      402 	     end;
      403 	     sort_list.count = sort_count;
      404 	     if sort_count < 2 then return;
      405 	     call sort_items_$general (sort_listp, compare_error);
      406 	     return;
      407 
      408 	end sort_it;
      409 
      410 compare_error: proc (p1, p2) returns (fixed bin (1));
      411 
      412 dcl (p1, p2) ptr unal;
      413 
      414 	     if p1 -> err.mem < p2 -> err.mem then return (-1);
      415 	     if p1 -> err.mem > p2 -> err.mem then return (+1);
      416 	     if p1 -> err.store < p2 -> err.store then return (-1);
      417 	     if p1 -> err.store > p2 -> err.store then return (+1);
      418 	     if p1 -> err.count < p2 -> err.count then return (+1);
      419 	     if p1 -> err.count > p2 -> err.count then return (-1);
      420 	     return (0);
      421 
      422 	end compare_error;
      423 
      424 /* Procedure to print results */
      425 
      426 print_it:	proc;
      427 
      428 dcl (tm1, tm2) char (24);				/* For editing times */
      429 dcl  work bit (72) aligned;
      430 dcl  mem_type char (32);
      431 dcl  error char (32);
      432 dcl  i fixed bin;
      433 dcl  prev_mem char (1);
      434 dcl  print_mem char (1);
      435 dcl  prev_store char (2);
      436 dcl  print_store char (2);
      437 dcl  prev_type char (32);
      438 dcl  print_type char (32);
      439 
      440 	     call date_time_ (from_time, tm1);
      441 	     call date_time_ (to_time, tm2);
      442 	     call ioa_ ("Summary from ^a to ^a^/^/MEM STORE CNT  TYPE                 SYNDROME DECODE", tm1, tm2);
      443 	     prev_mem, prev_store, prev_type = "";
      444 	     scrp = addr (work);
      445 	     do i = 1 to sort_list.count;
      446 		errentp = sort_list.errentp (i);
      447 		work = "0"b;
      448 		scr_su.ZAC_line = err.ZAC_line;
      449 		scr_su.syndrome = err.syndrome;
      450 		scr_su.identification = err.identification;
      451 		call edit_mos_rscr_$decode (scrp, mem_type, error);
      452 		if err.mem = prev_mem then do;
      453 		     print_mem = "";
      454 		     if err.store = prev_store then do;
      455 			print_store = "";
      456 			if mem_type = prev_type then print_type = "";
      457 			else print_type = mem_type;
      458 		     end;
      459 		     else do;
      460 			print_store = err.store;
      461 			print_type = mem_type;
      462 		     end;
      463 		end;
      464 		else do;
      465 		     call ioa_ ("");
      466 		     print_mem = err.mem;
      467 		     print_store = err.store;
      468 		     print_type = mem_type;
      469 		end;
      470 		prev_type = mem_type;
      471 		prev_mem = err.mem;
      472 		prev_store = err.store;
      473 		call ioa_ (" ^1a   ^2a^6d  ^20a ^a", print_mem, print_store, err.count, print_type, error);
      474 	     end;
      475 	     return;
      476 
      477 	end print_it;
      478 
      479 /* Cleanup handler */
      480 
      481 clean_up:	proc;
      482 
      483 	     call syserr_log_util_$close (code);
      484 
      485 	     if segs_allocated then do;
      486 		segs_allocated = "0"b;
      487 		call release_temp_segments_ (name, ptr_array, code);
      488 	     end;
      489 	     return;
      490 
      491 	end clean_up;
      492 
      493 
      494 
  1     1 /* Begin include file ..... syserr_message.incl.pl1 */
  1     2 
  1     3 /* Format of a syserr message */
  1     4 
  1     5 /* Created October 1975 by Larry Johnson */
  1     6 
  1     7 dcl  syserr_msgp ptr;				/* Base for include file */
  1     8 
  1     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  1    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  1    11     2 time fixed bin (71) unal,			/* Time message logged at */
  1    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  1    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  1    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  1    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  1    16     2 pad bit (60) unal,				/* RESERVED! */
  1    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  1    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  1    19 
  1    20 
  1    21 /* End include file ..... syserr_message.incl.pl1 */
      495 
      496 
  2     1 /* Begin include file ...... scr.incl.pl1
  2     2*   modified 5/75 by Noel I. Morris
  2     3*   modified 10/81 by M.R. Jordan for 64K chip, M64 memory 
  2     4*   modified '83 to make values constant */
  2     5 
  2     6 /* This include file is to be used in conjunction with pmut$rscr and pmut$sscr.
  2     7*   Wherever possible the terms in the processor manual are used in the declaration. */
  2     8 
  2     9 dcl (SC_MR init (0),				/* SC Mode Register */
  2    10      SC_CFG init (1),				/* SC Configuration Switches */
  2    11      SC_MSK init (2),				/* SC Interrupt Mask */
  2    12      SC_IC init (3),				/* SC Interrupt Cells */
  2    13      SC_ETC init (4),				/* SC Elapsed Time Clock */
  2    14      SC_SU init (6)) fixed bin (6) static options (constant); /* SU Mode Register */
  2    15 
  2    16 
  2    17 dcl  scrp ptr;					/* pointer to SC data */
  2    18 
  2    19 dcl 1 scr_cfg1 based (scrp) aligned,			/* configuration data for 6000 SC */
  2    20 
  2    21    (2 mode_a bit (3),				/* 000 => on-line
  2    22*						   001 => test mode
  2    23*						   010 => off-line */
  2    24     2 bdry_a bit (3),				/* 000 => 32K, 001 => 64K, etc */
  2    25     2 mode_b bit (3),				/* see mode_a */
  2    26     2 bdry_b bit (3),				/* see bdry_a */
  2    27     2 int bit (1),					/* 1 => stores are internally interlaced */
  2    28     2 lwr bit (1),					/* 1 => store B is low */
  2    29     2 addr_offset bit (2),				/* 00 => no offset, 01 => 32K offset, etc. */
  2    30     2 port_no bit (4),				/* requester's port number */
  2    31     2 port_enable (0:7) bit (2),			/* 00 => port disabled
  2    32*						   01 => port under program control
  2    33*						   11 => port enabled */
  2    34     2 pima (4) bit (9)) unaligned;			/* program interrupt mask assignments
  2    35*						   000 => unassigned
  2    36*						   400 => assigned to port 0
  2    37*						   200 => assigned to port 1
  2    38*						   .
  2    39*						   .
  2    40*						   .
  2    41*						   002 => assigned to port 7
  2    42*						   001 => assigned to maint. panel */
  2    43 
  2    44 
  2    45 dcl 1 scr_cfg2 based (scrp) aligned,			/* configuration data for 4MW SCU */
  2    46 
  2    47    (2 mask_a_assign bit (9),				/* interrupt mask "A" port assignment
  2    48*						   400 => assigned to port 0
  2    49*						   .
  2    50*						   .
  2    51*						   002 => assigned to port 7
  2    52*						   001 => mask off */
  2    53     2 size bit (3),					/* size of lower store */
  2    54     2 a_online bit (1),				/* 1 => store A online */
  2    55     2 a1_online bit (1),				/* 1 => store A1 online */
  2    56     2 b_online bit (1),				/* 1 => store B online */
  2    57     2 b1_online bit (1),				/* 1 => store B1 online */
  2    58     2 port_no bit (4),				/* requester's port number */
  2    59     2 pad1 bit (1),
  2    60     2 mode bit (1),					/* 1 => programmable mode */
  2    61     2 nea_enabled bit (1),				/* 1 => non-existent address logic enabled */
  2    62     2 nea bit (7),					/* 001 => 32K, 002 => 64K, 003 => 96K, etc. */
  2    63     2 int bit (1),					/* 1 => stores are internally interlaced */
  2    64     2 lwr bit (1),					/* 1 => store B is low */
  2    65     2 port_mask_0_3 bit (4),				/* 1 => corresponding port enabled */
  2    66 
  2    67     2 mask_b_assign bit (9),				/* interrupt mask "B" port assignment */
  2    68     2 pad2 bit (12),
  2    69     2 cyclic_prior bit (7),				/* cyclic port priority switches */
  2    70     2 pad3 bit (4),
  2    71     2 port_mask_4_7 bit (4)) unal;			/* 1 => corresponding port enabled */
  2    72 
  2    73 
  2    74 dcl 1 scr_mr based (scrp) aligned,			/* SC mode register */
  2    75 
  2    76    (2 pad1 bit (50),
  2    77     2 identification bit (4),				/* 0000 => 8034, 8035
  2    78*						   0001 => 6000 SC
  2    79*						   0010 => 4MW SCU */
  2    80     2 TS_strobe_margin bit (2),			/* 00 => normal timing
  2    81*						   01 => slow timing
  2    82*						   10 => inhibit strobe
  2    83*						   11 => fast timing */
  2    84     2 G0_strobe_margin bit (2),
  2    85     2 ANSWER_strobe_margin bit (2),
  2    86     2 DA_strobe_margin bit (2),
  2    87     2 EOC_strobe_margin bit (2),
  2    88     2 PLUS_5_VOLT_margin bit (2),			/* 00 => normal voltage
  2    89*						   01 => -5%
  2    90*						   10 => normal voltage
  2    91*						   11 => +5% */
  2    92     2 parity_override bit (1),			/* 1 => SU forced to accept data with incorrect parity */
  2    93     2 parity_disable bit (1),				/* 1 => disable data and ZAC parity checking */
  2    94     2 store_IA_disable bit (1),			/* 1 => disable illegal action indication */
  2    95     2 ZAC_parity_error bit (1),			/* 1 => cause ZAC parity error */
  2    96     2 SGR_accepted bit (1),				/* 1 => SGR command accepted by SC */
  2    97     2 pad2 bit (1)) unal;
  2    98 
  2    99 
  2   100 dcl 1 scr_msk based (scrp) aligned,			/* SC mask register */
  2   101 
  2   102    (2 interrupt_mask_1 bit (16),			/* mask bits for interrupts 0 thru 15 */
  2   103     2 pad1 bit (16),
  2   104     2 port_mask_1 bit (4),				/* mask bits for ports 0 thru 3 */
  2   105 
  2   106     2 interrupt_mask_2 bit (16),			/* mask bits for interrupts 16 thru 31 */
  2   107     2 pad2 bit (16),
  2   108     2 port_mask_2 bit (4)) unal;			/* mask bits for ports 4 thru 7 */
  2   109 
  2   110 
  2   111 dcl 1 scr_su based (scrp) aligned,			/* store unit mode register */
  2   112 
  2   113    (2 pad1 bit (36),
  2   114     2 ZAC_line bit (6),				/* EDAC mode only - address field */
  2   115     2 syndrome bit (8),				/* EDAC mode only - failure syndrome */
  2   116     2 identification bit (4),				/* 0000 => High Speed Core Model AA1
  2   117*						   0001 => High Speed Core Model AA3
  2   118*						   0011 => 4K, 16 pin chip, MOS memory, M32 boards
  2   119*						   0100 => 1K chip MOS memory with EDAC enabled
  2   120*						   1010 => 64K, 16 pin chip, MOS memory, M64 boards
  2   121*						   1011 => 16K, 16 pin chip, MOS memory, M264 boards
  2   122*						   1100 => 1K chip MOS memory with EDAC disabled
  2   123*						   1110 => 16K, 16 pin chip, MOS memory, M128 boards
  2   124*						   1111 => 4K, 22 pin chip MOS memory, M16 boards */
  2   125     2 EDAC_disabled bit (1),				/* 1 => correction disabled but detection still enabled */
  2   126     2 pad2 bit (4),
  2   127     2 MINUS_5_VOLT_margin bit (2),
  2   128     2 PLUS_5_VOLT_margin bit (2),
  2   129     2 spare_margin bit (2),
  2   130     2 PLUS_19_VOLT_margin bit (2),
  2   131     2 pad3 bit (1),
  2   132     2 SENSE_strobe_margin bit (2),			/* core only */
  2   133     2 pad4 bit (1),
  2   134     2 maint_functions_enabled bit (1)) unal;		/* 1 => maintenance functions enabled */
  2   135 
  2   136 /* End of include file ...... scr.incl.pl1 */
  2   137 
      497 
      498 
  3     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  3     2 
  3     3 /* This include file has an ALM version, keep 'em in sync. */
  3     4 
  3     5 /* format: off */
  3     6 
  3     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  3     8*   to be examined by display_cpu_error. */
  3     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  3    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  3    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  3    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  3    13*		also changed some codes to "SB_unused_NN" - see line comments */
  3    14 
  3    15 /* In the future, these will be the only constants needed in this include
  3    16*file.  They are the binary data class strings for messages in the new format
  3    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  3    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  3    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  3    20 
  3    21 dcl (						/* include file name */
  3    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  3    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  3    24 SB_mos_data_class		init ("mos"),		/* scr */
  3    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  3    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  3    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  3    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  3    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  3    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  3    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  3    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  3    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  3    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  3    35 ) static internal char (16) varying options (constant);
  3    36 
  3    37 
  3    38 /************************
  3    39*Once the syserr$binary is replaced with something that takes real data classes
  3    40*and all system modules and tools are upgraded to use the new interface, the
  3    41*rest of this include file may be discarded.
  3    42*************************/
  3    43 
  3    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  3    45*   extended at any time. */
  3    46 
  3    47 dcl (
  3    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  3    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  3    50 SB_io_err		init (3),		SBL_io_err	init (5),
  3    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  3    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  3    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  3    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  3    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  3    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  3    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  3    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  3    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  3    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  3    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  3    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  3    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  3    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  3    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  3    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  3    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  3    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  3    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  3    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  3    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  3    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  3    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  3    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  3    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  3    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  3    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  3    78   ) internal static options (constant) fixed bin;
  3    79 
  3    80 
  3    81 /* The following array is a mapping of the old syserr$binary codes into the
  3    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  3    83*the binary data codes stored in the wired syserr log (see above) into the data
  3    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  3    85*is also used by syserr_log_util_ to translate the data classes back into the
  3    86*corresponding binary code (for tools not yet upgraded to deal with the new
  3    87*format log messages). */
  3    88 
  3    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  3    90 	init (	"io_status",		/* 1 */
  3    91 		"hwfault",		/* 2 */
  3    92 		"io_status",		/* 3 */
  3    93 		"unused_4",		/* 4 */
  3    94 		"mos",			/* 5 */
  3    95 
  3    96 		"unused_6",		/* 6 */
  3    97 		"unused_7",		/* 7 */
  3    98 		"unused_8",		/* 8 */
  3    99 		"unused_9",		/* 9 */ 
  3   100 		"unused_10",		/* 10 */
  3   101 
  3   102 		"segdamage",		/* 11 */
  3   103 		"unused_12",		/* 12 */
  3   104 		"segdamage",		/* 13 */
  3   105 		"unused_14",		/* 14 */
  3   106 		"unused_15",		/* 15 */
  3   107 
  3   108 		"segdamage",		/* 16 */
  3   109 		"voldamage",		/* 17 */
  3   110 		"unused_18",		/* 18 */
  3   111 		"mdc_del_uidpath",		/* 19 */
  3   112 		"io_status",		/* 20 */
  3   113 
  3   114 		"mmdam",			/* 21 */
  3   115 		"hwfault",		/* 22 */
  3   116 		"io_status",		/* 23 */
  3   117 		"mpc_poll",		/* 24 */
  3   118 		"fnp_poll",		/* 25 */
  3   119 
  3   120 		"config_deck",		/* 26 */
  3   121 		"vtoce",			/* 27 */
  3   122 		"access_audit",		/* 28 */
  3   123 		"unused_29",		/* 29 */
  3   124 		"unused_30",		/* 30 */
  3   125 		"unused_31",		/* 31 */
  3   126 		"unused_32",		/* 32 */
  3   127 		"unused_33",		/* 33 */
  3   128 		"unused_34",		/* 34 */
  3   129 		"ibm3270_mde",		/* 35 */
  3   130 		"unused_36"		/* 36 */
  3   131 	);
  3   132 
  3   133 
  3   134 /* format: on */
  3   135 
  3   136 /* These constants are used by various tools which analyze syserr messages and
  3   137*still call the old interface "syserr_log_util_". */
  3   138 
  3   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  3   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  3   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  3   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  3   143 
  3   144      dcl	   display_cpu_error_binary_defs (2) init (
  3   145 			      2,			/** SB_hw_fault */
  3   146 			      22			/** SB_verify_lock */
  3   147 			      ) internal static options (constant) fixed bin;
  3   148 
  3   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      499 
      500 
      501      end mos_edac_summary;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/13/85  1100.2  mos_edac_summary.pl1              >spec>on>41-11>mos_edac_summary.pl1
495          1    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
497          2    08/17/83  1135.7  scr.incl.pl1                      >ldd>include>scr.incl.pl1
499          3    03/12/85  1556.6  syserr_binary_def.incl.pl1        >spec>on>41-11>syserr_binary_def.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
SB_mos_err                             constant        fixed bin(17,0)          initial dcl 3-47 ref 167
ZAC_line                  2            based           bit(6)                   level 2 in structure "err" packed unaligned dcl 61
                                                                                  in procedure "mes" set ref 356 369* 448
ZAC_line                  1            based           bit(6)                   level 2 in structure "scr_su" packed unaligned
                                                                                  dcl 2-111 in procedure "mes" set ref 356 369 448*
addr                                                   builtin function         dcl 100 ref 151 329 355 364 393 397 400 444
arg                                    based           char                     unaligned dcl 30 set ref 187 187 191 195 201 202 210
                                                                                  216 217 217 220* 226 229 241* 282 288* 290* 304
                                                                                  311 313*
arg_copy                        000100 automatic       varying char(10)         dcl 302 in procedure "decimal_arg" set ref 304* 306*
                                                                                  313*
arg_copy                        000202 automatic       varying char(10)         dcl 280 in procedure "time_arg" set ref 282* 284*
                                                                                  290*
arg_count                       000111 automatic       fixed bin(17,0)          dcl 31 set ref 115* 116 265 270
arg_len                         000110 automatic       fixed bin(17,0)          dcl 29 set ref 187 187 191 195 198 201 202 210 216
                                                                                  217 217 220 220 226 229 241 241 259* 282 288 288
                                                                                  290 290 304 311 313 313
arg_list_ptr                    000112 automatic       pointer                  dcl 32 set ref 114* 259*
arg_no                          000136 automatic       fixed bin(17,0)          initial dcl 46 set ref 46* 259* 261* 264* 264 265
                                                                                  269* 269 270
arg_ptr                         000106 automatic       pointer                  dcl 28 set ref 187 187 191 195 199 201 202 210 216
                                                                                  217 217 220 226 229 241 259* 282 288 290 304 311
                                                                                  313
bin                                                    builtin function         dcl 100 ref 311
buffer                  140            based           bit(36)                  array level 2 dcl 56 set ref 151 155 155
cleanup                         000154 stack reference condition                dcl 98 ref 104
code                            000100 automatic       fixed bin(35,0)          dcl 23 set ref 106* 107 108* 119* 120 121* 122 126*
                                                                                  127 128* 134* 135 136* 142* 143 144* 155* 156 157
                                                                                  158* 259* 260 261* 288* 289 290* 483* 487*
com_err_                        000016 constant        entry                    external dcl 78 ref 108 128 136 144 158 205 212 220
                                                                                  232 241 247 261 284 290 306 313 332
conversion                      000000 stack reference condition                dcl 98 ref 310
convert_date_to_binary_         000046 constant        entry                    external dcl 90 ref 288
convert_date_to_binary_$relative
                                000050 constant        entry                    external dcl 91 ref 142
count                     1            based           fixed bin(35,0)          level 2 in structure "err" dcl 61 in procedure "mes"
                                                                                  set ref 358* 358 367* 398 418 418 419 419 473*
count                                  based           fixed bin(17,0)          level 2 in structure "sort_list" dcl 71 in procedure
                                                                                  "mes" set ref 394* 403* 445
count_limit                     000132 automatic       fixed bin(17,0)          initial dcl 43 set ref 43* 201* 398
cu_$arg_count                   000040 constant        entry                    external dcl 87 ref 115
cu_$arg_list_ptr                000036 constant        entry                    external dcl 86 ref 114
cu_$arg_ptr_rel                 000042 constant        entry                    external dcl 88 ref 259
data                                   based           bit(36)                  array level 2 dcl 1-9 set ref 329
data_code                 4            based           fixed bin(11,0)          level 2 packed unaligned dcl 1-9 ref 167
data_size                 3(24)        based           fixed bin(11,0)          level 2 packed unaligned dcl 1-9 ref 167
date_time_                      000034 constant        entry                    external dcl 85 ref 440 441
day_count                 2(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 61 set ref
                                                                                  368* 375 378 379* 379 380 398
day_limit                       000133 automatic       fixed bin(17,0)          initial dcl 44 set ref 44* 203* 204 373 398
day_list                  3            based           fixed bin(18,0)          array level 2 packed unsigned unaligned dcl 61 set
                                                                                  ref 376 378 380*
day_no                          000221 automatic       fixed bin(17,0)          dcl 326 set ref 374* 376 380
divide                                                 builtin function         dcl 100 ref 374
edit_mos_rscr_$decode           000044 constant        entry                    external dcl 89 ref 451
err                                    based           structure                level 1 dcl 61
err_cnt                         000146 automatic       fixed bin(17,0)          initial dcl 51 set ref 51* 354 363* 363 364 393 394
                                                                                  396
errentp                         000140 automatic       pointer                  dcl 47 in procedure "mes" set ref 355* 356 356 356
                                                                                  356 356 358 358 364* 365 366 367 368 369 370 371
                                                                                  375 376 378 378 379 379 380 380 397* 398 398 446*
                                                                                  448 449 450 452 454 460 466 467 471 472 473
errentp                   1            based           pointer                  array level 2 in structure "sort_list" packed
                                                                                  unaligned dcl 71 in procedure "mes" set ref 400*
                                                                                  446
errentry               1124            based           structure                array level 2 dcl 56 set ref 355 364 393 397 400
error                           000314 automatic       char(32)                 unaligned dcl 431 set ref 451* 473*
error_table_$badopt             000056 external static fixed bin(35,0)          dcl 96 set ref 241*
error_table_$end_of_info        000054 external static fixed bin(35,0)          dcl 95 ref 157
for_arg                                based           char                     unaligned dcl 35 set ref 142* 144*
for_len                         000116 automatic       fixed bin(17,0)          dcl 34 set ref 142 142 144 144 198*
for_ptr                         000114 automatic       pointer                  dcl 33 set ref 142 144 199*
for_sw                          000121 automatic       bit(1)                   initial unaligned dcl 38 set ref 38* 141 196* 246
for_time                        000130 automatic       fixed bin(71,0)          dcl 42 set ref 197*
found                           000216 automatic       bit(1)                   unaligned dcl 323 set ref 328* 337 339* 343
from_sw                         000117 automatic       bit(1)                   initial unaligned dcl 36 set ref 36* 125 188*
from_time                       000124 automatic       fixed bin(71,0)          dcl 40 set ref 131* 134* 142* 149 189* 440*
get_temp_segments_              000020 constant        entry                    external dcl 79 ref 106
hbound                                                 builtin function         dcl 100 ref 155 155 230 232 232 378
i                               000254 automatic       fixed bin(17,0)          dcl 390 in procedure "sort_it" set ref 396* 397 400*
i                               000214 automatic       fixed bin(17,0)          dcl 322 in procedure "count_it" set ref 330* 331 335
                                                                                  349* 350 351 354* 355* 375* 376*
i                               000324 automatic       fixed bin(17,0)          dcl 432 in procedure "print_it" set ref 445* 446*
identification            1(14)        based           bit(4)                   level 2 in structure "scr_su" packed unaligned
                                                                                  dcl 2-111 in procedure "mes" set ref 356 371 450*
identification            2(14)        based           bit(4)                   level 2 in structure "err" packed unaligned dcl 61
                                                                                  in procedure "mes" set ref 356 371* 450
index                                                  builtin function         dcl 100 ref 217 330 349
ioa_                            000030 constant        entry                    external dcl 83 ref 442 465 473
j                               000215 automatic       fixed bin(17,0)          dcl 322 set ref 337* 339*
mask                            000105 automatic       bit(36)                  initial dcl 27 set ref 27*
mem                                    based           char(1)                  level 2 in structure "err" packed unaligned dcl 61
                                                                                  in procedure "mes" set ref 356 365* 414 414 415
                                                                                  415 452 466 471
mem                             000217 automatic       char(1)                  unaligned dcl 324 in procedure "count_it" set ref
                                                                                  335* 339 356 365
mem_type                        000304 automatic       char(32)                 unaligned dcl 430 set ref 451* 456 457 461 468 470
more_args                       000122 automatic       bit(1)                   unaligned dcl 39 set ref 116* 185 211 227 265* 270*
                                                                                  283 305
msg_seq                         000144 automatic       fixed bin(35,0)          dcl 49 set ref 126* 134*
msg_time                        000142 automatic       fixed bin(71,0)          dcl 48 set ref 126* 131 134*
name                            000000 constant        char(17)                 initial unaligned dcl 22 set ref 106* 108* 121* 128*
                                                                                  136* 144* 158* 205* 212* 220* 232* 241* 247* 261*
                                                                                  284* 290* 306* 313* 332* 487*
open_status                     000101 automatic       bit(36)                  dcl 24 set ref 119* 120 121*
p1                                     parameter       pointer                  unaligned dcl 412 ref 410 414 415 416 417 418 419
p2                                     parameter       pointer                  unaligned dcl 412 ref 410 414 415 416 417 418 419
prev_mem                        000325 automatic       char(1)                  unaligned dcl 433 set ref 443* 452 471*
prev_store                      000327 automatic       char(2)                  unaligned dcl 435 set ref 443* 454 472*
prev_type                       000331 automatic       char(32)                 unaligned dcl 437 set ref 443* 456 470*
print_mem                       000326 automatic       char(1)                  unaligned dcl 434 set ref 453* 466* 473*
print_store                     000330 automatic       char(2)                  unaligned dcl 436 set ref 455* 460* 467* 473*
print_syserr_msg_$open_err      000014 constant        entry                    external dcl 77 ref 121
print_type                      000341 automatic       char(32)                 unaligned dcl 438 set ref 456* 457* 461* 468* 473*
ptr_array                       000102 automatic       pointer                  array dcl 25 set ref 106* 112 487*
release_temp_segments_          000026 constant        entry                    external dcl 82 ref 487
scr_su                                 based           structure                level 1 dcl 2-111
scrp                            000164 automatic       pointer                  dcl 2-17 set ref 329* 356 356 356 369 370 371 444*
                                                                                  448 449 450 451*
scu_cnt                         000145 automatic       fixed bin(17,0)          initial dcl 50 set ref 50* 225* 225 226 230 337 337
                                                                                  343
scureq                                 based           varying char(7)          array level 2 dcl 56 set ref 226* 230 232 232 339
segs_allocated                  000147 automatic       bit(1)                   initial unaligned dcl 52 set ref 52* 111* 485 486*
sort_count                      000255 automatic       fixed bin(17,0)          dcl 391 set ref 395* 399* 399 400 403 404
sort_items_$general             000010 constant        entry                    external dcl 75 ref 405
sort_list                              based           structure                level 1 dcl 71
sort_listp                      000150 automatic       pointer                  dcl 53 set ref 393* 394 400 403 405* 445 446
store                           000220 automatic       char(2)                  unaligned dcl 325 in procedure "count_it" set ref
                                                                                  351* 352 352* 356 366
store                     0(09)        based           char(2)                  level 2 in structure "err" packed unaligned dcl 61
                                                                                  in procedure "mes" set ref 356 366* 416 416 417
                                                                                  417 454 460 467 472
substr                                                 builtin function         dcl 100 set ref 120 216 229 335 351 352 352*
syndrome                  1(06)        based           bit(8)                   level 2 in structure "scr_su" packed unaligned
                                                                                  dcl 2-111 in procedure "mes" set ref 356 370 449*
syndrome                  2(06)        based           bit(8)                   level 2 in structure "err" packed unaligned dcl 61
                                                                                  in procedure "mes" set ref 356 370* 449
syserr_log_util_$close          000024 constant        entry                    external dcl 81 ref 483
syserr_log_util_$open           000012 constant        entry                    external dcl 76 ref 119
syserr_log_util_$read           000022 constant        entry                    external dcl 80 ref 155
syserr_log_util_$search         000032 constant        entry                    external dcl 84 ref 126 134
syserr_msg                             based           structure                level 1 dcl 1-9
syserr_msgp                     000162 automatic       pointer                  dcl 1-7 set ref 151* 155* 163 165 167 167 329 330
                                                                                  332 335 349 351 374
t                                      parameter       fixed bin(71,0)          dcl 279 set ref 277 288*
tab_cnt                         000104 automatic       fixed bin(17,0)          initial dcl 26 set ref 26*
text                      6            based           char                     level 2 dcl 1-9 set ref 330 332* 335 349 351
text_len                  3(12)        based           fixed bin(11,0)          level 2 packed unaligned dcl 1-9 ref 329 330 332 332
                                                                                  335 349 351
time                      1            based           fixed bin(71,0)          level 2 packed unaligned dcl 1-9 ref 163 165 374
time_data_$time_delta           000052 external static fixed bin(71,0)          dcl 93 ref 374
tm1                             000266 automatic       char(24)                 unaligned dcl 428 set ref 440* 442*
tm2                             000274 automatic       char(24)                 unaligned dcl 428 set ref 441* 442*
to_sw                           000120 automatic       bit(1)                   initial unaligned dcl 37 set ref 37* 147* 149 162
                                                                                  192* 246
to_time                         000126 automatic       fixed bin(71,0)          dcl 41 set ref 142* 149* 163 165* 193* 441*
us_per_day                      000152 automatic       fixed bin(71,0)          dcl 54 set ref 208* 374
work                            000302 automatic       bit(72)                  dcl 429 in procedure "print_it" set ref 444 447*
work                                   based           structure                level 1 dcl 56 in procedure "mes"
workp                           000134 automatic       pointer                  dcl 45 set ref 112* 151 155 155 226 230 232 232 339
                                                                                  355 364 393 397 400

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 3-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 3-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 3-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 3-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 3-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 3-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 3-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 3-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 3-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 3-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 3-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 3-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 3-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 3-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 3-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 3-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 3-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 3-89
SB_config_deck                         internal static fixed bin(17,0)          initial dcl 3-47
SB_config_deck_data_class              internal static varying char(16)         initial dcl 3-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 3-47
SB_end_of_table                        internal static fixed bin(17,0)          initial dcl 3-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 3-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 3-21
SB_hw_fault                            internal static fixed bin(17,0)          initial dcl 3-47
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 3-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 3-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 3-21
SB_io_err                              internal static fixed bin(17,0)          initial dcl 3-47
SB_io_err_detail                       internal static fixed bin(17,0)          initial dcl 3-47
SB_io_status_data_class                internal static varying char(16)         initial dcl 3-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 3-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 3-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 3-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 3-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 3-21
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 3-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 3-21
SB_ocdcm_err                           internal static fixed bin(17,0)          initial dcl 3-47
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 3-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 3-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 3-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 3-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 3-47
SB_verify_lock                         internal static fixed bin(17,0)          initial dcl 3-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 3-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 3-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 3-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 3-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 3-47
SC_CFG                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_ETC                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_IC                                  internal static fixed bin(6,0)           initial dcl 2-9
SC_MR                                  internal static fixed bin(6,0)           initial dcl 2-9
SC_MSK                                 internal static fixed bin(6,0)           initial dcl 2-9
SC_SU                                  internal static fixed bin(6,0)           initial dcl 2-9
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 3-144
scr_cfg1                               based           structure                level 1 dcl 2-19
scr_cfg2                               based           structure                level 1 dcl 2-45
scr_mr                                 based           structure                level 1 dcl 2-74
scr_msk                                based           structure                level 1 dcl 2-100
syserr_binary_address_damage_mask      internal static bit(36)                  initial unaligned dcl 3-142
syserr_binary_mos_mask                 internal static bit(36)                  initial unaligned dcl 3-139
syserr_binary_seg_damage_mask          internal static bit(36)                  initial unaligned dcl 3-140
syserr_binary_vol_damage_mask          internal static bit(36)                  initial unaligned dcl 3-141

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_dec_arg                     002077 constant        label                    dcl 313 ref 310
check_day                       002442 constant        label                    dcl 373 ref 359
clean_up                        003210 constant        entry                    internal dcl 481 ref 104 178
compare_error                   002615 constant        entry                    internal dcl 410 ref 405 405
count_it                        002144 constant        entry                    internal dcl 320 ref 167
decimal_arg                     001762 constant        entry                    internal dcl 300 ref 201 203
done                            001041 constant        label                    dcl 178 ref 109 122 129 137 145 159 206 213 221 234
                                                                                  242 248 262 285 291 307 314
get_arg                         001512 constant        entry                    internal dcl 257 ref 186 215 228 287 309
loop                            000733 constant        label                    dcl 155 ref 169
mes                             000315 constant        entry                    external dcl 20
mos_edac_summary                000325 constant        entry                    external dcl 20
new_scu                         001256 constant        label                    dcl 217 ref 230
no_scu                          001217 constant        label                    dcl 212 ref 216
print                           001037 constant        label                    dcl 173 ref 157 163
print_it                        002715 constant        entry                    internal dcl 426 ref 174
put_arg                         001602 constant        entry                    internal dcl 268 ref 237
scan_args                       001046 constant        entry                    internal dcl 183 ref 117
sort_it                         002525 constant        entry                    internal dcl 388 ref 173
time_arg                        001617 constant        entry                    internal dcl 277 ref 189 193 197
unparsable                      002171 constant        label                    dcl 332 ref 350

NAME DECLARED BY CONTEXT OR IMPLICATION.
length                                                 builtin function         ref 217

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3616        3676    3267        3626
Length      4174    3267        60         261     326           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
mes                                 502 external procedure  is an external procedure.  
on unit on line 104                  64 on unit               
scan_args                               internal procedure  shares stack frame of external procedure mes.  
get_arg                              96 internal procedure  is called by several nonquick procedures.  
time_arg                                internal procedure  shares stack frame of external procedure mes.  
decimal_arg                         262 internal procedure  enables or reverts conditions.  
on unit on line 310                  64 on unit               
count_it                                internal procedure  shares stack frame of external procedure mes.  
sort_it                                 internal procedure  shares stack frame of external procedure mes.  
compare_error                        70 internal procedure  is assigned to an entry variable.  
print_it                                internal procedure  shares stack frame of external procedure mes.  
clean_up                             82 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
decimal_arg              000100 arg_copy                    decimal_arg
mes                      000100 code                        mes
                         000101 open_status                 mes
                         000102 ptr_array                   mes
                         000104 tab_cnt                     mes
                         000105 mask                        mes
                         000106 arg_ptr                     mes
                         000110 arg_len                     mes
                         000111 arg_count                   mes
                         000112 arg_list_ptr                mes
                         000114 for_ptr                     mes
                         000116 for_len                     mes
                         000117 from_sw                     mes
                         000120 to_sw                       mes
                         000121 for_sw                      mes
                         000122 more_args                   mes
                         000124 from_time                   mes
                         000126 to_time                     mes
                         000130 for_time                    mes
                         000132 count_limit                 mes
                         000133 day_limit                   mes
                         000134 workp                       mes
                         000136 arg_no                      mes
                         000140 errentp                     mes
                         000142 msg_time                    mes
                         000144 msg_seq                     mes
                         000145 scu_cnt                     mes
                         000146 err_cnt                     mes
                         000147 segs_allocated              mes
                         000150 sort_listp                  mes
                         000152 us_per_day                  mes
                         000162 syserr_msgp                 mes
                         000164 scrp                        mes
                         000202 arg_copy                    time_arg
                         000214 i                           count_it
                         000215 j                           count_it
                         000216 found                       count_it
                         000217 mem                         count_it
                         000220 store                       count_it
                         000221 day_no                      count_it
                         000254 i                           sort_it
                         000255 sort_count                  sort_it
                         000266 tm1                         print_it
                         000274 tm2                         print_it
                         000302 work                        print_it
                         000304 mem_type                    print_it
                         000314 error                       print_it
                         000324 i                           print_it
                         000325 prev_mem                    print_it
                         000326 print_mem                   print_it
                         000327 prev_store                  print_it
                         000330 print_store                 print_it
                         000331 prev_type                   print_it
                         000341 print_type                  print_it

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_le_a              call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              ext_entry           int_entry           set_cs_eis
index_cs_eis        any_to_any_tr       divide_fx4

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_date_to_binary_       convert_date_to_binary_$relative
cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr_rel               date_time_
edit_mos_rscr_$decode         get_temp_segments_            ioa_                          print_syserr_msg_$open_err
release_temp_segments_        sort_items_$general           syserr_log_util_$close        syserr_log_util_$open
syserr_log_util_$read         syserr_log_util_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$end_of_info      time_data_$time_delta




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     26 000276        27 000277        36 000300        37 000301        38 000302        43 000303        44 000304
     46 000305        50 000307        51 000310        52 000311        20 000314       104 000333       106 000355
    107 000376       108 000400       109 000424       111 000425       112 000427       114 000431       115 000440
    116 000447       117 000452       119 000453       120 000464       121 000472       122 000513       125 000515
    126 000517       127 000536       128 000540       129 000564       131 000565       132 000567       134 000570
    135 000605       136 000607       137 000633       141 000634       142 000636       143 000665       144 000667
    145 000721       147 000722       149 000724       151 000730       155 000733       156 000753       157 000755
    158 000760       159 001006       162 001007       163 001011       164 001017       165 001020       167 001025
    169 001036       173 001037       174 001040       178 001041       179 001045       183 001046       185 001047
    186 001052       187 001056       188 001070       189 001072       190 001074       191 001075       192 001101
    193 001103       194 001105       195 001106       196 001112       197 001114       198 001116       199 001120
    200 001122       201 001123       202 001136       203 001142       204 001150       205 001153       206 001200
    208 001201       209 001210       210 001211       211 001215       212 001217       213 001244       215 001245
    216 001251       217 001256       220 001270       221 001324       225 001325       226 001326       227 001343
    228 001345       229 001351       230 001356       232 001361       234 001414       237 001415       239 001421
    241 001422       242 001454       244 001455       246 001456       247 001462       248 001507       251 001510
    257 001511       259 001517       260 001536       261 001541       262 001570       264 001573       265 001574
    266 001600       268 001601       269 001607       270 001612       271 001616       277 001617       282 001621
    283 001632       284 001634       285 001665       287 001666       288 001672       289 001717       290 001721
    291 001757       294 001760       300 001761       304 001767       305 002001       306 002003       307 002033
    309 002036       310 002043       311 002062       313 002077       314 002141       320 002144       328 002145
    329 002146       330 002156       331 002170       332 002171       333 002231       335 002232       337 002236
    339 002251       341 002263       343 002265       349 002272       350 002304       351 002305       352 002311
    354 002320       355 002327       356 002333       358 002401       359 002405       361 002406       363 002410
    364 002411       365 002416       366 002420       367 002423       368 002425       369 002427       370 002432
    371 002436       373 002442       374 002445       375 002457       376 002467       377 002501       378 002503
    379 002512       380 002514       382 002524       388 002525       393 002526       394 002533       395 002535
    396 002536       397 002545       398 002551       399 002561       400 002562       401 002567       402 002570
    403 002572       404 002574       405 002577       406 002613       410 002614       414 002622       415 002653
    416 002657       417 002675       418 002701       419 002707       420 002713       426 002715       440 002716
    441 002733       442 002750       443 002773       444 003002       445 003004       446 003013       447 003015
    448 003017       449 003022       450 003026       451 003032       452 003052       453 003056       454 003060
    455 003066       456 003070       457 003100       458 003103       460 003104       461 003105       463 003110
    465 003111       466 003122       467 003124       468 003127       470 003132       471 003135       472 003140
    473 003144       474 003204       475 003206       481 003207       483 003215       485 003224       486 003227
    487 003230       489 003251


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
