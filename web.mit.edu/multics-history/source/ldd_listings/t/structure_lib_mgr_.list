	COMPILATION LISTING OF SEGMENT structure_lib_mgr_
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/24/88  1434.0 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 structure_lib_mgr_: 
        7      procedure ();
        8 
        9 	return;					/* not an entrypoint */
       10 
       11 /* Written 30 May 1983, W. Olin Sibert (from struct_seg_man_) */
       12 /* Modified for mr10.2 to not use a search list at all. Instead the pathname is hardcoded in. B. Braun 09/15/83 */
       13 /* Modified at some later time to use the search list after all. */
       14 /* Modified 1984-10-03 BIM to make archive components work,
       15*	  remove search list setting (in favor of .search segment),
       16*	  and add get_segment_ptr entrypoint. */
       17 
       18 /* * 	STRUCTURE_LIB_MGR_ (nee struct_seg_man_)
       19*   *
       20*   *      This is the procedure used to locate the library segments for the
       21*   *	structure display facility in analyze_multics, and manage the
       22*   *	structure search list. The reason for the extra layer of
       23*   * 	procedure being used here is to provide an easy interface to 
       24*   *	get segment pointers, which are remembered in an array internal
       25*   *      to this program. The array is rebuilt whenever the search list
       26*   *      changes, and also if any error ever occurs accessing one of the
       27*   *      segments.
       28*   *
       29*   */
       30 
       31 dcl  P_seg_idx fixed bin parameter; 
       32 dcl  P_segp pointer parameter;
       33 dcl  P_bit_count fixed bin (24);
       34 dcl  P_comp_name char (*);
       35 dcl  P_headerp pointer parameter;
       36 dcl  P_pathname char (*) parameter;
       37 dcl  P_known_list_ptr pointer;
       38 dcl  P_known_list_size fixed bin;
       39 dcl  P_code fixed bin (35) parameter;
       40 
       41 dcl  code fixed bin (35);
       42 
       43 dcl  last_change_idx fixed bin (71) internal static init (-137); /* used to decide whether search list has changed */
       44 dcl  change_idx_ptr pointer internal static init (null ());
       45 
       46 dcl  seg_info_ptr pointer internal static init (null ());	/* address of seg pointer array */
       47 dcl  alloc_seg_info_count fixed bin;
       48 
       49 dcl 1 seg_info based (seg_info_ptr),
       50     2 count fixed bin,
       51     2 max_count fixed bin,
       52     2 array (alloc_seg_info_count refer (seg_info.count)) like seg_info_entry;
       53 
       54 dcl 1 seg_info_entry aligned based,
       55     2 seg_ptr pointer,
       56     2 header_ptr pointer,
       57     2 time_compiled fixed bin (71),
       58     2 pl1_root pointer,
       59     2 known_list_ptr pointer,
       60     2 known_list_size fixed bin,     
       61     2 pathname char (168) unaligned,
       62     2 name char (32) unaligned;
       63 
       64 dcl 1 temp_seg_info aligned like seg_info_entry automatic;
       65 
       66 dcl  com_err_ entry options (variable);
       67 dcl  component_info_$name entry (pointer, char (*), pointer, fixed bin (35));
       68 dcl  expand_pathname_$component entry (character (*), character (*), character (*), character (*),
       69 	fixed binary (35));
       70 dcl  get_system_free_area_ entry returns (pointer);
       71 dcl  initiate_file_$component entry (character (*), character (*), character (*), bit (*), pointer,
       72 	fixed binary (24), fixed binary (35));
       73 dcl  object_info_$brief entry 
       74     (pointer, fixed bin (24), pointer, fixed bin (35));
       75 dcl  pathname_$component entry (character (*), character (*), character (*)) returns(character (194));
       76 dcl  search_paths_$set entry (character (*), pointer, pointer, fixed binary (35));
       77 dcl  search_paths_$get entry (char (*), 
       78      bit (36), char (*), pointer, pointer, fixed bin, pointer, fixed bin (35));
       79 dcl  stu_$find_runtime_symbol entry (pointer, char (*), pointer, fixed bin (35)) returns (pointer);
       80 
       81 dcl  error_table_$oldobj fixed bin (35) external static;
       82 dcl  error_table_$no_search_list fixed bin (35) external static;
       83 dcl  error_table_$new_search_list fixed bin (35) external static;
       84 dcl  error_table_$bad_segment fixed bin (35) external static;
       85 dcl  error_table_$zero_length_seg fixed bin (35) external static;
       86 
       87 dcl  WHOAMI char (32) internal static options (constant) init ("structure_lib_mgr_");
       88 dcl  SDL_LIST_NAME char (32) internal static options (constant) init ("structure");
       89 
       90 dcl (cleanup, out_of_bounds, no_read_permission, 
       91      not_in_read_bracket, seg_fault_error) condition;
       92 
       93 dcl (addr, codeptr, length, hbound, null, substr) builtin;
       94 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
       95 
       96 
       97 /*  */
       98 
       99 /* This entry returns information about the "next" segment in the search
      100*   list. It assumes that the search list does not change between calls
      101*   to this entrypoint, though if it does, the effect should be largely 
      102*   benign.  The first call should initialize P_seg_idx to zero; subsequent
      103*   calls will increment P_seg_idx, and a null pointer will be returned
      104*   when there are no more segments to be had.
      105*   */
      106 
      107 structure_lib_mgr_$next_segment:
      108      entry (P_seg_idx,
      109 	P_segp, P_headerp, P_pathname, P_known_list_ptr, P_known_list_size);
      110 
      111 
      112 	P_segp = null ();				/* Default values for initialization */
      113 	P_headerp = null ();
      114 	P_pathname = "";
      115 
      116 	P_seg_idx = P_seg_idx + 1;			/* get the next one, and return it */
      117 
      118 	if ^get_seg_info () then return;		/* get the array */
      119 
      120 	if (P_seg_idx > seg_info.count) then return;	/* all used up; just return */
      121 
      122 	P_segp = seg_info.seg_ptr (P_seg_idx);
      123 	P_headerp = seg_info.header_ptr (P_seg_idx);
      124 	P_pathname = seg_info.pathname (P_seg_idx);
      125 	P_known_list_ptr = seg_info.known_list_ptr (P_seg_idx);
      126 	P_known_list_size = seg_info.known_list_size (P_seg_idx);
      127 
      128 	return;					/* end of code for $next_segment */
      129 
      130 /*  */
      131 
      132 /* This entrypoint gets relevant information about a specific segment */
      133 
      134 structure_lib_mgr_$get_segment:
      135      entry (P_pathname, 
      136           P_segp, P_headerp, P_known_list_ptr, P_known_list_size, P_code);
      137 
      138 
      139 	if ^find_segment (P_pathname, addr (temp_seg_info), "0"b) then do;
      140 	     P_segp = null ();
      141 	     P_headerp = null ();
      142 	     P_known_list_ptr = null ();
      143 	     P_known_list_size = 0;
      144 	     P_code = code;
      145 	     return;
      146 	     end;
      147 
      148 	P_segp = temp_seg_info.seg_ptr;
      149 	P_headerp = temp_seg_info.header_ptr;
      150 	P_known_list_ptr = temp_seg_info.known_list_ptr;
      151 	P_known_list_size = temp_seg_info.known_list_size;
      152 	P_code = 0;
      153 	return;
      154 
      155 /**** This entrypoint takes a segment pointer, and does the object segment
      156*      analysis. */
      157 
      158 structure_lib_mgr_$get_segment_ptr:
      159      entry (P_segp, P_bit_count, P_comp_name, P_headerp, P_known_list_ptr, 
      160 	  P_known_list_size, P_code);
      161 
      162 	if ^find_segment$$analyze (P_segp, P_bit_count, P_comp_name, addr (temp_seg_info))
      163 	then do;
      164 	     P_headerp = null ();
      165 	     P_known_list_ptr = null ();
      166 	     P_known_list_size = 0;
      167 	     return;
      168 	end;
      169 
      170 	P_headerp = temp_seg_info.header_ptr;
      171 	P_known_list_ptr = temp_seg_info.known_list_ptr;
      172 	P_known_list_size = temp_seg_info.known_list_size;
      173 	P_code = 0;
      174 	return;
      175 
      176 /*  */
      177 
      178 get_seg_info: 
      179      procedure () returns (bit (1) aligned);
      180 
      181 /* This procedure fills in the seg_info array whenever the search list changes.
      182*   It returns a bit indicating whether it was successful at getting it. 
      183*   */
      184 
      185 dcl  idx fixed bin;
      186 dcl  idx1 fixed bin;
      187 dcl  next_seg_idx fixed bin;
      188 dcl  original_num_paths fixed bin;
      189 dcl  update_sw bit (1) aligned;
      190 dcl  system_area_ptr pointer;
      191 dcl  system_area area based (system_area_ptr);
      192 
      193 
      194 	if ^search_list_changed () then return ("1"b);	/* OK if it's still the same */
      195 
      196 	system_area_ptr = get_system_free_area_ ();
      197 	sl_info_p = null ();			/* prepare for cleanup handler */
      198 
      199 	on condition (cleanup) begin;
      200 	     if (sl_info_p ^= null ()) then
      201 		free sl_info in (system_area);
      202 	     end;
      203 
      204 	call search_paths_$get (SDL_LIST_NAME, sl_control_default, "", null (), addr(system_area), (1), sl_info_p,
      205 	     code);
      206 
      207 
      208 	if code ^= 0 then do;
      209 	     call com_err_ (code, WHOAMI, "Cannot get ^a search list.", SDL_LIST_NAME);
      210 	     return ("0"b);
      211 	     end;
      212 
      213 
      214 
      215 	if (sl_info.num_paths = 0) then do;		/* nothing there already */
      216 	     call com_err_ (0, WHOAMI, "The ^a search list is empty.", SDL_LIST_NAME);
      217 	     goto GET_SEG_INFO_RETURNS;
      218 	     end;
      219 
      220 	if (seg_info_ptr ^= null ()) then do;		/* free old one */
      221 	     free seg_info in (system_area);
      222 	     seg_info_ptr = null ();
      223 	     end;
      224 
      225 	original_num_paths = sl_info.num_paths;		/* Used to reset so extents will be correct when freeing */
      226 
      227 	alloc_seg_info_count = sl_info.num_paths;
      228 	allocate seg_info in (system_area) set (seg_info_ptr);
      229 
      230 	seg_info.max_count = alloc_seg_info_count;
      231 	seg_info.count = 0;
      232 	next_seg_idx = 1;				/* Index of next entry to fill in */
      233 	update_sw = "0"b;				/* Whether we need to re-set the list afterwards */
      234 
      235 	do idx = 1 to sl_info.num_paths;		/* loop through and initiate all the search paths */
      236 	     if (sl_info.paths (idx).type ^= ABSOLUTE_PATH) then do;
      237 		call com_err_ (0, WHOAMI, "Removing invalid search path ^a.", sl_info.paths (idx).pathname);
      238 
      239 		update_sw = "1"b;
      240 		goto NEXT_SEARCH_PATH;
      241 		end;
      242 
      243 	     if ^find_segment (sl_info.paths (idx).pathname, addr (seg_info.array (next_seg_idx)), "1"b) then do;
      244 		update_sw = "1"b;			/* Must update */
      245 		goto NEXT_SEARCH_PATH;		/* We've already printed a message */
      246 		end;
      247 
      248 	     do idx1 = 1 to seg_info.count;		/* Check for duplications now */
      249 		if (seg_info.header_ptr (idx1) = seg_info.header_ptr (next_seg_idx)) then do;
      250 		     call com_err_ (0, WHOAMI, 
      251 			"^a appears multiply in the ^a search list.^/^3xExtra instances will be removed.", 
      252 			seg_info.pathname (idx1), SDL_LIST_NAME);
      253 		     update_sw = "1"b;
      254 		     goto NEXT_SEARCH_PATH;		/* Only one duplication can ever occur at a time, */
      255 		     end;				/* since others would have been detected already */
      256 		end;
      257 
      258 	     seg_info.count = next_seg_idx;
      259 	     next_seg_idx = next_seg_idx + 1;		/* Go on to the next slot */
      260 
      261 	     if (sl_info.paths (idx).pathname ^= seg_info.pathname (seg_info.count)) then
      262 		update_sw = "1"b;			/* update to include the suffix */
      263 
      264 NEXT_SEARCH_PATH:
      265 	     end;
      266 
      267 	if update_sw then do;			/* Update back into the search list */
      268 	     do idx = 1 to seg_info.count;
      269 		sl_info.paths (idx).type = ABSOLUTE_PATH;
      270 		sl_info.paths (idx).pathname = seg_info.pathname (idx);
      271 		sl_info.paths (idx).code = 0;
      272 		end;
      273 
      274 	     sl_info.num_paths = seg_info.count;
      275 	     call search_paths_$set (SDL_LIST_NAME, (null ()), sl_info_p, (0));
      276 	     if (sl_info.num_paths = 0) then
      277 		call com_err_ (0, WHOAMI, "The ^a search list is empty.", SDL_LIST_NAME);
      278 	     end;
      279 
      280 	last_change_idx = sl_info.change_index;
      281 	change_idx_ptr = sl_info.change_index_p;
      282 
      283 GET_SEG_INFO_RETURNS:
      284 	if (sl_info_p ^= null ()) then do;
      285 	     sl_info.num_paths = original_num_paths;	/* not strictly necessary, but let's */
      286 	     free sl_info in (system_area);		/* be polite to PL/I here */
      287 	     end;
      288 
      289 	if (seg_info_ptr = null ()) then return ("0"b);   /* Major failure */
      290 	return (seg_info.count > 0);			/* Consider it OK if there are any */
      291 
      292 	end get_seg_info;
      293 
      294 /* */
      295 
      296 search_list_changed:
      297      procedure () returns (bit (1) aligned);
      298 
      299 dcl  idx fixed bin;
      300 dcl  change_idx fixed bin (71) based;
      301 dcl  time_compiled fixed bin (71);
      302 
      303 
      304 	if (change_idx_ptr = null ()) then goto UPDATE;	/* First time */
      305 
      306 	if (change_idx_ptr -> change_idx ^= last_change_idx) then goto UPDATE; /* It's changed */
      307 
      308 	if (seg_info_ptr = null ()) then goto UPDATE;	/* In case something's screwed up */
      309 	if (seg_info.count <= 0) then goto UPDATE;
      310 
      311 	on condition (seg_fault_error) goto UPDATE;
      312 	on condition (not_in_read_bracket) goto UPDATE;
      313 	on condition (no_read_permission) goto UPDATE;
      314 	on condition (out_of_bounds) goto UPDATE;
      315 	
      316 	do idx = 1 to seg_info.count;			/* Try to reference each one */
      317 	     time_compiled = seg_info.header_ptr (idx) -> std_symbol_header.object_created;
      318 	     if (time_compiled ^= seg_info.time_compiled (idx)) then goto UPDATE;
      319 	     end;
      320 	     
      321 	return ("0"b);				/* If we make it through, nothing has changed, */
      322 						/* and nothing needs recalculation */
      323 
      324 
      325 UPDATE:
      326 	return ("1"b);				/* one of the segments in the list */
      327 
      328 	end search_list_changed;
      329 
      330 /*  */
      331 
      332 /* This procedure fills in seg_info information for the requested segment.
      333*   A bit is returned indicating whether the segment could be found or not,
      334*   and whether it turned out to be in the right format.
      335*   */
      336 
      337 find_segment: 
      338      procedure (P_pathname, P_seg_info_ptr, P_report_errors)
      339 	returns (bit (1) aligned);
      340 
      341 dcl  P_pathname char (*) parameter;
      342 dcl  P_seg_info_ptr pointer parameter;
      343 dcl  P_report_errors bit (1) aligned parameter;
      344 
      345 dcl 1 P_seg_info aligned like seg_info_entry based (P_seg_info_ptr);
      346 
      347 dcl  dname char (168);
      348 dcl  ename char (32);
      349 dcl  component char (32);
      350 dcl  bitcount fixed bin (24);
      351 dcl  segp pointer;
      352 dcl  report_errors bit (1) aligned;
      353 
      354 /* First, locate the segment in the hierarchy, and get a pointer to it */
      355 
      356           report_errors = P_report_errors;
      357 	call locate_segment ();
      358 	go to COMMON;
      359 
      360 find_segment$$analyze:
      361 	entry (P_segp, P_bitcount, P_comp_name, P_seg_info_ptr) returns (bit (1) aligned);
      362 declare P_bitcount fixed bin (24);
      363 declare P_segp pointer;
      364 declare P_comp_name char (*);
      365 
      366 	segp = P_segp;
      367 	bitcount = P_bitcount;
      368 	ename = P_comp_name; /* for component_info */
      369 	report_errors = "0"b;
      370 
      371 COMMON:
      372 
      373 /* Now, try to find the symbol table header (these structure library segments
      374*   are Multics standard object segments), and find the root of the PL/I
      375*   block tree */
      376 
      377 	call analyze_segment ();
      378 
      379 	call find_structure_list ();
      380 
      381 	return ("1"b);				/* If we get here, it worked */
      382 
      383 
      384 
      385 FIND_SEGMENT_FAILS:
      386      return ("0"b);
      387 
      388 
      389 invalid_segment:
      390      procedure (error_code);
      391 
      392 dcl  error_code fixed bin (35) parameter;
      393 
      394 	if report_errors then
      395 	     call com_err_ (error_code, WHOAMI, 
      396 	          "^a>^a.^/^3xRemoving it from the ^a search list.", 
      397 	          dname, ename, SDL_LIST_NAME);
      398 
      399 	code = error_code;
      400 	goto FIND_SEGMENT_FAILS;
      401 
      402 	end invalid_segment;
      403 
      404 /*  */
      405 
      406 locate_segment:					/* Procedure internal to find_segment */
      407      procedure ();
      408 
      409 	call expand_pathname_$component (P_pathname, dname, ename, component, code);
      410 	if code ^= 0 then do;
      411 	     if report_errors then
      412 	          call com_err_ (code, WHOAMI, "^a", P_pathname);
      413 	     goto FIND_SEGMENT_FAILS;
      414 	     end;
      415 
      416 	call initiate_file_$component (dname, ename, component, R_ACCESS, segp, bitcount, code);
      417 	if code ^= 0 then call invalid_segment (code);
      418 	if (bitcount = 0) then 
      419 	     call invalid_segment (error_table_$zero_length_seg);
      420 
      421 	P_seg_info.seg_ptr = segp;
      422 	P_seg_info.pathname = pathname_$component (dname, ename, component);
      423 	P_seg_info.name = ename;
      424 
      425 	return;
      426 	end locate_segment;
      427 
      428 /*  */
      429 
      430 analyze_segment:
      431      procedure ();
      432 
      433 dcl 1 oi aligned like object_info automatic;
      434 dcl  hp pointer;
      435 dcl  bp pointer; 
      436 dcl  rootp pointer;
      437 
      438 
      439 	oi.version_number = object_info_version_2;
      440 	call object_info_$brief (segp, bitcount, addr (oi), code);
      441 	if (code ^= 0) then call invalid_segment (code);
      442 
      443 	P_seg_info.time_compiled = oi.symbp -> std_symbol_header.object_created;
      444 
      445 	if oi.bound then do;			/* Get info about the component, then */
      446 	     call component_info_$name (segp, ename, addr (ci), code);
      447 	     if (code ^= 0) then call invalid_segment (code);
      448 	     hp= ci.symb_start;
      449 	     end;
      450 
      451 	else hp= oi.symbp;			/* Only one for an unbound segment */
      452 
      453 	if (hp -> std_symbol_header.identifier ^= "symbtree") then call invalid_segment (error_table_$oldobj);
      454 	if (hp -> std_symbol_header.area_pointer = ""b) then call invalid_segment (error_table_$oldobj);
      455 	
      456 	bp = addrel (hp, hp -> std_symbol_header.area_pointer);
      457 	if (bp -> pl1_symbol_block.identifier ^= "pl1info") then call invalid_segment (error_table_$oldobj);
      458 
      459 	rootp = addrel (hp, bp -> pl1_symbol_block.root);
      460 	if (rel (rootp) = ""b) then call invalid_segment (error_table_$oldobj);
      461 	rootp = addrel (rootp, rootp -> runtime_block.son); /* Look in the outermost "real" block */
      462 	if (rel (rootp) = ""b) then call invalid_segment (error_table_$oldobj);
      463 
      464 	P_seg_info.header_ptr = hp;
      465 	P_seg_info.pl1_root = rootp;
      466 
      467 	return;
      468 	end analyze_segment;
      469 
      470 /*  */
      471 
      472 find_structure_list:
      473      procedure ();
      474      
      475 dcl  symp pointer;
      476 dcl  idx fixed bin;
      477 dcl  known_list (P_seg_info.known_list_size) char (32) unaligned based (P_seg_info.known_list_ptr);
      478 
      479 
      480 	P_seg_info.known_list_ptr = null ();
      481 	P_seg_info.known_list_size = 0;
      482 
      483 	symp = stu_$find_runtime_symbol 
      484 	     (P_seg_info.pl1_root, "STRUCTURES", (null ()), code);
      485 	if (symp = null ()) then return;		/* No list of defined structures in this segment */
      486 
      487 	if (binary (symp -> runtime_symbol.type, 6) ^= char_dtype) then goto INVALID;
      488 	if (binary (symp -> runtime_symbol.ndims, 6) ^= 1) then goto INVALID;
      489 	if (symp -> runtime_symbol.size ^= 32) then goto INVALID;
      490 	if (symp -> runtime_symbol.bounds (1).lower ^= 1) then goto INVALID;
      491 	if (symp -> runtime_symbol.bounds (1).upper > 1000) then goto INVALID;
      492 	if (symp -> runtime_symbol.address.class ^= "1100"b) then goto INVALID;
      493 
      494 	P_seg_info.known_list_ptr = pointer (symp, symp -> runtime_symbol.address.location);
      495 	P_seg_info.known_list_size = symp -> runtime_symbol.bounds (1).upper;
      496 
      497 	do idx = 1 to P_seg_info.known_list_size	/* Trim off blank entries */
      498 		while (known_list (idx) ^= "");
      499 	     P_seg_info.known_list_size = idx;
      500 	     end;
      501 
      502 	return;
      503 
      504 
      505 INVALID:
      506 	if report_errors 
      507 	then call com_err_ (0, WHOAMI,
      508 	     "The ""STRUCTURES"" list of known structures in ^a^/^3x must be declared as dim (XXX) char (32) internal static options (constant).",
      509 	     pathname_$component (dname, ename, component));
      510 	code = error_table_$bad_segment;
      511 	goto FIND_SEGMENT_FAILS;
      512 
      513 	end find_structure_list;
      514 
      515 	end find_segment;
      516 
      517  /* BEGIN INCLUDE FILE . . . sl_info.incl.pl1 */
  2     2 
  2     3      
  2     4 
  2     5 /****^  HISTORY COMMENTS:
  2     6*  1) change(87-11-16,Lippard), approve(87-12-21,MCR7822),
  2     7*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  2     8*     Modified to add INITIATED_SEGS type.
  2     9*  2) change(87-11-19,Lippard), approve(87-12-21,MCR7822),
  2    10*     audit(88-02-09,Blair), install(88-02-16,MR12.2-1023):
  2    11*     Added uid to sl_info structure.
  2    12*                                                   END HISTORY COMMENTS */
  2    13 
  2    14 
  2    15 declare 1 sl_info	      aligned based (sl_info_p),
  2    16 	     2 version	      fixed binary,		/* Must be 1 */
  2    17 	     2 num_paths	      fixed binary,		/* Number of search paths */
  2    18 	     2 change_index_p     pointer,		/* Pointer to search list's update count */
  2    19 	     2 change_index	      fixed binary (71),	/* This search list's update count */
  2    20 	     2 pad1	      (6) bit (36),		/* Must be zero */
  2    21 	     2 paths	      (sl_info_num_paths refer (sl_info.num_paths)),
  2    22 	       3 type	      fixed binary,		/* Type of search path */
  2    23 	       3 code	      fixed binary (35),	/* Standard status code of search path */
  2    24 	       3 uid	      bit (36),		/* Unique ID */
  2    25 	       3 pathname	      char (168) unaligned;	/* Search pathname */
  2    26 
  2    27      declare sl_info_num_paths      fixed binary;
  2    28      declare sl_info_p	      pointer;
  2    29      declare sl_info_version_1      fixed binary internal static options (constant) initial (1);
  2    30 
  2    31 /* Keyword Types */
  2    32 
  2    33      declare ABSOLUTE_PATH	      fixed binary internal static options (constant) initial (0);
  2    34      declare UNEXPANDED_PATH	      fixed binary internal static options (constant) initial (1);
  2    35      declare REFERENCING_DIR	      fixed binary internal static options (constant) initial (3);
  2    36      declare WORKING_DIR	      fixed binary internal static options (constant) initial (4);
  2    37      declare PROCESS_DIR	      fixed binary internal static options (constant) initial (5);
  2    38      declare HOME_DIR	      fixed binary internal static options (constant) initial (6);
  2    39      declare INITIATED_SEGS	      fixed binary internal static options (constant) initial (7);
  2    40 
  2    41 /* END INCLUDE FILE . . . sl_info.incl.pl1 */
      517 
      518  /* BEGIN INCLUDE FILE . . . sl_control_s.incl.pl1 */
  3     2 
  3     3      declare 1 sl_control_s	      unaligned based (addr (sl_control)),
  3     4 	     2 af_pathname	      bit (1),		/* "1"b => expand active functions */
  3     5 	     2 pad1	      bit (1),		/* Must be zero */
  3     6 	     2 key_ref_dir	      bit (1),		/* "1"b => expand -referencing_dir keyword */
  3     7 	     2 key_work_dir	      bit (1),		/* "1"b => expand -working_dir keyword */
  3     8 	     2 key_proc_dir	      bit (1),		/* "1"b => expand -process_dir keyword */
  3     9 	     2 key_home_dir	      bit (1),		/* "1"b => expand -home_dir keyword */
  3    10 	     2 pad2	      bit (30);		/* Must be zero */
  3    11 
  3    12      declare sl_control	      bit (36);
  3    13      declare sl_control_default     bit (36) internal static options (constant) initial ("101111"b);
  3    14 
  3    15 /* END INCLUDE FILE . . . sl_control_s.incl.pl1 */
      518 
      519  /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  4     2*coded February 8, 1972 by Michael J. Spier	*/
  4     3 /* modified May 26, 1972 by M. Weaver */
  4     4 /* modified 15 April, 1975 by M. Weaver */
  4     5 
  4     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  4     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  4     8 	2 textp pointer,			/* pointer to beginning of text section */
  4     9 	2 defp pointer,			/* pointer to beginning of definition section */
  4    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  4    11 	2 statp pointer,			/* pointer to beginning of static section */
  4    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  4    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  4    14 	2 tlng fixed bin,			/* length in words of text section */
  4    15 	2 dlng fixed bin,			/* length in words of definition section */
  4    16 	2 llng fixed bin,			/* length in words of linkage section */
  4    17 	2 ilng fixed bin,			/* length in words of static section */
  4    18 	2 slng fixed bin,			/* length in words of symbol section */
  4    19 	2 blng fixed bin,			/* length in words of break map */
  4    20 	2 format,				/* word containing bit flags about object type */
  4    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  4    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  4    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  4    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  4    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  4    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  4    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  4    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  4    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  4    30 	  3 pad bit(27) unaligned,
  4    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  4    32 	2 textlinkp pointer,		/* ptr to first link in text */
  4    33 
  4    34 	/* LIMIT OF BRIEF STRUCTURE */
  4    35 
  4    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  4    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  4    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  4    39 	2 cvers aligned,			/* generator version name in printable char string form */
  4    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  4    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  4    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  4    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  4    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  4    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  4    46 
  4    47 	/* LIMIT OF DISPLAY STRUCTURE */
  4    48 
  4    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  4    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  4    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  4    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  4    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  4    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  4    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  4    56 					/* currently not used by system */
  4    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  4    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  4    59 
  4    60 declare	object_info_version_2 fixed bin int static init(2);
  4    61 
  4    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
      519 
      520  	/* BEGIN INCLUDE SEGMENT ...  component_info.incl.pl1   M. Weaver  4/26/72  */
  5     2 
  5     3 declare	1 ci aligned,
  5     4 	2 dcl_version fixed bin,		/* version number of this structure */
  5     5 	2 name char(32) aligned,		/* objectname of component segment */
  5     6 	2 text_start pointer,		/* ptr to component's section of text */
  5     7 	2 stat_start pointer,		/* pointer to component's section of internal static */
  5     8 	2 symb_start pointer,		/* pointer to component's first symbol block */
  5     9 	2 defblock_ptr pointer,		/* ptr to component's definition block */
  5    10 	2 text_lng fixed bin,		/* length of text section */
  5    11 	2 stat_lng fixed bin,		/* length of internal static */
  5    12 	2 symb_lng fixed bin,		/* length of symbol section */
  5    13 	2 n_blocks fixed bin,		/* number of symbol blocks in component's symbol section */
  5    14 	2 standard bit(1) aligned,		/* indicates whether component is in standard (new) format */
  5    15 	2 compiler char(8) aligned,		/* name of component's compiler */
  5    16 	2 compile_time fixed bin(71),		/* time component was compiled */
  5    17 	2 userid char(32) aligned,		/* id of creator of component */
  5    18 	2 cvers aligned,			/* version of component's compiler in printable form */
  5    19 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  5    20 	  3 length bit(18) unaligned,		/* length of name in characters */
  5    21 	2 comment aligned,			/* component's comment */
  5    22 	  3 offset bit(18) unaligned,		/* offset in words relative to symb_start */
  5    23 	  3 length bit(18) unaligned,		/* length of comment in characters */
  5    24 	2 source_map fixed bin;		/* offset, rel to beg of symbol block, of component's source map */
  5    25 
  5    26 	/* END INCLUDE SEGMENT ... component_info.incl.pl1 */
      520 
      521  dcl	1 std_symbol_header	based aligned,
  6     2 	2 dcl_version	fixed bin,
  6     3 	2 identifier	char(8),
  6     4 	2 gen_number	fixed bin,
  6     5 	2 gen_created	fixed bin(71),
  6     6 	2 object_created	fixed bin(71),
  6     7 	2 generator	char(8),
  6     8 	2 gen_version	unaligned,
  6     9 	  3 offset	bit(18),
  6    10 	  3 size		bit(18),
  6    11 	2 userid		unaligned,
  6    12 	  3 offset	bit(18),
  6    13 	  3 size		bit(18),
  6    14 	2 comment		unaligned,
  6    15 	  3 offset	bit(18),
  6    16 	  3 size		bit(18),
  6    17 	2 text_boundary	bit(18) unaligned,
  6    18 	2 stat_boundary	bit(18) unaligned,
  6    19 	2 source_map	bit(18) unaligned,
  6    20 	2 area_pointer	bit(18) unaligned,
  6    21 	2 backpointer	bit(18) unaligned,
  6    22 	2 block_size	bit(18) unaligned,
  6    23 	2 next_block	bit(18) unaligned,
  6    24 	2 rel_text	bit(18) unaligned,
  6    25 	2 rel_def		bit(18) unaligned,
  6    26 	2 rel_link	bit(18) unaligned,
  6    27 	2 rel_symbol	bit(18) unaligned,
  6    28 	2 mini_truncate	bit(18) unaligned,
  6    29 	2 maxi_truncate	bit(18) unaligned;
      521 
      522  dcl	1 pl1_symbol_block	aligned based,
  7     2 	2 version		fixed bin,
  7     3 	2 identifier	char(8),		/* must be "pl1info" */
  7     4 	2 flags,
  7     5 	  3 profile	bit(1) unal,
  7     6 	  3 table		bit(1) unal,
  7     7 	  3 map		bit(1) unal,
  7     8 	  3 flow		bit(1) unal,
  7     9 	  3 io		bit(1) unal,
  7    10 	  3 table_removed	bit(1) unal,
  7    11 	  3 long_profile	bit(1) unal,
  7    12 	  3 pad		bit(29) unal,
  7    13 	2 greatest_severity	fixed bin,
  7    14 	2 root		unal bit(18),
  7    15 	2 profile		unal bit(18),
  7    16 	2 map		unal,
  7    17 	  3 first		bit(18),
  7    18 	  3 last		bit(18),
  7    19 	2 segname		unaligned,
  7    20 	  3 offset	bit(18),
  7    21 	  3 size		bit(18);
      522 
      523  /*	BEGIN INCLUDE FILE ... runtime_symbol.incl.pl1 ... Modified 07/79 */
  8     2 
  8     3 dcl	1 runtime_symbol	aligned based,
  8     4 	2 flag		unal bit(1),	/* always "1"b for Version II */
  8     5 	2 use_digit	unal bit(1),	/* if "1"b and units are half words units are really digits */
  8     6 	2 array_units	unal bit(2),
  8     7 	2 units		unal bit(2),	/* addressing units */
  8     8 	2 type		unal bit(6),	/* data type */
  8     9 	2 level		unal bit(6),	/* structure level */
  8    10 	2 ndims		unal bit(6),	/* number of dimensions */
  8    11 	2 bits		unal,
  8    12 	  3 aligned	bit(1),
  8    13 	  3 packed	bit(1),
  8    14 	  3 simple	bit(1),
  8    15 	2 skip		unal bit(1),
  8    16 	2 scale		unal bit(8),	/* arithmetic scale factor */
  8    17 	2 name		unal bit(18),	/* rel ptr to acc name */
  8    18 	2 brother		unal bit(18),	/* rel ptr to brother entry */
  8    19 	2 father		unal bit(18),	/* rel ptr to father entry */
  8    20 	2 son		unal bit(18),	/* rel ptr to son entry */
  8    21 	2 address		unal,
  8    22 	  3 location	bit(18),		/* location in storage class */
  8    23 	  3 class		bit(4),		/* storage class */
  8    24 	  3 next		bit(14),		/* rel ptr to next of same class */
  8    25 	2 size		fixed bin(35),	/* encoded string|arith size */
  8    26 	2 offset		fixed bin(35),	/* encoded offset from address */
  8    27 	2 virtual_org	fixed bin(35),
  8    28 	2 bounds(1),
  8    29 	  3 lower		fixed bin(35),	/* encoded lower bound */
  8    30 	  3 upper		fixed bin(35),	/* encoded upper bound */
  8    31 	  3 multiplier	fixed bin(35);	/* encoded multiplier */
  8    32 
  8    33 dcl	1 runtime_bound	based,
  8    34 	2 lower		fixed bin(35),
  8    35 	2 upper		fixed bin(35),
  8    36 	2 multiplier	fixed bin(35);
  8    37 
  8    38 dcl	1 runtime_block	aligned based,
  8    39 	2 flag		unal bit(1),	/* always "1"b for Version II */
  8    40 	2 quick		unal bit(1),	/* "1"b if quick block */
  8    41 	2 fortran		unal bit(1),	/* "1"b if fortran program */
  8    42 	2 standard	unal bit(1),	/* "1"b if program has std obj segment */
  8    43 	2 owner_flag	unal bit(1),	/* "1"b if block has valid owner field */
  8    44 	2 skip		unal bit(1),
  8    45 	2 type		unal bit(6),	/* = 0 for a block node */
  8    46 	2 number		unal bit(6),	/* begin block number */
  8    47 	2 start		unal bit(18),	/* rel ptr to start of symbols */
  8    48 	2 name		unal bit(18),	/* rel ptr to name of proc */
  8    49 	2 brother		unal bit(18),	/* rel ptr to brother block */
  8    50 	2 father		unal bit(18),	/* rel ptr to father block */
  8    51 	2 son		unal bit(18),	/* rel ptr to son block */
  8    52 	2 map		unal,
  8    53 	  3 first		bit(18),		/* rel ptr to first word of map */
  8    54 	  3 last		bit(18),		/* rel ptr to last word of map */
  8    55 	2 entry_info	unal bit(18),	/* info about entry of quick block */
  8    56 	2 header		unal bit(18),	/* rel ptr to symbol header */
  8    57 	2 chain(4)	unal bit(18),	/* chain(i) is rel ptr to first symbol
  8    58*					   on start list with length >= 2**i */
  8    59 	2 token(0:5)	unal bit(18),	/* token(i) is rel ptr to first token
  8    60*					   on list with length >= 2 ** i */
  8    61 	2 owner		unal bit(18);	/* rel ptr to owner block */
  8    62 
  8    63 dcl	1 runtime_token	aligned based,
  8    64 	2 next		unal bit(18),	/* rel ptr to next token */
  8    65 	2 dcl		unal bit(18),	/* rel ptr to first dcl of this token */
  8    66 	2 name,				/* ACC */
  8    67 	  3 size		unal unsigned fixed bin (9), /* number of chars in token */
  8    68 	  3 string	unal char(n refer(runtime_token.size));
  8    69 
  8    70 dcl	1 encoded_value	aligned based,
  8    71 	2 flag		bit (2) unal,
  8    72 	2 code		bit (4) unal,
  8    73 	2 n1		bit (6) unal,
  8    74 	2 n2		bit (6) unal,
  8    75 	2 n3		bit (18) unal;
  8    76 
  8    77 /*	END INCLUDE FILE ... runtime_symbol.incl.pl1 */
      523 
      524  /* BEGIN INCLUDE FILE ... std_descriptor_types.incl.pl1 */
  9     2 
  9     3 
  9     4 /****^  HISTORY COMMENTS:
  9     5*  1) change(86-09-05,JMAthane), approve(86-09-05,MCR7525),
  9     6*     audit(86-09-11,Martinson), install(86-11-12,MR12.0-1208):
  9     7*     Added pascal_string_type_dtype descriptor type.  Its number is 87.
  9     8*     Objects of this type are PASCAL string types.
  9     9*  2) change(88-09-20,WAAnderson), approve(88-09-20,MCR7952),
  9    10*     audit(88-09-30,JRGray), install(88-10-24,MR12.2-1184):
  9    11*     Added the new C types.
  9    12*                                                   END HISTORY COMMENTS */
  9    13 
  9    14 /* This include file defines mnemonic names for the Multics
  9    15*   standard descriptor types, using both pl1 and cobol terminology.
  9    16*   PG 780613
  9    17*   JRD 790530
  9    18*   JRD 791016
  9    19*   MBW 810731
  9    20*   TGO 830614 Add hex types.
  9    21*   Modified June 83 JMAthane to add PASCAL data types
  9    22*   TGO 840120 Add float dec extended and generic, float binary generic
  9    23**/
  9    24 
  9    25      dcl	   (real_fix_bin_1_dtype  init (1),
  9    26 	   real_fix_bin_2_dtype   init (2),
  9    27 	   real_flt_bin_1_dtype   init (3),
  9    28 	   real_flt_bin_2_dtype   init (4),
  9    29 	   cplx_fix_bin_1_dtype   init (5),
  9    30 	   cplx_fix_bin_2_dtype   init (6),
  9    31 	   cplx_flt_bin_1_dtype   init (7),
  9    32 	   cplx_flt_bin_2_dtype   init (8),
  9    33 	   real_fix_dec_9bit_ls_dtype init (9),
  9    34 	   real_flt_dec_9bit_dtype init (10),
  9    35 	   cplx_fix_dec_9bit_ls_dtype init (11),
  9    36 	   cplx_flt_dec_9bit_dtype init (12),
  9    37 	   pointer_dtype	      init (13),
  9    38 	   offset_dtype	      init (14),
  9    39 	   label_dtype	      init (15),
  9    40 	   entry_dtype	      init (16),
  9    41 	   structure_dtype	      init (17),
  9    42 	   area_dtype	      init (18),
  9    43 	   bit_dtype	      init (19),
  9    44 	   varying_bit_dtype      init (20),
  9    45 	   char_dtype	      init (21),
  9    46 	   varying_char_dtype     init (22),
  9    47 	   file_dtype	      init (23),
  9    48 	   real_fix_dec_9bit_ls_overp_dtype init (29),
  9    49 	   real_fix_dec_9bit_ts_overp_dtype init (30),
  9    50 	   real_fix_bin_1_uns_dtype init (33),
  9    51 	   real_fix_bin_2_uns_dtype init (34),
  9    52 	   real_fix_dec_9bit_uns_dtype init (35),
  9    53 	   real_fix_dec_9bit_ts_dtype init (36),
  9    54 	   real_fix_dec_4bit_uns_dtype init (38),	/* digit-aligned */
  9    55 	   real_fix_dec_4bit_ts_dtype init (39),	/* byte-aligned */
  9    56 	   real_fix_dec_4bit_bytealigned_uns_dtype init (40), /* COBOL */
  9    57 	   real_fix_dec_4bit_ls_dtype init (41),	/* digit-aligned */
  9    58 	   real_flt_dec_4bit_dtype init (42),		/* digit-aligned */
  9    59 	   real_fix_dec_4bit_bytealigned_ls_dtype init (43),
  9    60 	   real_flt_dec_4bit_bytealigned_dtype init (44),
  9    61 	   cplx_fix_dec_4bit_bytealigned_ls_dtype init (45),
  9    62 	   cplx_flt_dec_4bit_bytealigned_dtype init (46),
  9    63 	   real_flt_hex_1_dtype   init (47),
  9    64 	   real_flt_hex_2_dtype   init (48),
  9    65 	   cplx_flt_hex_1_dtype   init (49),
  9    66 	   cplx_flt_hex_2_dtype   init (50),
  9    67 	   c_typeref_dtype        init (54),
  9    68 	   c_enum_dtype           init (55),
  9    69              c_enum_const_dtype     init (56),
  9    70 	   c_union_dtype          init (57),
  9    71 	   algol68_straight_dtype init (59),
  9    72 	   algol68_format_dtype   init (60),
  9    73 	   algol68_array_descriptor_dtype init (61),
  9    74 	   algol68_union_dtype    init (62),
  9    75 
  9    76 	   cobol_comp_6_dtype     init (1),
  9    77 	   cobol_comp_7_dtype     init (1),
  9    78 	   cobol_display_ls_dtype init (9),
  9    79 	   cobol_structure_dtype  init (17),
  9    80 	   cobol_char_string_dtype init (21),
  9    81 	   cobol_display_ls_overp_dtype init (29),
  9    82 	   cobol_display_ts_overp_dtype init (30),
  9    83 	   cobol_display_uns_dtype init (35),
  9    84 	   cobol_display_ts_dtype init (36),
  9    85 	   cobol_comp_8_uns_dtype init (38),		/* digit aligned */
  9    86 	   cobol_comp_5_ts_dtype  init (39),		/* byte aligned */
  9    87 	   cobol_comp_5_uns_dtype init (40),
  9    88 	   cobol_comp_8_ls_dtype  init (41),		/* digit aligned */
  9    89 	   real_flt_dec_extended_dtype init (81),	/* 9-bit exponent */
  9    90 	   cplx_flt_dec_extended_dtype init (82),	/* 9-bit exponent */
  9    91 	   real_flt_dec_generic_dtype init (83),	/* generic float decimal */
  9    92 	   cplx_flt_dec_generic_dtype init (84),
  9    93 	   real_flt_bin_generic_dtype init (85),	/* generic float binary */
  9    94 	   cplx_flt_bin_generic_dtype init (86)) fixed bin internal static options (constant);
  9    95 
  9    96      dcl	   (ft_integer_dtype      init (1),
  9    97 	   ft_real_dtype	      init (3),
  9    98 	   ft_double_dtype	      init (4),
  9    99 	   ft_complex_dtype	      init (7),
  9   100 	   ft_complex_double_dtype init (8),
  9   101 	   ft_external_dtype      init (16),
  9   102 	   ft_logical_dtype	      init (19),
  9   103 	   ft_char_dtype	      init (21),
  9   104 	   ft_hex_real_dtype      init (47),
  9   105 	   ft_hex_double_dtype    init (48),
  9   106 	   ft_hex_complex_dtype   init (49),
  9   107 	   ft_hex_complex_double_dtype init (50)
  9   108 	   )		      fixed bin internal static options (constant);
  9   109 
  9   110      dcl	   (algol68_short_int_dtype init (1),
  9   111 	   algol68_int_dtype      init (1),
  9   112 	   algol68_long_int_dtype init (2),
  9   113 	   algol68_real_dtype     init (3),
  9   114 	   algol68_long_real_dtype init (4),
  9   115 	   algol68_compl_dtype    init (7),
  9   116 	   algol68_long_compl_dtype init (8),
  9   117 	   algol68_bits_dtype     init (19),
  9   118 	   algol68_bool_dtype     init (19),
  9   119 	   algol68_char_dtype     init (21),
  9   120 	   algol68_byte_dtype     init (21),
  9   121 	   algol68_struct_struct_char_dtype init (22),
  9   122 	   algol68_struct_struct_bool_dtype init (20)
  9   123 	   )		      fixed bin internal static options (constant);
  9   124 
  9   125      dcl	   (label_constant_runtime_dtype init (24),
  9   126 	   int_entry_runtime_dtype init (25),
  9   127 	   ext_entry_runtime_dtype init (26),
  9   128 	   ext_procedure_runtime_dtype init (27),
  9   129 	   picture_runtime_dtype  init (63)
  9   130 	   )		      fixed bin internal static options (constant);
  9   131 
  9   132      dcl	   (pascal_integer_dtype  init (1),
  9   133 	   pascal_real_dtype      init (4),
  9   134 	   pascal_label_dtype     init (24),
  9   135 	   pascal_internal_procedure_dtype init (25),
  9   136 	   pascal_exportable_procedure_dtype init (26),
  9   137 	   pascal_imported_procedure_dtype init (27),
  9   138 	   pascal_typed_pointer_type_dtype init (64),
  9   139 	   pascal_char_dtype      init (65),
  9   140 	   pascal_boolean_dtype   init (66),
  9   141 	   pascal_record_file_type_dtype init (67),
  9   142 	   pascal_record_type_dtype init (68),
  9   143 	   pascal_set_dtype	      init (69),
  9   144 	   pascal_enumerated_type_dtype init (70),
  9   145 	   pascal_enumerated_type_element_dtype init (71),
  9   146 	   pascal_enumerated_type_instance_dtype init (72),
  9   147 	   pascal_user_defined_type_dtype init (73),
  9   148 	   pascal_user_defined_type_instance_dtype init (74),
  9   149 	   pascal_text_file_dtype init (75),
  9   150 	   pascal_procedure_type_dtype init (76),
  9   151 	   pascal_variable_formal_parameter_dtype init (77),
  9   152 	   pascal_value_formal_parameter_dtype init (78),
  9   153 	   pascal_entry_formal_parameter_dtype init (79),
  9   154 	   pascal_parameter_procedure_dtype init (80),
  9   155 	   pascal_string_type_dtype init (87)) fixed bin int static options (constant);
  9   156 
  9   157 
  9   158 /* END INCLUDE FILE ... std_descriptor_types.incl.pl1 */
      524 
      525 
      526 	end structure_lib_mgr_;			/* external procedure */
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/24/88  1400.6  structure_lib_mgr_.pl1            >special_ldd>install>MR12.2-1184>structure_lib_mgr_.pl1
95           1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
517          2    02/18/88  2023.8  sl_info.incl.pl1                  >ldd>include>sl_info.incl.pl1
518          3    01/09/79  1617.9  sl_control_s.incl.pl1             >ldd>include>sl_control_s.incl.pl1
519          4    08/05/77  1022.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
520          5    05/06/74  1741.0  component_info.incl.pl1           >ldd>include>component_info.incl.pl1
521          6    05/06/74  1751.6  std_symbol_header.incl.pl1        >ldd>include>std_symbol_header.incl.pl1
522          7    03/10/77  1345.4  pl1_symbol_block.incl.pl1         >ldd>include>pl1_symbol_block.incl.pl1
523          8    11/26/79  1320.6  runtime_symbol.incl.pl1           >ldd>include>runtime_symbol.incl.pl1
524          9    10/24/88  1336.9  std_descriptor_types.incl.pl1     >special_ldd>install>MR12.2-1184>std_descriptor_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ABSOLUTE_PATH                          constant        fixed bin(17,0)          initial dcl 2-33 ref 236 269
P_bit_count                            parameter       fixed bin(24,0)          dcl 33 set ref 158 162*
P_bitcount                             parameter       fixed bin(24,0)          dcl 362 ref 360 367
P_code                                 parameter       fixed bin(35,0)          dcl 39 set ref 134 144* 152* 158 173*
P_comp_name                            parameter       char                     packed unaligned dcl 364 in procedure "find_segment"
                                                                                  ref 360 368
P_comp_name                            parameter       char                     packed unaligned dcl 34 in procedure
                                                                                  "structure_lib_mgr_" set ref 158 162*
P_headerp                              parameter       pointer                  dcl 35 set ref 107 113* 123* 134 141* 149* 158 164*
                                                                                  170*
P_known_list_ptr                       parameter       pointer                  dcl 37 set ref 107 125* 134 142* 150* 158 165* 171*
P_known_list_size                      parameter       fixed bin(17,0)          dcl 38 set ref 107 126* 134 143* 151* 158 166* 172*
P_pathname                             parameter       char                     packed unaligned dcl 36 in procedure
                                                                                  "structure_lib_mgr_" set ref 107 114* 124* 134
                                                                                  139*
P_pathname                             parameter       char                     packed unaligned dcl 341 in procedure "find_segment"
                                                                                  set ref 337 409* 411*
P_report_errors                        parameter       bit(1)                   dcl 343 ref 337 356
P_seg_idx                              parameter       fixed bin(17,0)          dcl 31 set ref 107 116* 116 120 122 123 124 125 126
P_seg_info                             based           structure                level 1 dcl 345
P_seg_info_ptr                         parameter       pointer                  dcl 342 ref 337 360 421 422 423 443 464 465 480 481
                                                                                  483 494 495 497 497 499
P_segp                                 parameter       pointer                  dcl 363 in procedure "find_segment" ref 360 366
P_segp                                 parameter       pointer                  dcl 32 in procedure "structure_lib_mgr_" set ref 107
                                                                                  112* 122* 134 140* 148* 158 162*
R_ACCESS                        000040 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 416*
SDL_LIST_NAME                   000001 constant        char(32)                 initial packed unaligned dcl 88 set ref 204* 209*
                                                                                  216* 250* 275* 276* 394*
WHOAMI                          000011 constant        char(32)                 initial packed unaligned dcl 87 set ref 209* 216*
                                                                                  237* 250* 276* 394* 411* 505*
addr                                                   builtin function         dcl 93 ref 139 139 162 162 204 204 243 243 440 440
                                                                                  446 446
address                   3            based           structure                level 2 packed packed unaligned dcl 8-3
alloc_seg_info_count            000101 automatic       fixed bin(17,0)          dcl 47 set ref 227* 228 228 230
area_pointer             16(18)        based           bit(18)                  level 2 packed packed unaligned dcl 6-1 ref 454 456
array                     2            based           structure                array level 2 unaligned dcl 49 set ref 243 243
bitcount                        000172 automatic       fixed bin(24,0)          dcl 350 set ref 367* 416* 418 440*
bound                    24(01) 000226 automatic       bit(1)                   level 3 packed packed unaligned dcl 433 set ref 445
bounds                    7            based           structure                array level 2 dcl 8-3
bp                              000316 automatic       pointer                  dcl 435 set ref 456* 457 459
change_idx                             based           fixed bin(71,0)          dcl 300 ref 306
change_idx_ptr                  000012 internal static pointer                  initial dcl 44 set ref 281* 304 306
change_index              4            based           fixed bin(71,0)          level 2 dcl 2-15 ref 280
change_index_p            2            based           pointer                  level 2 dcl 2-15 ref 281
char_dtype                             constant        fixed bin(17,0)          initial dcl 9-25 ref 487
ci                              000202 automatic       structure                level 1 dcl 5-3 set ref 446 446
class                     3(18)        based           bit(4)                   level 3 packed packed unaligned dcl 8-3 ref 492
cleanup                         000000 stack reference condition                dcl 90 ref 199
code                     15            based           fixed bin(35,0)          array level 3 in structure "sl_info" dcl 2-15
                                                                                  in procedure "structure_lib_mgr_" set ref 271*
code                            000100 automatic       fixed bin(35,0)          dcl 41 in procedure "structure_lib_mgr_" set ref 144
                                                                                  204* 208 209* 399* 409* 410 411* 416* 417 417*
                                                                                  440* 441 441* 446* 447 447* 483* 510*
com_err_                        000016 constant        entry                    external dcl 66 ref 209 216 237 250 276 394 411 505
component                       000162 automatic       char(32)                 packed unaligned dcl 349 set ref 409* 416* 422* 505*
                                                                                  505*
component_info_$name            000020 constant        entry                    external dcl 67 ref 446
count                                  based           fixed bin(17,0)          level 2 dcl 49 set ref 120 221 228* 231* 248 258*
                                                                                  261 268 274 290 309 316
dname                           000100 automatic       char(168)                packed unaligned dcl 347 set ref 394* 409* 416* 422*
                                                                                  505* 505*
ename                           000152 automatic       char(32)                 packed unaligned dcl 348 set ref 368* 394* 409* 416*
                                                                                  422* 423 446* 505* 505*
error_code                             parameter       fixed bin(35,0)          dcl 392 set ref 389 394* 399
error_table_$bad_segment        000044 external static fixed bin(35,0)          dcl 84 ref 510
error_table_$oldobj             000042 external static fixed bin(35,0)          dcl 81 set ref 453* 454* 457* 460* 462*
error_table_$zero_length_seg    000046 external static fixed bin(35,0)          dcl 85 set ref 418*
expand_pathname_$component      000022 constant        entry                    external dcl 68 ref 409
format                   24     000226 automatic       structure                level 2 dcl 433
get_system_free_area_           000024 constant        entry                    external dcl 70 ref 196
header_ptr                2     000102 automatic       pointer                  level 2 in structure "temp_seg_info" dcl 64
                                                                                  in procedure "structure_lib_mgr_" set ref 149 170
header_ptr                2            based           pointer                  level 2 in structure "P_seg_info" dcl 345
                                                                                  in procedure "find_segment" set ref 464*
header_ptr                4            based           pointer                  array level 3 in structure "seg_info" dcl 49
                                                                                  in procedure "structure_lib_mgr_" set ref 123 249
                                                                                  249 317
hp                              000314 automatic       pointer                  dcl 434 set ref 448* 451* 453 454 456 456 459 464
identifier                1            based           char(8)                  level 2 in structure "std_symbol_header" dcl 6-1
                                                                                  in procedure "structure_lib_mgr_" ref 453
identifier                1            based           char(8)                  level 2 in structure "pl1_symbol_block" dcl 7-1
                                                                                  in procedure "structure_lib_mgr_" ref 457
idx                             000100 automatic       fixed bin(17,0)          dcl 185 in procedure "get_seg_info" set ref 235* 236
                                                                                  237 243 261* 268* 269 270 270 271*
idx                             000332 automatic       fixed bin(17,0)          dcl 476 in procedure "find_structure_list" set ref
                                                                                  497* 497* 499*
idx                             000100 automatic       fixed bin(17,0)          dcl 299 in procedure "search_list_changed" set ref
                                                                                  316* 317 318*
idx1                            000101 automatic       fixed bin(17,0)          dcl 186 set ref 248* 249 250*
initiate_file_$component        000026 constant        entry                    external dcl 71 ref 416
known_list                             based           char(32)                 array packed unaligned dcl 477 ref 497
known_list_ptr           12            based           pointer                  array level 3 in structure "seg_info" dcl 49
                                                                                  in procedure "structure_lib_mgr_" set ref 125
known_list_ptr           10     000102 automatic       pointer                  level 2 in structure "temp_seg_info" dcl 64
                                                                                  in procedure "structure_lib_mgr_" set ref 150 171
known_list_ptr           10            based           pointer                  level 2 in structure "P_seg_info" dcl 345
                                                                                  in procedure "find_segment" set ref 480* 494* 497
known_list_size          12            based           fixed bin(17,0)          level 2 in structure "P_seg_info" dcl 345
                                                                                  in procedure "find_segment" set ref 481* 495* 497
                                                                                  499*
known_list_size          14            based           fixed bin(17,0)          array level 3 in structure "seg_info" dcl 49
                                                                                  in procedure "structure_lib_mgr_" set ref 126
known_list_size          12     000102 automatic       fixed bin(17,0)          level 2 in structure "temp_seg_info" dcl 64
                                                                                  in procedure "structure_lib_mgr_" set ref 151 172
last_change_idx                 000010 internal static fixed bin(71,0)          initial dcl 43 set ref 280* 306
location                  3            based           bit(18)                  level 3 packed packed unaligned dcl 8-3 ref 494
lower                     7            based           fixed bin(35,0)          array level 3 dcl 8-3 ref 490
max_count                 1            based           fixed bin(17,0)          level 2 dcl 49 set ref 230*
name                     65            based           char(32)                 level 2 packed packed unaligned dcl 345 set ref 423*
ndims                     0(18)        based           bit(6)                   level 2 packed packed unaligned dcl 8-3 ref 488
next_seg_idx                    000102 automatic       fixed bin(17,0)          dcl 187 set ref 232* 243 243 249 258 259* 259
no_read_permission              000000 stack reference condition                dcl 90 ref 313
not_in_read_bracket             000000 stack reference condition                dcl 90 ref 312
null                                                   builtin function         dcl 93 ref 112 113 140 141 142 164 165 197 200 204
                                                                                  204 220 222 275 283 289 304 308 480 483 485
num_paths                 1            based           fixed bin(17,0)          level 2 dcl 2-15 set ref 200 215 225 227 235 274*
                                                                                  276 285* 286
object_created            6            based           fixed bin(71,0)          level 2 dcl 6-1 ref 317 443
object_info                            based           structure                level 1 dcl 4-6
object_info_$brief              000030 constant        entry                    external dcl 73 ref 440
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 4-60 ref 439
oi                              000226 automatic       structure                level 1 dcl 433 set ref 440 440
original_num_paths              000103 automatic       fixed bin(17,0)          dcl 188 set ref 225* 285
out_of_bounds                   000000 stack reference condition                dcl 90 ref 314
pathname                 15            based           char(168)                array level 3 in structure "seg_info" packed packed
                                                                                  unaligned dcl 49 in procedure "structure_lib_mgr_"
                                                                                  set ref 124 250* 261 270
pathname                 17            based           char(168)                array level 3 in structure "sl_info" packed packed
                                                                                  unaligned dcl 2-15 in procedure
                                                                                  "structure_lib_mgr_" set ref 237* 243* 261 270*
pathname                 13            based           char(168)                level 2 in structure "P_seg_info" packed packed
                                                                                  unaligned dcl 345 in procedure "find_segment" set
                                                                                  ref 422*
pathname_$component             000032 constant        entry                    external dcl 75 ref 422 505 505
paths                    14            based           structure                array level 2 dcl 2-15
pl1_root                  6            based           pointer                  level 2 dcl 345 set ref 465* 483*
pl1_symbol_block                       based           structure                level 1 dcl 7-1
report_errors                   000176 automatic       bit(1)                   dcl 352 set ref 356* 369* 394 411 505
root                      5            based           bit(18)                  level 2 packed packed unaligned dcl 7-1 ref 459
rootp                           000320 automatic       pointer                  dcl 436 set ref 459* 460 461* 461 461 462 465
runtime_block                          based           structure                level 1 dcl 8-38
runtime_symbol                         based           structure                level 1 dcl 8-3
search_paths_$get               000036 constant        entry                    external dcl 77 ref 204
search_paths_$set               000034 constant        entry                    external dcl 76 ref 275
seg_fault_error                 000000 stack reference condition                dcl 90 ref 311
seg_info                               based           structure                level 1 unaligned dcl 49 set ref 221 228
seg_info_entry                         based           structure                level 1 dcl 54
seg_info_ptr                    000014 internal static pointer                  initial dcl 46 set ref 120 122 123 124 125 126 220
                                                                                  221 222* 228* 230 231 243 243 248 249 249 250 258
                                                                                  261 261 268 270 274 289 290 308 309 316 317 318
seg_ptr                   2            based           pointer                  array level 3 in structure "seg_info" dcl 49
                                                                                  in procedure "structure_lib_mgr_" set ref 122
seg_ptr                         000102 automatic       pointer                  level 2 in structure "temp_seg_info" dcl 64
                                                                                  in procedure "structure_lib_mgr_" set ref 148
seg_ptr                                based           pointer                  level 2 in structure "P_seg_info" dcl 345
                                                                                  in procedure "find_segment" set ref 421*
segp                            000174 automatic       pointer                  dcl 351 set ref 366* 416* 421 440* 446*
size                      4            based           fixed bin(35,0)          level 2 dcl 8-3 ref 489
sl_control_default              000000 constant        bit(36)                  initial packed unaligned dcl 3-13 set ref 204*
sl_info                                based           structure                level 1 dcl 2-15 set ref 200 286
sl_info_p                       000200 automatic       pointer                  dcl 2-28 set ref 197* 200 200 204* 215 225 227 235
                                                                                  236 237 243 261 269 270 271 274 275* 276 280 281
                                                                                  283 285 286
son                       2(18)        based           bit(18)                  level 2 packed packed unaligned dcl 8-38 ref 461
std_symbol_header                      based           structure                level 1 dcl 6-1
stu_$find_runtime_symbol        000040 constant        entry                    external dcl 79 ref 483
symb_start               16     000202 automatic       pointer                  level 2 dcl 5-3 set ref 448
symbp                    12     000226 automatic       pointer                  level 2 dcl 433 set ref 443 451
symp                            000330 automatic       pointer                  dcl 475 set ref 483* 485 487 488 489 490 491 492 494
                                                                                  494 495
system_area                            based           area(1024)               dcl 191 set ref 200 204 204 221 228 286
system_area_ptr                 000106 automatic       pointer                  dcl 190 set ref 196* 200 204 204 221 228 286
temp_seg_info                   000102 automatic       structure                level 1 dcl 64 set ref 139 139 162 162
time_compiled                   000102 automatic       fixed bin(71,0)          dcl 301 in procedure "search_list_changed" set ref
                                                                                  317* 318
time_compiled             6            based           fixed bin(71,0)          array level 3 in structure "seg_info" dcl 49
                                                                                  in procedure "structure_lib_mgr_" set ref 318
time_compiled             4            based           fixed bin(71,0)          level 2 in structure "P_seg_info" dcl 345
                                                                                  in procedure "find_segment" set ref 443*
type                      0(06)        based           bit(6)                   level 2 in structure "runtime_symbol" packed packed
                                                                                  unaligned dcl 8-3 in procedure
                                                                                  "structure_lib_mgr_" ref 487
type                     14            based           fixed bin(17,0)          array level 3 in structure "sl_info" dcl 2-15
                                                                                  in procedure "structure_lib_mgr_" set ref 236 269*
update_sw                       000104 automatic       bit(1)                   dcl 189 set ref 233* 239* 244* 253* 261* 267
upper                    10            based           fixed bin(35,0)          array level 3 dcl 8-3 ref 491 495
version_number                  000226 automatic       fixed bin(17,0)          level 2 dcl 433 set ref 439*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
HOME_DIR                               internal static fixed bin(17,0)          initial dcl 2-38
INITIATED_SEGS                         internal static fixed bin(17,0)          initial dcl 2-39
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PROCESS_DIR                            internal static fixed bin(17,0)          initial dcl 2-37
REFERENCING_DIR                        internal static fixed bin(17,0)          initial dcl 2-35
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
UNEXPANDED_PATH                        internal static fixed bin(17,0)          initial dcl 2-34
WORKING_DIR                            internal static fixed bin(17,0)          initial dcl 2-36
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
algol68_array_descriptor_dtype         internal static fixed bin(17,0)          initial dcl 9-25
algol68_bits_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_bool_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_byte_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_compl_dtype                    internal static fixed bin(17,0)          initial dcl 9-110
algol68_format_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
algol68_int_dtype                      internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_compl_dtype               internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_int_dtype                 internal static fixed bin(17,0)          initial dcl 9-110
algol68_long_real_dtype                internal static fixed bin(17,0)          initial dcl 9-110
algol68_real_dtype                     internal static fixed bin(17,0)          initial dcl 9-110
algol68_short_int_dtype                internal static fixed bin(17,0)          initial dcl 9-110
algol68_straight_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
algol68_struct_struct_bool_dtype       internal static fixed bin(17,0)          initial dcl 9-110
algol68_struct_struct_char_dtype       internal static fixed bin(17,0)          initial dcl 9-110
algol68_union_dtype                    internal static fixed bin(17,0)          initial dcl 9-25
area_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
bit_dtype                              internal static fixed bin(17,0)          initial dcl 9-25
c_enum_const_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
c_enum_dtype                           internal static fixed bin(17,0)          initial dcl 9-25
c_typeref_dtype                        internal static fixed bin(17,0)          initial dcl 9-25
c_union_dtype                          internal static fixed bin(17,0)          initial dcl 9-25
cobol_char_string_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_5_ts_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_5_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_6_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_7_dtype                     internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_8_ls_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
cobol_comp_8_uns_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ls_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ls_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ts_dtype                 internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_ts_overp_dtype           internal static fixed bin(17,0)          initial dcl 9-25
cobol_display_uns_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cobol_structure_dtype                  internal static fixed bin(17,0)          initial dcl 9-25
codeptr                                                builtin function         dcl 93
cplx_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25
cplx_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
cplx_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
encoded_value                          based           structure                level 1 dcl 8-70
entry_dtype                            internal static fixed bin(17,0)          initial dcl 9-25
error_table_$new_search_list           external static fixed bin(35,0)          dcl 83
error_table_$no_search_list            external static fixed bin(35,0)          dcl 82
ext_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125
ext_procedure_runtime_dtype            internal static fixed bin(17,0)          initial dcl 9-125
file_dtype                             internal static fixed bin(17,0)          initial dcl 9-25
ft_char_dtype                          internal static fixed bin(17,0)          initial dcl 9-96
ft_complex_double_dtype                internal static fixed bin(17,0)          initial dcl 9-96
ft_complex_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_double_dtype                        internal static fixed bin(17,0)          initial dcl 9-96
ft_external_dtype                      internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_complex_double_dtype            internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_complex_dtype                   internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_double_dtype                    internal static fixed bin(17,0)          initial dcl 9-96
ft_hex_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-96
ft_integer_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_logical_dtype                       internal static fixed bin(17,0)          initial dcl 9-96
ft_real_dtype                          internal static fixed bin(17,0)          initial dcl 9-96
hbound                                                 builtin function         dcl 93
int_entry_runtime_dtype                internal static fixed bin(17,0)          initial dcl 9-125
label_constant_runtime_dtype           internal static fixed bin(17,0)          initial dcl 9-125
label_dtype                            internal static fixed bin(17,0)          initial dcl 9-25
length                                                 builtin function         dcl 93
offset_dtype                           internal static fixed bin(17,0)          initial dcl 9-25
pascal_boolean_dtype                   internal static fixed bin(17,0)          initial dcl 9-132
pascal_char_dtype                      internal static fixed bin(17,0)          initial dcl 9-132
pascal_entry_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_dtype           internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_element_dtype   internal static fixed bin(17,0)          initial dcl 9-132
pascal_enumerated_type_instance_dtype  internal static fixed bin(17,0)          initial dcl 9-132
pascal_exportable_procedure_dtype      internal static fixed bin(17,0)          initial dcl 9-132
pascal_imported_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_integer_dtype                   internal static fixed bin(17,0)          initial dcl 9-132
pascal_internal_procedure_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_label_dtype                     internal static fixed bin(17,0)          initial dcl 9-132
pascal_parameter_procedure_dtype       internal static fixed bin(17,0)          initial dcl 9-132
pascal_procedure_type_dtype            internal static fixed bin(17,0)          initial dcl 9-132
pascal_real_dtype                      internal static fixed bin(17,0)          initial dcl 9-132
pascal_record_file_type_dtype          internal static fixed bin(17,0)          initial dcl 9-132
pascal_record_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132
pascal_set_dtype                       internal static fixed bin(17,0)          initial dcl 9-132
pascal_string_type_dtype               internal static fixed bin(17,0)          initial dcl 9-132
pascal_text_file_dtype                 internal static fixed bin(17,0)          initial dcl 9-132
pascal_typed_pointer_type_dtype        internal static fixed bin(17,0)          initial dcl 9-132
pascal_user_defined_type_dtype         internal static fixed bin(17,0)          initial dcl 9-132
pascal_user_defined_type_instance_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-132
pascal_value_formal_parameter_dtype    internal static fixed bin(17,0)          initial dcl 9-132
pascal_variable_formal_parameter_dtype internal static fixed bin(17,0)          initial dcl 9-132
picture_runtime_dtype                  internal static fixed bin(17,0)          initial dcl 9-125
pointer_dtype                          internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_1_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_fix_bin_2_uns_dtype               internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_bytealigned_ls_dtype internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_bytealigned_uns_dtype
                                       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_4bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ls_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ls_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ts_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_ts_overp_dtype       internal static fixed bin(17,0)          initial dcl 9-25
real_fix_dec_9bit_uns_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_bin_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_4bit_bytealigned_dtype    internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_4bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_9bit_dtype                internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_extended_dtype            internal static fixed bin(17,0)          initial dcl 9-25
real_flt_dec_generic_dtype             internal static fixed bin(17,0)          initial dcl 9-25
real_flt_hex_1_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
real_flt_hex_2_dtype                   internal static fixed bin(17,0)          initial dcl 9-25
runtime_bound                          based           structure                level 1 unaligned dcl 8-33
runtime_token                          based           structure                level 1 dcl 8-63
sl_control                             automatic       bit(36)                  packed unaligned dcl 3-12
sl_control_s                           based           structure                level 1 packed packed unaligned dcl 3-3
sl_info_num_paths                      automatic       fixed bin(17,0)          dcl 2-27
sl_info_version_1                      internal static fixed bin(17,0)          initial dcl 2-29
structure_dtype                        internal static fixed bin(17,0)          initial dcl 9-25
substr                                                 builtin function         dcl 93
varying_bit_dtype                      internal static fixed bin(17,0)          initial dcl 9-25
varying_char_dtype                     internal static fixed bin(17,0)          initial dcl 9-25

NAMES DECLARED BY EXPLICIT CONTEXT.
COMMON                          001746 constant        label                    dcl 371 ref 358
FIND_SEGMENT_FAILS              001753 constant        label                    dcl 385 ref 400 413 511
GET_SEG_INFO_RETURNS            001461 constant        label                    dcl 283 ref 217
INVALID                         002637 constant        label                    dcl 505 ref 487 488 489 490 491 492
NEXT_SEARCH_PATH                001325 constant        label                    dcl 264 ref 240 245 254
UPDATE                          001657 constant        label                    dcl 325 ref 304 306 308 309 311 312 313 314 318
analyze_segment                 002241 constant        entry                    internal dcl 430 ref 371
find_segment                    001664 constant        entry                    internal dcl 337 ref 139 243
find_segment$$analyze           001712 constant        entry                    internal dcl 360 ref 162
find_structure_list             002473 constant        entry                    internal dcl 472 ref 379
get_seg_info                    000574 constant        entry                    internal dcl 178 ref 118
invalid_segment                 001755 constant        entry                    internal dcl 389 ref 417 418 441 447 453 454 457 460
                                                                                  462
locate_segment                  002024 constant        entry                    internal dcl 406 ref 357
search_list_changed             001513 constant        entry                    internal dcl 296 ref 194
structure_lib_mgr_              000234 constant        entry                    external dcl 6
structure_lib_mgr_$get_segment  000363 constant        entry                    external dcl 134
structure_lib_mgr_$get_segment_ptr
                                000472 constant        entry                    external dcl 158
structure_lib_mgr_$next_segment 000250 constant        entry                    external dcl 107

NAMES DECLARED BY CONTEXT OR IMPLICATION.
addrel                                                 builtin function         ref 456 459 461
binary                                                 builtin function         ref 487 488
pointer                                                builtin function         ref 494
rel                                                    builtin function         ref 460 462

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3312        3362    2723        3322
Length      4026    2723        50         430     367           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
structure_lib_mgr_                  240 external procedure  is an external procedure.  
get_seg_info                        170 internal procedure  enables or reverts conditions.  
on unit on line 199                  64 on unit               
search_list_changed                  94 internal procedure  enables or reverts conditions.  
on unit on line 311                  64 on unit               
on unit on line 312                  64 on unit               
on unit on line 313                  64 on unit               
on unit on line 314                  64 on unit               
find_segment                        503 internal procedure  is called by several nonquick procedures.  
invalid_segment                         internal procedure  shares stack frame of internal procedure find_segment.  
locate_segment                          internal procedure  shares stack frame of internal procedure find_segment.  
analyze_segment                         internal procedure  shares stack frame of internal procedure find_segment.  
find_structure_list                     internal procedure  shares stack frame of internal procedure find_segment.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 last_change_idx             structure_lib_mgr_
000012 change_idx_ptr              structure_lib_mgr_
000014 seg_info_ptr                structure_lib_mgr_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
find_segment             000100 dname                       find_segment
                         000152 ename                       find_segment
                         000162 component                   find_segment
                         000172 bitcount                    find_segment
                         000174 segp                        find_segment
                         000176 report_errors               find_segment
                         000226 oi                          analyze_segment
                         000314 hp                          analyze_segment
                         000316 bp                          analyze_segment
                         000320 rootp                       analyze_segment
                         000330 symp                        find_structure_list
                         000332 idx                         find_structure_list
get_seg_info             000100 idx                         get_seg_info
                         000101 idx1                        get_seg_info
                         000102 next_seg_idx                get_seg_info
                         000103 original_num_paths          get_seg_info
                         000104 update_sw                   get_seg_info
                         000106 system_area_ptr             get_seg_info
search_list_changed      000100 idx                         search_list_changed
                         000102 time_compiled               search_list_changed
structure_lib_mgr_       000100 code                        structure_lib_mgr_
                         000101 alloc_seg_info_count        structure_lib_mgr_
                         000102 temp_seg_info               structure_lib_mgr_
                         000200 sl_info_p                   structure_lib_mgr_
                         000202 ci                          structure_lib_mgr_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc
call_int_other      return_mac          tra_ext_1           enable_op           ext_entry           ext_entry_desc
int_entry           int_entry_desc      op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      component_info_$name          expand_pathname_$component    get_system_free_area_
initiate_file_$component      object_info_$brief            pathname_$component           search_paths_$get
search_paths_$set             stu_$find_runtime_symbol

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_segment      error_table_$oldobj           error_table_$zero_length_seg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      6 000233         9 000241       107 000242       112 000273       113 000275       114 000276       116 000306
    118 000310       120 000321       122 000326       123 000332       124 000335       125 000350       126 000352
    128 000354       134 000355       139 000410       140 000442       141 000444       142 000445       143 000446
    144 000447       145 000451       148 000452       149 000454       150 000456       151 000460       152 000462
    153 000463       158 000464       162 000520       164 000556       165 000560       166 000561       167 000562
    170 000563       171 000565       172 000567       173 000571       174 000572       178 000573       194 000601
    196 000617       197 000626       199 000631       200 000645       202 000661       204 000662       208 000734
    209 000737       210 000766       215 000771       216 000774       217 001024       220 001025       221 001032
    222 001037       225 001042       227 001046       228 001047       230 001063       231 001064       232 001065
    233 001067       235 001070       236 001101       237 001107       239 001143       240 001145       243 001146
    244 001210       245 001212       248 001213       249 001223       250 001237       253 001274       254 001276
    256 001277       258 001301       259 001304       261 001305       264 001325       267 001327       268 001331
    269 001341       270 001347       271 001360       272 001361       274 001363       275 001370       276 001416
    280 001452       281 001457       283 001461       285 001466       286 001471       289 001475       290 001505
    296 001512       304 001520       306 001524       308 001527       309 001533       311 001535       312 001554
    313 001573       314 001612       316 001631       317 001641       318 001650       319 001652       321 001654
    325 001657       337 001663       356 001704       357 001707       358 001710       360 001711       366 001732
    367 001736       368 001740       369 001745       371 001746       379 001747       381 001750       385 001753
    389 001755       394 001757       399 002017       400 002023       406 002024       409 002025       410 002060
    411 002063       413 002116       416 002117       417 002157       418 002170       421 002201       422 002204
    423 002235       425 002240       430 002241       439 002242       440 002244       441 002264       443 002275
    445 002302       446 002305       447 002335       448 002346       449 002351       451 002352       453 002353
    454 002367       456 002402       457 002410       459 002425       460 002433       461 002444       462 002451
    464 002462       465 002466       467 002472       472 002473       480 002474       481 002500       483 002503
    485 002541       487 002546       488 002553       489 002560       490 002564       491 002567       492 002572
    494 002577       495 002606       497 002612       499 002632       500 002634       502 002636       505 002637
    510 002716       511 002722


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
