	COMPILATION LISTING OF SEGMENT print_dump_seg_name_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/22/85  1523.7 mst Tue
	    Options: optimize list

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 print_dump_seg_name_: proc (segno, psdw, sstp, sstnp);
       12 						/* Converted to 6180 and v2pl1 by R Mullen Feb 1973 */
       13 dcl  segno fixed bin,				/* Parameters */
       14      psdw fixed bin (71),
       15     (xsltp, xnamp) ptr,				/* Pointers to copies of the SLT and Name Table in dump */
       16      astep ptr,					/* Pointer to AST entry of interest */
       17      np ptr,					/* r0 name table ptr */
       18      sstnp ptr;					/* Pointer to copy of SST name table */
       19 
       20 dcl  axbitsp ptr;
       21 dcl  ax char (8) aligned;
       22 dcl  axbits (6) bit (1) unaligned based (axbitsp);
       23 
       24 dcl (cl, esw) fixed bin;
       25 
       26 dcl (line char (130),
       27      dirname char (168),
       28      name char (32),
       29      ename char (32),
       30      bline char (l) based (lp)) aligned,
       31      namebuf char (64),
       32     (lp, sltp, namp, segptr, xsegptr) ptr,
       33      expand_path_ entry (ptr, fixed bin, ptr, ptr, fixed bin (35)),
       34      get_ast_name_ entry (ptr, ptr, ptr, char (*)),
       35      hcs_$initiate entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin (1), fixed bin (2),
       36      ptr, fixed bin (35)),
       37     (l, maxl, minl, i) fixed bin;
       38 
       39 
       40 dcl (fmtnl char (2) init ("^a"),
       41      fmtsstn char (5) init ("^a ^a"),
       42      fmtsdw char (46) init ("^-^-^8o  ^o ^o ^o  ^1a  ^5o  ^8a^5o        ^4o")) int static aligned;
       43 
       44 dcl (ioa_$rsnnl, od_print_) entry options (variable);	/* Descriptors required */
       45 dcl  ring0_get_$name_given_slt entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35), ptr, ptr);
       46 
       47 dcl (addr, baseptr, bin, null, substr) builtin;
       48 
       49 dcl  code fixed bin (35);
       50 dcl  dfchar char (1);
       51 dcl  dfno fixed bin;
       52 
       53 /*  */
  1     1 /*   BEGIN INCLUDE FILE ... sst.incl.pl1 ... January 1971 */
  1     2 /* Note: This include file has an ALM counterpart made with cif. Keep it up to date */
  1     3 /* Deleted paging device info and added pc segmove info, Benson Margulies 84-01-03 */
  1     4 /* Added covert channel meters, Keith Loepere 85-01-08. */
  1     5 
  1     6 dcl  sst_seg$ external;
  1     7 dcl  sstp ptr;
  1     8 
  1     9 dcl 1 sst based (sstp) aligned,
  1    10     2 space (8) fixed bin,				/* empty space to watch for bugs */
  1    11 
  1    12 /* SST HEADER */
  1    13 
  1    14     2 pre_page_time fixed bin (71),			/* total time spent pre-paging */
  1    15     2 post_purge_time fixed bin (71),			/* total time spent post-purging */
  1    16     2 post_in_core fixed bin,				/* total pages in core (and in list) at purge time */
  1    17     2 thrashing fixed bin,				/* meter of thrashing being done on system */
  1    18     2 npfs_misses fixed bin,				/* meter of times npfs was on when pre-paging */
  1    19     2 salv fixed bin,				/* flag which is ^=0 if and only if salvaging */
  1    20 
  1    21     2 ptl bit (36),					/* global page table loop lock */
  1    22     2 astl bit (36),				/* global ast allocation block lock */
  1    23     2 astl_event bit (36),				/* event used when waiting for AST lock */
  1    24     2 astl_notify_requested bit (1) aligned,		/* flag to notify AST lock */
  1    25     2 nused fixed bin,				/* number of pages on used list */
  1    26     2 ptwbase fixed bin (24),				/* absolute address of page table array */
  1    27     2 tfreep ptr,					/* pointer to first trailer on free list */
  1    28 
  1    29     2 astap ptr,					/* aste array pointer */
  1    30     2 ptl_wait_ct fixed bin,				/* pxss: number is >= # of processes waiting to ptl */
  1    31     2 astsize fixed bin,				/* size of an AST entry */
  1    32     2 cmesize fixed bin,				/* size of a CME entry */
  1    33     2 root_astep ptr,				/* pointer to the root AST entry */
  1    34 
  1    35     2 pts (0: 3) fixed bin,				/* array of page table sizes */
  1    36     2 level (0:3),					/* per-list information about ASTE's */
  1    37       3 (ausedp, no_aste) bit (18) unaligned,		/* used list and count of number of entries */
  1    38 
  1    39     2 (atempp, atempp1) bit (18) unal,			/* temp seg list pointer */
  1    40     2 dm_enabled bit (1) aligned,			/* ON => journal seg exists */
  1    41     2 (ainitp, ainitp1) bit (18) unal,			/* init seg list pointer */
  1    42     2 strsize fixed bin,				/* Trailer size in words. */
  1    43 
  1    44 /* CORE MAP HEADER */
  1    45 
  1    46     2 cmp ptr,					/* pointer to start of core map */
  1    47     2 usedp bit (18),				/* pointer to first used core block */
  1    48     2 wtct fixed bin,				/* count of pages being written */
  1    49 
  1    50     2 startp bit (18),				/* pointer to solid page for lap counting (fsdct) */
  1    51     2 removep bit (18),				/* pointer to list of pages being removed from use */
  1    52 						/* MISC */
  1    53 
  1    54     2 double_write fixed bin,				/* trigger for store through scheme */
  1    55 						/* 0 = no double writes,
  1    56*						   1 = all non-pd pages get written,
  1    57*						   2 = all directories get written */
  1    58     2 temp_w_event bit (36) aligned,			/* wait event for temp wiring lock */
  1    59     2 root_pvtx fixed bin,				/* pvtx or rpv */
  1    60     2 nolock bit (1) aligned,				/* if on, don't lock ptl on interrupts */
  1    61 
  1    62     2 fc_skips_pinned fixed bin (35),			/* number of skips over pinned page in find_core */
  1    63     2 cl_skips_pinned fixed bin (35),			/* number of skips over pinned page in claim_mod_core */
  1    64     2 ast_ht_ptr ptr,				/* AST hast table pointer */
  1    65     2 ast_ht_n_buckets fixed bin,			/* number of buckets in AST hash table */
  1    66     2 ast_ht_uid_mask bit (36) aligned,			/* mask to strip out low-order bits of uid */
  1    67     2 meter_ast_locking fixed bin,			/* non-zero enables AST lock meters */
  1    68     2 checksum_filemap fixed bin,			/* non-zero enables filemap checksumming */
  1    69 
  1    70     2 page_read_errors fixed bin,			/* read errors posted to page control */
  1    71     2 page_write_errors fixed bin,			/* write errors posted to page control */
  1    72 
  1    73     2 cycle_pv_allocation fixed bin,			/* flag to cycle VTOCE allocation among PVs */
  1    74 
  1    75     2 n_trailers fixed bin,				/* Number of trailer entries in str_seg */
  1    76     2 synch_activations fixed bin (35),			/* Activation attempts for synchronized segs */
  1    77     2 synch_skips fixed bin (35),			/* get_aste skips because not synchronized */
  1    78 
  1    79     2 lock_waits fixed bin,				/* Number of times we had to wait for a lock */
  1    80     2 total_locks_set fixed bin,			/* Total number of block locks set */
  1    81     2 pdir_page_faults fixed bin,			/* total page faults off >pdd */
  1    82     2 level_1_page_faults fixed bin,			/* total page faults in sys libes */
  1    83     2 dir_page_faults fixed bin,			/* Total page faults on directories */
  1    84     2 ring_0_page_faults fixed bin,			/* page faults in ring 0 */
  1    85     2 rqover fixed bin (35),				/* errcode for record quota overflow */
  1    86     2 pc_io_waits fixed bin,				/* Number of times pc had to wait on io */
  1    87 
  1    88 
  1    89 /*  The following (until pdmap) used to be the 'cnt' in cnt.incl.pl1 */
  1    90 
  1    91     2 steps fixed bin,				/* number of steps taken around used list */
  1    92     2 needc fixed bin,				/* number of times core page needed */
  1    93     2 ceiling fixed bin,				/* number of times ceiling hit */
  1    94     2 ctwait fixed bin,				/* number of times write counter was full */
  1    95     2 wired fixed bin,				/* number of pages wired by pc */
  1    96     2 laps fixed bin,				/* number of times around used list */
  1    97     2 skipw fixed bin,				/* number of pages skiped because they were wired */
  1    98     2 skipu fixed bin,				/* because of being used */
  1    99 
  1   100     2 skipm fixed bin,				/* because of being modified */
  1   101     2 skipos fixed bin,				/* because out of service */
  1   102     2 aused fixed bin,				/* number of AST entries on used list */
  1   103     2 damaged_ct fixed bin,				/* count of segments that system damaged */
  1   104     2 deact_count fixed bin,				/* count of deactivations */
  1   105     2 demand_deact_attempts fixed bin,			/* user requested deactivations */
  1   106     2 demand_deactivations fixed bin,			/* user instigated deactivations */
  1   107 
  1   108     2 reads (8) fixed bin,				/* number of reads for each did */
  1   109     2 writes (8) fixed bin,				/* number of writes for each did */
  1   110 
  1   111     2 short_pf_count fixed bin,			/* count of page faults on out of service pages */
  1   112     2 loop_locks fixed bin,				/* count of times locked PTL */
  1   113     2 loop_lock_time fixed bin (71),			/* time spent looping on PTL */
  1   114     2 cpu_sf_time fixed bin (71),			/* cpu time spent in seg_fault */
  1   115     2 total_sf_pf fixed bin,				/* total page faults while in seg_fault */
  1   116     2 total_sf fixed bin,				/* total number of seg_faults */
  1   117     2 pre_page_size fixed bin,			/* total pre-pagings expected */
  1   118     2 post_list_size fixed bin,
  1   119     2 post_purgings fixed bin,			/* total number of post-purgings */
  1   120     2 post_purge_calls fixed bin,			/* total number of calls to post-purge */
  1   121     2 pre_page_calls fixed bin,			/* total number of calls tp pre-page */
  1   122     2 pre_page_list_size fixed bin,
  1   123     2 pre_page_misses fixed bin,			/* total number of misses in pre-page list */
  1   124     2 pre_pagings fixed bin,				/* total number of pre-pagings */
  1   125 
  1   126 /*  TEMPORARY WIRED PROCEDURE INFO  */
  1   127 
  1   128     2 wire_proc_data (8) fixed bin (71),		/* data for wire_proc */
  1   129 
  1   130 /* MAIN MEMORY USAGE INFORMATION */
  1   131 
  1   132     2 abs_wired_count fixed bin,			/* count of abs-wired pages */
  1   133     2 system_type fixed bin,				/* ADP_SYSTEM or L68_SYSTEM */
  1   134     2 wired_copies fixed bin,				/* number of times a wired page was copied */
  1   135     2 recopies fixed bin,				/* number of times recopied because modified */
  1   136     2 first_core_block fixed bin,			/* core map index for first block of core */
  1   137     2 last_core_block fixed bin,			/* core map index for last block of core */
  1   138     2 fw_retries fixed bin (35),			/* force_write retries due to ASTE move */
  1   139     2 pvhtp ptr unaligned,				/* ptr to PV hold table for debugging */
  1   140 
  1   141 /*  AST METERS  */
  1   142 
  1   143     2 askipsize (0: 3) fixed bin,			/* array of skips because wrong AST size */
  1   144     2 aneedsize (0: 3) fixed bin,			/* array of times needed each size */
  1   145 
  1   146     2 stepsa fixed bin,				/* count of steps taken looking for an AST entry */
  1   147     2 askipsehs fixed bin,				/* count of skips because EHS was ON */
  1   148     2 asearches fixed bin,				/* count of full searches made */
  1   149     2 askipslevel fixed bin,				/* count of skips because pages were in core */
  1   150     2 askipsinit fixed bin,				/* count of times turned OFF init switch */
  1   151     2 acost fixed bin,				/* cumulative cost of deactivations */
  1   152     2 askipslock fixed bin,				/* count of skips because couldn't lock parent */
  1   153     2 askipdius fixed bin,				/* count of skips because DIUS was on */
  1   154 
  1   155     2 alaps fixed bin,				/* lap counter for AST list */
  1   156     2 updates fixed bin,				/* calls to updateb */
  1   157     2 setfaults_all fixed bin,			/* setfaults done to the entire SDW */
  1   158     2 setfaults_acc fixed bin,			/* setfaults done to the access field */
  1   159     2 total_bf fixed bin,				/* count of bound faults */
  1   160     2 total_bf_pf fixed bin,				/* page faults during bound faults */
  1   161     2 cpu_bf_time fixed bin (71),			/* cpu time spent in bound fault */
  1   162 
  1   163     2 asteps (0: 3) fixed bin,			/* per-size AST step counters */
  1   164 
  1   165     2 ast_locked_at_time fixed bin (71),		/* clock reading when ast last locked */
  1   166     2 ast_locked_total_time fixed bin (71),		/* total real time the ast lock was locked */
  1   167     2 ast_lock_wait_time fixed bin (71),		/* total real time of all waiting on ast lock */
  1   168     2 ast_locking_count fixed bin (35),			/* number of times ast was locked */
  1   169     2 cleanup_count fixed bin,			/* calls to pc$cleanup */
  1   170     2 cleanup_real_time fixed bin (71),			/* total real time in pc$cleanup */
  1   171 
  1   172 /* PRE-PAGE METERS */
  1   173 
  1   174     2 tree_count (0: 63) fixed bin,			/* counters for pre-page decisions */
  1   175 
  1   176     2 pp_meters (0: 63) fixed bin,			/* counters for measuring pre-page success */
  1   177 
  1   178 
  1   179     2 wusedp bit (18) aligned,			/* Relative cmep to next cme for writing */
  1   180     2 write_hunts fixed bin,				/* Times claim_mod_core invoked */
  1   181     2 claim_skip_cme fixed bin,			/* Times unacceptable cme found by c_m_c */
  1   182     2 claim_skip_free fixed bin,			/* Times free cme passed by c_m_c */
  1   183     2 claim_notmod fixed bin,				/* Times c_m_c passed pure page */
  1   184     2 claim_passed_used fixed bin,			/* Times used page seen */
  1   185     2 claim_skip_ptw fixed bin,			/* Times c_m_c saw unacceptable ptw */
  1   186     2 claim_writes fixed bin,				/* Writes queued by c_m_c */
  1   187     2 claim_steps fixed bin,				/* Steps passed in core claiming */
  1   188     2 pre_seeks_failed fixed bin,			/* counter of times quick find_core_ failed */
  1   189     2 resurrections fixed bin,			/* nulled addresses reinstated */
  1   190     2 volmap_seg_page_faults fixed bin (35),		/* Pseudo-page faults on volmap_seg */
  1   191     2 oopv fixed bin,				/* out-of-physical-volume page faults */
  1   192     2 dblw_resurrections fixed bin,			/* addresses resurrected by double-writing */
  1   193     2 sgm_time fixed bin (71),			/* Time (VCPU) in seg mover */
  1   194     2 sgm_pf fixed bin,				/* Page faults in seg moving */
  1   195     2 bad_sgms fixed bin,				/* Seg moves that failed */
  1   196     2 sgm_sgft fixed bin,				/* Seg faults in seg moves */
  1   197     2 good_sgms fixed bin,				/* Seg moves that completed */
  1   198     2 claim_runs fixed bin,				/* Times claim_mod_core had to run */
  1   199     2 activations fixed bin,				/* total count of activations */
  1   200     2 dir_activations fixed bin,			/* count of directory activations */
  1   201     2 hedge_updatevs fixed bin,			/* call-in updatevs */
  1   202     2 hedge_writes fixed bin,				/* call in core flush writes */
  1   203     2 evict_recover_data,				/* see evict_page.alm */
  1   204      3 evict_ptp bit (18) unal,			/* ptp of page being moved */
  1   205      3 evict_phmbit bit (18) unal,			/* N/Z if page was mod */
  1   206 
  1   207 /* Data for metering force_write facility 08/19/78 */
  1   208 
  1   209     2 force_swrites fixed bin,			/* Calls on segments to force write */
  1   210     2 force_pwrites fixed bin,			/* Mod pages so written */
  1   211     2 fw_none fixed bin,				/* Force write wrote none */
  1   212     2 force_updatevs fixed bin,			/* Updatev's so forced */
  1   213 
  1   214     2 pf_unlock_ptl_time fixed bin (71),		/* Time unlocking ptln page faults */
  1   215     2 pf_unlock_ptl_meterings fixed bin,
  1   216 
  1   217     2 makeknown_activations fixed bin (35),		/* activations at makeknown time */
  1   218     2 backup_activations fixed bin (35),		/* activations for backup */
  1   219     2 metering_flags aligned,				/* small chunks of misc. information */
  1   220       3 activate_activated bit (1) unal,		/* ON => last call to activate entry actually activated something */
  1   221       3 pad bit (35) unal,
  1   222     2 seg_fault_calls fixed bin (35),			/* number calls to seg_fault for explicit activation */
  1   223 
  1   224 /* METERS FOR STACK TRUNCATION */
  1   225 
  1   226     2 (stk_truncate_should_didnt,			/* counts */
  1   227        stk_truncate_should_did,
  1   228        stk_truncate_shouldnt_didnt,
  1   229        stk_truncate_shouldnt_did) fixed bin (35),
  1   230     2 stk_pages_truncated fixed bin (35),
  1   231     2 stk_pages_truncated_in_core fixed bin (35),
  1   232 
  1   233 /* SUPPORT FOR PC SEGMOVES */
  1   234 
  1   235     2 segmove_lock aligned,
  1   236       3 pid bit (36) aligned,
  1   237       3 event bit (36) aligned,
  1   238       3 notify bit (1) aligned,
  1   239     2 segmove_io_limit fixed bin, /* max read aheads */
  1   240     2 segmove_found_synch fixed bin (35), /* cme.synch_held */
  1   241     2 segmove_synch_disappeared fixed bin (35), /* page$check_synch fixed */
  1   242     2 segmove_n_reads fixed bin (35), /* total IO's queued. */
  1   243     2 segmove_max_tries fixed bin (35), /* max times through the read loop */
  1   244 
  1   245     2 segmove_astep ptr unal,				/* if non-null, addresses to be rescued from old_addr_astep */
  1   246     2 segmove_pvtx fixed bin,				/* if segmove_astep nonnull, valid */
  1   247     2 segmove_vtocx fixed bin,			/* ditto */
  1   248     2 segmove_old_addr_astep ptr unaligned,		/* ditto */
  1   249     2 segmove_new_addr_astep ptr unaligned,		/* if non-null, the addresses must be deposited. */
  1   250 
  1   251     2 mod_during_write fixed bin,			/* times a page was modified while it was being written */
  1   252     2 zero_pages fixed bin,				/* count of pages truncated because all zero */
  1   253     2 trace_sw aligned,				/* tracing control flags */
  1   254       3 pad_trace bit (32) unaligned,
  1   255       3 pc_trace_pf bit (1) unaligned,			/* tracing for page faults, done, etc. */
  1   256       3 tty_trace bit (1) unaligned,
  1   257       3 pc_trace bit (1) unaligned,			/* flag used by page control primitives */
  1   258       3 sc_trace bit (1) unaligned,			/* flag used by segment control primitives */
  1   259     2 new_pages fixed bin,				/* newly created pages */
  1   260     2 ast_track bit (1) aligned,			/* "1"b => keep SST name table */
  1   261     2 dirlock_writebehind fixed bin,			/* =1 to flush modified dir pages in lock$unlock */
  1   262     2 write_limit fixed bin,				/* Max # of outstanding writes by page control */
  1   263     2 crash_test_segmove bit (1) aligned,		/* crash in mid-segmove */
  1   264     2 delayed_seg_state_chg fixed bin (35),		/* count of times a process was delayed in affecting a seg state */
  1   265     2 audit_seg_state_chg fixed bin (35),		/* count of times a process was audited for excessive seg state changes */
  1   266     2 seg_state_chg_delay fixed bin (52),		/* total times processes were delayed for covert channels */
  1   267     2 seg_state_change_limit fixed bin,			/* number of events over which we determine covert channel bandwidth */
  1   268     2 max_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we delay */
  1   269     2 audit_seg_state_change_bw fixed bin,		/* maximum bps for covert channel before we audit */
  1   270     2 seg_state_chg_operation bit (36) aligned,		/* access_operation_ value for excessive_seg_state_chg */
  1   271     2 pad4 (126) bit (36) aligned;			/* padding to 512 words (1000)8 */
  1   272 
  1   273 /* END INCLUDE FILE sst.incl.pl1 */
       54 
       55 /*  */
  2     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  2     2 
  2     3 dcl  sdwp ptr;
  2     4 
  2     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  2     6 
  2     7    (2 add bit (24),					/* main memory address of page table */
  2     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  2     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  2    10     2 df_no bit (2),				/* directed fault number */
  2    11 
  2    12     2 pad1 bit (1),
  2    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  2    14     2 access,					/* access bits */
  2    15       3 read bit (1),				/* read permission bit */
  2    16       3 execute bit (1),				/* execute permission bit */
  2    17       3 write bit (1),				/* write permission bit */
  2    18       3 privileged bit (1),				/* privileged bit */
  2    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  2    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  2    21     2 cache bit (1),				/* cache enable bit */
  2    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  2    23 
  2    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  2    25 
  2    26 /* END INCLUDE FILE  sdw.incl.pl1 */
       56 
       57 /* 
       58*   Copy args, initialize for formatting SDW breakout */
       59 
       60 	esw = 1;
       61 
       62 	go to common;
       63 
       64 print_dump_seg_name_$get_ptr: entry (segno, sstp, sstnp, xsegptr);
       65 	xsegptr = null;
       66 	esw = 0;
       67 	go to common;
       68 
       69 
       70 print_dump_seg_name_$hard: entry (segno, psdw, xsltp, xnamp);
       71 	esw = 2;
       72 
       73 
       74 common:	
       75 	dirname = "";
       76 	ename = "";
       77 	if esw ^= 0 then do;
       78 	     maxl = 100;
       79 	     minl = 0;
       80 
       81 	     lp = addr (line);
       82 	     sdwp = addr (psdw);
       83 
       84 	     ax = "REWPUG  ";			/* fill in letters for these 6 bits */
       85 	     axbitsp = addr (sdwp -> sdw.read);		/* get pointer to the bits */
       86 
       87 	     do i = 1 to 6;				/* look at each one */
       88 		if axbitsp -> axbits (i) = "0"b then substr (ax, i, 1) = " "; /* if axbitsp ->  zero, remove the letter */
       89 	     end;
       90 
       91 	     if sdwp -> sdw.df then dfchar = " ";
       92 	     else do;
       93 		dfno = bin (sdwp -> sdw.df_no, 2);
       94 		dfchar = substr ("0123", dfno + 1, 1);
       95 	     end;
       96 
       97 	     cl = bin (sdwp -> sdw.entry_bound, 17);
       98 
       99 	     call ioa_$rsnnl (fmtsdw, line, l,
      100 	     bin (sdwp -> sdw.add, 24),
      101 	     bin (sdwp -> sdw.r1, 3),
      102 	     bin (sdwp -> sdw.r2, 3),
      103 	     bin (sdwp -> sdw.r3, 3),
      104 	     dfchar,
      105 	     bin (sdwp -> sdw.bound, 14),
      106 	     ax,
      107 	     bin (sdwp -> sdw.entry_bound, 14),
      108 	     segno);
      109 	end;
      110 
      111 	if esw ^= 2 then do;			/* non hardcore segname/refname wanted */
      112 	     if sstp = null | sstnp = null then go to print_line;
      113 	     astep = ptr (sstp, bin (sdwp -> sdw.add, 24) - sstp -> sst.ptwbase
      114 			- sstp -> sst.astsize);	/* Compute Astep */
      115 	     call get_ast_name_ (astep, sstp, sstnp, namebuf);	/* Figure out the name */
      116 	     if esw = 1 then call ioa_$rsnnl(fmtsstn, line, l, bline, namebuf);
      117 	     else do;
      118 		call expand_path_ (addr(namebuf), length (namebuf), addr (dirname), addr (ename), code);
      119 		if code ^= 0 then go to pfail;
      120 		if dirname = ">system_library_1" then dirname = ">ldd>hard>object";
      121 		call hcs_$initiate (dirname, ename, "", 0, 1, segptr, code);
      122 		if segptr = null then xsegptr = segptr;
      123 		else
      124 pfail:		xsegptr = null;
      125 	     end;
      126 	     go to print_line;
      127 	end;
      128 	else do;
      129 
      130 	     sltp = xsltp;
      131 	     namp = xnamp;
      132 	     np = baseptr (segno);
      133 	     call ring0_get_$name_given_slt (dirname, name, np, code, sltp, namp);
      134 	     if code = 0 then call ioa_$rsnnl (fmtsstn, line, l, bline, name);
      135 	end;
      136 
      137 
      138 print_line:					/* Print accumulated line image */
      139 	if esw = 0 then return;
      140 	if l > minl				/* See if anything significant in buffer */
      141 	then call od_print_ (1, fmtnl, bline);
      142      end print_dump_seg_name_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/22/85  1311.1  print_dump_seg_name_.pl1          >spec>temp>41-5>print_dump_seg_name_.pl1
54           1    01/22/85  1321.6  sst.incl.pl1                      >spec>temp>41-5>sst.incl.pl1
56           2    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
access                    1(15)        based           structure                level 2 packed unaligned dcl 2-5
add                                    based           bit(24)                  level 2 packed unaligned dcl 2-5 ref 99 99 113
addr                                                   builtin function         dcl 47 ref 81 82 85 118 118 118 118 118 118
astep                           000100 automatic       pointer                  dcl 13 set ref 113* 115*
astsize                  33            based           fixed bin(17,0)          level 2 dcl 1-9 ref 113
ax                              000106 automatic       char(8)                  dcl 21 set ref 84* 88* 99*
axbits                                 based           bit(1)                   array unaligned dcl 22 ref 88
axbitsp                         000104 automatic       pointer                  dcl 20 set ref 85* 88
baseptr                                                builtin function         dcl 47 ref 132
bin                                                    builtin function         dcl 47 ref 93 97 99 99 99 99 99 99 99 99 99 99 99 99
                                                                                  113
bline                                  based           char                     dcl 26 set ref 116* 134* 140*
bound                     1(01)        based           bit(14)                  level 2 packed unaligned dcl 2-5 ref 99 99
cl                              000110 automatic       fixed bin(17,0)          dcl 24 set ref 97*
code                            000302 automatic       fixed bin(35,0)          dcl 49 set ref 118* 119 121* 133* 134
df                        0(33)        based           bit(1)                   level 2 packed unaligned dcl 2-5 ref 91
df_no                     0(34)        based           bit(2)                   level 2 packed unaligned dcl 2-5 ref 93
dfchar                          000303 automatic       char(1)                  unaligned dcl 50 set ref 91* 94* 99*
dfno                            000304 automatic       fixed bin(17,0)          dcl 51 set ref 93* 94
dirname                         000153 automatic       char(168)                dcl 26 set ref 74* 118 118 120 120* 121* 133*
ename                           000235 automatic       char(32)                 dcl 26 set ref 76* 118 118 121*
entry_bound               1(22)        based           bit(14)                  level 2 packed unaligned dcl 2-5 ref 97 99 99
esw                             000111 automatic       fixed bin(17,0)          dcl 24 set ref 60* 66* 71* 77 111 116 138
expand_path_                    000030 constant        entry                    external dcl 26 ref 118
fmtnl                           000010 internal static char(2)                  initial dcl 40 set ref 140*
fmtsdw                          000014 internal static char(46)                 initial dcl 40 set ref 99*
fmtsstn                         000012 internal static char(5)                  initial dcl 40 set ref 116* 134*
get_ast_name_                   000032 constant        entry                    external dcl 26 ref 115
hcs_$initiate                   000034 constant        entry                    external dcl 26 ref 121
i                               000301 automatic       fixed bin(17,0)          dcl 26 set ref 87* 88 88*
ioa_$rsnnl                      000036 constant        entry                    external dcl 44 ref 99 116 134
l                               000276 automatic       fixed bin(17,0)          dcl 26 set ref 99* 116* 116 116 134* 134 134 140 140
                                                                                  140
line                            000112 automatic       char(130)                dcl 26 set ref 81 99* 116* 134*
lp                              000266 automatic       pointer                  dcl 26 set ref 81* 116 134 140
maxl                            000277 automatic       fixed bin(17,0)          dcl 26 set ref 78*
minl                            000300 automatic       fixed bin(17,0)          dcl 26 set ref 79* 140
name                            000225 automatic       char(32)                 dcl 26 set ref 133* 134*
namebuf                         000245 automatic       char(64)                 unaligned dcl 26 set ref 115* 116* 118 118 118 118
namp                            000272 automatic       pointer                  dcl 26 set ref 131* 133*
np                              000102 automatic       pointer                  dcl 13 set ref 132* 133*
null                                                   builtin function         dcl 47 ref 65 112 112 122 123
od_print_                       000040 constant        entry                    external dcl 44 ref 140
psdw                                   parameter       fixed bin(71,0)          dcl 13 set ref 11 70 82
ptwbase                  25            based           fixed bin(24,0)          level 2 dcl 1-9 ref 113
r1                        0(24)        based           bit(3)                   level 2 packed unaligned dcl 2-5 ref 99 99
r2                        0(27)        based           bit(3)                   level 2 packed unaligned dcl 2-5 ref 99 99
r3                        0(30)        based           bit(3)                   level 2 packed unaligned dcl 2-5 ref 99 99
read                      1(15)        based           bit(1)                   level 3 packed unaligned dcl 2-5 set ref 85
ring0_get_$name_given_slt       000042 constant        entry                    external dcl 45 ref 133
sdw                                    based           structure                level 1 dcl 2-5
sdwp                            000306 automatic       pointer                  dcl 2-3 set ref 82* 85 91 93 97 99 99 99 99 99 99 99
                                                                                  99 99 99 99 99 113
segno                                  parameter       fixed bin(17,0)          dcl 13 set ref 11 64 70 99* 132
segptr                          000274 automatic       pointer                  dcl 26 set ref 121* 122 122
sltp                            000270 automatic       pointer                  dcl 26 set ref 130* 133*
sst                                    based           structure                level 1 dcl 1-9
sstnp                                  parameter       pointer                  dcl 13 set ref 11 64 112 115*
sstp                                   parameter       pointer                  dcl 1-7 set ref 11 64 112 113 113 113 115*
substr                                                 builtin function         dcl 47 set ref 88* 94
xnamp                                  parameter       pointer                  dcl 13 ref 70 131
xsegptr                                parameter       pointer                  dcl 26 set ref 64 65* 122* 123*
xsltp                                  parameter       pointer                  dcl 13 ref 70 130

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
sdwa                                   based           structure                array level 1 dcl 2-24
sst_seg$                               external static fixed bin(17,0)          dcl 1-6

NAMES DECLARED BY EXPLICIT CONTEXT.
common                          000122 constant        label                    dcl 74 ref 62 67
pfail                           000543 constant        label                    dcl 123 ref 119
print_dump_seg_name_            000050 constant        entry                    external dcl 11
print_dump_seg_name_$get_ptr    000072 constant        entry                    external dcl 64
print_dump_seg_name_$hard       000113 constant        entry                    external dcl 70
print_line                      000653 constant        label                    dcl 138 ref 112 126

NAMES DECLARED BY CONTEXT OR IMPLICATION.
length                                                 builtin function         ref 118 118
ptr                                                    builtin function         ref 113

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1052        1116     706        1062
Length      1334     706        44         202     143          20

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
print_dump_seg_name_                268 external procedure  is an external procedure.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 fmtnl                       print_dump_seg_name_
000012 fmtsstn                     print_dump_seg_name_
000014 fmtsdw                      print_dump_seg_name_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
print_dump_seg_name_     000100 astep                       print_dump_seg_name_
                         000102 np                          print_dump_seg_name_
                         000104 axbitsp                     print_dump_seg_name_
                         000106 ax                          print_dump_seg_name_
                         000110 cl                          print_dump_seg_name_
                         000111 esw                         print_dump_seg_name_
                         000112 line                        print_dump_seg_name_
                         000153 dirname                     print_dump_seg_name_
                         000225 name                        print_dump_seg_name_
                         000235 ename                       print_dump_seg_name_
                         000245 namebuf                     print_dump_seg_name_
                         000266 lp                          print_dump_seg_name_
                         000270 sltp                        print_dump_seg_name_
                         000272 namp                        print_dump_seg_name_
                         000274 segptr                      print_dump_seg_name_
                         000276 l                           print_dump_seg_name_
                         000277 maxl                        print_dump_seg_name_
                         000300 minl                        print_dump_seg_name_
                         000301 i                           print_dump_seg_name_
                         000302 code                        print_dump_seg_name_
                         000303 dfchar                      print_dump_seg_name_
                         000304 dfno                        print_dump_seg_name_
                         000306 sdwp                        print_dump_seg_name_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return              ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
expand_path_                  get_ast_name_                 hcs_$initiate                 ioa_$rsnnl
od_print_                     ring0_get_$name_given_slt

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.


CONSTANTS
000000  aa     524000000002

000001  aa     404000000005

000002  aa     404000000043

000003  aa     404000000002

000004  aa     404000000001

000005  aa     524000000040

000006  aa     524000000250

000007  aa     524000000000

000010  aa     524000000005

000011  aa     526000000100

000012  aa     524000000010

000013  aa     404000000016

000014  aa     526000000001

000015  aa     404000000003

000016  aa     404000000030

000017  aa     524000000202

000020  aa     524000000056

000021  aa  060 061 062 063	0123

000022  aa     464000000000

000023  aa     410000000107

000024  aa     404000000021

000026  aa  122 105 127 120	REWP
000027  aa  125 107 040 040	UG  

000030  aa     077777000043
000031  aa     000001000000

000032  aa  076 154 144 144	>ldd
000033  aa  076 150 141 162	>har
000034  aa  144 076 157 142	d>ob
000035  aa  152 145 143 164	ject

000036  aa  076 163 171 163	>sys
000037  aa  164 145 155 137	tem_
000040  aa  154 151 142 162	libr
000041  aa  141 162 171 137	ary_
000042  aa  061 000 000 000	1

BEGIN PROCEDURE print_dump_seg_name_
ENTRY TO print_dump_seg_name_                               STATEMENT 1 ON LINE 11
print_dump_seg_name_: proc (segno, psdw, sstp, sstnp);

000043  at     000004000024
000044  tt     000023000022
000045  ta     000022000000
000046  ta     000043000000
000047  da     000100300000
000050  aa   000420 6270 00	eax7 	272
000051  aa  7 00034 3521 20	epp2 	pr7|28,*
000052  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000053  aa     000010000000
000054  aa     000000000000
000055  aa  6 00032 3735 20	epp7 	pr6|26,*
000056  aa  7 00006 3715 20	epp5 	pr7|6,*
000057  aa  6 00312 6515 00	spri5	pr6|202
000060  aa  7 00010 3535 20	epp3 	pr7|8,*
000061  aa  6 00310 2535 00	spri3	pr6|200
						STATEMENT 1 ON LINE 60
	esw = 1;

000062  aa   000001 2360 07	ldq  	1,dl
000063  aa  6 00111 7561 00	stq  	pr6|73		esw
						STATEMENT 1 ON LINE 62
	go to common;

000064  aa   000036 7100 04	tra  	30,ic		000122
ENTRY TO print_dump_seg_name_$get_ptr                       STATEMENT 1 ON LINE 64
print_dump_seg_name_$get_ptr: entry (segno, sstp, sstnp, xsegptr);

000065  at     000004000024
000066  tt     000022000022
000067  ta     000022000000
000070  ta     000065000000
000071  da     000120300000
000072  aa   000420 6270 00	eax7 	272
000073  aa  7 00034 3521 20	epp2 	pr7|28,*
000074  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000075  aa     000010000000
000076  aa     000000000000
000077  aa  6 00032 3735 20	epp7 	pr6|26,*
000100  aa  7 00004 3715 20	epp5 	pr7|4,*
000101  aa  6 00312 6515 00	spri5	pr6|202
000102  aa  7 00006 3535 20	epp3 	pr7|6,*
000103  aa  6 00310 2535 00	spri3	pr6|200
						STATEMENT 1 ON LINE 65
	xsegptr = null;

000104  aa   777724 2370 04	ldaq 	-44,ic		000030 = 077777000043 000001000000
000105  aa  6 00032 3735 20	epp7 	pr6|26,*
000106  aa  7 00010 7571 20	staq 	pr7|8,*		xsegptr
						STATEMENT 1 ON LINE 66
	esw = 0;

000107  aa  6 00111 4501 00	stz  	pr6|73		esw
						STATEMENT 1 ON LINE 67
	go to common;

000110  aa   000012 7100 04	tra  	10,ic		000122
ENTRY TO print_dump_seg_name_$hard                          STATEMENT 1 ON LINE 70
print_dump_seg_name_$hard: entry (segno, psdw, xsltp, xnamp);

000111  ta     000043000000
000112  da     000137300000
000113  aa   000420 6270 00	eax7 	272
000114  aa  7 00034 3521 20	epp2 	pr7|28,*
000115  aa  2 01045 2721 00	tsp2 	pr2|549		ext_entry
000116  aa     000010000000
000117  aa     000000000000
						STATEMENT 1 ON LINE 71
	esw = 2;

000120  aa   000002 2360 07	ldq  	2,dl
000121  aa  6 00111 7561 00	stq  	pr6|73		esw
						STATEMENT 1 ON LINE 74
common:	
	dirname = "";

000122  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000123  aa   000000 00 0000	desc9a	0,0
000124  aa  6 00153 00 0250	desc9a	pr6|107,168	dirname
						STATEMENT 1 ON LINE 76
	ename = "";

000125  aa  040 100 100 400	mlr  	(),(pr),fill(040)
000126  aa   000000 00 0000	desc9a	0,0
000127  aa  6 00235 00 0040	desc9a	pr6|157,32	ename
						STATEMENT 1 ON LINE 77
	if esw ^= 0 then do;

000130  aa  6 00111 2361 00	ldq  	pr6|73		esw
000131  aa   000170 6000 04	tze  	120,ic		000321
						STATEMENT 1 ON LINE 78
	     maxl = 100;

000132  aa   000144 2360 07	ldq  	100,dl
000133  aa  6 00277 7561 00	stq  	pr6|191		maxl
						STATEMENT 1 ON LINE 79
	     minl = 0;

000134  aa  6 00300 4501 00	stz  	pr6|192		minl
						STATEMENT 1 ON LINE 81
	     lp = addr (line);

000135  aa  6 00112 3735 00	epp7 	pr6|74		line
000136  aa  6 00266 6535 00	spri7	pr6|182		lp
						STATEMENT 1 ON LINE 82
	     sdwp = addr (psdw);

000137  aa  6 00032 3715 20	epp5 	pr6|26,*
000140  aa  5 00004 3535 20	epp3 	pr5|4,*		psdw
000141  aa  6 00306 2535 00	spri3	pr6|198		sdwp
						STATEMENT 1 ON LINE 84
	     ax = "REWPUG  ";

000142  aa   777664 2370 04	ldaq 	-76,ic		000026 = 122105127120 125107040040
000143  aa  6 00106 7571 00	staq 	pr6|70		ax
						STATEMENT 1 ON LINE 85
	     axbitsp = addr (sdwp -> sdw.read);

000144  aa   000017 7270 07	lxl7 	15,dl
000145  aa  3 00001 3521 00	epp2 	pr3|1		sdw.read
000146  aa  2 00000 5035 17	abd  	pr2|0,7
000147  aa  6 00104 2521 00	spri2	pr6|68		axbitsp
						STATEMENT 1 ON LINE 87
	     do i = 1 to 6;

000150  aa   000001 2360 07	ldq  	1,dl
000151  aa  6 00301 7561 00	stq  	pr6|193		i
000152  aa  6 00301 2361 00	ldq  	pr6|193		i
000153  aa   000006 1160 07	cmpq 	6,dl
000154  aa   000013 6054 04	tpnz 	11,ic		000167
						STATEMENT 1 ON LINE 88
		if axbitsp -> axbits (i) = "0"b then substr (ax, i, 1) = " ";

000155  aa  6 00104 3735 20	epp7 	pr6|68,*		axbitsp
000156  aa  000 000 066 506	cmpb 	(pr,ql),(),fill(0)
000157  aa  7 77777 70 0001	descb	pr7|-1(35),1	axbits
000160  aa   000000 00 0000	descb	0,0
000161  aa   000004 6010 04	tnz  	4,ic		000165
000162  aa  040 106 100 400	mlr  	(),(pr,ql),fill(040)
000163  aa   000000 00 0000	desc9a	0,0
000164  aa  6 00105 60 0001	desc9a	pr6|69(3),1	ax
						STATEMENT 1 ON LINE 89
	     end;

000165  aa  6 00301 0541 00	aos  	pr6|193		i
000166  aa   777764 7100 04	tra  	-12,ic		000152
						STATEMENT 1 ON LINE 91
	     if sdwp -> sdw.df then dfchar = " ";

000167  aa  6 00306 2351 20	lda  	pr6|198,*		sdw.df
000170  aa   000004 3150 07	cana 	4,dl
000171  aa   000004 6000 04	tze  	4,ic		000175
000172  aa   040000 2350 03	lda  	16384,du
000173  aa  6 00303 7551 00	sta  	pr6|195		dfchar
000174  aa   000007 7100 04	tra  	7,ic		000203
						STATEMENT 1 ON LINE 92
	     else do;

						STATEMENT 1 ON LINE 93
		dfno = bin (sdwp -> sdw.df_no, 2);

000175  aa  6 00306 2361 20	ldq  	pr6|198,*		sdw.df_no
000176  aa  0 00434 3771 00	anaq 	pr0|284		= 000000000000 000000000003
000177  aa  6 00304 7561 00	stq  	pr6|196		dfno
						STATEMENT 1 ON LINE 94
		dfchar = substr ("0123", dfno + 1, 1);

000200  aa  040 100 100 406	mlr  	(ql),(pr),fill(040)
000201  ta   000021 00 0001	desc9a	17,1
000202  aa  6 00303 00 0001	desc9a	pr6|195,1		dfchar
						STATEMENT 1 ON LINE 95
	     end;

						STATEMENT 1 ON LINE 97
	     cl = bin (sdwp -> sdw.entry_bound, 17);

000203  aa  6 00306 3735 20	epp7 	pr6|198,*		sdwp
000204  aa  7 00001 2351 00	lda  	pr7|1		sdw.entry_bound
000205  aa   000026 7350 00	als  	22
000206  aa  6 00314 7551 00	sta  	pr6|204		sdw.entry_bound
000207  aa   000072 7730 00	lrl  	58
000210  aa  6 00110 7561 00	stq  	pr6|72		cl
						STATEMENT 1 ON LINE 99
	     call ioa_$rsnnl (fmtsdw, line, l,
	     bin (sdwp -> sdw.add, 24),
	     bin (sdwp -> sdw.r1, 3),
	     bin (sdwp -> sdw.r2, 3),
	     bin (sdwp -> sdw.r3, 3),
	     dfchar,
	     bin (sdwp -> sdw.bound, 14),
	     ax,
	     bin (sdwp -> sdw.entry_bound, 14),
	     segno);

000211  aa  7 00000 2351 00	lda  	pr7|0		sdw.add
000212  aa   000060 7730 00	lrl  	48
000213  aa  6 00315 7561 00	stq  	pr6|205
000214  aa  7 00000 2351 00	lda  	pr7|0		sdw.r1
000215  aa   000030 7350 00	als  	24
000216  aa   000105 7730 00	lrl  	69
000217  aa  6 00316 7561 00	stq  	pr6|206
000220  aa  7 00000 2351 00	lda  	pr7|0		sdw.r2
000221  aa   000033 7350 00	als  	27
000222  aa   000105 7730 00	lrl  	69
000223  aa  6 00317 7561 00	stq  	pr6|207
000224  aa  7 00000 2351 00	lda  	pr7|0		sdw.r3
000225  aa   000036 7350 00	als  	30
000226  aa   000105 7730 00	lrl  	69
000227  aa  6 00320 7561 00	stq  	pr6|208
000230  aa  7 00001 2351 00	lda  	pr7|1		sdw.bound
000231  aa   000001 7350 00	als  	1
000232  aa   000072 7730 00	lrl  	58
000233  aa  6 00321 7561 00	stq  	pr6|209
000234  aa  6 00314 2351 00	lda  	pr6|204		sdw.entry_bound
000235  aa   000072 7730 00	lrl  	58
000236  aa  6 00322 7561 00	stq  	pr6|210
000237  aa  6 00044 3701 20	epp4 	pr6|36,*
000240  ia  4 00014 3521 00	epp2 	pr4|12		fmtsdw
000241  aa  6 00326 2521 00	spri2	pr6|214
000242  aa  6 00112 3521 00	epp2 	pr6|74		line
000243  aa  6 00330 2521 00	spri2	pr6|216
000244  aa  6 00276 3521 00	epp2 	pr6|190		l
000245  aa  6 00332 2521 00	spri2	pr6|218
000246  aa  6 00315 3521 00	epp2 	pr6|205
000247  aa  6 00334 2521 00	spri2	pr6|220
000250  aa  6 00316 3521 00	epp2 	pr6|206
000251  aa  6 00336 2521 00	spri2	pr6|222
000252  aa  6 00317 3521 00	epp2 	pr6|207
000253  aa  6 00340 2521 00	spri2	pr6|224
000254  aa  6 00320 3521 00	epp2 	pr6|208
000255  aa  6 00342 2521 00	spri2	pr6|226
000256  aa  6 00303 3521 00	epp2 	pr6|195		dfchar
000257  aa  6 00344 2521 00	spri2	pr6|228
000260  aa  6 00321 3521 00	epp2 	pr6|209
000261  aa  6 00346 2521 00	spri2	pr6|230
000262  aa  6 00106 3521 00	epp2 	pr6|70		ax
000263  aa  6 00350 2521 00	spri2	pr6|232
000264  aa  6 00322 3521 00	epp2 	pr6|210
000265  aa  6 00352 2521 00	spri2	pr6|234
000266  aa  6 00032 3715 20	epp5 	pr6|26,*
000267  aa  5 00002 3521 20	epp2 	pr5|2,*		segno
000270  aa  6 00354 2521 00	spri2	pr6|236
000271  aa   777527 3520 04	epp2 	-169,ic		000020 = 524000000056
000272  aa  6 00356 2521 00	spri2	pr6|238
000273  aa   777524 3520 04	epp2 	-172,ic		000017 = 524000000202
000274  aa  6 00360 2521 00	spri2	pr6|240
000275  aa   777527 3520 04	epp2 	-169,ic		000024 = 404000000021
000276  aa  6 00362 2521 00	spri2	pr6|242
000277  aa  6 00404 2521 00	spri2	pr6|260
000300  aa   777516 3520 04	epp2 	-178,ic		000016 = 404000000030
000301  aa  6 00364 2521 00	spri2	pr6|244
000302  aa   777513 3520 04	epp2 	-181,ic		000015 = 404000000003
000303  aa  6 00366 2521 00	spri2	pr6|246
000304  aa  6 00370 2521 00	spri2	pr6|248
000305  aa  6 00372 2521 00	spri2	pr6|250
000306  aa   777506 3520 04	epp2 	-186,ic		000014 = 526000000001
000307  aa  6 00374 2521 00	spri2	pr6|252
000310  aa   777503 3520 04	epp2 	-189,ic		000013 = 404000000016
000311  aa  6 00376 2521 00	spri2	pr6|254
000312  aa  6 00402 2521 00	spri2	pr6|258
000313  aa   777477 3520 04	epp2 	-193,ic		000012 = 524000000010
000314  aa  6 00400 2521 00	spri2	pr6|256
000315  aa  6 00324 6211 00	eax1 	pr6|212
000316  aa   060000 4310 07	fld  	24576,dl
000317  la  4 00036 3521 20	epp2 	pr4|30,*		ioa_$rsnnl
000320  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 109
	end;

						STATEMENT 1 ON LINE 111
	if esw ^= 2 then do;

000321  aa  6 00111 2361 00	ldq  	pr6|73		esw
000322  aa   000002 1160 07	cmpq 	2,dl
000323  aa   000224 6000 04	tze  	148,ic		000547
						STATEMENT 1 ON LINE 112
	     if sstp = null | sstnp = null then go to print_line;

000324  aa  6 00312 2371 20	ldaq 	pr6|202,*		sstp
000325  aa   777503 6770 04	eraq 	-189,ic		000030 = 077777000043 000001000000
000326  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000327  aa   000324 6000 04	tze  	212,ic		000653
000330  aa  6 00310 2371 20	ldaq 	pr6|200,*		sstnp
000331  aa   777477 6770 04	eraq 	-193,ic		000030 = 077777000043 000001000000
000332  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000333  aa   000320 6000 04	tze  	208,ic		000653
						STATEMENT 1 ON LINE 113
	     astep = ptr (sstp, bin (sdwp -> sdw.add, 24) - sstp -> sst.ptwbase
			- sstp -> sst.astsize);

000334  aa  6 00306 2351 20	lda  	pr6|198,*		sdw.add
000335  aa   000060 7730 00	lrl  	48
000336  aa  6 00312 3735 20	epp7 	pr6|202,*		sstp
000337  aa  7 00000 3735 20	epp7 	pr7|0,*		sstp
000340  aa  7 00025 1761 00	sbq  	pr7|21		sst.ptwbase
000341  aa  7 00033 1761 00	sbq  	pr7|27		sst.astsize
000342  aa   000000 3334 06	eawp7	0,ql
000343  aa  6 00100 6535 00	spri7	pr6|64		astep
						STATEMENT 1 ON LINE 115
	     call get_ast_name_ (astep, sstp, sstnp, namebuf);

000344  aa  6 00100 3521 00	epp2 	pr6|64		astep
000345  aa  6 00326 2521 00	spri2	pr6|214
000346  aa  6 00312 3521 20	epp2 	pr6|202,*		sstp
000347  aa  6 00330 2521 00	spri2	pr6|216
000350  aa  6 00310 3521 20	epp2 	pr6|200,*		sstnp
000351  aa  6 00332 2521 00	spri2	pr6|218
000352  aa  6 00245 3521 00	epp2 	pr6|165		namebuf
000353  aa  6 00334 2521 00	spri2	pr6|220
000354  aa   777446 3520 04	epp2 	-218,ic		000022 = 464000000000
000355  aa  6 00336 2521 00	spri2	pr6|222
000356  aa  6 00340 2521 00	spri2	pr6|224
000357  aa  6 00342 2521 00	spri2	pr6|226
000360  aa   777431 3520 04	epp2 	-231,ic		000011 = 526000000100
000361  aa  6 00344 2521 00	spri2	pr6|228
000362  aa  6 00324 6211 00	eax1 	pr6|212
000363  aa   020000 4310 07	fld  	8192,dl
000364  aa  6 00044 3701 20	epp4 	pr6|36,*
000365  la  4 00032 3521 20	epp2 	pr4|26,*		get_ast_name_
000366  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 116
	     if esw = 1 then call ioa_$rsnnl(fmtsstn, line, l, bline, namebuf);

000367  aa  6 00111 2361 00	ldq  	pr6|73		esw
000370  aa   000001 1160 07	cmpq 	1,dl
000371  aa   000036 6010 04	tnz  	30,ic		000427
000372  aa  6 00276 2361 00	ldq  	pr6|190		l
000373  aa   524000 2760 03	orq  	174080,du
000374  aa  6 00322 7561 00	stq  	pr6|210
000375  aa  6 00044 3701 20	epp4 	pr6|36,*
000376  ia  4 00012 3521 00	epp2 	pr4|10		fmtsstn
000377  aa  6 00326 2521 00	spri2	pr6|214
000400  aa  6 00112 3521 00	epp2 	pr6|74		line
000401  aa  6 00330 2521 00	spri2	pr6|216
000402  aa  6 00276 3521 00	epp2 	pr6|190		l
000403  aa  6 00332 2521 00	spri2	pr6|218
000404  aa  6 00266 3521 20	epp2 	pr6|182,*		bline
000405  aa  6 00334 2521 00	spri2	pr6|220
000406  aa  6 00245 3521 00	epp2 	pr6|165		namebuf
000407  aa  6 00336 2521 00	spri2	pr6|222
000410  aa   777400 3520 04	epp2 	-256,ic		000010 = 524000000005
000411  aa  6 00340 2521 00	spri2	pr6|224
000412  aa   777405 3520 04	epp2 	-251,ic		000017 = 524000000202
000413  aa  6 00342 2521 00	spri2	pr6|226
000414  aa   777410 3520 04	epp2 	-248,ic		000024 = 404000000021
000415  aa  6 00344 2521 00	spri2	pr6|228
000416  aa  6 00322 3521 00	epp2 	pr6|210
000417  aa  6 00346 2521 00	spri2	pr6|230
000420  aa   777371 3520 04	epp2 	-263,ic		000011 = 526000000100
000421  aa  6 00350 2521 00	spri2	pr6|232
000422  aa  6 00324 6211 00	eax1 	pr6|212
000423  aa   024000 4310 07	fld  	10240,dl
000424  la  4 00036 3521 20	epp2 	pr4|30,*		ioa_$rsnnl
000425  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
000426  aa   000225 7100 04	tra  	149,ic		000653
						STATEMENT 1 ON LINE 117
	     else do;

						STATEMENT 1 ON LINE 118
		call expand_path_ (addr(namebuf), length (namebuf), addr (dirname), addr (ename), code);

000427  aa  6 00245 3735 00	epp7 	pr6|165		namebuf
000430  aa  6 00406 6535 00	spri7	pr6|262
000431  aa   000100 2360 07	ldq  	64,dl
000432  aa  6 00322 7561 00	stq  	pr6|210
000433  aa  6 00153 3715 00	epp5 	pr6|107		dirname
000434  aa  6 00410 6515 00	spri5	pr6|264
000435  aa  6 00235 3535 00	epp3 	pr6|157		ename
000436  aa  6 00412 2535 00	spri3	pr6|266
000437  aa  6 00406 3521 00	epp2 	pr6|262
000440  aa  6 00326 2521 00	spri2	pr6|214
000441  aa  6 00322 3521 00	epp2 	pr6|210
000442  aa  6 00330 2521 00	spri2	pr6|216
000443  aa  6 00410 3521 00	epp2 	pr6|264
000444  aa  6 00332 2521 00	spri2	pr6|218
000445  aa  6 00412 3521 00	epp2 	pr6|266
000446  aa  6 00334 2521 00	spri2	pr6|220
000447  aa  6 00302 3521 00	epp2 	pr6|194		code
000450  aa  6 00336 2521 00	spri2	pr6|222
000451  aa  6 00324 6211 00	eax1 	pr6|212
000452  aa   024000 4310 07	fld  	10240,dl
000453  aa  6 00044 3701 20	epp4 	pr6|36,*
000454  la  4 00030 3521 20	epp2 	pr4|24,*		expand_path_
000455  aa  0 00623 7001 00	tsx0 	pr0|403		call_ext_out
						STATEMENT 1 ON LINE 119
		if code ^= 0 then go to pfail;

000456  aa  6 00302 2361 00	ldq  	pr6|194		code
000457  aa   000064 6010 04	tnz  	52,ic		000543
						STATEMENT 1 ON LINE 120
		if dirname = ">system_library_1" then dirname = ">ldd>hard>object";

000460  aa  040 004 106 500	cmpc 	(pr),(ic),fill(040)
000461  aa  6 00153 00 0250	desc9a	pr6|107,168	dirname
000462  aa   777356 00 0021	desc9a	-274,17		000036 = 076163171163
000463  aa   000004 6010 04	tnz  	4,ic		000467
000464  aa  040 100 100 404	mlr  	(ic),(pr),fill(040)
000465  aa   777346 00 0020	desc9a	-282,16		000032 = 076154144144
000466  aa  6 00153 00 0250	desc9a	pr6|107,168	dirname
						STATEMENT 1 ON LINE 121
		call hcs_$initiate (dirname, ename, "", 0, 1, segptr, code);

000467  aa  6 00321 4501 00	stz  	pr6|209
000470  aa   000001 2360 07	ldq  	1,dl
000471  aa  6 00320 7561 00	stq  	pr6|208
000472  aa  6 00153 3521 00	epp2 	pr6|107		dirname
000473  aa  6 00326 2521 00	spri2	pr6|214
000474  aa  6 00235 3521 00	epp2 	pr6|157		ename
000475  aa  6 00330 2521 00	spri2	pr6|216
000476  aa  6 00322 3521 00	epp2 	pr6|210
000477  aa  6 00332 2521 00	spri2	pr6|218
000500  aa  6 00321 3521 00	epp2 	pr6|209
000501  aa  6 00334 2521 00	spri2	pr6|220
000502  aa  6 00320 3521 00	epp2 	pr6|208
000503  aa  6 00336 2521 00	spri2	pr6|222
000504  aa  6 00274 3521 00	epp2 	pr6|188		segptr
000505  aa  6 00340 2521 00	spri2	pr6|224
000506  aa  6 00302 3521 00	epp2 	pr6|194		code
000507  aa  6 00342 2521 00	spri2	pr6|226
000510  aa   777276 3520 04	epp2 	-322,ic		000006 = 524000000250
000511  aa  6 00344 2521 00	spri2	pr6|228
000512  aa   777273 3520 04	epp2 	-325,ic		000005 = 524000000040
000513  aa  6 00346 2521 00	spri2	pr6|230
000514  aa   777273 3520 04	epp2 	-325,ic		000007 = 524000000000
000515  aa  6 00350 2521 00	spri2	pr6|232
000516  aa   777266 3520 04	epp2 	-330,ic		000004 = 404000000001
000517  aa  6 00352 2521 00	spri2	pr6|234
000520  aa   777263 3520 04	epp2 	-333,ic		000003 = 404000000002
000521  aa  6 00354 2521 00	spri2	pr6|236
000522  aa   777300 3520 04	epp2 	-320,ic		000022 = 464000000000
000523  aa  6 00356 2521 00	spri2	pr6|238
000524  aa   777256 3520 04	epp2 	-338,ic		000002 = 404000000043
000525  aa  6 00360 2521 00	spri2	pr6|240
000526  aa  6 00324 6211 00	eax1 	pr6|212
000527  aa   034000 4310 07	fld  	14336,dl
000530  aa  6 00044 3701 20	epp4 	pr6|36,*
000531  la  4 00034 3521 20	epp2 	pr4|28,*		hcs_$initiate
000532  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 122
		if segptr = null then xsegptr = segptr;

000533  aa  6 00274 2371 00	ldaq 	pr6|188		segptr
000534  aa   777274 6770 04	eraq 	-324,ic		000030 = 077777000043 000001000000
000535  aa  0 00460 3771 00	anaq 	pr0|304		= 077777000077 777777077077
000536  aa   000005 6010 04	tnz  	5,ic		000543
000537  aa  6 00274 3735 20	epp7 	pr6|188,*		segptr
000540  aa  6 00032 3715 20	epp5 	pr6|26,*
000541  aa  5 00010 6535 20	spri7	pr5|8,*		xsegptr
000542  aa   000111 7100 04	tra  	73,ic		000653
						STATEMENT 1 ON LINE 123
		else
pfail:		xsegptr = null;

000543  aa   777265 2370 04	ldaq 	-331,ic		000030 = 077777000043 000001000000
000544  aa  6 00032 3735 20	epp7 	pr6|26,*
000545  aa  7 00010 7571 20	staq 	pr7|8,*		xsegptr
						STATEMENT 1 ON LINE 125
	     end;

						STATEMENT 1 ON LINE 126
	     go to print_line;

000546  aa   000105 7100 04	tra  	69,ic		000653
						STATEMENT 1 ON LINE 127
	end;

						STATEMENT 1 ON LINE 128
	else do;

						STATEMENT 1 ON LINE 130
	     sltp = xsltp;

000547  aa  6 00032 3735 20	epp7 	pr6|26,*
000550  aa  7 00006 3715 20	epp5 	pr7|6,*		xsltp
000551  aa  5 00000 3715 20	epp5 	pr5|0,*		xsltp
000552  aa  6 00270 6515 00	spri5	pr6|184		sltp
						STATEMENT 1 ON LINE 131
	     namp = xnamp;

000553  aa  7 00010 3535 20	epp3 	pr7|8,*		xnamp
000554  aa  3 00000 3535 20	epp3 	pr3|0,*		xnamp
000555  aa  6 00272 2535 00	spri3	pr6|186		namp
						STATEMENT 1 ON LINE 132
	     np = baseptr (segno);

000556  aa  7 00002 2361 20	ldq  	pr7|2,*		segno
000557  aa   000000 3130 06	easp2	0,ql
000560  aa  2 00000 3525 00	epbp2	pr2|0
000561  aa  6 00102 2521 00	spri2	pr6|66		np
						STATEMENT 1 ON LINE 133
	     call ring0_get_$name_given_slt (dirname, name, np, code, sltp, namp);

000562  aa  6 00153 3521 00	epp2 	pr6|107		dirname
000563  aa  6 00326 2521 00	spri2	pr6|214
000564  aa  6 00225 3521 00	epp2 	pr6|149		name
000565  aa  6 00330 2521 00	spri2	pr6|216
000566  aa  6 00102 3521 00	epp2 	pr6|66		np
000567  aa  6 00332 2521 00	spri2	pr6|218
000570  aa  6 00302 3521 00	epp2 	pr6|194		code
000571  aa  6 00334 2521 00	spri2	pr6|220
000572  aa  6 00270 3521 00	epp2 	pr6|184		sltp
000573  aa  6 00336 2521 00	spri2	pr6|222
000574  aa  6 00272 3521 00	epp2 	pr6|186		namp
000575  aa  6 00340 2521 00	spri2	pr6|224
000576  aa   777210 3520 04	epp2 	-376,ic		000006 = 524000000250
000577  aa  6 00342 2521 00	spri2	pr6|226
000600  aa   777205 3520 04	epp2 	-379,ic		000005 = 524000000040
000601  aa  6 00344 2521 00	spri2	pr6|228
000602  aa   777220 3520 04	epp2 	-368,ic		000022 = 464000000000
000603  aa  6 00346 2521 00	spri2	pr6|230
000604  aa  6 00352 2521 00	spri2	pr6|234
000605  aa  6 00354 2521 00	spri2	pr6|236
000606  aa   777174 3520 04	epp2 	-388,ic		000002 = 404000000043
000607  aa  6 00350 2521 00	spri2	pr6|232
000610  aa  6 00324 6211 00	eax1 	pr6|212
000611  aa   030000 4310 07	fld  	12288,dl
000612  aa  6 00044 3701 20	epp4 	pr6|36,*
000613  la  4 00042 3521 20	epp2 	pr4|34,*		ring0_get_$name_given_slt
000614  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 134
	     if code = 0 then call ioa_$rsnnl (fmtsstn, line, l, bline, name);

000615  aa  6 00302 2361 00	ldq  	pr6|194		code
000616  aa   000035 6010 04	tnz  	29,ic		000653
000617  aa  6 00276 2361 00	ldq  	pr6|190		l
000620  aa   524000 2760 03	orq  	174080,du
000621  aa  6 00320 7561 00	stq  	pr6|208
000622  aa  6 00044 3701 20	epp4 	pr6|36,*
000623  ia  4 00012 3521 00	epp2 	pr4|10		fmtsstn
000624  aa  6 00326 2521 00	spri2	pr6|214
000625  aa  6 00112 3521 00	epp2 	pr6|74		line
000626  aa  6 00330 2521 00	spri2	pr6|216
000627  aa  6 00276 3521 00	epp2 	pr6|190		l
000630  aa  6 00332 2521 00	spri2	pr6|218
000631  aa  6 00266 3521 20	epp2 	pr6|182,*		bline
000632  aa  6 00334 2521 00	spri2	pr6|220
000633  aa  6 00225 3521 00	epp2 	pr6|149		name
000634  aa  6 00336 2521 00	spri2	pr6|222
000635  aa   777153 3520 04	epp2 	-405,ic		000010 = 524000000005
000636  aa  6 00340 2521 00	spri2	pr6|224
000637  aa   777160 3520 04	epp2 	-400,ic		000017 = 524000000202
000640  aa  6 00342 2521 00	spri2	pr6|226
000641  aa   777163 3520 04	epp2 	-397,ic		000024 = 404000000021
000642  aa  6 00344 2521 00	spri2	pr6|228
000643  aa  6 00320 3521 00	epp2 	pr6|208
000644  aa  6 00346 2521 00	spri2	pr6|230
000645  aa   777140 3520 04	epp2 	-416,ic		000005 = 524000000040
000646  aa  6 00350 2521 00	spri2	pr6|232
000647  aa  6 00324 6211 00	eax1 	pr6|212
000650  aa   024000 4310 07	fld  	10240,dl
000651  la  4 00036 3521 20	epp2 	pr4|30,*		ioa_$rsnnl
000652  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 135
	end;

						STATEMENT 1 ON LINE 138
print_line:					/* Print accumulated line image */
	if esw = 0 then return;

000653  aa  6 00111 2361 00	ldq  	pr6|73		esw
000654  aa  0 00631 6001 00	tze  	pr0|409		return
						STATEMENT 1 ON LINE 140
	if l > minl				/* See if anything significant in buffer */
	then call od_print_ (1, fmtnl, bline);

000655  aa  6 00276 2361 00	ldq  	pr6|190		l
000656  aa  6 00300 1161 00	cmpq 	pr6|192		minl
000657  aa   000026 6044 04	tmoz 	22,ic		000705
000660  aa   524000 2760 03	orq  	174080,du
000661  aa  6 00320 7561 00	stq  	pr6|208
000662  aa   000001 2360 07	ldq  	1,dl
000663  aa  6 00321 7561 00	stq  	pr6|209
000664  aa  6 00321 3521 00	epp2 	pr6|209
000665  aa  6 00326 2521 00	spri2	pr6|214
000666  aa  6 00044 3701 20	epp4 	pr6|36,*
000667  ia  4 00010 3521 00	epp2 	pr4|8		fmtnl
000670  aa  6 00330 2521 00	spri2	pr6|216
000671  aa  6 00266 3521 20	epp2 	pr6|182,*		bline
000672  aa  6 00332 2521 00	spri2	pr6|218
000673  aa   777106 3520 04	epp2 	-442,ic		000001 = 404000000005
000674  aa  6 00334 2521 00	spri2	pr6|220
000675  aa   777103 3520 04	epp2 	-445,ic		000000 = 524000000002
000676  aa  6 00336 2521 00	spri2	pr6|222
000677  aa  6 00320 3521 00	epp2 	pr6|208
000700  aa  6 00340 2521 00	spri2	pr6|224
000701  aa  6 00324 6211 00	eax1 	pr6|212
000702  aa   014000 4310 07	fld  	6144,dl
000703  la  4 00040 3521 20	epp2 	pr4|32,*		od_print_
000704  aa  0 00622 7001 00	tsx0 	pr0|402		call_ext_out_desc
						STATEMENT 1 ON LINE 142
     end print_dump_seg_name_;

000705  aa  0 00631 7101 00	tra  	pr0|409		return
  END PROCEDURE print_dump_seg_name_


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
