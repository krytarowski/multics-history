	COMPILATION LISTING OF SEGMENT print_syserr_msg_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/13/85  1200.7 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Procedure to print a syserr message */
       12 
       13 /* Coded November 1975 by Larry Johnson */
       14 /* Modified January 1976 by Larry Johnson */
       15 /* Modified October 1976 by Larry Johnson for new hardware fault messages. */
       16 /* Modified November 1979 by Larry Johnson for detailed device status */
       17 /* Modified June 1982 by E. N. Kittlitz to handle (i.e. do nothing for) config deck. */
       18 /* Modified May 1983 by E. N. Kittlitz to print config decks nicely. (There! that wasn't so hard, was it?) */
       19 
       20 /* format: style4 */
       21 print_syserr_msg_: proc (argp, code);
       22 
       23 
       24 dcl  code fixed bin (35);				/* Status code */
       25 dcl  (ctp, ptp) ptr;				/* Pointers to times */
       26 dcl  cur_time char (24);				/* Current time from date_time_ */
       27 dcl  seq_edit picture "zzzzzzzzzzz9";			/* To edit sequence number field */
       28 dcl  seq_sz fixed bin;				/* Number of chars in sequence number  */
       29 dcl  tpos fixed bin;				/* Current position while scanning text */
       30 dcl  (i, j) fixed bin;
       31 dcl  tlen fixed bin;				/* Length of portion of text being checked */
       32 dcl  room fixed bin;				/* Number of characters on line available for text */
       33 dcl  start fixed bin;				/* Starting position for characters */
       34 dcl  line_length fixed bin;				/* Length of line */
       35 dcl  moved fixed bin (21);				/* Number of characters moved into line */
       36 dcl  fl bit (1) init ("1"b);				/* Set while 1st line is edited */
       37 dcl  line char (1024);				/* Print line is built here */
       38 dcl  aline (1024) char (1) based (addr (line));		/* Another way of addressing line */
       39 dcl  next fixed bin;				/* Next character position available on line */
       40 dcl  restl fixed bin;				/* Length of rest of line */
       41 dcl  restp ptr;					/* Pointer to rest of line */
       42 dcl  rest char (restl) based (restp);			/* Rest of the line */
       43 dcl  arrayl fixed bin;				/* Length of portion of array */
       44 dcl  arrayp ptr;					/* Pointer to portion of array */
       45 dcl  based_array (arrayl) bit (36) aligned based (arrayp);	/* Portion of array */
       46 dcl  work char (1024) var;				/* A temp string */
       47 dcl  work2 char (128) var;				/* Another */
       48 dcl  code_edit picture "zzz9";			/* To edit the action code */
       49 dcl  bin_mode bit (1) init ("0"b);			/* Set while editing the binary part of message */
       50 dcl  first_bin bit (1) init ("0"b);			/* Set until 1st line of binary data printed */
       51 dcl  hold_moved fixed bin;				/* Used during binary editing to save text length */
       52 dcl  nwords fixed bin;				/* Number of words of binary data */
       53 dcl  wordp ptr;					/* Pointer to binary data */
       54 dcl  words (nwords) based (wordp);
       55 
       56 dcl  1 tm based,					/* Structure that overlays time from date_time_ */
       57        2 date char (8) unal,				/* MM/DD/YY */
       58        2 fill1 char (2) unal,
       59        2 time char (6) unal,				/* HHMM.T */
       60        2 fill2 char (1) unal,
       61        2 zone char (3) unal,				/* ZZZ - time zone */
       62        2 fill3 char (1) unal,
       63        2 day char (3) unal;				/* DDD - day of week */
       64 
       65 dcl  1 dtl,					/* Date line printed when day changes */
       66        2 nl1 char (1) unal,				/* A newline */
       67        2 day char (3) unal,				/* The day of the week */
       68        2 bl1 char (2) unal,				/* "  " */
       69        2 date char (8) unal,				/* MM/DD/YY */
       70        2 bl2 char (2) unal,				/* " (" */
       71        2 zone char (3) unal,				/* The time zone */
       72        2 bl3 char (1) unal,				/* ")" */
       73        2 nl2 char (1) unal;				/* A newline */
       74 
       75 
       76 dcl  newline char (1) int static init ("
       77 ");						/* A new line character */
       78 
  1     1 /* Begin include file ..... print_syserr_msg_args.incl.pl1 */
  1     2 
  1     3 /* This include file defines a structure which is used as a parameter to call the
  1     4*   subroutine print_syserr_msg_ */
  1     5 
  1     6 /* Written January 1976 by Larry Johnson */
  1     7 
  1     8 dcl  argp ptr;					/* Pointer to structure */
  1     9 
  1    10 dcl 1 parg aligned based (argp),
  1    11     2 msgp ptr,					/* Pointer to syserr message */
  1    12     2 iocbp ptr,					/* Pointer to iocb to which data is written */
  1    13     2 textp ptr,					/* Pointer to real text of message */
  1    14     2 printp ptr,					/* Pointer to message to print */
  1    15     2 textl fixed bin,				/* Length of real text of message */
  1    16     2 printl fixed bin,				/* Length of message to print */
  1    17     2 linelen fixed bin,				/* Length to terminal line */
  1    18     2 prev_time char (24),				/* Time of last message */
  1    19     2 bin_sw bit (1) unal,				/* Set if binary data should be printed */
  1    20     2 octal_sw bit (1) unal,				/* Set if binary data should be printed in octal */
  1    21     2 pad bit (34) unal;
  1    22 
  1    23 
  1    24 /* Notes:
  1    25*
  1    26*   This include file defines 3 different  character string messages. The first is contained
  1    27*   in the syserr message pointed to by "msgp". The second is defined by "textp" and "textl".
  1    28*   The third is defined by "printp" and "printl". The print_syserr_msg_ subroutine never looks at
  1    29*   the text in the syserr message pointer to by "msgp". It always prints the message
  1    30*   defined by "printp" and "printl". This may be an "=". If bin_sw is "1"b and octal_sw is "0"b,
  1    31*   the subroutine requires the real text of the message which is defined by "textp" and
  1    32*   "textl" to determine how to interpret the binary data. These paramaters should
  1    33*   be set to the last non "=" message from the log. */
  1    34 
  1    35 /* End include file ..... print_syserr_msg_args.incl.pl1 */
       79 
       80 
       81 dcl  text_data char (parg.textl) based (parg.textp);	/* Text from param list */
       82 dcl  print_data char (parg.printl) based (parg.printp);
       83 
       84 dcl  date_time_ entry (fixed bin (71), char (*));
       85 dcl  ioa_$rsnpnnl entry options (variable);
       86 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (21), fixed bin (35));
       87 dcl  syserr_log_util_$search entry (fixed bin (71), fixed bin (71), fixed bin (35), fixed bin (35));
       88 
       89 dcl  com_err_ entry options (variable);
       90 
       91 dcl  error_table_$smallarg ext fixed bin (35);
       92 
       93 dcl  (addr, addrel, bin, divide, index, hbound, length, max, min, reverse, rtrim, string, substr, verify) builtin;
       94 
  2     1 /* Begin include file ..... syserr_message.incl.pl1 */
  2     2 
  2     3 /* Format of a syserr message */
  2     4 
  2     5 /* Created October 1975 by Larry Johnson */
  2     6 
  2     7 dcl  syserr_msgp ptr;				/* Base for include file */
  2     8 
  2     9 dcl 1 syserr_msg based (syserr_msgp) aligned,
  2    10     2 seq_num fixed bin (35),				/* Sequence number of this message. */
  2    11     2 time fixed bin (71) unal,			/* Time message logged at */
  2    12     2 code fixed bin (11) unal,			/* Syserr code associated with this message. */
  2    13     2 text_len fixed bin (11) unal,			/* Length of message text in ASCII characters. */
  2    14     2 data_size fixed bin (11) unal,			/* Size of binary data */
  2    15     2 data_code fixed bin (11) unal,			/* Code identifying message type. */
  2    16     2 pad bit (60) unal,				/* RESERVED! */
  2    17     2 text char (0 refer (syserr_msg.text_len)),		/* Text of expanded message - kept in ASCII. */
  2    18     2 data (0 refer (syserr_msg.data_size)) bit (36);	/* Binary data area */
  2    19 
  2    20 
  2    21 /* End include file ..... syserr_message.incl.pl1 */
       95 
  3     1 /*  */
  3     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  3     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  3     4 /* Modified 07/07/76 by Morris for fault register data */
  3     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  3     6 /* Modified '82 to make values constant */
  3     7 
  3     8 /* words 0-15 pointer registers */
  3     9 
  3    10 dcl  mcp ptr;
  3    11 
  3    12 dcl 1 mc based (mcp) aligned,
  3    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  3    14    (2 regs,					/* registers */
  3    15       3 x (0:7) bit (18),				/* index registers */
  3    16       3 a bit (36),					/* accumulator */
  3    17       3 q bit (36),					/* q-register */
  3    18       3 e bit (8),					/* exponent */
  3    19       3 pad1 bit (28),
  3    20       3 t bit (27),					/* timer register */
  3    21       3 pad2 bit (6),
  3    22       3 ralr bit (3),				/* ring alarm register */
  3    23 
  3    24     2 scu (0:7) bit (36),
  3    25 
  3    26     2 mask bit (72),				/* mem controller mask at time of fault */
  3    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  3    28     2 errcode fixed bin (35),				/* fault handler's error code */
  3    29     2 fim_temp,
  3    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  3    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  3    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  3    33     2 fault_reg bit (36),				/* fault register */
  3    34     2 pad2 bit (1),
  3    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  3    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  3    37     2 fault_time bit (54),				/* time of fault */
  3    38 
  3    39     2 eis_info (0:7) bit (36)) unaligned;
  3    40 
  3    41 
  3    42 dcl (apx fixed bin init (0),
  3    43      abx fixed bin init (1),
  3    44      bpx fixed bin init (2),
  3    45      bbx fixed bin init (3),
  3    46      lpx fixed bin init (4),
  3    47      lbx fixed bin init (5),
  3    48      spx fixed bin init (6),
  3    49      sbx fixed bin init (7)) internal static options (constant);
  3    50 
  3    51 
  3    52 
  3    53 
  3    54 dcl  scup ptr;
  3    55 
  3    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  3    57 
  3    58 
  3    59 /*	WORD (0)		*/
  3    60 
  3    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  3    62       3 prr bit (3),				/* procedure ring register */
  3    63       3 psr bit (15),				/* procedure segment register */
  3    64       3 p bit (1),					/* procedure privileged bit */
  3    65 
  3    66     2 apu,					/* APPENDING UNIT STATUS */
  3    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  3    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  3    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  3    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  3    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  3    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  3    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  3    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  3    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  3    76       3 ptw bit (1),				/* Fetch of PTW */
  3    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  3    78       3 fap bit (1),				/* Fetch of final address paged */
  3    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  3    80       3 fabs bit (1),				/* Fetch of final address absolute */
  3    81 
  3    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  3    83 
  3    84 
  3    85 /*	WORD (1)		*/
  3    86 
  3    87     2 fd,						/* FAULT  DATA */
  3    88       3 iro bit (1),				/* illegal ring order */
  3    89       3 oeb bit (1),				/* out of execute bracket */
  3    90       3 e_off bit (1),				/* no execute */
  3    91       3 orb bit (1),				/* out of read bracket */
  3    92       3 r_off bit (1),				/* no read */
  3    93       3 owb bit (1),				/* out of write bracket */
  3    94       3 w_off bit (1),				/* no write */
  3    95       3 no_ga bit (1),				/* not a gate */
  3    96       3 ocb bit (1),				/* out of call bracket */
  3    97       3 ocall bit (1),				/* outward call */
  3    98       3 boc bit (1),				/* bad outward call */
  3    99       3 inret bit (1),				/* inward return */
  3   100       3 crt bit (1),				/* cross ring transfer */
  3   101       3 ralr bit (1),				/* ring alarm register */
  3   102       3 am_er bit (1),				/* associative memory fault */
  3   103       3 oosb bit (1),				/* out of segment bounds */
  3   104       3 paru bit (1),				/* processor parity upper */
  3   105       3 parl bit (1),				/* processor parity lower */
  3   106       3 onc_1 bit (1),				/* op not complete type 1 */
  3   107       3 onc_2 bit (1),				/* op not complete type 2 */
  3   108 
  3   109     2 port_stat,					/* PORT  STATUS */
  3   110       3 ial bit (4),				/* illegal action lines */
  3   111       3 iac bit (3),				/* illegal action channel */
  3   112       3 con_chan bit (3),				/* connect channel */
  3   113 
  3   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  3   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  3   116 
  3   117 
  3   118 /*	WORD (2)		*/
  3   119 
  3   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  3   121       3 trr bit (3),				/* temporary ring register */
  3   122       3 tsr bit (15),				/* temporary segment register */
  3   123 
  3   124     2 pad2 bit (9),
  3   125 
  3   126     2 cpu_no bit (3),				/* CPU number */
  3   127 
  3   128     2 delta bit (6),				/* tally modification DELTA */
  3   129 
  3   130 
  3   131 /*	WORD (3)		*/
  3   132 
  3   133     2 word3 bit (18),
  3   134 
  3   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  3   136       3 tsna,					/* Word 1 status */
  3   137         4 prn bit (3),				/* Word 1  PR  number */
  3   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  3   139       3 tsnb,					/* Word 2  status */
  3   140         4 prn bit (3),				/* Word 2  PR  number */
  3   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  3   142       3 tsnc,					/* Word 3  status */
  3   143         4 prn bit (3),				/* Word 3  PR  number */
  3   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  3   145 
  3   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  3   147 
  3   148 
  3   149 /* 	WORD (4)		*/
  3   150 
  3   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  3   152 
  3   153     2 ir,						/* INDICATOR  REGISTERS */
  3   154       3 zero bit (1),				/* zero indicator */
  3   155       3 neg bit (1),				/* negative indicator */
  3   156       3 carry bit (1),				/* carryry indicator */
  3   157       3 ovfl bit (1),				/* overflow indicator */
  3   158       3 eovf bit (1),				/* eponent overflow */
  3   159       3 eufl bit (1),				/* exponent underflow */
  3   160       3 oflm bit (1),				/* overflow mask */
  3   161       3 tro bit (1),				/* tally runout */
  3   162       3 par bit (1),				/* parity error */
  3   163       3 parm bit (1),				/* parity mask */
  3   164       3 bm bit (1),					/* ^bar mode */
  3   165       3 tru bit (1),				/* truncation mode */
  3   166       3 mif bit (1),				/* multi-word instruction mode */
  3   167       3 abs bit (1),				/* absolute mode */
  3   168       3 hex bit (1),				/* hexadecimal exponent mode */
  3   169       3 pad bit (3),
  3   170 
  3   171 
  3   172 /*	WORD (5)		*/
  3   173 
  3   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  3   175 
  3   176     2 cu,						/* CONTROL UNIT STATUS */
  3   177       3 rf bit (1),					/* on first cycle of repeat instr */
  3   178       3 rpt bit (1),				/* repeat instruction */
  3   179       3 rd bit (1),					/* repeat double instruction */
  3   180       3 rl bit (1),					/* repeat link instruciton */
  3   181       3 pot bit (1),				/* IT  modification */
  3   182       3 pon bit (1),				/* return type instruction */
  3   183       3 xde bit (1),				/* XDE from Even location */
  3   184       3 xdo bit (1),				/* XDE from Odd  location */
  3   185       3 poa bit (1),				/* operation preparation */
  3   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  3   187       3 its bit (1),				/* ITS modification */
  3   188       3 if bit (1),					/* fault occured during instruction fetch */
  3   189 
  3   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  3   191 
  3   192 
  3   193 /*	WORDS (6,7)	*/
  3   194 
  3   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  3   196 
  3   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  3   198 
  3   199 
  3   200 
  3   201 
  3   202 
  3   203 
  3   204 /*	ALTERNATE   SCU  DECLARATION		*/
  3   205 
  3   206 
  3   207 dcl 1 scux based (scup) aligned,
  3   208 
  3   209    (2 pad0 bit (36),
  3   210 
  3   211     2 fd,						/* GROUP II  FAULT DATA */
  3   212       3 isn bit (1),				/* illegal segment number */
  3   213       3 ioc bit (1),				/* illegal op  code  */
  3   214       3 ia_am bit (1),				/* illegal address - modifier */
  3   215       3 isp bit (1),				/* illegal slave  procedure */
  3   216       3 ipr bit (1),				/* illegal procedure */
  3   217       3 nea bit (1),				/* non existent address */
  3   218       3 oobb bit (1),				/* out of bounds */
  3   219       3 pad bit (29),
  3   220 
  3   221     2 pad2 bit (36),
  3   222 
  3   223     2 pad3a bit (18),
  3   224 
  3   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  3   226       3 prn bit (3),				/* PR  number */
  3   227       3 prv bit (1),				/* PR  valid bit */
  3   228 
  3   229     2 pad3b bit (6)) unaligned,
  3   230 
  3   231     2 pad45 (0:1) bit (36),
  3   232 
  3   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  3   234 
  3   235 
  3   236 
  3   237 /*  END INCLUDE FILE   mc.incl.pl1 */
       96 
       97 
       98 /* Get time of message */
       99 
      100 	syserr_msgp = parg.msgp;			/* Get pointer to message */
      101 
      102 	call date_time_ ((syserr_msg.time), cur_time);
      103 	ctp = addr (cur_time);			/* Get pointers to time structures */
      104 	ptp = addr (parg.prev_time);
      105 	if ctp -> tm.date ^= ptp -> tm.date then do;	/* If date change */
      106 	     dtl.nl1, dtl.nl2 = newline;		/* Fill in line to print */
      107 	     dtl.day = ctp -> tm.day;
      108 	     dtl.bl1 = "  ";
      109 	     dtl.date = ctp -> tm.date;
      110 	     dtl.bl2 = " (";
      111 	     dtl.zone = ctp -> tm.zone;
      112 	     dtl.bl3 = ")";
      113 	     call iox_$put_chars (iocbp, addr (dtl), length (string (dtl)), code);
      114 	     if code ^= 0 then return;		/* If put_chars error */
      115 	end;
      116 	parg.prev_time = cur_time;			/* Remember for next call */
      117 
      118 
      119 /* Determine how much space is on line for text */
      120 
      121 	line = "";				/* Clear line */
      122 	moved = 0;				/* No characters in it */
      123 	seq_edit = syserr_msg.seq_num;		/* Edit the sequence number */
      124 	seq_sz = max (6, 13 - verify (seq_edit, " "));	/* Characters in edited number with leading spaces removed */
      125 	start = seq_sz + 12;			/* Starting column for text */
      126 	line_length = min (parg.linelen, length (line) - 1);
      127 	room = line_length - start + 1;		/* Characters available in text portion of line */
      128 	if room <= 25 then do;			/* If too small */
      129 	     code = error_table_$smallarg;
      130 	     return;
      131 	end;
      132 
      133 	tpos = 1;					/* Start with first character */
      134 
      135 
      136 /* This routine edits the line. If it is too long, or contains newline, it will be
      137*   broken into several lines */
      138 
      139 top:	if tpos > length (print_data) then go to done;	/* Done if finished line */
      140 
      141 
      142 	i = index (substr (print_data, tpos), newline);
      143 						/* Check for newline */
      144 	if i = 0 then				/* No newline in remaining text */
      145 	     tlen = length (print_data) - tpos + 1;	/* Length to consider is rest of line */
      146 	else if i = 1 then do;			/* If newline is first */
      147 	     tpos = tpos + 1;			/* Skip over it */
      148 	     go to top;
      149 	end;
      150 	else tlen = i - 1;				/* Consider just stuff before newline */
      151 
      152 	i = verify (substr (print_data, tpos, tlen), " ");/* Count leading blanks */
      153 	if i = 0 then do;				/* Line is all blank */
      154 	     tpos = tpos + tlen;			/* Skip it all */
      155 	     go to top;
      156 	end;
      157 	if i > 1 then do;				/* Some leading blanks */
      158 	     tpos = tpos + i - 1;			/* Skip them */
      159 	     tlen = tlen - i + 1;			/* Adjust count */
      160 	end;
      161 
      162 	if moved ^= 0 then call put;			/* If stuff already on line, dump it */
      163 
      164 	if tlen <= room then do;			/* If it all fits */
      165 	     substr (line, start, tlen) = substr (print_data, tpos, tlen); /* Copy it all */
      166 	     moved = tlen;				/* Remember how much */
      167 	     tpos = tpos + tlen;
      168 	end;
      169 	else do;
      170 	     i = index (reverse (substr (print_data, tpos + room - 20, 20)), " ");
      171 						/* Check last 20 characters that fit for a blank */
      172 
      173 	     if i = 0 then do;			/* If no blank, break is arbitrary */
      174 		substr (line, start, room) = substr (print_data, tpos, room); /* Fill line */
      175 		moved = room;			/* Remember how much */
      176 		tpos = tpos + room;			/* Skip over what moved */
      177 	     end;
      178 	     else do;				/* Be neat and break on blank */
      179 		tlen = room - i;			/* Length to copy */
      180 		substr (line, start, tlen) = substr (print_data, tpos, tlen); /* Do it */
      181 		moved = tlen;			/* Remember how much */
      182 		tpos = tpos + tlen + 1;		/* Skip over stuff copied, + blank */
      183 	     end;
      184 	end;
      185 	go to top;				/* Back for more */
      186 
      187 done:	if parg.bin_sw then if syserr_msg.data_size > 0 then call edit_binary;
      188 
      189 	if fl | moved ^= 0 then call put;		/* Write last line */
      190 
      191 	code = 0;
      192 
      193 finish:	return;
      194 
      195 /* Procedure to print 1 line */
      196 
      197 put: proc;
      198 
      199 	if fl then do;				/* If first line */
      200 	     substr (line, 1, 6) = ctp -> tm.time;	/* Move in time */
      201 	     substr (line, 8, seq_sz) = substr (seq_edit, 13 - seq_sz); /* And sequence number */
      202 	     code_edit = syserr_msg.code;		/* Edit the action code */
      203 	     substr (line, seq_sz + 8, 3) = substr (code_edit, 2, 3); /* Move into line */
      204 	     fl = "0"b;				/* Only do this once */
      205 	end;
      206 
      207 	if first_bin then do;			/* If first line of binary data */
      208 	     first_bin = "0"b;
      209 	     if (hold_moved > 0) & (hold_moved ^= moved) then
      210 		moved = moved + 2;			/* This accounts for the 2 spaces between text and data
      211*						   when they both appear on the same line */
      212 	end;
      213 	moved = moved + start;			/* Total length */
      214 	substr (line, moved, 1) = newline;		/* Put new line at end */
      215 	call iox_$put_chars (iocbp, addr (line), moved, code);
      216 	if code ^= 0 then go to finish;
      217 	line = "";				/* Initialize for next line */
      218 	moved = 0;
      219 	if bin_mode then do;			/* Binary editors need extra stuff */
      220 	     restp = addr (aline (start));
      221 	     restl = room;
      222 	end;
      223 	return;
      224 
      225      end put;
      226 
      227 /* Procedure to edit binary data */
      228 
      229 edit_binary: proc;
      230 
      231 dcl  s fixed bin;
      232 dcl  i fixed bin;
      233 dcl  tbuf char (260);
      234 
  4     1 /* BEGIN INCLUDE FILE .. syserr_binary_def.incl.pl1 */
  4     2 
  4     3 /* This include file has an ALM version, keep 'em in sync. */
  4     4 
  4     5 /* format: off */
  4     6 
  4     7 /* Modified January 1984 by Paul Farley to add an array of entry values
  4     8*   to be examined by display_cpu_error. */
  4     9 /* Modified October 1984 by EJ Sharpe to include SB_audit_message */
  4    10 /* Modified January 1985 by EJ Sharpe for SB_char_data_classes */
  4    11 /* Modified 1985-01-25, BIM: added ring alarm audit support. */
  4    12 /* Modified 1985-02-20, EJ Sharpe: added SB_ibm3270_mde, syserr_binary_(seg vol)damage_class,
  4    13*		also changed some codes to "SB_unused_NN" - see line comments */
  4    14 
  4    15 /* In the future, these will be the only constants needed in this include
  4    16*file.  They are the binary data class strings for messages in the new format
  4    17*syserr logs.  The names are all of the form SB_ZZZZZZZ_data_class where
  4    18*ZZZZZZZ is the value of the data class string.  Message expanders are named
  4    19*expand_ZZZZZZZ_msg_ and are referenced by the log perusal tools. */
  4    20 
  4    21 dcl (						/* include file name */
  4    22 SB_io_status_data_class	init ("io_status"),		/* io_syserr_msg */
  4    23 SB_hwfault_data_class	init ("hwfault"),		/* syserr_fault_msg */
  4    24 SB_mos_data_class		init ("mos"),		/* scr */
  4    25 SB_segdamage_data_class	init ("segdamage"),		/* segdamage_msg */
  4    26 SB_voldamage_data_class	init ("voldamage"),		/* segdamage_msg (first two words) */
  4    27 SB_mdc_del_uidpath_data_class	init ("mdc_del_uidpath"),	/* none - 16 word UID path */
  4    28 SB_mmdam_data_class		init ("mmdam"),		/* syserr_mmdam_msg */
  4    29 SB_mpc_poll_data_class	init ("mpc_poll"),		/* poll_mpc_data */
  4    30 SB_fnp_poll_data_class	init ("fnp_poll"),		/* poll_fnp_data */
  4    31 SB_config_deck_data_class	init ("config_deck"),	/* config_deck */
  4    32 SB_vtoce_data_class		init ("vtoce"),		/* vtoce */
  4    33 SB_access_audit_data_class	init ("access_audit"),	/* access_audit_bin_header */
  4    34 SB_ibm3270_mde_data_class	init ("ibm3270_mde")	/* ibm3270_mpx_data */
  4    35 ) static internal char (16) varying options (constant);
  4    36 
  4    37 
  4    38 /************************
  4    39*Once the syserr$binary is replaced with something that takes real data classes
  4    40*and all system modules and tools are upgraded to use the new interface, the
  4    41*rest of this include file may be discarded.
  4    42*************************/
  4    43 
  4    44 /* The limit of 36 is arbitrary- there is no reason that it can not be
  4    45*   extended at any time. */
  4    46 
  4    47 dcl (
  4    48 SB_disk_err	init (1),		SBL_disk_err	init (5),
  4    49 SB_hw_fault	init (2),		SBL_hw_fault	init (176),
  4    50 SB_io_err		init (3),		SBL_io_err	init (5),
  4    51 SB_unused_4	init (4),		SBL_unused_4	init (1),	/* was "mos_poll" (mos poll time) */
  4    52 SB_mos_err	init (5),		SBL_mos_err	init (2),	/* mos memory error data */
  4    53 SB_unused_6	init (6),		SBL_unused_6	init (1),	/* was "bulk_status" (bulk dcb status) */
  4    54 SB_unused_7	init (7),		SBL_unused_7	init (1), /* was "bulk_csb" (bulk csb status) */
  4    55 SB_unused_8	init (8),		SBL_unused_8	init (3), /* was "free_st_1" */
  4    56 SB_unused_9	init (9),		SBL_unused_9	init (2), /* was "free_st_2" */
  4    57 SB_unused_10	init (10),	SBL_unused_10	init (21), /* was "unpr_add" */
  4    58 SB_zerpag		init (11),	SBL_zerpag	init (20),
  4    59 SB_unused_12	init (12),	SBL_unused_12	init (20), /* was "unpr_add" */
  4    60 SB_vtoc_salv_dam	init (13),	SBL_vtoc_salv_dam	init (20),
  4    61 SB_unused_14	init (14),	SBL_unused_14	init (20), /* was "page_rw_err" */
  4    62 SB_unused_15	init (15),	SBL_unused_15	init (3), /* was "ruad" */
  4    63 SB_random_segdamage	init (16),	SBL_random_segdamage init (20),
  4    64 SB_read_nc	init (17),	SBL_read_nc	init (2),
  4    65 SB_unused_18	init (18),	SBL_unused_18	init (2), /* was "vtoc_err" */
  4    66 SB_mdc_del_uidpath	init (19),	SBL_mdc_del_uidpath	init (16),
  4    67 SB_ocdcm_err	init (20),	SBL_ocdcm_err	init (5),
  4    68 SB_mmdam		init (21),	SBL_mmdam		init (2),
  4    69 SB_verify_lock	init (22),	SBL_verify_lock	init (176),
  4    70 SB_io_err_detail	init (23),	SBL_io_err_detail	init (11),
  4    71 SB_mpc_poll	init (24),	SBL_mpc_poll	init (256) /* max */,
  4    72 SB_fnp_poll	init (25),	SBL_fnp_poll	init (256) /* max */,
  4    73 SB_config_deck	init (26),	SBL_config_deck	init (256) /* 16 cards at 16 words */,
  4    74 SB_vtoce		init (27),	SBL_vtoce		init (192),    /* 1 VTOCE */
  4    75 SB_access_audit	init (28),	SBL_access_audit	init (256), /* max */
  4    76 SB_ibm3270_mde	init (35),	SBL_ibm3270_mde	init (256), /* max */
  4    77 SB_end_of_table	init (36),	SBL_end_of_table	init (1)
  4    78   ) internal static options (constant) fixed bin;
  4    79 
  4    80 
  4    81 /* The following array is a mapping of the old syserr$binary codes into the
  4    82*new data classes for MR11.  It is primarily used by syserr_copy to translate
  4    83*the binary data codes stored in the wired syserr log (see above) into the data
  4    84*classes needed by the ring-0 paged syserr log which is a new format log.  It
  4    85*is also used by syserr_log_util_ to translate the data classes back into the
  4    86*corresponding binary code (for tools not yet upgraded to deal with the new
  4    87*format log messages). */
  4    88 
  4    89 dcl SB_char_data_classes (36) char (16) varying internal static options (constant)
  4    90 	init (	"io_status",		/* 1 */
  4    91 		"hwfault",		/* 2 */
  4    92 		"io_status",		/* 3 */
  4    93 		"unused_4",		/* 4 */
  4    94 		"mos",			/* 5 */
  4    95 
  4    96 		"unused_6",		/* 6 */
  4    97 		"unused_7",		/* 7 */
  4    98 		"unused_8",		/* 8 */
  4    99 		"unused_9",		/* 9 */ 
  4   100 		"unused_10",		/* 10 */
  4   101 
  4   102 		"segdamage",		/* 11 */
  4   103 		"unused_12",		/* 12 */
  4   104 		"segdamage",		/* 13 */
  4   105 		"unused_14",		/* 14 */
  4   106 		"unused_15",		/* 15 */
  4   107 
  4   108 		"segdamage",		/* 16 */
  4   109 		"voldamage",		/* 17 */
  4   110 		"unused_18",		/* 18 */
  4   111 		"mdc_del_uidpath",		/* 19 */
  4   112 		"io_status",		/* 20 */
  4   113 
  4   114 		"mmdam",			/* 21 */
  4   115 		"hwfault",		/* 22 */
  4   116 		"io_status",		/* 23 */
  4   117 		"mpc_poll",		/* 24 */
  4   118 		"fnp_poll",		/* 25 */
  4   119 
  4   120 		"config_deck",		/* 26 */
  4   121 		"vtoce",			/* 27 */
  4   122 		"access_audit",		/* 28 */
  4   123 		"unused_29",		/* 29 */
  4   124 		"unused_30",		/* 30 */
  4   125 		"unused_31",		/* 31 */
  4   126 		"unused_32",		/* 32 */
  4   127 		"unused_33",		/* 33 */
  4   128 		"unused_34",		/* 34 */
  4   129 		"ibm3270_mde",		/* 35 */
  4   130 		"unused_36"		/* 36 */
  4   131 	);
  4   132 
  4   133 
  4   134 /* format: on */
  4   135 
  4   136 /* These constants are used by various tools which analyze syserr messages and
  4   137*still call the old interface "syserr_log_util_". */
  4   138 
  4   139      dcl	   syserr_binary_mos_mask init ("060000000000"b3) bit (36) static options (constant);
  4   140      dcl	   syserr_binary_seg_damage_mask init ("000374000000"b3) bit (36) static options (constant);
  4   141      dcl	   syserr_binary_vol_damage_mask init ("003413000000"b3) bit (36) static options (constant);
  4   142      dcl	   syserr_binary_address_damage_mask init ("002010000000"b3) bit (36) static options (constant);
  4   143 
  4   144      dcl	   display_cpu_error_binary_defs (2) init (
  4   145 			      2,			/** SB_hw_fault */
  4   146 			      22			/** SB_verify_lock */
  4   147 			      ) internal static options (constant) fixed bin;
  4   148 
  4   149 /* END INCLUDE FILE syserr_binary_def.incl.pl1 */
      235 
      236 
      237 dcl  binary_segmsg_util_ entry (ptr) returns (char (250));
      238 dcl  binary_segmsg_util_$interpret_pvname entry (ptr) returns (char (32));
      239 
      240 dcl  special_chars (15) char (32) var int static options (constant) init (/* Table of special messages */
      241 	"ioi_interrupt: I/O error.",
      242 	"op-not-complete fault by ",
      243 	"startup fault by ",
      244 	"shutdown fault by ",
      245 	"parity fault by ",
      246 	"mos_memory_check: EDAC error",
      247 	"cache dir parity fault on",
      248 	"cache store parity fault on",
      249 	"cache store thru parity fault on",
      250 	"cache load parity fault on",
      251 	"parity fault on",
      252 	"startup fault on",
      253 	"shutdown fault on",
      254 	"op_not_complete fault on",
      255 	"command fault on");
      256 
      257 
      258 	if moved = 0 then next = start;		/* Line empty */
      259 	else next = start + moved + 2;		/* Next available column */
      260 	hold_moved = moved;				/* Save text length */
      261 	bin_mode = "1"b;				/* In binary mode now */
      262 	first_bin = "1"b;				/* Editing first line */
      263 	restp = addr (aline (next));			/* Address of rest of line */
      264 	restl = line_length - next + 1;		/* Length of rest of line */
      265 
      266 	if octal_sw then do;			/* Do simple dump */
      267 	     call edit_std;
      268 	     return;
      269 	end;
      270 
      271 
      272 	if syserr_msg.data_code ^= 0 then do;
      273 	     s = syserr_msg.data_code;
      274 	     if s = SB_mos_err then call edit_mos_memory;
      275 	     else if s = SB_io_err then call edit_ioi;
      276 	     else if s = SB_io_err_detail then call edit_ioi_detail;
      277 	     else if s = SB_ocdcm_err then call edit_ioi;
      278 	     else if s = SB_hw_fault then go to scan;
      279 	     else if s = SB_verify_lock then call edit_fault;
      280 	     else if s = SB_config_deck then call edit_config;
      281 	     else if s < 0 | s > SB_end_of_table then ;
      282 	     else if substr (syserr_binary_seg_damage_mask, s, 1) then do;
      283 		tbuf = "Segment: " || binary_segmsg_util_ (addr (syserr_msg.data));
      284 		go to out_tbuf;
      285 	     end;
      286 	     else if substr (syserr_binary_vol_damage_mask, s, 1) then do;
      287 		tbuf = "Volume: " || binary_segmsg_util_$interpret_pvname (addr (syserr_msg.data));
      288 out_tbuf:		i = length (rtrim (tbuf));
      289 		if i > restl then call put;
      290 		moved = min (i, length (line));
      291 		rest = tbuf;
      292 		call put;
      293 		return;
      294 	     end;
      295 	     else call edit_std;
      296 
      297 	     return;
      298 	end;
      299 
      300 scan:
      301 	do i = 1 to hbound (special_chars, 1);		/* Scan table of names */
      302 	     if length (text_data) >= length (special_chars (i)) then
      303 		if index (text_data, special_chars (i)) ^= 0 then
      304 		     go to make_call;
      305 	end;
      306 
      307 	call edit_std;				/* Use a standard routine */
      308 	return;
      309 
      310 make_call: go to c (i);				/* Branch to appropriate call */
      311 c (1):	call edit_ioi;				/* Ioi error */
      312 	return;
      313 c (2):	call edit_old_onc;				/* Op-not-complete fault */
      314 	return;
      315 c (3):	call edit_old_startup;			/* Startup fault */
      316 	return;
      317 c (4):	call edit_old_startup;			/* Shutdown fault */
      318 	return;
      319 c (5):	call edit_old_parity;			/* Parity fault */
      320 	return;
      321 c (6):	call edit_mos_memory;			/* Mos memory EDAC error */
      322 	return;
      323 c (7):						/* Cache dir parity fault */
      324 c (8):						/* Cache store parity fault */
      325 c (9):						/* Cache store thru parity fault */
      326 c (10):						/* Cache load parity fault */
      327 c (11):						/* Parity fault */
      328 c (12):						/* Startup fault */
      329 c (13):						/* Shutdown fault */
      330 c (14):						/* Op not complete fault */
      331 c (15):						/* Command fault */
      332 	call edit_fault;
      333 	return;
      334 
      335      end edit_binary;
      336 
      337 /* Procedure to edit unidentified binary data */
      338 
      339 edit_std: proc;
      340 
      341 	nwords = syserr_msg.data_size;
      342 	wordp = addr (syserr_msg.data);
      343 	call edit_words;
      344 	return;
      345      end edit_std;
      346 
      347 
      348 /* Procedure that edits any random words */
      349 /* It will be put on the current line if it fits, otherwise on succeeding lines
      350*   with some power of 2 words per line */
      351 
      352 edit_words: proc;
      353 
      354 	i = 13 * nwords - 1;			/* Space needed for all words */
      355 	if i <= restl then do;			/* It fits */
      356 all_fits:	     call ioa_$rsnpnnl ("^(^w ^)", rest, (0), words); /* Edit it */
      357 	     moved = moved + i;
      358 	     call put;
      359 	     return;
      360 	end;
      361 
      362 	if moved > 0 then call put;			/* Dump current line */
      363 	if i <= restl then go to all_fits;		/* Fits on one line now */
      364 
      365 /* Determine number of words to print per line */
      366 
      367 	i, j = 1;
      368 	do while (j <= room);
      369 	     i = 2 * i;				/* A power of 2 */
      370 	     j = 13 * i - 1;			/* Space for that many words */
      371 	end;
      372 	i = divide (i, 2, 17, 0);			/* Last power of two that fit */
      373 
      374 	do j = 1 by i while (j <= nwords);		/* Loop to print the lines */
      375 	     arrayp = addr (words (j));		/* Addr of current piece */
      376 	     arrayl = min (i, nwords - j + 1);
      377 	     call ioa_$rsnpnnl ("^(^w ^)", rest, moved, based_array);
      378 	     call put;
      379 	end;
      380 
      381 	return;
      382 
      383      end edit_words;
      384 
      385 /* Procedure to edit a config deck fragment */
      386 
      387 edit_config: proc;
      388 dcl  data_left fixed bin;
      389 dcl  field_no fixed bin;
      390 dcl  config_card_field_in_ascii char (4) based;
  5     1 /* BEGIN INCLUDE FILE ... config_deck.incl.pl1 ... 11/13/80, W. Olin Sibert */
  5     2 
  5     3 dcl (configp, cardp) pointer;
  5     4 dcl  config_n_cards fixed bin;			/* Number of cards used in config */
  5     5 dcl  config_max_cards fixed bin;			/* Max number of cards in config */
  5     6 
  5     7 dcl  config_deck$ fixed bin external static;
  5     8 
  5     9 dcl 1 config_deck aligned based (configp),
  5    10     2 cards (config_n_cards) aligned like config_card,
  5    11     2 pad_cards (config_max_cards - config_n_cards) aligned like config_card;
  5    12 
  5    13 dcl 1 config_card aligned based (cardp),
  5    14     2 word char (4) aligned,
  5    15     2 data_field (14) bit (36) aligned,
  5    16     2 type_word aligned like config_card_type_word;
  5    17 
  5    18 dcl 1 config_card_type_word aligned based,
  5    19     2 field_type (14) bit (2) unaligned,
  5    20     2 pad1 bit (4) unaligned,
  5    21     2 n_fields fixed bin (4) unsigned unaligned;
  5    22 
  5    23 dcl (CONFIG_DECIMAL_TYPE	init ("11"b),
  5    24      CONFIG_OCTAL_TYPE	init ("00"b),
  5    25      CONFIG_SINGLE_CHAR_TYPE	init ("01"b),
  5    26      CONFIG_STRING_TYPE	init ("10"b)) bit (2) aligned static options (constant);
  5    27 
  5    28 dcl  ZERO_CARD_WORD char (4) aligned internal static options (constant) init ("    ");
  5    29 dcl  FREE_CARD_WORD char (4) aligned internal static options (constant) init ("ÿÿÿÿ");
  5    30 
  5    31 dcl  VALID_CARD_WORD_CHARACTERS char (38) internal static options (constant) init
  5    32     ("abcdefghijklmnopqrstuvwxyz0123456789_.");		/* lowercase letters, digits, period and underscore */
  5    33 
  5    34 dcl  EMPTY_FIELD bit (36) aligned internal static options (constant) init ("777777777777"b3);
  5    35 
  5    36 /* END INCLUDE FILE config_deck.incl.pl1 */
      391 
      392 	data_left = syserr_msg.data_size;
      393 	cardp = addr (syserr_msg.data);
      394 	do while (data_left > 0);
      395 	     call ioa_$rsnpnnl ("^a", work, (0), config_card.word);
      396 	     do field_no = 1 to config_card.type_word.n_fields by 1;
      397 		if config_card.type_word.field_type (field_no) = CONFIG_STRING_TYPE
      398 		then call ioa_$rsnpnnl ("^a  ^a", work, (0), work,
      399 			addr (config_card.data_field (field_no)) -> config_card_field_in_ascii);
      400 		else if config_card.type_word.field_type (field_no) = CONFIG_OCTAL_TYPE
      401 		then call ioa_$rsnpnnl ("^a  ^o", work, (0), work, fixed (config_card.data_field (field_no)));
      402 		else if config_card.type_word.field_type (field_no) = CONFIG_DECIMAL_TYPE
      403 		then call ioa_$rsnpnnl ("^a  ^d.", work, (0), work, fixed (config_card.data_field (field_no)));
      404 		else if config_card.type_word.field_type (field_no) = CONFIG_SINGLE_CHAR_TYPE
      405 		then call ioa_$rsnpnnl ("^a  ^a", work, (0), work,
      406 			substr ("abcdefgh", fixed (config_card.data_field (field_no)), 1));
      407 		else ;
      408 	     end;
      409 	     call put;
      410 	     substr (rest, 1, length (work)) = work;
      411 	     moved = moved + length (work);
      412 	     data_left = data_left - size (config_card);
      413 	     cardp = addrel (cardp, size (config_card));
      414 	end;
      415 	call put;
      416      end edit_config;
      417 
      418 /* Procedure to edit an ioi syserr message */
      419 
      420 edit_ioi: proc;
      421 
      422 dcl  edit_detail bit (1) init ("0"b);
      423 dcl  detailed_status_length fixed bin;
      424 dcl  i fixed bin;
      425 dcl  dtstat (detailed_status_length) bit (8) unal based (addr (io_msg.detailed_status));
      426 
  6     1 /* Begin include file ..... io_syserr_msg.incl.pl1 */
  6     2 
  6     3 /* Created October 1975 by Larry Johnson */
  6     4 /* Modified 11/11/76 by Noel I. Morris */
  6     5 /* Modified November 1979 by Larry Johnson for detailed status */
  6     6 /* Modified February 1981 by Chris Jones to use channel names */
  6     7 
  6     8 /* This include file defines the format of the syserr message generated for I/O errors. */
  6     9 /* This message is also defined (size and type) by the "io_msg" and "io_msg_detail"
  6    10*   constants in syserr_binary_def.incl.pl1 */
  6    11 
  6    12 dcl  io_msgp ptr;					/* Pointer to syserr message structure */
  6    13 
  6    14 dcl  1 io_msg aligned based (io_msgp),
  6    15        (
  6    16        2 level bit (3),				/* Level of interrupt being logged */
  6    17        2 fill1 bit (9),
  6    18        2 device bit (6),				/* Device which caused error */
  6    19        2 time_out bit (1),				/* Set if error caused by channel timeout */
  6    20        2 type bit (2),				/* Type of last DCW */
  6    21        2 command bit (6),				/* Command being executed by device */
  6    22        2 fill2 bit (3),
  6    23        2 count bit (6)
  6    24        ) unal,					/* Count of message repetitions */
  6    25        2 channel char (8),				/* Channel over which interrupt came */
  6    26        2 status bit (36),				/* First word of IOM status */
  6    27        2 devname char (4),				/* Device name */
  6    28        2 detailed_status bit (216) unaligned;               /* Optional detailed device status */
  6    29 
  6    30 /* End include file ..... io_syserr_msg.incl.pl1 */
      427 
      428 
      429 edit_ioi_join: io_msgp = addr (syserr_msg.data);
      430 	call ioa_$rsnpnnl ("channel=^a device=^2.3b", work, (0),
      431 	     io_msg.channel, io_msg.device);
      432 	if io_msg.time_out then work = work || "  timeout";
      433 	else do;
      434 	     call ioa_$rsnpnnl ("  status=^w", work2, (0), io_msg.status);
      435 	     work = work || work2;
      436 	end;
      437 
      438 	if io_msg.count ^= "0"b then do;
      439 	     call ioa_$rsnpnnl (" (^d times)", work2, (0), bin (io_msg.count, 6) + 1);
      440 	     work = work || work2;
      441 	end;
      442 
      443 	if room < length (work) then do;		/* If terminal too short for this message */
      444 	     call edit_std;
      445 	     return;
      446 	end;
      447 
      448 	if length (work) > restl then			/* If it won't fit on current line */
      449 	     call put;				/* Dump line */
      450 
      451 	substr (rest, 1, length (work)) = work;		/* Copy line */
      452 	moved = moved + length (work);
      453 
      454 	if edit_detail then do;
      455 	     call put;
      456 	     detailed_status_length = 27;
      457 	     do i = detailed_status_length to 1 by -1 while (dtstat (i) = "0"b);
      458 	     end;
      459 	     detailed_status_length = max (i, 1);
      460 	     call ioa_$rsnpnnl ("Detailed status:^( ^.4b^)", work, (0), dtstat);
      461 	     substr (rest, 1, length (work)) = work;	/* Copy line */
      462 	     moved = moved + length (work);
      463 
      464 	end;
      465 
      466 	return;
      467 
      468 edit_ioi_detail: entry;
      469 
      470 	edit_detail = "1"b;
      471 	go to edit_ioi_join;
      472 
      473      end edit_ioi;
      474 
      475 /* Edit message from a fault */
      476 
      477 edit_fault: proc;
      478 
      479 dcl  fault_msgp ptr;
      480 dcl  1 fault_msg aligned based (fault_msgp),
      481        2 mcx like mc aligned,
      482        2 hist_reg (128) bit (36) aligned;
      483 
      484 	fault_msgp = addr (syserr_msg.data);
      485 	scup = addr (mcx.scu);
      486 	call edit_text ("Pointer Registers:");
      487 	wordp = addr (fault_msg.prs);
      488 	nwords = 16;
      489 	call edit_words;
      490 	call ioa_$rsnpnnl ("x0-7:^( ^.3b^)", rest, moved, fault_msg.x);
      491 	call put;
      492 	call ioa_$rsnpnnl ("a: ^.3b q: ^.3b e: ^.3b t: ^.3b ralr: ^.3b", rest, moved,
      493 	     fault_msg.a, fault_msg.q, "0"b || fault_msg.e,
      494 	     fault_msg.t, fault_msg.ralr);
      495 	call put;
      496 	call edit_scu (addr (fault_msg.scu));
      497 	call ioa_$rsnpnnl ("Fault Register: ^.3b", rest, moved, fault_msg.fault_reg);
      498 	call put;
      499 	call edit_text ("EIS Info:");
      500 	nwords = 8;
      501 	wordp = addr (fault_msg.eis_info);
      502 	call edit_words;
      503 	call edit_hist (addr (fault_msg.hist_reg), (scu.pad2));
      504 	return;
      505 
      506      end edit_fault;
      507 
      508 edit_scu: proc (p);
      509 
      510 dcl  p ptr;
      511 
      512 	call edit_text ("SCU data:");
      513 	nwords = 8;
      514 	wordp = p;
      515 	call edit_words;
      516 	return;
      517 
      518      end edit_scu;
      519 
      520 edit_hist: proc (p, cpu_type);
      521 
      522 dcl  p ptr;
      523 dcl  cpu_type bit (9);
      524 
      525 	if cpu_type = "0"b then
      526 	     call edit_text ("OU History Reg Data:");
      527 	else call edit_text ("DU/OU History Reg Data:");
      528 	nwords = 32;
      529 	wordp = p;
      530 	call edit_words;
      531 	call edit_text ("CU History Reg Data:");
      532 	wordp = addrel (p, 32);
      533 	call edit_words;
      534 	if cpu_type = "0"b then
      535 	     call edit_text ("DU History Reg Data:");
      536 	else call edit_text ("APU#2 History Reg Data:");
      537 	wordp = addrel (p, 64);
      538 	call edit_words;
      539 	if cpu_type = "0"b then
      540 	     call edit_text ("APU History Reg Data:");
      541 	else call edit_text ("APU#1 History Reg Data:");
      542 	wordp = addrel (p, 96);
      543 	call edit_words;
      544 	return;
      545 
      546      end edit_hist;
      547 
      548 edit_text: proc (msg);
      549 
      550 dcl  msg char (*);
      551 
      552 	if moved > 0 then call put;
      553 	substr (rest, 1, length (msg)) = msg;
      554 	moved = length (msg);
      555 	call put;
      556 	return;
      557 
      558      end edit_text;
      559 
      560 /* Edit old style parity message */
      561 
      562 edit_old_parity: proc;
      563 
      564 dcl  parity_msgp ptr;
      565 
      566 dcl  1 parity_msg aligned based (parity_msgp),
      567        2 scu (8) bit (36) aligned,
      568        2 inst_addr fixed bin (18),
      569        2 inst (3) bit (36) aligned,
      570        2 abs_tsr_valid bit (1) unal,
      571        2 tsr_repeat bit (1) unal,
      572        2 fill1 bit (9) unal,
      573        2 tsr_loc fixed bin (24) unal,
      574        2 tsr_data bit (36) unal,
      575        2 abs_psr_valid bit (1) unal,
      576        2 psr_repeat bit (1) unal,
      577        2 fill2 bit (9) unal,
      578        2 psr_loc fixed bin (24) unal,
      579        2 psr_data bit (36) aligned;
      580 
      581 	parity_msgp = addr (syserr_msg.data);
      582 	if moved > 0 then call put;
      583 	call ioa_$rsnpnnl ("inst at ^o: ^w ^w ^w", rest, moved, parity_msg.inst_addr, parity_msg.inst);
      584 	call put;
      585 	call edit_scu (addr (parity_msg.scu));
      586 	call ioa_$rsnpnnl ("PSR: ^o", work, 0, parity_msg.psr_loc);
      587 	if parity_msg.abs_psr_valid then do;
      588 	     call ioa_$rsnpnnl (" (^w)", work2, 0, parity_msg.psr_data);
      589 	     work = work || work2;
      590 	     work = work || " Retry ";
      591 	     if parity_msg.psr_repeat then work = work || "succeeded.";
      592 	     else work = work || "failed.";
      593 	end;
      594 	else work = work || " invalid absaddr.";
      595 	rest = work;
      596 	moved = length (work);
      597 	call put;
      598 	call ioa_$rsnpnnl ("TSR: ^o", work, 0, parity_msg.tsr_loc);
      599 	if parity_msg.abs_tsr_valid then do;
      600 	     call ioa_$rsnpnnl (" (^w)", work2, 0, parity_msg.tsr_data);
      601 	     work = work || work2;
      602 	     work = work || " Retry ";
      603 	     if parity_msg.tsr_repeat then work = work || "succeeded.";
      604 	     else work = work || "failed.";
      605 	end;
      606 	else work = work || " invalid absaddr.";
      607 	rest = work;
      608 	moved = length (work);
      609 	call put;
      610 	return;
      611 
      612      end edit_old_parity;
      613 
      614 /* Edit old style op-not-complete fault */
      615 
      616 edit_old_onc: proc;
      617 
      618 dcl  onc_msgp ptr;
      619 dcl  cpu_type bit (9);
      620 dcl  1 onc_msg aligned based (onc_msgp),
      621        2 scu (8) bit (36),
      622        2 inst_addr fixed bin (18),
      623        2 inst (3) bit (36) aligned,
      624        2 hist_reg (128) bit (36) aligned;
      625 
      626 	onc_msgp = addr (syserr_msg.data);
      627 	cpu_type = substr (scu (3), 19, 9);
      628 	if moved > 0 then call put;
      629 	call ioa_$rsnpnnl ("inst at ^o: ^w ^w ^w", rest, moved, onc_msg.inst_addr, onc_msg.inst);
      630 	call put;
      631 	call edit_scu (addr (onc_msg.scu));
      632 	call edit_hist (addr (onc_msg.hist_reg), cpu_type);
      633 	return;
      634 
      635      end edit_old_onc;
      636 
      637 /* Edit old style startup and shutdown faults */
      638 
      639 edit_old_startup: proc;
      640 
      641 dcl  startup_msgp ptr;
      642 dcl  1 startup_msg aligned based (startup_msgp),
      643        2 scu (8) bit (36) aligned;
      644 
      645 	startup_msgp = addr (syserr_msg.data);
      646 	call edit_scu (addr (startup_msg.scu));
      647 	return;
      648 
      649      end edit_old_startup;
      650 
      651 /* Edit message from mos memory EDAC error */
      652 
      653 edit_mos_memory: proc;
      654 
      655 dcl  edit_mos_rscr_ entry (ptr, char (*) var);
      656 
      657 	call edit_mos_rscr_ (addr (syserr_msg.data), work);
      658 	if room < length (work) then do;
      659 	     call edit_std;
      660 	     return;
      661 	end;
      662 	if length (work) > restl then call put;
      663 	substr (rest, 1, length (work)) = work;
      664 	moved = moved + length (work);
      665 	return;
      666 
      667      end edit_mos_memory;
      668 
      669 /* Procedure called to print errors by interpreting status from syserr_log_util_$open */
      670 
      671 open_err: entry (open_status, caller, code);
      672 
      673 dcl  open_status bit (36) aligned;			/* Set by syserr_log_util_$open */
      674 dcl  caller char (*);				/* Name of caller for com_err_ */
      675 dcl  msg_time fixed bin (71);				/* Time of a syserr message */
      676 dcl  msg_seq fixed bin (35);				/* Sequence number */
      677 dcl  sw fixed bin;
      678 dcl  code2 fixed bin (35);
      679 
      680 	if substr (open_status, 1, 2) = "11"b then do;	/* If all access needed is present */
      681 	     code = 0;				/* No error */
      682 	     return;
      683 	end;
      684 
      685 	if substr (open_status, 1, 2) = "00"b then do;	/* If no access */
      686 	     call com_err_ (code, caller, "Unable to open syserr_log");
      687 	     return;
      688 	end;
      689 
      690 	sw = 0;					/* An ioa_ switch */
      691 
      692 	if substr (open_status, 1, 2) = "01"b then do;	/* No access to current log */
      693 	     call syserr_log_util_$search (-1, msg_time, msg_seq, code2); /* Get time of last message */
      694 	     if code2 = 0 then do;			/* It workd */
      695 		sw = 1;
      696 		call date_time_ (msg_time, cur_time);
      697 	     end;
      698 	     call com_err_ (code, caller, "Current log not available. ^v(Permanent log ends ^a.^)",
      699 		sw, cur_time);
      700 	     code = 0;
      701 	     return;
      702 	end;
      703 
      704 	else do;					/* No access to permanent log */
      705 	     call syserr_log_util_$search (0, msg_time, msg_seq, code2); /* Read oldest message */
      706 	     if code2 = 0 then do;
      707 		sw = 1;
      708 		call date_time_ (msg_time, cur_time);
      709 	     end;
      710 	     call com_err_ (code, caller, "Permanent log not available. ^v(Current log starts ^a.^)",
      711 		sw, cur_time);
      712 	     code = 0;
      713 	     return;
      714 	end;
      715 
      716      end print_syserr_msg_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/13/85  1100.2  print_syserr_msg_.pl1             >spec>on>41-11>print_syserr_msg_.pl1
79           1    06/22/76  1355.6  print_syserr_msg_args.incl.pl1    >ldd>include>print_syserr_msg_args.incl.pl1
95           2    08/18/77  1118.1  syserr_message.incl.pl1           >ldd>include>syserr_message.incl.pl1
96           3    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
235          4    03/12/85  1556.6  syserr_binary_def.incl.pl1        >spec>on>41-11>syserr_binary_def.incl.pl1
391          5    05/08/81  1853.6  config_deck.incl.pl1              >ldd>include>config_deck.incl.pl1
427          6    01/18/85  0953.2  io_syserr_msg.incl.pl1            >ldd>include>io_syserr_msg.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CONFIG_DECIMAL_TYPE                    constant        bit(2)                   initial dcl 5-23 ref 402
CONFIG_OCTAL_TYPE                      constant        bit(2)                   initial dcl 5-23 ref 400
CONFIG_SINGLE_CHAR_TYPE                constant        bit(2)                   initial dcl 5-23 ref 404
CONFIG_STRING_TYPE                     constant        bit(2)                   initial dcl 5-23 ref 397
SB_config_deck                         constant        fixed bin(17,0)          initial dcl 4-47 ref 280
SB_end_of_table                        constant        fixed bin(17,0)          initial dcl 4-47 ref 281
SB_hw_fault                            constant        fixed bin(17,0)          initial dcl 4-47 ref 278
SB_io_err                              constant        fixed bin(17,0)          initial dcl 4-47 ref 275
SB_io_err_detail                       constant        fixed bin(17,0)          initial dcl 4-47 ref 276
SB_mos_err                             constant        fixed bin(17,0)          initial dcl 4-47 ref 274
SB_ocdcm_err                           constant        fixed bin(17,0)          initial dcl 4-47 ref 277
SB_verify_lock                         constant        fixed bin(17,0)          initial dcl 4-47 ref 279
a                        24            based           bit(36)                  level 4 packed unaligned dcl 480 set ref 492*
abs_psr_valid            16            based           bit(1)                   level 2 packed unaligned dcl 566 ref 587
abs_tsr_valid            14            based           bit(1)                   level 2 packed unaligned dcl 566 ref 599
addr                                                   builtin function         dcl 93 ref 103 104 113 113 215 215 220 220 263 263
                                                                                  283 283 287 287 342 375 393 397 429 457 460 484
                                                                                  485 487 496 496 501 503 503 581 585 585 626 631
                                                                                  631 632 632 645 646 646 657 657
addrel                                                 builtin function         dcl 93 ref 413 532 537 542
aline                                  based           char(1)                  array unaligned dcl 38 set ref 220 263
argp                                   parameter       pointer                  dcl 1-8 ref 21 100 104 113 116 126 139 139 142 142
                                                                                  144 144 152 152 165 165 170 170 174 174 180 180
                                                                                  187 215 266 302 302 302 302
arrayl                          000534 automatic       fixed bin(17,0)          dcl 43 set ref 376* 377
arrayp                          000536 automatic       pointer                  dcl 44 set ref 375* 377
based_array                            based           bit(36)                  array dcl 45 set ref 377*
bin                                                    builtin function         dcl 93 ref 439
bin_mode                        001203 automatic       bit(1)                   initial unaligned dcl 49 set ref 49* 219 261*
bin_sw                   21            based           bit(1)                   level 2 packed unaligned dcl 1-10 ref 187
binary_segmsg_util_             000024 constant        entry                    external dcl 237 ref 283
binary_segmsg_util_$interpret_pvname
                                000026 constant        entry                    external dcl 238 ref 287
bl1                       1     001212 automatic       char(2)                  level 2 packed unaligned dcl 65 set ref 108*
bl2                       3(18) 001212 automatic       char(2)                  level 2 packed unaligned dcl 65 set ref 110*
bl3                       4(27) 001212 automatic       char(1)                  level 2 packed unaligned dcl 65 set ref 112*
caller                                 parameter       char                     unaligned dcl 674 set ref 671 686* 698* 710*
cardp                           001402 automatic       pointer                  dcl 5-3 set ref 393* 395 396 397 397 400 400 400 402
                                                                                  402 402 404 404 404 412 413* 413 413
channel                   1            based           char(8)                  level 2 dcl 6-14 set ref 430*
code                      3            based           fixed bin(11,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 2-9 in procedure "print_syserr_msg_" ref 202
code                                   parameter       fixed bin(35,0)          dcl 24 in procedure "print_syserr_msg_" set ref 21
                                                                                  113* 114 129* 191* 215* 216 671 681* 686* 698*
                                                                                  700* 710* 712*
code2                           001230 automatic       fixed bin(35,0)          dcl 678 set ref 693* 694 705* 706
code_edit                       001202 automatic       picture(4)               unaligned dcl 48 set ref 202* 203
com_err_                        000020 constant        entry                    external dcl 89 ref 686 698 710
config_card                            based           structure                level 1 dcl 5-13 set ref 412 413
config_card_field_in_ascii             based           char(4)                  unaligned dcl 390 set ref 397*
config_card_type_word                  based           structure                level 1 dcl 5-18
count                     0(30)        based           bit(6)                   level 2 packed unaligned dcl 6-14 ref 438 439
cpu_type                               parameter       bit(9)                   unaligned dcl 523 in procedure "edit_hist" ref 520
                                                                                  525 534 539
cpu_type                        001476 automatic       bit(9)                   unaligned dcl 619 in procedure "edit_old_onc" set
                                                                                  ref 627* 632*
ctp                             000100 automatic       pointer                  dcl 25 set ref 103* 105 107 109 111 200
cur_time                        000104 automatic       char(24)                 unaligned dcl 26 set ref 102* 103 116 696* 698* 708*
                                                                                  710*
data                                   based           bit(36)                  array level 2 dcl 2-9 set ref 283 283 287 287 342
                                                                                  393 429 484 581 626 645 657 657
data_code                 4            based           fixed bin(11,0)          level 2 packed unaligned dcl 2-9 ref 272 273
data_field                1            based           bit(36)                  array level 2 dcl 5-13 set ref 397 400 400 402 402
                                                                                  404 404
data_left                       001400 automatic       fixed bin(17,0)          dcl 388 set ref 392* 394 412* 412
data_size                 3(24)        based           fixed bin(11,0)          level 2 packed unaligned dcl 2-9 ref 187 341 392
date                                   based           char(8)                  level 2 in structure "tm" packed unaligned dcl 56
                                                                                  in procedure "print_syserr_msg_" ref 105 105 109
date                      1(18) 001212 automatic       char(8)                  level 2 in structure "dtl" packed unaligned dcl 65
                                                                                  in procedure "print_syserr_msg_" set ref 109*
date_time_                      000010 constant        entry                    external dcl 84 ref 102 696 708
day                       5(09)        based           char(3)                  level 2 in structure "tm" packed unaligned dcl 56
                                                                                  in procedure "print_syserr_msg_" ref 107
day                       0(09) 001212 automatic       char(3)                  level 2 in structure "dtl" packed unaligned dcl 65
                                                                                  in procedure "print_syserr_msg_" set ref 107*
detailed_status           5            based           bit(216)                 level 2 packed unaligned dcl 6-14 set ref 457 460
detailed_status_length          001417 automatic       fixed bin(17,0)          dcl 423 set ref 456* 457 459* 460
device                    0(12)        based           bit(6)                   level 2 packed unaligned dcl 6-14 set ref 430*
divide                                                 builtin function         dcl 93 ref 372
dtl                             001212 automatic       structure                level 1 packed unaligned dcl 65 set ref 113 113 113
                                                                                  113
dtstat                                 based           bit(8)                   array unaligned dcl 425 set ref 457 460*
e                        26            based           bit(8)                   level 4 packed unaligned dcl 480 ref 492
edit_detail                     001416 automatic       bit(1)                   initial unaligned dcl 422 set ref 422* 454 470*
edit_mos_rscr_                  000030 constant        entry                    external dcl 655 ref 657
eis_info                 50            based           bit(36)                  array level 3 packed unaligned dcl 480 set ref 501
error_table_$smallarg           000022 external static fixed bin(35,0)          dcl 91 ref 129
fault_msg                              based           structure                level 1 dcl 480
fault_msgp                      001432 automatic       pointer                  dcl 479 set ref 484* 485 487 490 492 492 492 492 492
                                                                                  496 496 497 501 503 503
fault_reg                45            based           bit(36)                  level 3 packed unaligned dcl 480 set ref 497*
field_no                        001401 automatic       fixed bin(17,0)          dcl 389 set ref 396* 397 397 400 400 400 402 402 402
                                                                                  404 404 404*
field_type               17            based           bit(2)                   array level 3 packed unaligned dcl 5-13 ref 397 400
                                                                                  402 404
first_bin                       001204 automatic       bit(1)                   initial unaligned dcl 50 set ref 50* 207 208* 262*
fl                              000126 automatic       bit(1)                   initial unaligned dcl 36 set ref 36* 189 199 204*
hbound                                                 builtin function         dcl 93 ref 300
hist_reg                 60            based           bit(36)                  array level 2 in structure "fault_msg" dcl 480
                                                                                  in procedure "edit_fault" set ref 503 503
hist_reg                 14            based           bit(36)                  array level 2 in structure "onc_msg" dcl 620
                                                                                  in procedure "edit_old_onc" set ref 632 632
hold_moved                      001205 automatic       fixed bin(17,0)          dcl 51 set ref 209 209 260*
i                               001420 automatic       fixed bin(17,0)          dcl 424 in procedure "edit_ioi" set ref 457* 457*
                                                                                  459
i                               000117 automatic       fixed bin(17,0)          dcl 30 in procedure "print_syserr_msg_" set ref 142*
                                                                                  144 146 150 152* 153 157 158 159 170* 173 179 354*
                                                                                  355 357 363 367* 369* 369 370 372* 372 374 376
i                               001251 automatic       fixed bin(17,0)          dcl 232 in procedure "edit_binary" set ref 288* 289
                                                                                  290 300* 302 302* 310
index                                                  builtin function         dcl 93 ref 142 170 302
inst                     11            based           bit(36)                  array level 2 in structure "onc_msg" dcl 620
                                                                                  in procedure "edit_old_onc" set ref 629*
inst                     11            based           bit(36)                  array level 2 in structure "parity_msg" dcl 566
                                                                                  in procedure "edit_old_parity" set ref 583*
inst_addr                10            based           fixed bin(18,0)          level 2 in structure "parity_msg" dcl 566
                                                                                  in procedure "edit_old_parity" set ref 583*
inst_addr                10            based           fixed bin(18,0)          level 2 in structure "onc_msg" dcl 620 in procedure
                                                                                  "edit_old_onc" set ref 629*
io_msg                                 based           structure                level 1 dcl 6-14
io_msgp                         001422 automatic       pointer                  dcl 6-12 set ref 429* 430 430 432 434 438 439 457
                                                                                  460
ioa_$rsnpnnl                    000012 constant        entry                    external dcl 85 ref 356 377 395 397 400 402 404 430
                                                                                  434 439 460 490 492 497 583 586 588 598 600 629
iocbp                     2            based           pointer                  level 2 dcl 1-10 set ref 113* 215*
iox_$put_chars                  000014 constant        entry                    external dcl 86 ref 113 215
j                               000120 automatic       fixed bin(17,0)          dcl 30 set ref 367* 368 370* 374* 374* 375 376*
length                                                 builtin function         dcl 93 ref 113 113 126 139 144 288 290 302 302 410
                                                                                  411 443 448 451 452 461 462 553 554 596 608 658
                                                                                  662 663 664
line                            000127 automatic       char(1024)               unaligned dcl 37 set ref 121* 126 165* 174* 180*
                                                                                  200* 201* 203* 214* 215 215 217* 220 263 290
line_length                     000124 automatic       fixed bin(17,0)          dcl 34 set ref 126* 127 264
linelen                  12            based           fixed bin(17,0)          level 2 dcl 1-10 ref 126
max                                                    builtin function         dcl 93 ref 124 459
mc                                     based           structure                level 1 dcl 3-12
mcx                                    based           structure                level 2 dcl 480
min                                                    builtin function         dcl 93 ref 126 290 376
moved                           000125 automatic       fixed bin(21,0)          dcl 35 set ref 122* 162 166* 175* 181* 189 209 209*
                                                                                  209 213* 213 214 215* 218* 258 259 260 290* 357*
                                                                                  357 362 377* 411* 411 452* 452 462* 462 490* 492*
                                                                                  497* 552 554* 582 583* 596* 608* 628 629* 664* 664
msg                                    parameter       char                     unaligned dcl 550 ref 548 553 553 554
msg_seq                         001226 automatic       fixed bin(35,0)          dcl 676 set ref 693* 705*
msg_time                        001224 automatic       fixed bin(71,0)          dcl 675 set ref 693* 696* 705* 708*
msgp                                   based           pointer                  level 2 dcl 1-10 ref 100
n_fields                 17(32)        based           fixed bin(4,0)           level 3 packed unsigned unaligned dcl 5-13 ref 396
newline                                constant        char(1)                  initial unaligned dcl 76 ref 106 142 214
next                            000527 automatic       fixed bin(17,0)          dcl 39 set ref 258* 259* 263 264
nl1                             001212 automatic       char(1)                  level 2 packed unaligned dcl 65 set ref 106*
nl2                       5     001212 automatic       char(1)                  level 2 packed unaligned dcl 65 set ref 106*
nwords                          001206 automatic       fixed bin(17,0)          dcl 52 set ref 341* 354 356 374 376 488* 500* 513*
                                                                                  528*
octal_sw                 21(01)        based           bit(1)                   level 2 packed unaligned dcl 1-10 ref 266
onc_msg                                based           structure                level 1 dcl 620
onc_msgp                        001474 automatic       pointer                  dcl 618 set ref 626* 627 629 629 631 631 632 632
open_status                            parameter       bit(36)                  dcl 673 ref 671 680 685 692
p                                      parameter       pointer                  dcl 522 in procedure "edit_hist" ref 520 529 532 537
                                                                                  542
p                                      parameter       pointer                  dcl 510 in procedure "edit_scu" ref 508 514
pad2                      2(18)        based           bit(9)                   level 2 packed unaligned dcl 3-56 ref 503
parg                                   based           structure                level 1 dcl 1-10
parity_msg                             based           structure                level 1 dcl 566
parity_msgp                     001464 automatic       pointer                  dcl 564 set ref 581* 583 583 585 585 586 587 588 591
                                                                                  598 599 600 603
prev_time                13            based           char(24)                 level 2 dcl 1-10 set ref 104 116*
print_data                             based           char                     unaligned dcl 82 ref 139 142 144 152 165 170 174 180
printl                   11            based           fixed bin(17,0)          level 2 dcl 1-10 ref 139 142 144 152 165 170 174 180
printp                    6            based           pointer                  level 2 dcl 1-10 ref 139 142 144 152 165 170 174 180
prs                                    based           pointer                  array level 3 dcl 480 set ref 487
psr_data                 17            based           bit(36)                  level 2 dcl 566 set ref 588*
psr_loc                  16(11)        based           fixed bin(24,0)          level 2 packed unaligned dcl 566 set ref 586*
psr_repeat               16(01)        based           bit(1)                   level 2 packed unaligned dcl 566 ref 591
ptp                             000102 automatic       pointer                  dcl 25 set ref 104* 105
q                        25            based           bit(36)                  level 4 packed unaligned dcl 480 set ref 492*
ralr                     27(33)        based           bit(3)                   level 4 packed unaligned dcl 480 set ref 492*
regs                     20            based           structure                level 3 packed unaligned dcl 480
rest                                   based           char                     unaligned dcl 42 set ref 291* 356* 377* 410* 451*
                                                                                  461* 490* 492* 497* 553* 583* 595* 607* 629* 663*
restl                           000530 automatic       fixed bin(17,0)          dcl 40 set ref 221* 264* 289 291 355 356 356 363 377
                                                                                  377 410 448 451 461 490 490 492 492 497 497 553
                                                                                  583 583 595 607 629 629 662 663
restp                           000532 automatic       pointer                  dcl 41 set ref 220* 263* 291 356 377 410 451 461 490
                                                                                  492 497 553 583 595 607 629 663
reverse                                                builtin function         dcl 93 ref 170
room                            000122 automatic       fixed bin(17,0)          dcl 32 set ref 127* 128 164 170 174 174 175 176 179
                                                                                  221 368 443 658
rtrim                                                  builtin function         dcl 93 ref 288
s                               001250 automatic       fixed bin(17,0)          dcl 231 set ref 273* 274 275 276 277 278 279 280 281
                                                                                  281 282 286
scu                                    based           structure                level 1 dcl 3-56 in procedure "print_syserr_msg_"
scu                                    based           bit(36)                  array level 2 in structure "parity_msg" dcl 566
                                                                                  in procedure "edit_old_parity" set ref 585 585
scu                                    based           bit(36)                  array level 2 in structure "startup_msg" dcl 642
                                                                                  in procedure "edit_old_startup" set ref 646 646
scu                                    based           bit(36)                  array level 2 in structure "onc_msg" dcl 620
                                                                                  in procedure "edit_old_onc" set ref 627 631 631
scu                      30            based           bit(36)                  array level 3 in structure "fault_msg" packed
                                                                                  unaligned dcl 480 in procedure "edit_fault" set
                                                                                  ref 485 496 496
scup                            001222 automatic       pointer                  dcl 3-54 set ref 485* 503
seq_edit                        000112 automatic       picture(12)              unaligned dcl 27 set ref 123* 124 201
seq_num                                based           fixed bin(35,0)          level 2 dcl 2-9 ref 123
seq_sz                          000115 automatic       fixed bin(17,0)          dcl 28 set ref 124* 125 201 201 203
special_chars                   000017 constant        varying char(32)         initial array dcl 240 ref 300 302 302
start                           000123 automatic       fixed bin(17,0)          dcl 33 set ref 125* 127 165 174 180 213 220 258 259
startup_msg                            based           structure                level 1 dcl 642
startup_msgp                    001506 automatic       pointer                  dcl 641 set ref 645* 646 646
status                    3            based           bit(36)                  level 2 dcl 6-14 set ref 434*
string                                                 builtin function         dcl 93 ref 113 113
substr                                                 builtin function         dcl 93 set ref 142 152 165* 165 170 174* 174 180*
                                                                                  180 200* 201* 201 203* 203 214* 282 286 404 404
                                                                                  410* 451* 461* 553* 627 663* 680 685 692
sw                              001227 automatic       fixed bin(17,0)          dcl 677 set ref 690* 695* 698* 707* 710*
syserr_binary_seg_damage_mask   004657 constant        bit(36)                  initial unaligned dcl 4-140 ref 282
syserr_binary_vol_damage_mask   004656 constant        bit(36)                  initial unaligned dcl 4-141 ref 286
syserr_log_util_$search         000016 constant        entry                    external dcl 87 ref 693 705
syserr_msg                             based           structure                level 1 dcl 2-9
syserr_msgp                     001220 automatic       pointer                  dcl 2-7 set ref 100* 102 123 187 202 272 273 283 283
                                                                                  287 287 341 342 392 393 429 484 581 626 645 657
                                                                                  657
t                        27            based           bit(27)                  level 4 packed unaligned dcl 480 set ref 492*
tbuf                            001252 automatic       char(260)                unaligned dcl 233 set ref 283* 287* 288 291
text_data                              based           char                     unaligned dcl 81 ref 302 302
text_len                  3(12)        based           fixed bin(11,0)          level 2 packed unaligned dcl 2-9 ref 283 283 287 287
                                                                                  342 393 429 484 581 626 645 657 657
textl                    10            based           fixed bin(17,0)          level 2 dcl 1-10 ref 302 302
textp                     4            based           pointer                  level 2 dcl 1-10 ref 302 302
time                      2(18)        based           char(6)                  level 2 in structure "tm" packed unaligned dcl 56
                                                                                  in procedure "print_syserr_msg_" ref 200
time                      1            based           fixed bin(71,0)          level 2 in structure "syserr_msg" packed unaligned
                                                                                  dcl 2-9 in procedure "print_syserr_msg_" ref 102
time_out                  0(18)        based           bit(1)                   level 2 packed unaligned dcl 6-14 ref 432
tlen                            000121 automatic       fixed bin(17,0)          dcl 31 set ref 144* 150* 152 154 159* 159 164 165
                                                                                  165 166 167 179* 180 180 181 182
tm                                     based           structure                level 1 packed unaligned dcl 56
tpos                            000116 automatic       fixed bin(17,0)          dcl 29 set ref 133* 139 142 144 147* 147 152 154*
                                                                                  154 158* 158 165 167* 167 170 174 176* 176 180
                                                                                  182* 182
tsr_data                 15            based           bit(36)                  level 2 packed unaligned dcl 566 set ref 600*
tsr_loc                  14(11)        based           fixed bin(24,0)          level 2 packed unaligned dcl 566 set ref 598*
tsr_repeat               14(01)        based           bit(1)                   level 2 packed unaligned dcl 566 ref 603
type_word                17            based           structure                level 2 dcl 5-13
verify                                                 builtin function         dcl 93 ref 124 152
word                                   based           char(4)                  level 2 dcl 5-13 set ref 395*
wordp                           001210 automatic       pointer                  dcl 53 set ref 342* 356 375 487* 501* 514* 529* 532*
                                                                                  537* 542*
words                                  based           fixed bin(17,0)          array dcl 54 set ref 356* 375
work                            000540 automatic       varying char(1024)       dcl 46 set ref 395* 397* 397* 400* 400* 402* 402*
                                                                                  404* 404* 410 410 411 430* 432* 432 435* 435 440*
                                                                                  440 443 448 451 451 452 460* 461 461 462 586* 589*
                                                                                  589 590* 590 591* 591 592* 592 594* 594 595 596
                                                                                  598* 601* 601 602* 602 603* 603 604* 604 606* 606
                                                                                  607 608 657* 658 662 663 663 664
work2                           001141 automatic       varying char(128)        dcl 47 set ref 434* 435 439* 440 588* 589 600* 601
x                        20            based           bit(18)                  array level 4 packed unaligned dcl 480 set ref 490*
zone                      4(09)        based           char(3)                  level 2 in structure "tm" packed unaligned dcl 56
                                                                                  in procedure "print_syserr_msg_" ref 111
zone                      4     001212 automatic       char(3)                  level 2 in structure "dtl" packed unaligned dcl 65
                                                                                  in procedure "print_syserr_msg_" set ref 111*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
EMPTY_FIELD                            internal static bit(36)                  initial dcl 5-34
FREE_CARD_WORD                         internal static char(4)                  initial dcl 5-29
SBL_access_audit                       internal static fixed bin(17,0)          initial dcl 4-47
SBL_config_deck                        internal static fixed bin(17,0)          initial dcl 4-47
SBL_disk_err                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_end_of_table                       internal static fixed bin(17,0)          initial dcl 4-47
SBL_fnp_poll                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_hw_fault                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_ibm3270_mde                        internal static fixed bin(17,0)          initial dcl 4-47
SBL_io_err                             internal static fixed bin(17,0)          initial dcl 4-47
SBL_io_err_detail                      internal static fixed bin(17,0)          initial dcl 4-47
SBL_mdc_del_uidpath                    internal static fixed bin(17,0)          initial dcl 4-47
SBL_mmdam                              internal static fixed bin(17,0)          initial dcl 4-47
SBL_mos_err                            internal static fixed bin(17,0)          initial dcl 4-47
SBL_mpc_poll                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_ocdcm_err                          internal static fixed bin(17,0)          initial dcl 4-47
SBL_random_segdamage                   internal static fixed bin(17,0)          initial dcl 4-47
SBL_read_nc                            internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_10                          internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_12                          internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_14                          internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_15                          internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_18                          internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_4                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_6                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_7                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_8                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_unused_9                           internal static fixed bin(17,0)          initial dcl 4-47
SBL_verify_lock                        internal static fixed bin(17,0)          initial dcl 4-47
SBL_vtoc_salv_dam                      internal static fixed bin(17,0)          initial dcl 4-47
SBL_vtoce                              internal static fixed bin(17,0)          initial dcl 4-47
SBL_zerpag                             internal static fixed bin(17,0)          initial dcl 4-47
SB_access_audit                        internal static fixed bin(17,0)          initial dcl 4-47
SB_access_audit_data_class             internal static varying char(16)         initial dcl 4-21
SB_char_data_classes                   internal static varying char(16)         initial array dcl 4-89
SB_config_deck_data_class              internal static varying char(16)         initial dcl 4-21
SB_disk_err                            internal static fixed bin(17,0)          initial dcl 4-47
SB_fnp_poll                            internal static fixed bin(17,0)          initial dcl 4-47
SB_fnp_poll_data_class                 internal static varying char(16)         initial dcl 4-21
SB_hwfault_data_class                  internal static varying char(16)         initial dcl 4-21
SB_ibm3270_mde                         internal static fixed bin(17,0)          initial dcl 4-47
SB_ibm3270_mde_data_class              internal static varying char(16)         initial dcl 4-21
SB_io_status_data_class                internal static varying char(16)         initial dcl 4-21
SB_mdc_del_uidpath                     internal static fixed bin(17,0)          initial dcl 4-47
SB_mdc_del_uidpath_data_class          internal static varying char(16)         initial dcl 4-21
SB_mmdam                               internal static fixed bin(17,0)          initial dcl 4-47
SB_mmdam_data_class                    internal static varying char(16)         initial dcl 4-21
SB_mos_data_class                      internal static varying char(16)         initial dcl 4-21
SB_mpc_poll                            internal static fixed bin(17,0)          initial dcl 4-47
SB_mpc_poll_data_class                 internal static varying char(16)         initial dcl 4-21
SB_random_segdamage                    internal static fixed bin(17,0)          initial dcl 4-47
SB_read_nc                             internal static fixed bin(17,0)          initial dcl 4-47
SB_segdamage_data_class                internal static varying char(16)         initial dcl 4-21
SB_unused_10                           internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_12                           internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_14                           internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_15                           internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_18                           internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_4                            internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_6                            internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_7                            internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_8                            internal static fixed bin(17,0)          initial dcl 4-47
SB_unused_9                            internal static fixed bin(17,0)          initial dcl 4-47
SB_voldamage_data_class                internal static varying char(16)         initial dcl 4-21
SB_vtoc_salv_dam                       internal static fixed bin(17,0)          initial dcl 4-47
SB_vtoce                               internal static fixed bin(17,0)          initial dcl 4-47
SB_vtoce_data_class                    internal static varying char(16)         initial dcl 4-21
SB_zerpag                              internal static fixed bin(17,0)          initial dcl 4-47
VALID_CARD_WORD_CHARACTERS             internal static char(38)                 initial unaligned dcl 5-31
ZERO_CARD_WORD                         internal static char(4)                  initial dcl 5-28
abx                                    internal static fixed bin(17,0)          initial dcl 3-42
apx                                    internal static fixed bin(17,0)          initial dcl 3-42
bbx                                    internal static fixed bin(17,0)          initial dcl 3-42
bpx                                    internal static fixed bin(17,0)          initial dcl 3-42
config_deck                            based           structure                level 1 dcl 5-9
config_deck$                           external static fixed bin(17,0)          dcl 5-7
config_max_cards                       automatic       fixed bin(17,0)          dcl 5-5
config_n_cards                         automatic       fixed bin(17,0)          dcl 5-4
configp                                automatic       pointer                  dcl 5-3
display_cpu_error_binary_defs          internal static fixed bin(17,0)          initial array dcl 4-144
lbx                                    internal static fixed bin(17,0)          initial dcl 3-42
lpx                                    internal static fixed bin(17,0)          initial dcl 3-42
mcp                                    automatic       pointer                  dcl 3-10
sbx                                    internal static fixed bin(17,0)          initial dcl 3-42
scux                                   based           structure                level 1 dcl 3-207
spx                                    internal static fixed bin(17,0)          initial dcl 3-42
syserr_binary_address_damage_mask      internal static bit(36)                  initial unaligned dcl 4-142
syserr_binary_mos_mask                 internal static bit(36)                  initial unaligned dcl 4-139

NAMES DECLARED BY EXPLICIT CONTEXT.
all_fits                        002156 constant        label                    dcl 356 ref 363
c                               000000 constant        label                    array(15) dcl 311 ref 310
done                            001164 constant        label                    dcl 187 ref 139
edit_binary                     001616 constant        entry                    internal dcl 229 ref 187
edit_config                     002342 constant        entry                    internal dcl 387 ref 280
edit_fault                      003233 constant        entry                    internal dcl 477 ref 279 323
edit_hist                       003522 constant        entry                    internal dcl 520 ref 503 632
edit_ioi                        002667 constant        entry                    internal dcl 420 ref 275 277 311
edit_ioi_detail                 003226 constant        entry                    internal dcl 468 ref 276
edit_ioi_join                   002671 constant        label                    dcl 429 ref 471
edit_mos_memory                 004503 constant        entry                    internal dcl 653 ref 274 321
edit_old_onc                    004367 constant        entry                    internal dcl 616 ref 313
edit_old_parity                 003722 constant        entry                    internal dcl 562 ref 319
edit_old_startup                004465 constant        entry                    internal dcl 639 ref 315 317
edit_scu                        003500 constant        entry                    internal dcl 508 ref 496 585 631 646
edit_std                        002130 constant        entry                    internal dcl 339 ref 267 295 307 444 659
edit_text                       003673 constant        entry                    internal dcl 548 ref 486 499 512 525 527 531 534 536
                                                                                  539 541
edit_words                      002147 constant        entry                    internal dcl 352 ref 343 489 502 515 530 533 538 543
finish                          001203 constant        label                    dcl 193 ref 216
make_call                       002110 constant        label                    dcl 310 ref 302
open_err                        001210 constant        entry                    external dcl 671
out_tbuf                        002024 constant        label                    dcl 288 ref 284
print_syserr_msg_               000600 constant        entry                    external dcl 21
put                             001472 constant        entry                    internal dcl 197 ref 162 189 289 292 358 362 378 409
                                                                                  415 448 455 491 495 498 552 555 582 584 597 609
                                                                                  628 630 662
scan                            002060 constant        label                    dcl 300 ref 278
top                             001003 constant        label                    dcl 139 ref 148 155 185

NAMES DECLARED BY CONTEXT OR IMPLICATION.
fixed                                                  builtin function         ref 400 400 402 402 404 404
size                                                   builtin function         ref 412 413

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5022        5054    4660        5032
Length      5400    4660        32         310     142           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
print_syserr_msg_                  1264 external procedure  is an external procedure.  
put                                     internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_binary                             internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_std                                internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_words                              internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_config                             internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_ioi                                internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_fault                              internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_scu                                internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_hist                               internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_text                               internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_old_parity                         internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_old_onc                            internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_old_startup                        internal procedure  shares stack frame of external procedure print_syserr_msg_.  
edit_mos_memory                         internal procedure  shares stack frame of external procedure print_syserr_msg_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
print_syserr_msg_        000100 ctp                         print_syserr_msg_
                         000102 ptp                         print_syserr_msg_
                         000104 cur_time                    print_syserr_msg_
                         000112 seq_edit                    print_syserr_msg_
                         000115 seq_sz                      print_syserr_msg_
                         000116 tpos                        print_syserr_msg_
                         000117 i                           print_syserr_msg_
                         000120 j                           print_syserr_msg_
                         000121 tlen                        print_syserr_msg_
                         000122 room                        print_syserr_msg_
                         000123 start                       print_syserr_msg_
                         000124 line_length                 print_syserr_msg_
                         000125 moved                       print_syserr_msg_
                         000126 fl                          print_syserr_msg_
                         000127 line                        print_syserr_msg_
                         000527 next                        print_syserr_msg_
                         000530 restl                       print_syserr_msg_
                         000532 restp                       print_syserr_msg_
                         000534 arrayl                      print_syserr_msg_
                         000536 arrayp                      print_syserr_msg_
                         000540 work                        print_syserr_msg_
                         001141 work2                       print_syserr_msg_
                         001202 code_edit                   print_syserr_msg_
                         001203 bin_mode                    print_syserr_msg_
                         001204 first_bin                   print_syserr_msg_
                         001205 hold_moved                  print_syserr_msg_
                         001206 nwords                      print_syserr_msg_
                         001210 wordp                       print_syserr_msg_
                         001212 dtl                         print_syserr_msg_
                         001220 syserr_msgp                 print_syserr_msg_
                         001222 scup                        print_syserr_msg_
                         001224 msg_time                    print_syserr_msg_
                         001226 msg_seq                     print_syserr_msg_
                         001227 sw                          print_syserr_msg_
                         001230 code2                       print_syserr_msg_
                         001250 s                           edit_binary
                         001251 i                           edit_binary
                         001252 tbuf                        edit_binary
                         001400 data_left                   edit_config
                         001401 field_no                    edit_config
                         001402 cardp                       edit_config
                         001416 edit_detail                 edit_ioi
                         001417 detailed_status_length      edit_ioi
                         001420 i                           edit_ioi
                         001422 io_msgp                     edit_ioi
                         001432 fault_msgp                  edit_fault
                         001464 parity_msgp                 edit_old_parity
                         001474 onc_msgp                    edit_old_onc
                         001476 cpu_type                    edit_old_onc
                         001506 startup_msgp                edit_old_startup

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   call_ext_out        return              shorten_stack       ext_entry
ext_entry_desc      set_cs_eis          index_cs_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
binary_segmsg_util_           binary_segmsg_util_$interpret_pvname                        com_err_
date_time_                    edit_mos_rscr_                ioa_$rsnpnnl                  iox_$put_chars
syserr_log_util_$search

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$smallarg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 000566        49 000570        50 000571        21 000574       100 000611       102 000616       103 000637
    104 000641       105 000646       106 000652       107 000655       108 000660       109 000662       110 000665
    111 000667       112 000672       113 000674       114 000715       116 000717       121 000725       122 000730
    123 000731       124 000741       125 000761       126 000763       127 000770       128 000773       129 000775
    130 001000       133 001001       139 001003       142 001011       144 001030       146 001036       147 001040
    148 001041       150 001042       152 001044       153 001056       154 001057       155 001061       157 001062
    158 001064       159 001067       162 001073       164 001076       165 001101       166 001112       167 001113
    168 001114       170 001115       173 001134       174 001135       175 001143       176 001145       177 001146
    179 001147       180 001152       181 001157       182 001160       185 001163       187 001164       189 001175
    191 001202       193 001203       671 001204       680 001227       681 001235       682 001236       685 001237
    686 001241       687 001266       690 001267       692 001270       693 001272       694 001311       695 001313
    696 001315       698 001332       700 001370       701 001371       705 001372       706 001411       707 001413
    708 001415       710 001432       712 001470       713 001471       197 001472       199 001473       200 001475
    201 001501       202 001515       203 001530       204 001534       207 001535       208 001537       209 001540
    213 001546       214 001550       215 001554       216 001576       217 001600       218 001603       219 001604
    220 001606       221 001613       223 001615       229 001616       258 001617       259 001624       260 001627
    261 001631       262 001633       263 001634       264 001641       266 001645       267 001653       268 001654
    272 001655       273 001662       274 001663       275 001667       276 001673       277 001677       278 001703
    279 001705       280 001711       281 001715       282 001722       283 001727       284 001762       286 001764
    287 001771       288 002024       289 002037       290 002042       291 002047       292 002054       293 002055
    295 002056       297 002057       300 002060       302 002065       305 002104       307 002106       308 002107
    310 002110       311 002112       312 002113       313 002114       314 002115       315 002116       316 002117
    317 002120       318 002121       319 002122       320 002123       321 002124       322 002125       323 002126
    333 002127       339 002130       341 002131       342 002136       343 002145       344 002146       352 002147
    354 002150       355 002154       356 002156       357 002221       358 002223       359 002224       362 002225
    363 002230       367 002233       368 002236       369 002241       370 002244       371 002247       372 002250
    374 002253       375 002261       376 002264       377 002273       378 002335       379 002336       381 002341
    387 002342       392 002343       393 002350       394 002357       395 002362       396 002412       397 002423
    400 002470       402 002532       404 002574       408 002640       409 002642       410 002643       411 002651
    412 002653       413 002655       414 002660       415 002661       416 002662       422 002664       420 002667
    429 002671       430 002701       432 002743       434 002761       435 003014       438 003026       439 003031
    440 003071       443 003103       444 003106       445 003107       448 003110       451 003114       452 003122
    454 003124       455 003126       456 003127       457 003131       458 003143       459 003146       460 003153
    461 003215       462 003223       466 003225       468 003226       470 003230       471 003232       477 003233
    484 003234       485 003244       486 003246       487 003254       488 003256       489 003260       490 003261
    491 003320       492 003321       495 003402       496 003403       497 003410       498 003447       499 003450
    500 003457       501 003461       502 003464       503 003465       504 003477       508 003500       512 003502
    513 003512       514 003514       515 003520       516 003521       520 003522       525 003524       527 003540
    528 003551       529 003553       530 003557       531 003560       532 003571       533 003576       534 003577
    536 003614       537 003625       538 003632       539 003633       541 003653       542 003664       543 003671
    544 003672       548 003673       552 003704       553 003707       554 003716       555 003720       556 003721
    562 003722       581 003723       582 003733       583 003736       584 004001       585 004002       586 004006
    587 004041       588 004045       589 004075       590 004107       591 004121       592 004140       593 004152
    594 004153       595 004165       596 004173       597 004175       598 004176       599 004231       600 004235
    601 004265       602 004277       603 004311       604 004330       605 004342       606 004343       607 004355
    608 004363       609 004365       610 004366       616 004367       626 004370       627 004400       628 004404
    629 004407       630 004452       631 004453       632 004457       633 004464       639 004465       645 004466
    646 004476       647 004502       653 004503       657 004504       658 004531       659 004534       660 004535
    662 004536       663 004542       664 004550       665 004552


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
