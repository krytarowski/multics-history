	COMPILATION LISTING OF SEGMENT crzcpz_dim
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/18/86  1352.9 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 
       13 /****^  HISTORY COMMENTS:
       14*  1) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
       15*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
       16*     Changed to user version constant in rcp_device_info.incl.pl1
       17*                                                   END HISTORY COMMENTS */
       18 
       19 
       20 crzcpz_dim: procedure;
       21 
       22 /* Originally coded by Ammons and Ohlin, June 1971 */
       23 
       24 
       25 /* Modified 8/74 by Noel I. Morris for I/O Interfacer operation. */
       26 /* Modified to combine reader & punch functions, 12/74 by Noel I. Morris	*/
       27 /* Modified by J. C. Whitmore, 6/78, to delay printing messages until blocking */
       28 
       29 
       30 
       31 
       32 dcl  stream_name char (*),				/* Name of current stream */
       33      crzcpz char (*),				/* Name of  DIM  being attached */
       34      device char (*),				/* Name of device being attached */
       35     (mode, new_mode, old_mode) char (*),		/* Device attributes */
       36      iostatus bit (72) aligned,			/* Status */
       37      element_size fixed bin (17),			/* Number of bits in element */
       38      offset fixed bin (17),				/* Offset from wkspptr */
       39      nelem fixed bin (17),				/* Number of elements requested */
       40      nelemt fixed bin (17),				/* Number of elements actually transmitted */
       41      sdb_ptr pointer,				/* Pointer to stream data block */
       42     (xwkspptr, wkspptr) pointer,			/* Pointer to workspace */
       43      dvname char (6);				/* name of device type */
       44 
       45 dcl  error_table_$ionmat ext fixed bin (35),		/* Error code - IOname already attached */
       46      error_table_$no_room_for_dsb ext fixed bin (35),	/* Error code - No room available for dsb */
       47      error_table_$invalid_elsize ext fixed bin (35),	/* Error code - Invalid element size */
       48      error_table_$invalid_read ext fixed bin (35),	/* Error code - Invalid read */
       49      error_table_$invalid_write ext fixed bin (35),	/* Error code - Invalid write */
       50      error_table_$net_timeout ext fixed bin (35),		/* Error code - Connect timed out */
       51      error_table_$no_operation ext fixed bin (35),	/* Error code - io operation not done */
       52      error_table_$undefined_order_request ext fixed bin (35), /* Error code - it is obvious, right? */
       53      error_table_$eof_record ext fixed bin (35);		/* Error code - eof found */
       54 
       55 dcl  crz_status_table_$crz_status_table_ ext;
       56 dcl  cpz_status_table_$cpz_status_table_ ext;
       57 
       58 dcl (addr, addrel, bin, bit, divide, mod, null, rel, substr, unspec) builtin;
       59 
       60 
       61 
       62 dcl 1 sdb aligned based (sdb_ptr),			/* Declare stream data block */
       63     2 outer_module_name char (32) aligned,
       64     2 device_name_list_ptr pointer,
       65     2 device_name,
       66       3 next_device_ptr pointer,
       67       3 name_size fixed bin (17),
       68       3 name char (32) aligned,
       69     2 ev_list aligned,				/* Event list for ipc_ */
       70       3 count fixed bin (17),				/* Event count = Always one */
       71       3 evchan fixed bin (71),			/* Event evchan name */
       72     2 devx fixed bin,				/* Device index returned by IOI */
       73     2 punch bit (1),				/* "0"b => reader; "1"b => punch */
       74     2 rcp_id bit (36),				/* ID for RCP attachment */
       75     2 areap ptr,					/* pointer to sdb allocation area */
       76     2 wsegp ptr,					/* pointer to IOI working segment */
       77     2 stat_tablep ptr,				/* pointer to status analysis table */
       78     2 running bit (1),				/* "1"b if channel running */
       79     2 eof_flag bit (1),				/* EOF recogntion - "1" = on - See order call */
       80     2 iobegin fixed bin (18),				/* index for starting up I/O */
       81     2 iocur fixed bin (18),				/* index for queuing next I/O record */
       82     2 movecur fixed bin (18),				/* index for copying next record */
       83     2 movestop fixed bin (18),			/* index for stopping data copy */
       84     2 term_idcw bit (36),				/* IDCW for stopping channel */
       85     2 io_idcw bit (36),				/* IDCW for reading or punching binary card */
       86     2 wait_flag bit (1) aligned,			/* waiting for special interrupt flag */
       87     2 marker_count fixed bin,				/* counter for setting marker interrupts */
       88     2 error_count fixed bin,				/* count of errors */
       89     2 card_count fixed bin,				/* number of cards read/punched since last reset */
       90     2 last_iom_stat bit (72),				/* last useful status bits reported */
       91     2 print_message bit (1),				/* print the following message before blocking */
       92     2 message char (256) var;				/* last error message not reported */
       93 
       94 dcl  workspace (27) bit (36) based (wkspptr) aligned;	/* Workspace allocated by caller */
       95 
       96 dcl 1 wseg based (wsegp) aligned,			/* working segment for I/O Interfacer */
       97     2 dcwlist (0:33),				/* DCW list */
       98       3 idcw bit (36),				/* Instruction DCW */
       99       3 dcw bit (36),				/* data transfer DCW */
      100     2 tdcw bit (36),				/* TDCW to beginning of list */
      101     2 pad bit (36),
      102     2 buffer (0:33),				/* card image buffer */
      103       3 words (27) bit (36);
      104 
      105 dcl  i fixed bin (17),				/* Do loop position indicator */
      106      iostop fixed bin (18),				/* place to stop queuing I/O */
      107      ionext fixed bin (18),				/* index for terminate IDCW */
      108      rcode fixed bin (35),				/* IOI error code - 0 = OK */
      109      ev_done fixed bin,				/* ipc_: 0 = no event yet, 1 = event occured */
      110      area_ptr pointer,
      111      wksp_max fixed bin (19),				/* max size of IOI workspace buffer */
      112      time_max fixed bin (52),				/* max time for IOI connect to complete */
      113      rcp_state fixed bin,				/* state variable from check_attach */
      114      temp_iom_stat bit (72) aligned,			/* Space to hold iom status on error */
      115      listen_based_area area ((16374)) based (area_ptr);	/* Area in listen_ to allocate sdb */
      116 
      117 dcl  punch_alert_flag bit (18) aligned static options (constant) init ("000000000000000001"b);
      118 dcl  dev_stat_bits bit (72) aligned int static options (constant) /* bits used by analyze_device_stat_ */
      119      init ("377700770000"b3 || (12) "0"b3);
      120 
      121 
      122 dcl  get_system_free_area_ ext entry (ptr),
      123      ioi_$workspace entry (fixed bin, ptr, fixed bin (18), fixed bin (35)),
      124      ioi_$connect entry (fixed bin, fixed bin (18), fixed bin (35)),
      125      ipc_$create_ev_chn ext entry (fixed bin (71), fixed bin (35)),
      126      ipc_$drain_chn ext entry (fixed bin (71), fixed bin (35)),
      127      ipc_$delete_ev_chn ext entry (fixed bin (71), fixed bin (35)),
      128      ipc_$block ext entry (ptr, ptr, fixed bin (35)),
      129      ipc_$read_ev_chn entry (fixed bin (71), fixed bin, ptr, fixed bin (35)),
      130      rcp_$attach entry (char (*), ptr, fixed bin (71), char (*), bit (36) aligned, fixed bin (35)),
      131      rcp_$check_attach entry (bit (36) aligned, ptr, char (*), fixed bin, fixed bin (19), fixed bin (52),
      132      fixed bin, fixed bin (35)),
      133      rcp_$detach entry (bit (36) aligned, bit (*), fixed bin, char (*), fixed bin (35)),
      134      analyze_system_fault_ entry (char (*) aligned, bit (72) aligned),
      135      analyze_device_stat_$rs entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned),
      136      convert_ipc_code_ entry (fixed bin (35)),
      137      com_err_ entry options (variable);
      138 
      139 dcl 1 rcp_info like device_info aligned auto;		/* automatic copy of RCP info structure */
      140 
      141 dcl 1 ipc_message aligned,
      142     2 chname fixed bin (71),				/* Chan over which message arrived */
      143     2 message fixed bin (71),				/* 2-word event message */
      144     2 sender bit (36),				/* Sending process */
      145     2 origin,					/* Origin of event message */
      146       3 devsignal bit (18),				/* 1 = device signal */
      147       3 ring bit (18),				/* Senders ring number */
      148     2 channel_index fixed bin;			/* Index in wait list */
      149 
      150 
      151 /*  */
      152 
  1     1 /*	Begin  include file rcp_device_info.incl.pl1
  1     2**
  1     3**	Created on 01/08/75 by Bill Silver.
  1     4**	This include file defines the RCP device info structure for a general device.
  1     5**/
  1     6 
  1     7 
  1     8 /****^  HISTORY COMMENTS:
  1     9*  1) change(86-06-04,Hartogs), approve(86-06-04,MCR7383),
  1    10*     audit(86-06-05,Coppola), install(86-07-18,MR12.0-1098):
  1    11*     Added DEVICE_INFO_VERSION_1 constant.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 
  1    15 dcl	device_info_ptr	ptr;		/* Pointer to general device info structure. */
  1    16 
  1    17 dcl    1	device_info based(device_info_ptr) aligned,  /* RCP device info structure for any device. */
  1    18 	2  version_num	fixed bin,	/* Version number of this structure. */
  1    19 	2  usage_time	fixed bin,	/* Number of minutes device will/may be used. */
  1    20 	2  wait_time	fixed bin,	/* Number of minutes user will/must wait. */
  1    21 	2  system_flag	bit(1),		/* ON => user wants to be a system process. */
  1    22 	2  device_name	char(8),		/* Device name. */
  1    23 	2  model		fixed bin,	/* Device model number. */
  1    24 	2  qualifiers(4)	fixed bin(35);	/* Qualifying characteristics. */
  1    25 
  1    26 dcl DEVICE_INFO_VERSION_1 fixed bin int static options (constant) init (1);
  1    27 
  1    28 /*	End of include file ... rcp_device_info.incl.pl1	*/
      153 
      154 
  2     1 
  2     2 /* Begin include file ...... status_flags.incl.pl1 */
  2     3 /* created 6/11/75 by Noel I. Morris	*/
  2     4 
  2     5 dcl (backup_flag init ("100000000000000000"b),		/* indicates retry of previous operation */
  2     6      init_flag init ("010000000000000000"b),		/* indicates backup if failure during initiation */
  2     7      report_flag init ("001000000000000000"b),		/* indicates error should be reported */
  2     8      halt_flag init ("000100000000000000"b),		/* indicates error caused device to halt */
  2     9      eurc_no_backup_flag init ("000010000000000000"b))	/* indicates eurc device should ignore backup_flag */
  2    10 	bit (18) aligned static;
  2    11 
  2    12 /* End of include file ...... status_flags.incl.pl1 */
  2    13 
      155 
      156 
      157 /*  */
      158 
  3     1 
  3     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  3     3 /* Last modified 3/24/75 by Noel I. Morris */
  3     4 
  3     5 dcl  isp ptr;					/* pointer to status structure */
  3     6 
  3     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  3     8     2 completion,					/* completion flags */
  3     9      (3 st bit (1),					/* "1"b if status returned */
  3    10       3 er bit (1),					/* "1"b if status indicates error condition */
  3    11       3 run bit (1),				/* "1"b if channel still running */
  3    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  3    13     2 level fixed bin (3),				/* IOM interrupt level */
  3    14     2 offset fixed bin (18),				/* DCW list offset */
  3    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  3    16     2 iom_stat bit (72),				/* IOM status */
  3    17     2 lpw bit (72);					/* LPW residue */
  3    18 
  3    19 dcl  imp ptr;					/* pointer to message structure */
  3    20 
  3    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  3    22    (2 completion like istat.completion,			/* completion flags */
  3    23     2 pad bit (11),
  3    24     2 level bit (3),				/* interrupt level */
  3    25     2 offset bit (18),				/* DCW list offset */
  3    26     2 status bit (36)) unal;				/* first 36 bits of status */
  3    27 
  3    28 /* End of include file ...... ioi_stat.incl.pl1 */
  3    29 
      159 
      160 
      161 
      162 /*  */
      163 
  4     1 
  4     2 /* Begin include file ...... iom_pcw.incl.pl1 */
  4     3 
  4     4 dcl  pcwp ptr;					/* pointer to PCW */
  4     5 
  4     6 dcl 1 pcw based (pcwp) aligned,			/* Peripheral Control Word */
  4     7      (2 command bit (6),				/* device command */
  4     8       2 device bit (6),				/* device code */
  4     9       2 ext bit (6),				/* address extension */
  4    10       2 code bit (3),				/* should be "111"b for PCW */
  4    11       2 mask bit (1),				/* channel mask bit */
  4    12       2 control bit (2),				/* terminate/proceed and marker control bits */
  4    13       2 chan_cmd bit (6),				/* type of I/O operation */
  4    14       2 count bit (6),				/* record count or control character */
  4    15       2 mbz1 bit (3),
  4    16       2 channel bit (6),				/* channel number */
  4    17       2 mbz2 bit (27)) unal;
  4    18 
  4    19 dcl  idcwp ptr;					/* pointer to IDCW */
  4    20 
  4    21 dcl 1 idcw based (idcwp) aligned,			/* Instruction DCW */
  4    22      (2 command bit (6),				/* device command */
  4    23       2 device bit (6),				/* device code */
  4    24       2 ext bit (6),				/* address extension */
  4    25       2 code bit (3),				/* should be "111"b for PCW */
  4    26       2 ext_ctl bit (1),				/* "1"b if address extension to be used */
  4    27       2 control bit (2),				/* terminate/proceed and marker control bits */
  4    28       2 chan_cmd bit (6),				/* type of I/O operation */
  4    29       2 count bit (6)) unal;				/* record count or control character */
  4    30 
  4    31 /* End include file ...... iom_pcw.incl.pl1 */
  4    32 
      164 
      165 
      166 
      167 /*  */
      168 
  5     1 
  5     2 /* Begin include file ...... iom_dcw.incl.pl1 */
  5     3 
  5     4 dcl  dcwp ptr,					/* pointer to DCW */
  5     5      tdcwp ptr;					/* pointer to TDCW */
  5     6 
  5     7 dcl 1 dcw based (dcwp) aligned,			/* Data Control Word */
  5     8      (2 address bit (18),				/* address for data transfer */
  5     9       2 char_pos bit (3),				/* character position */
  5    10       2 m64 bit (1),				/* non-zero for mod 64 address */
  5    11       2 type bit (2),				/* DCW type */
  5    12       2 tally bit (12)) unal;				/* tally for data transfer */
  5    13 
  5    14 dcl 1 tdcw based (tdcwp) aligned,			/* Transfer DCW */
  5    15      (2 address bit (18),				/* address to transfer to */
  5    16       2 mbz1 bit (4),
  5    17       2 type bit (2),				/* should be "10"b for TDCW */
  5    18       2 mbz2 bit (9),
  5    19       2 ec bit (1),					/* non-zero to set LPW AE bit */
  5    20       2 res bit (1),				/* non-zero to restrict further use of IDCW */
  5    21       2 rel bit (1)) unal;				/* non-zero to set relative mode after transfer */
  5    22 
  5    23 /* End of include file ...... iom_dcw.incl.pl1 */
  5    24 
      169 
      170 
  6     1 /* Begin include file ...... prt_order_info.incl.pl1 */
  6     2 /*	Created 3/15/77 by Noel I. Morris	*/
  6     3 
  6     4 dcl  orderp ptr;					/* pointer to order info structure */
  6     5 
  6     6 dcl 1 counts based (orderp) aligned,			/* structure used in "get_count"  order */
  6     7     2 line fixed bin,				/* line number */
  6     8     2 page_length fixed bin,				/* length of page */
  6     9     2 lmarg fixed bin,				/* left margin indentation */
  6    10     2 rmarg fixed bin,				/* line length */
  6    11     2 line_count fixed bin,				/* count of lines printed */
  6    12     2 page_count fixed bin;				/* count of pages printed */
  6    13 
  6    14 dcl 1 position_data based (orderp) aligned,		/* structure for "get_position" & "set_position" orders */
  6    15     2 line_number fixed bin (35),			/* current line on the page */
  6    16     2 page_number fixed bin (35),			/* current page number */
  6    17     2 total_lines fixed bin (35),			/* lines printed since reset */
  6    18     2 total_chars fixed bin (35),			/* chars processed since reset */
  6    19     2 pad(4) fixed bin;				/* for the future */
  6    20 
  6    21 dcl 1 page_labels based (orderp) aligned,		/* structure used in "page_labels" order */
  6    22     2 top_label char (136),				/* label for top of page */
  6    23     2 bottom_label char (136);			/* label for bottom of page */
  6    24 
  6    25 dcl  channel_stops (256) bit (16) based (orderp) unal;	/* structure used in "channel_stops" order */
  6    26 
  6    27 dcl 1 paper_info based (orderp) aligned,		/* structure used in "paper_info" order */
  6    28     2 phys_page_length fixed bin,			/* physical page length */
  6    29     2 phys_line_length fixed bin,			/* physical line length */
  6    30     2 lines_per_inch fixed bin;			/* lines per inch spacing */
  6    31 
  6    32 dcl  ret_error_count fixed bin based (orderp);		/* variable used for "get_error_count" order */
  6    33 
  6    34 /* End of include file ...... prt_order_info.incl.pl1 */
      171 
      172 
      173 
      174 /*  */
      175 
      176 crz_attach: entry (stream_name, crzcpz, device, mode, iostatus, sdb_ptr); /* Attach entry */
      177 cpz_attach: entry (stream_name, crzcpz, device, mode, iostatus, sdb_ptr); /* Attach entry */
      178 
      179 	iostatus = "0"b;				/* Zero iostatus string */
      180 	if sdb_ptr ^= null () then do;		/* Check for multiple attachments */
      181 	     substr (iostatus, 1, 36) = unspec (error_table_$ionmat); /* If multiple attachment return code */
      182 	     go to exit;
      183 	end;					/* End sdb_ptr not null do group */
      184 
      185 	call get_system_free_area_ (area_ptr);		/* Get ptr to area in listen_ before alloc */
      186 	allocate sdb in (listen_based_area) set (sdb_ptr); /* Create stream data block */
      187 	if sdb_ptr = null () then do;			/* If this - then no room for sdb */
      188 	     substr (iostatus, 1, 36) = unspec (error_table_$no_room_for_dsb); /* Send message */
      189 	     go to exit;				/* Exit */
      190 	end;					/* End sdb_ptr null do group */
      191 	sdb.areap = area_ptr;			/* Save area pointer for freeing sdb. */
      192 
      193 	outer_module_name = crzcpz;			/* Put name this outer module in sdb */
      194 	device_name_list_ptr = addr (sdb.device_name);	/* Set pointer */
      195 	next_device_ptr = null;			/* Only one device allowed */
      196 	name_size = 32;				/* Set name size */
      197 	name = device;				/* Put attached device name in sdb */
      198 
      199 	if outer_module_name = "cpz" then do;		/* If punch ... */
      200 	     punch = "1"b;				/* Set indicator to say punch attached. */
      201 	     dvname = "punch";
      202 	     sdb.stat_tablep = addr (cpz_status_table_$cpz_status_table_);
      203 	end;					/* Set pointer to punch status interpretation table. */
      204 	else do;					/* If reader ... */
      205 	     punch = "0"b;				/* Set indicator to say reader attached. */
      206 	     dvname = "reader";
      207 	     sdb.stat_tablep = addr (crz_status_table_$crz_status_table_);
      208 	end;					/* Set pointer to reader status interpretation table. */
      209 
      210 	call ipc_$create_ev_chn (evchan, rcode);	/* Create event channel so that the supervisor */
      211 	if rcode ^= 0 then do;			/* knows who to wake when we are blocked */
      212 	     call convert_ipc_code_ (rcode);
      213 	     go to free;				/* to free sdb */
      214 	end;
      215 	ev_list.count = 1;				/* Initialize event list count */
      216 
      217 	device_info_ptr = addr (rcp_info);		/* Get pointer to RCP info for device. */
      218 	rcp_info.version_num = DEVICE_INFO_VERSION_1;			/* Set up the RCP info structure. */
      219 	rcp_info.usage_time = 0;			/* Don't know how long we'll use device. */
      220 	rcp_info.wait_time = 0;			/* We are not willing to wait. */
      221 	rcp_info.system_flag = "0"b;			/* Not system process. */
      222 	rcp_info.device_name = name;			/* Set appropriate device name. */
      223 
      224 	call rcp_$attach (dvname, device_info_ptr, evchan, "", rcp_id, rcode);
      225 	if rcode ^= 0 then go to free;		/* Attempt to attach the device. */
      226 
      227 check:	call rcp_$check_attach (rcp_id, device_info_ptr, "", devx, wksp_max, time_max,
      228 	     rcp_state, rcode);			/* Check on progress of attachment. */
      229 	if rcode ^= 0 then go to free;
      230 
      231 	go to attach_state (rcp_state);		/* Dispatch on state variable. */
      232 
      233 attach_state (1):					/* Short wait needed */
      234 	call ipc_$block (addr (sdb.ev_list), addr (ipc_message), rcode);
      235 	if rcode ^= 0 then do;			/* Wait for attachment to complete. */
      236 	     call convert_ipc_code_ (rcode);
      237 	     go to free;
      238 	end;
      239 	go to check;				/* Perform check again. */
      240 
      241 attach_state (2):					/* long wait */
      242 attach_state (3):					/* error occurrence */
      243 	go to free;				/* This is an error condition. */
      244 
      245 attach_state (0):					/* Successful attachment */
      246 	call ioi_$workspace (devx, wsegp, 1024, rcode);	/* Get working segment. */
      247 	if rcode ^= 0 then go to free;		/* Check error code */
      248 
      249 	do i = 0 to 33;				/* Insert DCWs into working segment */
      250 	     dcwp = addr (dcwlist (i).dcw);		/* Get pointer to place for IOTD. */
      251 	     dcw.address = rel (addr (buffer (i)));	/* Set offset of data buffer. */
      252 	     dcw.tally = bit (bin (27, 12));		/* Set DCW tally. */
      253 	end;
      254 
      255 	idcwp = addr (sdb.term_idcw);			/* Get pointer to template terminate IDCW. */
      256 	sdb.term_idcw = "0"b;			/* Clear IDCW. */
      257 	idcw.command = "100000"b;			/* Command is RSS. */
      258 	idcw.device = "000001"b;
      259 	idcw.code = "111"b;
      260 	idcw.chan_cmd = "000010"b;
      261 	idcw.count = bit (bin (1, 6));
      262 
      263 	idcwp = addr (sdb.io_idcw);			/* Get pointer to template read/punch IDCW. */
      264 	sdb.io_idcw = "0"b;				/* Clear IDCW. */
      265 	if punch then				/* If punch ... */
      266 	     idcw.command = "001001"b;		/* Command is punch card binary. */
      267 	else					/* If reader ... */
      268 	idcw.command = "000001"b;			/* Command is read card binary. */
      269 	idcw.device = "000001"b;
      270 	idcw.code = "111"b;
      271 	idcw.control = "10"b;
      272 
      273 	tdcwp = addr (wseg.tdcw);			/* Get pointer to transfer DCW. */
      274 	wseg.tdcw = "0"b;				/* Clear the DCW. */
      275 	tdcw.address = bit (bin (0, 18));		/* Transfer back to beginning of list. */
      276 	tdcw.type = "10"b;				/* Set type bits. */
      277 
      278 	sdb.running = "0"b;				/* Indicate channel not running. */
      279 	sdb.wait_flag = "0"b;			/* Turn off waiting for special flag. */
      280 	sdb.eof_flag = "1"b;			/* Turn on EOF recognition mode */
      281 
      282 	sdb.iobegin,				/* Set indices for I/O and data copying. */
      283 	     sdb.iocur,
      284 	     sdb.movecur = 0;
      285 	if punch then sdb.movestop = 32;
      286 	else sdb.movestop = 0;
      287 	sdb.marker_count = 0;			/* Reset marker flag count. */
      288 	sdb.error_count = 0;			/* Reset error count. */
      289 	sdb.card_count = 0;				/* reset usage counter */
      290 	sdb.last_iom_stat = ""b;			/* Reset last reported status */
      291 	sdb.print_message = "0"b;			/* say no message to print */
      292 	sdb.message = "";				/* and clear the status message */
      293 
      294 	call ipc_$drain_chn (evchan, rcode);
      295 
      296 	return;					/* Return to caller */
      297 
      298 
      299 
      300 
      301 
      302 free:	substr (iostatus, 1, 36) = unspec (rcode);	/* Return error code. */
      303 
      304 	go to detach_it;
      305 						/* Now drop into detach code. */
      306 
      307 
      308 crz_detach: entry (sdb_ptr, device, mode, iostatus);	/* Detach entry point */
      309 cpz_detach: entry (sdb_ptr, device, mode, iostatus);	/* Detach entry point */
      310 
      311 	iostatus = ""b;				/* clear the status */
      312 
      313 detach_it:
      314 
      315 	call ipc_$delete_ev_chn (evchan, rcode);	/* Delete event channel */
      316 
      317 	call rcp_$detach (rcp_id, "0"b, error_count, "", rcode);
      318 	if rcode ^= 0 then				/* Attempt to detach the device. */
      319 	     if substr (iostatus, 1, 36) = ""b then	/* if not aborting an attach */
      320 		substr (iostatus, 1, 36) = unspec (rcode); /* Put error code in return iostatus */
      321 
      322 	area_ptr = sdb.areap;			/* Get back pointer to allocation area. */
      323 	free sdb in (listen_based_area);		/* Free-up allocated sdb */
      324 
      325 exit:	substr (iostatus, 52, 1) = "1"b;		/* Set ioname detached bit */
      326 	substr (iostatus, 41, 1) = "1"b;		/* Set transaction terminated bit */
      327 	return;
      328 
      329 
      330 /*  */
      331 
      332 crz_read:	entry (sdb_ptr, xwkspptr, offset, nelem, nelemt, iostatus); /* Read entry point */
      333 
      334 /* This is the read loop for the Ohlin - Ammons card reader DIM */
      335 
      336 	rcode = 0;				/* Clear error code. */
      337 	nelemt = 0;				/* Zero elements transmitted to start */
      338 	wkspptr = addrel (xwkspptr, offset * 27);	/* Copy pointer, and add in offset */
      339 	sdb.last_iom_stat = ""b;			/* reset for each read */
      340 	sdb.wait_flag = "0"b;			/* cancel last wait */
      341 	sdb.print_message = "0"b;			/* and pending message */
      342 
      343 	do while (nelemt < nelem);			/* Read as many cards as caller asked for */
      344 	     iostop = mod (sdb.movecur - 1, 34);	/* Compute stopping place for DCW list. */
      345 
      346 	     if sdb.iocur ^= iostop then		/* If more DCW's can be queued ... */
      347 		call set_io;			/* Queue up some more I/O. */
      348 
      349 	     else if sdb.movecur ^= sdb.movestop then do; /* If we have cards to move ... */
      350 
      351 		if eof_flag then			/* Check if EOF recognition is turned on */
      352 		     if wseg.buffer (movecur).words (1) = /* Check for multiple 5-7 punch in column 1 */
      353 		     "002400000000"b3 |
      354 		     (wseg.buffer (movecur).words (1) = "401240124020"b3 /* Check for ++FOF */
      355 		     & wseg.buffer (movecur).words (2) = "201040100000"b3) |
      356 		     (wseg.buffer (movecur).words (1) = "401240125020"b3 /* Check for ++eof */
      357 		     & wseg.buffer (movecur).words (2) = "601050100000"b3) then
      358 			do;
      359 			substr (iostatus, 41, 1) = "1"b; /* Set transaction terminated bit */
      360 			if nelemt = 0 then do;	/* First time through, don't give EOF status. */
      361 			     substr (iostatus, 46, 1) = "1"b; /* Set end-of-data bit */
      362 			     movecur = mod (movecur + 1, 34); /* Now throw card away */
      363 			end;			/* Note that EOF card is looked at twice */
      364 			substr (iostatus, 1, 36) = unspec (error_table_$eof_record);
      365 			return;			/* Return to caller */
      366 		     end;				/* End EOF recognized */
      367 
      368 		wkspptr -> workspace =		/* Address where we are putting it */
      369 		     addr (wseg.buffer (movecur)) -> workspace; /* Where it is in buffer */
      370 		wkspptr = addrel (wkspptr, 27);	/* Update workspace pointer */
      371 		nelemt = nelemt + 1;		/* Keep track of number of cards moved */
      372 		sdb.card_count = sdb.card_count + 1;	/* and total cards */
      373 		movecur = mod (movecur + 1, 34);	/* Increment data copy index. */
      374 	     end;
      375 
      376 	     else call wait_io;			/* Otherwise, wait for I/O completion. */
      377 
      378 	     if rcode ^= 0 then do;
      379 		substr (iostatus, 1, 36) = unspec (rcode);
      380 		substr (iostatus, 41, 1) = "1"b;	/* Set transaction terminated. */
      381 		return;				/* Return to caller immediately. */
      382 	     end;
      383 
      384 	end;
      385 
      386 	return;					/* Return to caller of crzcpz_read */
      387 
      388 /*  */
      389 
      390 cpz_write: entry (sdb_ptr, xwkspptr, offset, nelem, nelemt, iostatus); /* Write entry point */
      391 
      392 /* This is the write loop for the card punch DIM */
      393 
      394 	rcode = 0;				/* Clear the error code. */
      395 	nelemt = 0;				/* Zero elements transmitted to start */
      396 	wkspptr = addrel (xwkspptr, offset * 27);	/* Copy pointer, and add in offset */
      397 	sdb.last_iom_stat = ""b;
      398 	sdb.wait_flag = "0"b;			/* cancel last wait */
      399 	sdb.print_message = "0"b;			/* and pending message */
      400 
      401 	do while (nelemt < nelem);			/* Write as many cards as caller asked for */
      402 	     if movecur ^= movestop then do;		/* If room for more cards ... */
      403 		addr (wseg.buffer (movecur)) -> workspace = /* Where data is going in buffer */
      404 		     wkspptr -> workspace;		/* Address where we are getting it from */
      405 		wkspptr = addrel (wkspptr, 27);	/* Update workspace pointer */
      406 		nelemt = nelemt + 1;		/* Keep track of number of cards moved */
      407 		sdb.card_count = sdb.card_count + 1;	/* and total cards */
      408 
      409 		iocur = movecur;			/* Set up DCW list for card just copied. */
      410 		call set_io;			/* Patch new element into DCW list. */
      411 		movecur = iocur;			/* Copy next card into next slot for I/O. */
      412 	     end;
      413 
      414 	     else call wait_io;			/* Otherwise, wait for I/O to complete. */
      415 
      416 	     if rcode ^= 0 then do;
      417 		substr (iostatus, 1, 36) = unspec (rcode);
      418 		substr (iostatus, 41, 1) = "1"b;	/* Set transaction terminated. */
      419 		return;				/* Return to caller immediately. */
      420 	     end;
      421 
      422 	end;
      423 
      424 	return;					/* Return to caller of cpz_write */
      425 
      426 /*  */
      427 
      428 set_io:	proc;					/* procedure to set IDCW's to perform I/O */
      429 
      430 	     ionext = mod (iocur + 1, 34);		/* Compute place for terminate IDCW. */
      431 
      432 	     dcwlist (ionext).idcw = term_idcw;		/* Insert stopper first. */
      433 	     dcwlist (iocur).idcw = io_idcw;		/* Now insert I/O IDCW. */
      434 
      435 	     if running then do;			/* If channel is running ... */
      436 		marker_count = marker_count + 1;	/* Bump the marker count. */
      437 		if marker_count >= 17 then do;	/* Place a marker at half-way point. */
      438 		     idcwp = addr (dcwlist (iocur).idcw); /* Get pointer to current IDCW. */
      439 		     idcw.control = "11"b;		/* Make IDCW store marker status. */
      440 		     marker_count = 0;		/* Reset the marker counter. */
      441 		end;
      442 	     end;
      443 
      444 	     iocur = ionext;			/* Set index for next slot for I/O. */
      445 
      446 	     if ^running then call start_io;		/* Fire up the IOM. */
      447 
      448 	     return;
      449 
      450 	end set_io;
      451 
      452 /*  */
      453 
      454 start_io:	proc;					/* procedure to start up card I/O */
      455 
      456 	     if ^wait_flag then if iocur ^= iobegin then do; /* If something to do ... */
      457 		     marker_count = 0;		/* Reset the marker count. */
      458 		     running = "1"b;		/* Turn on running flag. */
      459 		     call ioi_$connect (devx, 2*iobegin, rcode); /* Fire up the IOM. */
      460 		end;
      461 
      462 	     return;
      463 
      464 	end start_io;
      465 
      466 
      467 
      468 
      469 
      470 wait_io:	proc;					/* procedure to wait for card I/O */
      471 
      472 	     if ^sdb.running then			/* If channel is idle ... */
      473 		call start_io;			/* Give it something to do. */
      474 
      475 	     call ipc_$read_ev_chn (sdb.evchan, ev_done, addr (ipc_message), rcode);
      476 	     if rcode ^= 0 then do;
      477 bad_ipc:		call convert_ipc_code_ (rcode);
      478 		return;
      479 	     end;
      480 
      481 	     if ev_done = 0 then do;			/* no event yet, print pending message and block */
      482 
      483 		if sdb.print_message then do;		/* if waiting, tell why once */
      484 		     call com_err_ (0, name, sdb.message);
      485 		     sdb.print_message = "0"b;
      486 		end;
      487 
      488 		call ipc_$block (addr (sdb.ev_list), addr (ipc_message), rcode);
      489 		if rcode ^= 0 then go to bad_ipc;
      490 
      491 	     end;
      492 
      493 	     call stat_check;			/* Examine status. */
      494 
      495 	     return;
      496 
      497 	end wait_io;
      498 
      499 /*  */
      500 
      501 stat_check: proc;					/* Card I/O status check entry  */
      502 
      503 dcl  lx fixed bin,
      504      flags bit (18) aligned;
      505 
      506 	     flags = "0"b;				/* Clear flags. */
      507 
      508 	     imp = addr (ipc_message.message);		/* Get address of ioi status message */
      509 	     if imess.level = "111"b then do;		/* If this is a special interupt... */
      510 		wait_flag = "0"b;			/* Reset this in case waiting for special */
      511 		return;				/* And all done */
      512 	     end;
      513 
      514 	     if imess.st then do;			/* If status is really present */
      515 		if imess.time_out then do;		/* if termination caused by a time out */
      516 		     rcode = error_table_$net_timeout;	/* this is a reasonable error */
      517 		     running = "0"b;		/* not running any more */
      518 		     return;
      519 		end;
      520 
      521 		temp_iom_stat = imess.status;		/* make a double word iom_stat */
      522 		if bin (imess.level) <= 5 then do;	/* If system fault, terminate, or marker ... */
      523 		     if imess.er then		/* If error occurred ... */
      524 			if imess.level = "001"b then do; /* If system fault ... */
      525 			     call analyze_system_fault_ (name, temp_iom_stat);
      526 			     sdb.message = "Waiting for interrupt after last system fault error.";
      527 			     sdb.print_message = "0"b; /* print this later if needed */
      528 			     sdb.last_iom_stat = ""b;
      529 			     sdb.error_count = sdb.error_count + 1; /* add them up */
      530 			     sdb.wait_flag = "1"b;	/* wait for special status */
      531 			end;
      532 			else do;			/* Must be terminate status. */
      533 			     call analyze_device_stat_$rs (sdb.message, stat_tablep, temp_iom_stat, flags);
      534 						/* Analyze the status. */
      535 			     sdb.wait_flag = (flags & halt_flag) ^= "0"b; /* Set wait flag based on examined status. */
      536 			     if flags & report_flag then do; /* should we report this */
      537 				sdb.error_count = sdb.error_count + 1;
      538 				if (temp_iom_stat & dev_stat_bits) ^= sdb.last_iom_stat then do;
      539 				     sdb.last_iom_stat = (temp_iom_stat & dev_stat_bits); /* save a message */
      540 				     if ^sdb.wait_flag then do;
      541 					call com_err_ (0, name, sdb.message);
      542 					sdb.print_message = "0"b; /* say message was printed */
      543 				     end;
      544 				     else sdb.print_message = "1"b; /* print message unless returning */
      545 				end;
      546 			     end;
      547 			     else sdb.print_message = "0"b; /* suppress the message */
      548 			end;
      549 
      550 		     lx = bin (imess.offset);		/* Copy list index for this status */
      551 		     if flags & backup_flag then lx = lx - mod (lx, 2);
      552 						/* If backup flag ON, go back to IDCW. */
      553 
      554 		     iobegin = mod (divide (lx + 1, 2, 17, 0), 34);
      555 						/* Compute place to start next block of I/O. */
      556 		     if punch then do;		/* If running punch ... */
      557 			movestop = mod (iobegin - 2, 34); /* Set place for stopping data copy. */
      558 			if flags & punch_alert_flag then /* If punch alert ... */
      559 			     iobegin = mod (iobegin - 1, 34); /* Back up still one more card. */
      560 		     end;
      561 		     else movestop = iobegin;		/* For reader, set place for stopping data copy. */
      562 		     running = imess.run;		/* Indicate if channel still running. */
      563 		end;
      564 	     end;
      565 
      566 	     return;
      567 
      568 	end stat_check;
      569 
      570 
      571 
      572 crz_setsize: entry (sdb_ptr, element_size, iostatus);	/* Set size entry point */
      573 cpz_setsize: entry (sdb_ptr, element_size, iostatus);	/* Set size entry point */
      574 
      575 	if element_size ^= 972 then			/* 972 bits equals 27 words */
      576 	     substr (iostatus, 1, 36) = unspec (error_table_$invalid_elsize); /* Send message */
      577 	else
      578 	substr (iostatus, 41, 1) = "1"b;		/* Set transaction terminated bit */
      579 
      580 	return;					/* Return to caller */
      581 
      582 
      583 crz_getsize: entry (sdb_ptr, element_size, iostatus);	/* Get size entry point */
      584 cpz_getsize: entry (sdb_ptr, element_size, iostatus);	/* Get size entry point */
      585 
      586 	element_size = 972;				/* Set element size */
      587 	iostatus = "0"b;				/* Zero iostatus string */
      588 	substr (iostatus, 41, 1) = "1"b;		/* Set transaction terminated bit */
      589 
      590 	return;					/* Return to caller */
      591 
      592 
      593 crz_changemode: entry (sdb_ptr, new_mode, old_mode, iostatus); /* Change mode entry point */
      594 
      595 	old_mode = "r";				/* Set old mode */
      596 	iostatus = "0"b;				/* Zero iostatus string */
      597 	substr (iostatus, 41, 1) = "1"b;		/* Set transaction terminated bit */
      598 	if new_mode ^= "" & new_mode ^= "r" then	/* Check for legal mode */
      599 	     substr (iostatus, 1, 36) = unspec (error_table_$invalid_write);
      600 
      601 	return;					/* Return to caller */
      602 
      603 
      604 cpz_changemode: entry (sdb_ptr, new_mode, old_mode, iostatus); /* Change mode entry point */
      605 
      606 	old_mode = "w";				/* Set old mode */
      607 	iostatus = "0"b;				/* Zero iostatus string */
      608 	substr (iostatus, 41, 1) = "1"b;		/* Set transaction terminated bit */
      609 	if new_mode ^= "" & new_mode ^= "w" then	/* Check for legal mode */
      610 	     substr (iostatus, 1, 36) = unspec (error_table_$invalid_read);
      611 
      612 	return;					/* Return to caller */
      613 
      614 
      615 crz_resetread: entry (sdb_ptr, iostatus);		/* Resetread entry point. */
      616 
      617 	iostatus = "0"b;
      618 	do while (running);				/* Wait until channel stops. */
      619 	     call wait_io;
      620 	end;
      621 	wait_flag = "0"b;				/* Now, reset the waiting for special flag. */
      622 
      623 	iobegin,					/* Reset all indices. */
      624 	     iocur,
      625 	     movestop,
      626 	     movecur = 0;
      627 
      628 	return;
      629 
      630 crz_order: entry (sdb_ptr, request, orderp, iostatus);	/* Order entry point */
      631 
      632 dcl  request char (*);				/* order request */
      633 
      634 	iostatus = "0"b;
      635 
      636 	if request = "eof_off" | request = "off" then	/* Check for off message */
      637 	     do;
      638 	     eof_flag = "0"b;			/* Turn off the flag */
      639 out:	     substr (iostatus, 41, 1) = "1"b;		/* Set terminate iostatus */
      640 	     return;
      641 	end;
      642 
      643 	if request = "eof_on" | request = "on" then
      644 	     do;
      645 	     eof_flag = "1"b;			/* Turn the flag on */
      646 	     goto out;
      647 	end;
      648 
      649 /* If we get here - "request" was not valid */
      650 
      651 	substr (iostatus, 1, 36) = unspec (error_table_$undefined_order_request);
      652 	go to out;
      653 
      654 
      655 cpz_order: entry (sdb_ptr, request, orderp, iostatus);	/* Order entry point */
      656 
      657 	iostatus = "0"b;
      658 
      659 	if request = "runout" then do;		/* To run out the remaining cards in buffer. */
      660 	     wait_flag = "0"b;			/* Turn off wait flag. */
      661 	     do while (iocur ^= iobegin);		/* Try until all remaining cards are punched. */
      662 		call wait_io;
      663 		if rcode ^= 0 then do;
      664 		     substr (iostatus, 1, 36) = unspec (rcode);
      665 		     go to out;
      666 		end;
      667 	     end;
      668 	     go to out;
      669 	end;
      670 
      671 	if request = "get_error_count" then do;
      672 	     if orderp = null then do;		/* bad news for this entry */
      673 		substr (iostatus, 1, 36) = unspec (error_table_$no_operation);
      674 		go to out;
      675 	     end;
      676 
      677 	     ret_error_count = sdb.error_count;		/* give it to the caller */
      678 	     go to out;				/* and we are done */
      679 	end;
      680 
      681 	if request = "reset" then do;			/* reset the card counter */
      682 	     sdb.card_count = 0;
      683 	     go to out;
      684 	end;
      685 
      686 	if request = "get_count" then do;		/* report the number of cards punched */
      687 	     if orderp = null then do;		/* bad news for this entry */
      688 		substr (iostatus, 1, 36) = unspec (error_table_$no_operation);
      689 		go to out;
      690 	     end;
      691 	     unspec (counts) = ""b;			/* clear everything */
      692 	     counts.line_count = sdb.card_count;	/* assume one card equals one line */
      693 	     go to out;
      694 	end;
      695 
      696 /*	if we pass here, the order is not defined */
      697 
      698 	substr (iostatus, 1, 36) = unspec (error_table_$undefined_order_request);
      699 	go to out;
      700 
      701 
      702      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/18/86  1235.1  crzcpz_dim.pl1                    >spec>install>1098>crzcpz_dim.pl1
153          1    07/18/86  1218.3  rcp_device_info.incl.pl1          >spec>install>1098>rcp_device_info.incl.pl1
155          2    09/13/83  1258.2  status_flags.incl.pl1             >ldd>include>status_flags.incl.pl1
159          3    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
164          4    05/06/74  1742.1  iom_pcw.incl.pl1                  >ldd>include>iom_pcw.incl.pl1
169          5    11/12/74  1550.1  iom_dcw.incl.pl1                  >ldd>include>iom_dcw.incl.pl1
171          6    09/28/78  1359.8  prt_order_info.incl.pl1           >ldd>include>prt_order_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DEVICE_INFO_VERSION_1                  constant        fixed bin(17,0)          initial dcl 1-26 ref 218
addr                                                   builtin function         dcl 58 ref 194 202 207 217 233 233 233 233 250 251
                                                                                  255 263 273 368 403 438 475 475 488 488 488 488
                                                                                  508
addrel                                                 builtin function         dcl 58 ref 338 370 396 405
address                                based           bit(18)                  level 2 in structure "tdcw" packed unaligned
                                                                                  dcl 5-14 in procedure "crzcpz_dim" set ref 275*
address                                based           bit(18)                  level 2 in structure "dcw" packed unaligned dcl 5-7
                                                                                  in procedure "crzcpz_dim" set ref 251*
analyze_device_stat_$rs         000066 constant        entry                    external dcl 122 ref 533
analyze_system_fault_           000064 constant        entry                    external dcl 122 ref 525
area_ptr                        000112 automatic       pointer                  dcl 105 set ref 185* 186 191 322* 323
areap                    36            based           pointer                  level 2 dcl 62 set ref 191* 322
backup_flag                            constant        bit(18)                  initial dcl 2-5 ref 551
bin                                                    builtin function         dcl 58 ref 252 261 275 522 550
bit                                                    builtin function         dcl 58 ref 252 261 275
buffer                  106            based           structure                array level 2 dcl 96 set ref 251 368 403
card_count               57            based           fixed bin(17,0)          level 2 dcl 62 set ref 289* 372* 372 407* 407 682*
                                                                                  692
chan_cmd                  0(24)        based           bit(6)                   level 2 packed unaligned dcl 4-21 set ref 260*
code                      0(18)        based           bit(3)                   level 2 packed unaligned dcl 4-21 set ref 259* 270*
com_err_                        000072 constant        entry                    external dcl 122 ref 484 541
command                                based           bit(6)                   level 2 packed unaligned dcl 4-21 set ref 257* 265*
                                                                                  267*
completion                             based           structure                level 2 in structure "imess" packed unaligned
                                                                                  dcl 3-21 in procedure "crzcpz_dim"
completion                             based           structure                level 2 in structure "istat" dcl 3-7 in procedure
                                                                                  "crzcpz_dim"
control                   0(22)        based           bit(2)                   level 2 packed unaligned dcl 4-21 set ref 271* 439*
convert_ipc_code_               000070 constant        entry                    external dcl 122 ref 212 236 477
count                    26            based           fixed bin(17,0)          level 3 in structure "sdb" dcl 62 in procedure
                                                                                  "crzcpz_dim" set ref 215*
count                     0(30)        based           bit(6)                   level 2 in structure "idcw" packed unaligned
                                                                                  dcl 4-21 in procedure "crzcpz_dim" set ref 261*
counts                                 based           structure                level 1 dcl 6-6 set ref 691*
cpz_status_table_$cpz_status_table_
                                000034 external static fixed bin(17,0)          dcl 56 set ref 202
crz_status_table_$crz_status_table_
                                000032 external static fixed bin(17,0)          dcl 55 set ref 207
crzcpz                                 parameter       char                     unaligned dcl 32 ref 176 177 193
dcw                                    based           structure                level 1 dcl 5-7 in procedure "crzcpz_dim"
dcw                       1            based           bit(36)                  array level 3 in structure "wseg" dcl 96
                                                                                  in procedure "crzcpz_dim" set ref 250
dcwlist                                based           structure                array level 2 dcl 96
dcwp                            000156 automatic       pointer                  dcl 5-4 set ref 250* 251 252
dev_stat_bits                   000004 constant        bit(72)                  initial dcl 118 ref 538 539
device                                 parameter       char                     unaligned dcl 32 in procedure "crzcpz_dim" ref 176
                                                                                  177 197 308 309
device                    0(06)        based           bit(6)                   level 2 in structure "idcw" packed unaligned
                                                                                  dcl 4-21 in procedure "crzcpz_dim" set ref 258*
                                                                                  269*
device_info                            based           structure                level 1 dcl 1-17
device_info_ptr                 000150 automatic       pointer                  dcl 1-15 set ref 217* 224* 227*
device_name              12            based           structure                level 2 in structure "sdb" dcl 62 in procedure
                                                                                  "crzcpz_dim" set ref 194
device_name               4     000124 automatic       char(8)                  level 2 in structure "rcp_info" dcl 139 in procedure
                                                                                  "crzcpz_dim" set ref 222*
device_name_list_ptr     10            based           pointer                  level 2 dcl 62 set ref 194*
devx                     32            based           fixed bin(17,0)          level 2 dcl 62 set ref 227* 245* 459*
divide                                                 builtin function         dcl 58 ref 554
dvname                          000102 automatic       char(6)                  unaligned dcl 32 set ref 201* 206* 224*
element_size                           parameter       fixed bin(17,0)          dcl 32 set ref 572 573 575 583 584 586*
eof_flag                 45            based           bit(1)                   level 2 dcl 62 set ref 280* 351 638* 645*
er                        0(01)        based           bit(1)                   level 3 packed unaligned dcl 3-21 ref 523
error_count              56            based           fixed bin(17,0)          level 2 dcl 62 set ref 288* 317* 529* 529 537* 537
                                                                                  677
error_table_$eof_record         000030 external static fixed bin(35,0)          dcl 45 ref 364
error_table_$invalid_elsize     000014 external static fixed bin(35,0)          dcl 45 ref 575
error_table_$invalid_read       000016 external static fixed bin(35,0)          dcl 45 ref 609
error_table_$invalid_write      000020 external static fixed bin(35,0)          dcl 45 ref 598
error_table_$ionmat             000010 external static fixed bin(35,0)          dcl 45 ref 181
error_table_$net_timeout        000022 external static fixed bin(35,0)          dcl 45 ref 516
error_table_$no_operation       000024 external static fixed bin(35,0)          dcl 45 ref 673 688
error_table_$no_room_for_dsb    000012 external static fixed bin(35,0)          dcl 45 ref 188
error_table_$undefined_order_request
                                000026 external static fixed bin(35,0)          dcl 45 ref 651 698
ev_done                         000110 automatic       fixed bin(17,0)          dcl 105 set ref 475* 481
ev_list                  26            based           structure                level 2 dcl 62 set ref 233 233 488 488
evchan                   30            based           fixed bin(71,0)          level 3 dcl 62 set ref 210* 224* 294* 313* 475*
flags                           000227 automatic       bit(18)                  dcl 503 set ref 506* 533* 535 536 551 558
get_system_free_area_           000036 constant        entry                    external dcl 122 ref 185
halt_flag                              constant        bit(18)                  initial dcl 2-5 ref 535
i                               000104 automatic       fixed bin(17,0)          dcl 105 set ref 249* 250 251*
idcw                                   based           structure                level 1 dcl 4-21 in procedure "crzcpz_dim"
idcw                                   based           bit(36)                  array level 3 in structure "wseg" dcl 96
                                                                                  in procedure "crzcpz_dim" set ref 432* 433* 438
idcwp                           000154 automatic       pointer                  dcl 4-19 set ref 255* 257 258 259 260 261 263* 265
                                                                                  267 269 270 271 438* 439
imess                                  based           structure                level 1 dcl 3-21
imp                             000152 automatic       pointer                  dcl 3-19 set ref 508* 509 514 515 521 522 523 523
                                                                                  550 562
io_idcw                  53            based           bit(36)                  level 2 dcl 62 set ref 263 264* 433
iobegin                  46            based           fixed bin(18,0)          level 2 dcl 62 set ref 282* 456 459 554* 557 558*
                                                                                  558 561 623* 661
iocur                    47            based           fixed bin(18,0)          level 2 dcl 62 set ref 282* 346 409* 411 430 433 438
                                                                                  444* 456 623* 661
ioi_$connect                    000042 constant        entry                    external dcl 122 ref 459
ioi_$workspace                  000040 constant        entry                    external dcl 122 ref 245
ionext                          000106 automatic       fixed bin(18,0)          dcl 105 set ref 430* 432 444
iostatus                               parameter       bit(72)                  dcl 32 set ref 176 177 179* 181* 188* 302* 308 309
                                                                                  311* 318 318* 325* 326* 332 359* 361* 364* 379*
                                                                                  380* 390 417* 418* 572 573 575* 577* 583 584 587*
                                                                                  588* 593 596* 597* 598* 604 607* 608* 609* 615
                                                                                  617* 630 634* 639* 651* 655 657* 664* 673* 688*
                                                                                  698*
iostop                          000105 automatic       fixed bin(18,0)          dcl 105 set ref 344* 346
ipc_$block                      000052 constant        entry                    external dcl 122 ref 233 488
ipc_$create_ev_chn              000044 constant        entry                    external dcl 122 ref 210
ipc_$delete_ev_chn              000050 constant        entry                    external dcl 122 ref 313
ipc_$drain_chn                  000046 constant        entry                    external dcl 122 ref 294
ipc_$read_ev_chn                000054 constant        entry                    external dcl 122 ref 475
ipc_message                     000140 automatic       structure                level 1 dcl 141 set ref 233 233 475 475 488 488
istat                                  based           structure                level 1 dcl 3-7
last_iom_stat            60            based           bit(72)                  level 2 dcl 62 set ref 290* 339* 397* 528* 538 539*
level                     0(15)        based           bit(3)                   level 2 packed unaligned dcl 3-21 ref 509 522 523
line_count                4            based           fixed bin(17,0)          level 2 dcl 6-6 set ref 692*
listen_based_area                      based           area(16374)              dcl 105 ref 186 323
lx                              000226 automatic       fixed bin(17,0)          dcl 503 set ref 550* 551* 551 551 554
marker_count             55            based           fixed bin(17,0)          level 2 dcl 62 set ref 287* 436* 436 437 440* 457*
message                  63            based           varying char(256)        level 2 in structure "sdb" dcl 62 in procedure
                                                                                  "crzcpz_dim" set ref 292* 484* 526* 533* 541*
message                   2     000140 automatic       fixed bin(71,0)          level 2 in structure "ipc_message" dcl 141
                                                                                  in procedure "crzcpz_dim" set ref 508
mod                                                    builtin function         dcl 58 ref 344 362 373 430 551 554 557 558
mode                                   parameter       char                     unaligned dcl 32 ref 176 177 308 309
movecur                  50            based           fixed bin(18,0)          level 2 dcl 62 set ref 282* 344 349 351 351 351 351
                                                                                  351 362* 362 368 373* 373 402 403 409 411* 623*
movestop                 51            based           fixed bin(18,0)          level 2 dcl 62 set ref 285* 286* 349 402 557* 561*
                                                                                  623*
name                     15            based           char(32)                 level 3 dcl 62 set ref 197* 222 484* 525* 541*
name_size                14            based           fixed bin(17,0)          level 3 dcl 62 set ref 196*
nelem                                  parameter       fixed bin(17,0)          dcl 32 ref 332 343 390 401
nelemt                                 parameter       fixed bin(17,0)          dcl 32 set ref 332 337* 343 360 371* 371 390 395*
                                                                                  401 406* 406
new_mode                               parameter       char                     unaligned dcl 32 ref 593 598 598 604 609 609
next_device_ptr          12            based           pointer                  level 3 dcl 62 set ref 195*
null                                                   builtin function         dcl 58 ref 180 187 195 672 687
offset                                 parameter       fixed bin(17,0)          dcl 32 in procedure "crzcpz_dim" ref 332 338 390 396
offset                    0(18)        based           bit(18)                  level 2 in structure "imess" packed unaligned
                                                                                  dcl 3-21 in procedure "crzcpz_dim" ref 550
old_mode                               parameter       char                     unaligned dcl 32 set ref 593 595* 604 606*
orderp                                 parameter       pointer                  dcl 6-4 ref 630 655 672 677 687 691 692
outer_module_name                      based           char(32)                 level 2 dcl 62 set ref 193* 199
print_message            62            based           bit(1)                   level 2 dcl 62 set ref 291* 341* 399* 483 485* 527*
                                                                                  542* 544* 547*
punch                    33            based           bit(1)                   level 2 dcl 62 set ref 200* 205* 265 285 556
punch_alert_flag                       constant        bit(18)                  initial dcl 117 ref 558
rcode                           000107 automatic       fixed bin(35,0)          dcl 105 set ref 210* 211 212* 224* 225 227* 229 233*
                                                                                  235 236* 245* 247 294* 302 313* 317* 318 318 336*
                                                                                  378 379 394* 416 417 459* 475* 476 477* 488* 489
                                                                                  516* 663 664
rcp_$attach                     000056 constant        entry                    external dcl 122 ref 224
rcp_$check_attach               000060 constant        entry                    external dcl 122 ref 227
rcp_$detach                     000062 constant        entry                    external dcl 122 ref 317
rcp_id                   34            based           bit(36)                  level 2 dcl 62 set ref 224* 227* 317*
rcp_info                        000124 automatic       structure                level 1 dcl 139 set ref 217
rcp_state                       000120 automatic       fixed bin(17,0)          dcl 105 set ref 227* 231
rel                                                    builtin function         dcl 58 ref 251
report_flag                            constant        bit(18)                  initial dcl 2-5 ref 536
request                                parameter       char                     unaligned dcl 632 ref 630 636 636 643 643 655 659
                                                                                  671 681 686
ret_error_count                        based           fixed bin(17,0)          dcl 6-32 set ref 677*
run                       0(02)        based           bit(1)                   level 3 packed unaligned dcl 3-21 ref 562
running                  44            based           bit(1)                   level 2 dcl 62 set ref 278* 435 446 458* 472 517*
                                                                                  562* 618
sdb                                    based           structure                level 1 dcl 62 set ref 186 323
sdb_ptr                                parameter       pointer                  dcl 32 set ref 176 177 180 186* 187 191 193 194 194
                                                                                  195 196 197 199 200 202 205 207 210 215 222 224
                                                                                  224 227 227 233 233 245 245 250 251 255 256 263
                                                                                  264 265 273 274 278 279 280 282 282 282 285 285
                                                                                  286 287 288 289 290 291 292 294 308 309 313 317
                                                                                  317 322 323 332 339 340 341 344 346 349 349 351
                                                                                  351 351 351 351 351 351 351 351 351 351 362 362
                                                                                  368 368 372 372 373 373 390 397 398 399 402 402
                                                                                  403 403 407 407 409 409 411 411 430 432 432 433
                                                                                  433 433 435 436 436 437 438 438 440 444 446 456
                                                                                  456 456 457 458 459 459 472 475 483 484 484 485
                                                                                  488 488 510 517 525 526 527 528 529 529 530 533
                                                                                  533 535 537 537 538 539 540 541 541 542 544 547
                                                                                  554 556 557 557 558 558 561 561 562 572 573 583
                                                                                  584 593 604 615 618 621 623 623 623 623 630 638
                                                                                  645 655 660 661 661 677 682 692
st                                     based           bit(1)                   level 3 packed unaligned dcl 3-21 ref 514
stat_tablep              42            based           pointer                  level 2 dcl 62 set ref 202* 207* 533*
status                    1            based           bit(36)                  level 2 packed unaligned dcl 3-21 ref 521
stream_name                            parameter       char                     unaligned dcl 32 ref 176 177
substr                                                 builtin function         dcl 58 set ref 181* 188* 302* 318 318* 325* 326*
                                                                                  359* 361* 364* 379* 380* 417* 418* 575* 577* 588*
                                                                                  597* 598* 608* 609* 639* 651* 664* 673* 688* 698*
system_flag               3     000124 automatic       bit(1)                   level 2 dcl 139 set ref 221*
tally                     0(24)        based           bit(12)                  level 2 packed unaligned dcl 5-7 set ref 252*
tdcw                    104            based           bit(36)                  level 2 in structure "wseg" dcl 96 in procedure
                                                                                  "crzcpz_dim" set ref 273 274*
tdcw                                   based           structure                level 1 dcl 5-14 in procedure "crzcpz_dim"
tdcwp                           000160 automatic       pointer                  dcl 5-4 set ref 273* 275 276
temp_iom_stat                   000122 automatic       bit(72)                  dcl 105 set ref 521* 525* 533* 538 539
term_idcw                52            based           bit(36)                  level 2 dcl 62 set ref 255 256* 432
time_max                        000116 automatic       fixed bin(52,0)          dcl 105 set ref 227*
time_out                  0(03)        based           bit(1)                   level 3 packed unaligned dcl 3-21 ref 515
type                      0(22)        based           bit(2)                   level 2 packed unaligned dcl 5-14 set ref 276*
unspec                                                 builtin function         dcl 58 set ref 181 188 302 318 364 379 417 575 598
                                                                                  609 651 664 673 688 691* 698
usage_time                1     000124 automatic       fixed bin(17,0)          level 2 dcl 139 set ref 219*
version_num                     000124 automatic       fixed bin(17,0)          level 2 dcl 139 set ref 218*
wait_flag                54            based           bit(1)                   level 2 dcl 62 set ref 279* 340* 398* 456 510* 530*
                                                                                  535* 540 621* 660*
wait_time                 2     000124 automatic       fixed bin(17,0)          level 2 dcl 139 set ref 220*
wksp_max                        000114 automatic       fixed bin(19,0)          dcl 105 set ref 227*
wkspptr                         000100 automatic       pointer                  dcl 32 set ref 338* 368 370* 370 396* 403 405* 405
words                   106            based           bit(36)                  array level 3 dcl 96 set ref 351 351 351 351 351
workspace                              based           bit(36)                  array dcl 94 set ref 368* 368 403* 403
wseg                                   based           structure                level 1 dcl 96
wsegp                    40            based           pointer                  level 2 dcl 62 set ref 245* 250 251 273 274 351 351
                                                                                  351 351 351 368 403 432 433 438
xwkspptr                               parameter       pointer                  dcl 32 ref 332 338 390 396

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
channel_stops                          based           bit(16)                  array unaligned dcl 6-25
eurc_no_backup_flag                    internal static bit(18)                  initial dcl 2-5
init_flag                              internal static bit(18)                  initial dcl 2-5
isp                                    automatic       pointer                  dcl 3-5
page_labels                            based           structure                level 1 dcl 6-21
paper_info                             based           structure                level 1 dcl 6-27
pcw                                    based           structure                level 1 dcl 4-6
pcwp                                   automatic       pointer                  dcl 4-4
position_data                          based           structure                level 1 dcl 6-14

NAMES DECLARED BY EXPLICIT CONTEXT.
attach_state                    000000 constant        label                    array(0:3) dcl 233 ref 231
bad_ipc                         002272 constant        label                    dcl 477 ref 489
check                           000430 constant        label                    dcl 227 ref 239
cpz_attach                      000155 constant        entry                    external dcl 177
cpz_changemode                  001573 constant        entry                    external dcl 604
cpz_detach                      000767 constant        entry                    external dcl 309
cpz_getsize                     001464 constant        entry                    external dcl 584
cpz_order                       002006 constant        entry                    external dcl 655
cpz_setsize                     001417 constant        entry                    external dcl 573
cpz_write                       001273 constant        entry                    external dcl 390
crz_attach                      000115 constant        entry                    external dcl 176
crz_changemode                  001512 constant        entry                    external dcl 593
crz_detach                      000741 constant        entry                    external dcl 308
crz_getsize                     001447 constant        entry                    external dcl 583
crz_order                       001715 constant        entry                    external dcl 630
crz_read                        001116 constant        entry                    external dcl 332
crz_resetread                   001656 constant        entry                    external dcl 615
crz_setsize                     001402 constant        entry                    external dcl 572
crzcpz_dim                      000101 constant        entry                    external dcl 20
detach_it                       001016 constant        label                    dcl 313 ref 304
exit                            001102 constant        label                    dcl 325 ref 182 189
free                            000731 constant        label                    dcl 302 ref 213 225 229 237 241 247
out                             001757 constant        label                    dcl 639 ref 646 652 665 668 674 678 683 689 693 699
set_io                          002145 constant        entry                    internal dcl 428 ref 346 410
start_io                        002207 constant        entry                    internal dcl 454 ref 446 472
stat_check                      002362 constant        entry                    internal dcl 501 ref 493
wait_io                         002241 constant        entry                    internal dcl 470 ref 376 414 619 662

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3342        3436    2665        3352
Length      4024    2665        74         351     455           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
crzcpz_dim                          304 external procedure  is an external procedure.  
set_io                                  internal procedure  shares stack frame of external procedure crzcpz_dim.  
start_io                                internal procedure  shares stack frame of external procedure crzcpz_dim.  
wait_io                                 internal procedure  shares stack frame of external procedure crzcpz_dim.  
stat_check                              internal procedure  shares stack frame of external procedure crzcpz_dim.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
crzcpz_dim               000100 wkspptr                     crzcpz_dim
                         000102 dvname                      crzcpz_dim
                         000104 i                           crzcpz_dim
                         000105 iostop                      crzcpz_dim
                         000106 ionext                      crzcpz_dim
                         000107 rcode                       crzcpz_dim
                         000110 ev_done                     crzcpz_dim
                         000112 area_ptr                    crzcpz_dim
                         000114 wksp_max                    crzcpz_dim
                         000116 time_max                    crzcpz_dim
                         000120 rcp_state                   crzcpz_dim
                         000122 temp_iom_stat               crzcpz_dim
                         000124 rcp_info                    crzcpz_dim
                         000140 ipc_message                 crzcpz_dim
                         000150 device_info_ptr             crzcpz_dim
                         000152 imp                         crzcpz_dim
                         000154 idcwp                       crzcpz_dim
                         000156 dcwp                        crzcpz_dim
                         000160 tdcwp                       crzcpz_dim
                         000226 lx                          stat_check
                         000227 flags                       stat_check

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             call_ext_out_desc   call_ext_out        return              mod_fx1             ext_entry
ext_entry_desc      alloc_based         free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
analyze_device_stat_$rs       analyze_system_fault_         com_err_                      convert_ipc_code_
get_system_free_area_         ioi_$connect                  ioi_$workspace                ipc_$block
ipc_$create_ev_chn            ipc_$delete_ev_chn            ipc_$drain_chn                ipc_$read_ev_chn
rcp_$attach                   rcp_$check_attach             rcp_$detach

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
cpz_status_table_$cpz_status_table_                         crz_status_table_$crz_status_table_
error_table_$eof_record       error_table_$invalid_elsize   error_table_$invalid_read     error_table_$invalid_write
error_table_$ionmat           error_table_$net_timeout      error_table_$no_operation     error_table_$no_room_for_dsb
error_table_$undefined_order_request




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     20 000100       176 000106       177 000152       179 000212       180 000216       181 000222       182 000224
    185 000225       186 000233       187 000240       188 000244       189 000247       191 000250       193 000252
    194 000262       195 000264       196 000270       197 000274       199 000304       200 000310       201 000312
    202 000314       203 000317       205 000320       206 000321       207 000324       210 000327       211 000341
    212 000343       213 000352       215 000353       217 000357       218 000361       219 000363       220 000364
    221 000365       222 000366       224 000371       225 000426       227 000430       229 000476       231 000500
    233 000502       235 000523       236 000525       237 000534       239 000535       241 000536       245 000537
    247 000560       249 000562       250 000567       251 000575       252 000602       253 000607       255 000611
    256 000615       257 000616       258 000620       259 000622       260 000624       261 000626       263 000633
    264 000635       265 000636       267 000643       269 000645       270 000647       271 000651       273 000655
    274 000660       275 000661       276 000666       278 000672       279 000673       280 000674       282 000676
    285 000701       286 000706       287 000707       288 000710       289 000711       290 000712       291 000715
    292 000716       294 000717       296 000730       302 000731       304 000733       308 000734       309 000764
    311 001012       313 001016       317 001031       318 001066       322 001074       323 001100       325 001102
    326 001105       327 001107       332 001110       336 001130       337 001131       338 001133       339 001141
    340 001146       341 001147       343 001150       344 001154       346 001163       349 001167       351 001172
    359 001215       360 001220       361 001222       362 001224       364 001230       365 001233       368 001234
    370 001244       371 001246       372 001247       373 001250       374 001255       376 001256       378 001257
    379 001261       380 001263       381 001266       384 001267       386 001270       390 001271       394 001305
    395 001306       396 001310       397 001316       398 001323       399 001324       401 001325       402 001332
    403 001337       405 001346       406 001350       407 001351       409 001352       410 001355       411 001356
    412 001362       414 001363       416 001364       417 001366       418 001370       419 001373       422 001374
    424 001375       572 001376       573 001414       575 001431       577 001441       580 001444       583 001445
    584 001461       586 001476       587 001501       588 001505       590 001507       593 001510       595 001537
    596 001545       597 001551       598 001553       601 001570       604 001571       606 001620       607 001626
    608 001632       609 001634       612 001651       615 001652       617 001670       618 001674       619 001700
    620 001701       621 001702       623 001703       628 001707       630 001710       634 001735       636 001741
    638 001754       639 001757       640 001762       643 001763       645 001773       646 001777       651 002000
    652 002003       655 002004       657 002026       659 002032       660 002041       661 002044       662 002051
    663 002052       664 002054       665 002056       667 002057       668 002060       671 002061       672 002065
    673 002071       674 002074       677 002075       678 002102       681 002103       682 002107       683 002112
    686 002113       687 002117       688 002123       689 002126       691 002127       692 002134       693 002140
    698 002141       699 002144       428 002145       430 002146       432 002155       433 002160       435 002164
    436 002167       437 002170       438 002173       439 002176       440 002200       444 002201       446 002203
    448 002206       454 002207       456 002210       457 002217       458 002220       459 002222       462 002240
    470 002241       472 002242       475 002247       476 002270       477 002272       478 002301       481 002302
    483 002304       484 002310       485 002332       488 002335       489 002356       493 002360       495 002361
    501 002362       506 002363       508 002364       509 002366       510 002374       511 002377       514 002400
    515 002403       516 002406       517 002411       518 002414       521 002415       522 002420       523 002427
    525 002435       526 002454       527 002463       528 002464       529 002467       530 002470       531 002472
    533 002473       535 002522       536 002531       537 002535       538 002536       539 002544       540 002550
    541 002552       542 002574       543 002577       544 002600       546 002602       547 002603       550 002604
    551 002607       554 002621       556 002631       557 002633       558 002636       560 002646       561 002647
    562 002650       566 002654


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
