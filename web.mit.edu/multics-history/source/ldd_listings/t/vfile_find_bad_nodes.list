	COMPILATION LISTING OF SEGMENT vfile_find_bad_nodes
	Compiled by: Multics PL/I Compiler, Release 28b, of April 11, 1983
	Compiled at: Honeywell LCPD Phoenix, System M
	Compiled on: 06/23/83  1125.4 mst Thu
	    Options: optimize map

        1 
        2 /* ***********************************************************
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   * Copyright (c) 1972 by Massachusetts Institute of        *
        7*   * Technology and Honeywell Information Systems, Inc.      *
        8*   *                                                         *
        9*   *********************************************************** */
       10 
       11 
       12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       13 	/*									*/
       14 	/* Name:  vfile_find_bad_nodes						*/
       15 	/*									*/
       16 	/*      This is a procedure for checking the consistency of the key-containing		*/
       17 	/* components of a vfile_ indexed file.						*/
       18 	/*									*/
       19 	/* Status									*/
       20 	/*									*/
       21 	/* 0) Created:   July, 1981 by  G.C. Dixon					*/
       22 	/* 1) Modified:  May, 1983 by G.C. Dixon to add node_tree checking.			*/
       23 	/*									*/
       24 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       25 
       26 	
       27 vfile_find_bad_nodes:
       28 	proc;
       29 
       30      dcl	Iarg			fixed bin,
       31 	Ibranch			fixed bin,
       32 	Ifn			fixed bin,
       33 	Imode			fixed bin,
       34 	Inode			fixed bin,
       35 	Larg			fixed bin(21),
       36 	Lnode_bit_overlay		fixed bin,
       37 	Lop			fixed bin(21),
       38 	Lread			fixed bin(21),
       39 	Lret			fixed bin(21),
       40 	LINE			char(256),
       41 	Nargs			fixed bin,
       42 	Nbad_nodes		fixed bin,
       43 	Nbad_nodes_in_comp		fixed bin,
       44 	Nkeys			fixed bin(34),
       45 	Nkey_bytes		fixed bin(34),
       46 	Nkey_bytes_in_node		fixed bin,
       47 	Nnon_empty_nodes		fixed bin,
       48 	Parg			ptr,
       49 	Pfn			ptr,
       50 	Pfree_nodes		ptr,
       51 	Piocb			ptr,
       52 	Piocb_node_tree		ptr,
       53          (Pnode1, Pnode2)		ptr,
       54 	Pnode_array		ptr,
       55 	Pnode_bit_overlay		ptr,
       56 	Pop			ptr,
       57 	Pret			ptr,
       58 	Sattached			bit(1),
       59 	Scommand			bit(1),
       60 	Sinput_switch		bit(1),
       61 	1 Smode			aligned,
       62 	 (2 node_branch,
       63 	  2 key_region,
       64 	  2 key_loc,
       65 	  2 key_overlap,
       66 	  2 key_order,
       67 	  2 node_tree,
       68 	  2 bad_mode_name,
       69 	  2 bad_mode_value)		bit(1) unal,
       70 	Sopened			bit(1),
       71 	Spathname			bit(1),
       72 	Srequest_loop		bit(1),
       73 	Stotal			bit(1),
       74 	1 branch_numb_key		aligned like numb_key,
       75 	code			fixed bin(35),
       76 	comp_num			fixed bin,
       77 	input_switch_name		char(32),
       78 	key			char(256) varying,
       79 	line			char(256) varying,
       80 	mode_string		char(256),	/* This mode string is only used in calls to	*/
       81 						/*   com_err_, so 256 chars is long enough.	*/
       82 	node_bits			bit(4096) unal,
       83 	1 numb_key		aligned,
       84 	  2 comp			fixed bin(17) unal,
       85 	  2 node			fixed bin(18) uns unal,
       86 	pathname			char(168) varying,
       87 	pos_frame (4)		ptr,
       88 	pos_ptr			ptr,
       89 	1 root_numb_key		aligned like numb_key,
       90 	save_numb_key_numb		fixed bin(35),
       91 	temp_comp_num		fixed bin,
       92 	unique			char(15);
       93 
       94      dcl	area			area based(Parea),
       95 	arg			char(Larg) based(Parg),
       96 	branch_numb_key_numb	fixed bin(35) based (addr(branch_numb_key)),
       97 	branch_numb_key_str		char(4) aligned based(addr(branch_numb_key_numb)),
       98 	1 fn			aligned based(Pfn), /* a free node, containing a list of other free	*/
       99 						/*   nodes.				*/
      100 	  2 N			fixed bin,	/* number free nodes listed in this node.	*/
      101 	  2 next_free_node_designator fixed bin(35),	/* record descriptor of next free node list.	*/
      102 	  2 node (0 refer (fn.N))	fixed bin(35),	/* record descriptors of free nodes in this list. */
      103 	1 free_nodes		aligned based(Pfree_nodes),
      104 	  2 N			fixed bin,	/* array of pointers to free nodes or free node 	*/
      105 	  2 node (0 refer (free_nodes.N))
      106 				ptr,		/*   lists.				*/
      107 	node_array (255)		char(4096) aligned based(Pnode_array),
      108 	node_bit_array (4096)	bit(1) unal based (addr(node_bits)),
      109 	node_bit_overlay		bit(Lnode_bit_overlay) based(Pnode_bit_overlay),
      110 	numb_key_numb		fixed bin(35) based(addr(numb_key)),
      111 	numb_key_str		char(4) aligned based(addr(numb_key)),
      112 	op			char(Lop) based(Pop),
      113 	open_descrip		char(100) varying based,
      114 	ret			char(Lret) varying based(Pret),
      115 	root_numb_key_numb		fixed bin(35) aligned based(addr(root_numb_key));
      116 
      117      dcl (char, currentsize, dimension, hbound, index, 
      118           lbound, ltrim, mod, rtrim)	builtin;
      119 
      120      dcl (cleanup, program_interrupt)	condition;
      121 
      122      dcl  active_fnc_err_		entry() options(variable),
      123 	arg_ptr			entry (fixed bin, ptr, fixed bin(21), fixed bin(35)) variable,
      124 	com_err_			entry() options(variable),
      125 	cu_$af_return_arg		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      126 	cu_$af_arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      127 	cu_$arg_ptr		entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
      128 	cu_$cp			entry (ptr, fixed bin(21), fixed bin(35)),
      129 	delete_$path		entry (char(*), char(*), bit(6), char(*), fixed bin(35)),
      130 	err			entry options(variable) variable,
      131 	get_pdir_			entry() returns(char(168)),
      132 	get_system_free_area_	entry() returns(ptr),
      133 	get_temp_segment_		entry (char(*), ptr, fixed bin(35)),
      134 	ioa_			entry() options(variable),
      135 	ioa_$nnl			entry() options(variable),
      136 	iox_$attach_name		entry (char(*), ptr, char(*), ptr, fixed bin(35)),
      137 	iox_$close		entry (ptr, fixed bin(35)),
      138 	iox_$control		entry (ptr, char(*), ptr, fixed bin(35)),
      139 	iox_$detach_iocb		entry (ptr, fixed bin(35)),
      140 	iox_$destroy_iocb		entry (ptr, fixed bin(35)),
      141 	iox_$get_line		entry (ptr, ptr, fixed bin(21), fixed bin(21), fixed bin(35)),
      142 	iox_$look_iocb		entry (char(*), ptr, fixed bin(35)),
      143 	iox_$open			entry (ptr, fixed bin, bit(1) aligned, fixed bin(35)),
      144 	iox_$position		entry (ptr, fixed bin, fixed bin(21), fixed bin(35)),
      145 	iox_$read_key		entry (ptr, char(256) varying, fixed bin(21), fixed bin(35)),
      146 	mode_string_$get_error	entry (ptr, char(*), fixed bin(35)),
      147 	mode_string_$parse		entry (char(*), ptr, ptr, fixed bin(35)),
      148 	pathname_			entry (char(*), char(*)) returns(char(168)),
      149 	release_temp_segment_	entry (char(*), ptr, fixed bin(35)),
      150 	unique_chars_		entry (bit(*)) returns(char(15));
      151 
      152      dcl (FALSE			init("0"b),
      153 	TRUE			init("1"b)) bit(1) int static options(constant),
      154 	HT_SP			char(2) int static options(constant) init("	 "),
      155 	HT_SP_NL			char(3) int static options(constant) init("	 
      156 "),
      157 	Parea			ptr int static init(null),
      158          (error_table_$bad_mode,
      159 	error_table_$bad_mode_value,
      160 	error_table_$badopt,
      161 	error_table_$inconsistent,
      162 	error_table_$key_duplication,
      163 	error_table_$noarg,
      164 	error_table_$not_attached,
      165 	error_table_$unimplemented_version,
      166 	error_table_$wrong_no_of_args)
      167 				fixed bin(35) ext static,
      168 	iox_$user_input		ptr external static,
      169 	proc			char(20) int static options(constant) init("vfile_find_bad_nodes");
      170 
      171 	Pfree_nodes = null;				/* Initialize variables for cleanup on unit.	*/
      172 	Piocb = null;
      173 	Piocb_node_tree = null;
      174 	Sattached = FALSE;
      175 	Sopened = FALSE;
      176 	mode_string_info_ptr = null;
      177 	on cleanup call janitor();
      178 
      179 	Sinput_switch = FALSE;			/* Initialize variables used to process args.	*/
      180 	Spathname = FALSE;
      181 	input_switch_name = "";
      182 	pathname = "";
      183 	Smode = FALSE;
      184 	Smode.node_branch = TRUE;
      185 	Smode.key_region = TRUE;
      186 	Smode.key_loc = TRUE;
      187 
      188 	call cu_$af_return_arg (Nargs, Pret, Lret, code); /* Called as a command, or as an af?		*/
      189 	if code = 0 then do;
      190 	     Scommand = FALSE;
      191 	     Srequest_loop = FALSE;
      192 	     arg_ptr = cu_$af_arg_ptr;
      193 	     err = active_fnc_err_;
      194 	     end;
      195 	else do;
      196 	     Scommand = TRUE;
      197 	     Srequest_loop = TRUE;
      198 	     arg_ptr = cu_$arg_ptr;
      199 	     err = com_err_;
      200 	     end;
      201 
      202 	do Iarg = 1 to Nargs;			/* Process arguments.			*/
      203 	     call arg_ptr (Iarg, Parg, Larg, code);
      204 
      205 	     if arg = "-input_switch" | arg = "-isw" then do;
      206 		if Spathname then do;
      207 		     call err (error_table_$inconsistent, proc, "^a
      208 Usage:	vfile_find_bad_nodes {pathname}
      209    or:	vfile_find_bad_nodes -input_switch switch_name", arg);
      210 		     go to FINISH;
      211 		     end;
      212 		Iarg = Iarg + 1;
      213 		if Iarg > Nargs then do;
      214 		     call err (error_table_$noarg, proc, "
      215 ^a requires an I/O switch name as its operand.  The switch must be 
      216 attached to the keyed file.  If open, the switch must be opened for
      217 ^a or ^a.", arg, iox_modes(Keyed_sequential_input), iox_modes(Keyed_sequential_update));
      218 		     go to FINISH;
      219 		     end;
      220 		call arg_ptr (Iarg, Pop, Lop, code);
      221 		input_switch_name = op;
      222 		Sinput_switch = TRUE;
      223 		end;
      224 
      225 	     else if arg = "-request_loop" | arg = "-rql" then
      226 		Srequest_loop = TRUE;
      227 
      228 	     else if arg = "-no_request_loop" | arg = "-nrql" then
      229 		Srequest_loop = FALSE;
      230 
      231 	     else if arg = "-check" | arg = "-ck" then do;
      232 		Iarg = Iarg + 1;
      233 		if Iarg > Nargs then do;
      234 		     call err (error_table_$noarg, proc, "
      235 ^a requires a mode string as its operand.  For a list of modes, type
      236   help ^a -brief", arg, proc);
      237 		     go to FINISH;
      238 		     end;
      239 		call arg_ptr (Iarg, Pop, Lop, code);
      240 		if Parea = null then
      241 		     Parea = get_system_free_area_();
      242 		call mode_string_$parse (op, Parea, mode_string_info_ptr, code);
      243 		if code ^= 0 then do;
      244 		     call err (code, proc, "^a ^a", arg, op);
      245 		     go to FINISH;
      246 		     end;
      247 		if mode_string_info.version ^= mode_string_info_version_2 then do;
      248 		     call err (error_table_$unimplemented_version, proc, "
      249 Expected version ^d structure from mode_string_$parse, received version ^d.",
      250 			mode_string_info_version_2, mode_string_info.version);
      251 		     go to FINISH;
      252 		     end;
      253 		if mode_string_info.number >= 1 then
      254 		if mode_string_info.modes(1).version ^= mode_value_version_3 then do;
      255 		     call err (error_table_$unimplemented_version, proc, "
      256 Expected version ^d structure from mode_string_$parse, received version ^d.",
      257 			mode_value_version_3, mode_string_info.modes(1).version);
      258 		     go to FINISH;
      259 		     end;
      260 		Smode = FALSE;
      261 		code = 0;
      262 		mode_string_info.modes(*).code = 0;
      263 		do Imode = 1 to mode_string_info.number;
      264 		     if mode_string_info.modes(Imode).boolean_valuep then do;
      265 			if mode_string_info.modes(Imode).mode_name = "node_branch" then
      266 			     Smode.node_branch = mode_string_info.modes(Imode).boolean_value;
      267 			else if mode_string_info.modes(Imode).mode_name = "key_region" then
      268 			     Smode.key_region = mode_string_info.modes(Imode).boolean_value;
      269 			else if mode_string_info.modes(Imode).mode_name = "key_loc" then
      270 			     Smode.key_loc = mode_string_info.modes(Imode).boolean_value;
      271 			else if mode_string_info.modes(Imode).mode_name = "key_overlap" then
      272 			     Smode.key_overlap = mode_string_info.modes(Imode).boolean_value;
      273 			else if mode_string_info.modes(Imode).mode_name = "key_order" then
      274 			     Smode.key_order = mode_string_info.modes(Imode).boolean_value;
      275 			else if mode_string_info.modes(Imode).mode_name = "node_tree" then
      276 			     Smode.node_tree = mode_string_info.modes(Imode).boolean_value;
      277 			else if mode_string_info.modes(Imode).mode_name = "default" then
      278 			     Smode.node_branch,
      279 			     Smode.key_region,
      280 			     Smode.key_loc = mode_string_info.modes(Imode).boolean_value;
      281 
      282 			else if mode_string_info.modes(Imode).mode_name = "all" then
      283 			     Smode.node_branch,
      284 			     Smode.key_region,
      285 			     Smode.key_loc,
      286 			     Smode.key_overlap,
      287 			     Smode.key_order,
      288 			     Smode.node_tree = mode_string_info.modes(Imode).boolean_value;
      289 			else do;
      290 			     mode_string_info.modes(Imode).code = error_table_$bad_mode;
      291 			     Smode.bad_mode_name = TRUE;
      292 			     code = error_table_$bad_mode_value;
      293 			     end;
      294 			end;
      295 		     else do;
      296 			mode_string_info.modes(Imode).code = error_table_$bad_mode_value;
      297 			Smode.bad_mode_value = TRUE;
      298 			code = error_table_$bad_mode_value;
      299 			end;
      300 		     end;
      301 		if Smode.bad_mode_name | Smode.bad_mode_value then do;
      302 		     call mode_string_$get_error (mode_string_info_ptr, mode_string, 0);
      303 		     call err (code, proc, "^a^[
      304 Only boolean modes can be given.^]", mode_string, Smode.bad_mode_value & ^Smode.bad_mode_name);
      305 		     go to FINISH;
      306 		     end;
      307 		free mode_string_info in (area);
      308 		mode_string_info_ptr = null;
      309 		end;
      310 
      311 	     else if index(arg, "-") = 1 then do;
      312 		call err (error_table_$badopt, proc, "^a
      313 Usage:	vfile_find_bad_nodes {pathname}
      314    or:	vfile_find_bad_nodes -input_switch switch_name", arg);
      315 		go to FINISH;
      316 		end;
      317 
      318 	     else do;
      319 		if Sinput_switch then do;
      320 		     call err (error_table_$inconsistent, proc, "^a
      321 Usage:	vfile_find_bad_nodes {pathname}
      322    or:	vfile_find_bad_nodes -input_switch switch_name", arg);
      323 		     go to FINISH;
      324 		     end;
      325 		pathname = arg;
      326 		Spathname = TRUE;
      327 		end;
      328 	     end;
      329 	if Spathname | Sinput_switch then;
      330 	else do;
      331 	     call err (error_table_$wrong_no_of_args, proc, "
      332 Usage:	vfile_find_bad_nodes {pathname}
      333    or:	vfile_find_bad_nodes -input_switch switch_name");
      334 	     go to FINISH;
      335 	     end;
      336 
      337 
      338 	unique = unique_chars_(""b);
      339 	if Spathname then do;			/* For paths, attach to file in this code.	*/
      340 	     input_switch_name = proc || "." || unique;
      341 	     call iox_$attach_name (input_switch_name, Piocb, "vfile_ " ||
      342 		pathname || " -share 120", null, code);
      343 	     if code ^= 0 then do;
      344 		call err (code, proc, "Attaching to ^a",
      345 		     pathname);
      346 		go to FINISH;
      347 		end;
      348 	     Sattached = TRUE;
      349 	     call iox_$open (Piocb, Keyed_sequential_input, ""b, code);
      350 	     if code ^= 0 then do;
      351 		call err (code, proc, "Opening ^a for ^a.",
      352 		     pathname, iox_modes(Keyed_sequential_input));
      353 		go to FINISH;
      354 		end;
      355 	     Sopened = TRUE;
      356 	     end;
      357 
      358 	else do;					/* For I/O switches,			*/
      359 	     call iox_$look_iocb (input_switch_name, Piocb, code);
      360 	     if code ^= 0 then do;			/*   make sure I/O switch exists.		*/
      361 		call err (code, proc, "Finding ^a I/O switch.
      362 Usage:	vfile_find_bad_nodes {pathname}
      363    or:	vfile_find_bad_nodes -input_switch switch_name",
      364 		     input_switch_name);
      365 		go to FINISH;
      366 		end;
      367 	     if Piocb -> iocb.attach_descrip_ptr = null then do;
      368 		call err (error_table_$not_attached, proc,
      369 		     "
      370 Referencing ^a I/O switch.", input_switch_name);		/*   make sure it is attached to something.	*/
      371 		go to FINISH;
      372 		end;
      373 	     if Piocb -> iocb.open_descrip_ptr = null then do;
      374 		call iox_$open (Piocb, Keyed_sequential_input, ""b, code);
      375 		if code ^= 0 then do;		/*   if not open, open it for ksqi		*/
      376 		     call err (code, proc, "
      377 Opening ^a I/O switch for ^a.", input_switch_name, iox_modes(Keyed_sequential_input));
      378 		     go to FINISH;
      379 		     end;
      380 		Sopened = TRUE;
      381 		end;
      382 	     else do;				/*   if already open, make sure it is for ksqi	*/
      383 		if Piocb -> iocb.open_descrip_ptr -> open_descrip = iox_modes(Keyed_sequential_input) |
      384 		   Piocb -> iocb.open_descrip_ptr -> open_descrip = iox_modes(Keyed_sequential_update) then;
      385 		else do;
      386 		     call err (error_table_$bad_mode, proc, "
      387 ^a I/O switch is opened for ^a.  It must be opened for
      388 ^a or ^a to use ^a.", input_switch_name,
      389 			Piocb -> iocb.open_descrip_ptr -> open_descrip,
      390 			iox_modes(Keyed_sequential_input),
      391 			iox_modes(Keyed_sequential_update), proc);
      392 		     go to FINISH;
      393 		     end;
      394 		end;
      395 	     end;
      396 
      397 	if Smode.node_tree then do;			/* For node_tree checking, create temp vfile_	*/
      398 						/*   in process directory.			*/
      399 	     call iox_$attach_name ("vfbn." || unique, Piocb_node_tree,
      400 		"vfile_ " || pathname_(get_pdir_(), "vfbn." || unique),
      401 		null, code);
      402 	     if code ^= 0 then do;
      403 		call err (code, proc, "
      404 Attempting to attach to temp vfile_ in process dir.");
      405 		go to FINISH;
      406 		end;
      407 	     call iox_$open (Piocb_node_tree, Keyed_sequential_update, ""b, code);
      408 	     if code ^= 0 then do;
      409 		call err (code, proc, "
      410 Attempting to open temp vfile_ in process dir for keyed_sequential_update.");
      411 		go to FINISH;
      412 		end;
      413 
      414 	     aki.input_key = TRUE;			/* Initialize structures used to manipulate	*/
      415 	     aki.input_desc = TRUE;			/*   keys in this temp vfile_			*/
      416 	     aki.key_len = 4;
      417 
      418 	     gki.input_key = TRUE;
      419 	     gki.input_desc = FALSE;
      420 	     gki.desc_code = 0;
      421 	     gki.current = FALSE;
      422 	     gki.rel_type = 0;
      423 	     gki.head_size = 4;
      424 	     gki.reset_pos = TRUE;
      425 	     gki.pad = FALSE;
      426 	     gki.version = gk_info_version_0;
      427 	     gki.key_len = 4;
      428 
      429 	     rki.input_key = TRUE;
      430 	     rki.input_old_desc = TRUE;
      431 	     rki.input_new_desc = TRUE;
      432 	     rki.mbz = FALSE;
      433 	     rki.key_len = 4;
      434 	     end;
      435 
      436 	call iox_$read_key (Piocb, key, Lread, code);	/* This call forces initiation of key components. */
      437 	if code ^= 0 then do;
      438 	     call err (code, proc, "
      439 Attempting to read first key ^[of file ^a^s^;on ^s^a I/O switch^].",
      440 		Spathname, pathname, input_switch_name);
      441 	     go to FINISH;
      442 	     end;
      443 
      444 	key = "";					/* set variables to access file structures.	*/
      445 	pos_ptr = addr(pos_frame);
      446 	Nbad_nodes = 0;
      447 	indx_cb_ptr = Piocb -> iocb.open_data_ptr;
      448 	f_b_ptr = indx_cb.file_base_ptr;
      449 	if file_base.file_version = 10 then do;
      450 	     call err (0, proc, 
      451 		"This file is in too old a format to check its nodes.");
      452 	     go to FINISH;
      453 	     end;
      454 	is_ptr = indx_cb.index_state_ptr;
      455 
      456 	if index_state_block.free_node_designator ^= 0 then do;
      457 	     call get_temp_segment_ (proc, Pfree_nodes, code);
      458 	     if code ^= 0 then do;
      459 		call err (code, proc, "Getting temp segment.");
      460 		go to FINISH;			/* In a temp seg, get a list of the unused nodes  */
      461 		end;				/*   in the index, and avoid doing consistency	*/
      462 	     free_nodes.N = 0;			/*   checks on them, since they may contain data	*/
      463 	     Pfn = is_ptr;				/*   from a previous use which is in an		*/
      464 	     if Pfn = null then go to ABORT_FREE_NODES;	/*   inconsistent state.			*/
      465 	     do while (fn.next_free_node_designator ^= 0);
      466 		Pfn = get_ptr (fn.next_free_node_designator);
      467 		if Pfn = null then go to ABORT_FREE_NODES;
      468 		call ioa_ ("Begin checking free node list (node_ptr = ^p).", Pfn);
      469 		if fn.N < 0 then do;
      470 		     call tell$bad_free_node ("Free node count < 0", 23, Pfn);
      471 		     go to ABORT_FREE_NODES;
      472 		     end;
      473 		if fn.N > 1022 then do;
      474 		     call tell$bad_free_node ("Free node count > 1022", 24, Pfn);
      475 		     go to ABORT_FREE_NODES;
      476 		     end;
      477 		free_nodes.N = free_nodes.N + 1;
      478 		free_nodes.node(free_nodes.N) = Pfn;
      479 		do Ifn = 1 to fn.N;
      480 		     free_nodes.N = free_nodes.N + 1;
      481 		     free_nodes.node(free_nodes.N) = get_ptr(fn.node(Ifn));
      482 		     end;
      483 		end;
      484 	     call ioa_ ("Found ^d undamaged free nodes.  Processing continues.", free_nodes.N);
      485 	     go to END_FREE_NODE_PROCESSING;
      486 
      487 ABORT_FREE_NODES:
      488 	     call ioa_ ("Processing of free nodes aborted by this error.
      489 Found ^d undamaged free nodes so far.
      490 Some damaged nodes reported below may actually be undamaged free nodes which
      491 were not located, due to this error.", free_nodes.N);
      492 END_FREE_NODE_PROCESSING:
      493 	     end;
      494 
      495 	root_numb_key_numb = file_base.root_node_block.only_branch_in_root;
      496 						/* Remember descriptor of root node for node_tree */
      497 						/*   checking.				*/
      498 
      499 	Nnon_empty_nodes = 0;
      500 	Nkeys = 0;
      501 	Nkey_bytes = 0;
      502 	do comp_num = 0,				/* Start with component 0 of the keyed file,	*/
      503 	   index_state_block.index_tail_comp_num repeat comp_table(comp_num).comp_link
      504 	        while (comp_num ^= 0);		/*   and follow chain of key-containing 	*/
      505 	     Pnode_array = seg_ptr_array(comp_num);	/*   components from the comp_table.		*/
      506 	     if comp_num = 0 then Inode = 5;		/* Skip over file_base in component 0.		*/
      507 	     else Inode = 1;			/* For other components, consider pages 1-255	*/
      508 
      509 	     call ioa_ ("^/Begin checking component ^d, node:", comp_num);
      510 	     on program_interrupt;			/* Ignore pi unless in request loop.		*/
      511 	     Stotal = FALSE;
      512 	     Nbad_nodes_in_comp = 0;
      513 
      514 						/* Note that the following code walks through the */
      515 						/* nodes in each component sequentially, NOT in	*/
      516 						/* tree order.				*/
      517 	     do Inode = Inode to dimension(node_array,1); /* For each potential key-containing node,	*/
      518 		node_ptr = addr(node_array(Inode));	/*   get ptr to node page.  vfile_ has kindly 	*/
      519 						/*   initiated the compoent for us.		*/
      520 		if mod(Inode,25) = 0 then call ioa_$nnl (" ^d", Inode);
      521 						/* Give user a progress indicator every 25 pages. */
      522 		if Pfree_nodes ^= null then do;	/* Avoid checking free nodes.			*/
      523 		     do Ifn = 1 to free_nodes.N while (node_ptr ^= free_nodes.node(Ifn));
      524 			end;
      525 		     if Ifn <= free_nodes.N then go to NEXT_NODE;
      526 		     end;
      527 		if node_block.last_branch_num = 0 then go to NEXT_NODE;
      528 						/* Avoid checking empty nodes.		*/
      529 
      530 		Nnon_empty_nodes = Nnon_empty_nodes + 1;
      531 		Nkeys = Nkeys + node_block.last_branch_num - 1;
      532 		Nkey_bytes = Nkey_bytes + 4096 - node_block.low_key_pos + 1 - node_block.scat_space;
      533 
      534 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      535 	/*									*/
      536 	/* The tests for consistency of each node follow:					*/
      537 	/*									*/
      538 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      539 
      540 		if Smode.node_branch then do;
      541 		     if node_block.last_branch_num > 313  then go to FAIL6;
      542 						/* A node can contain at most, 313 1-char keys.	*/
      543 		     if node_block.last_branch_num < 0 then go to FAIL7;
      544 						/* Key count must be positive.		*/
      545 		     end;
      546 
      547 		if Smode.key_region then do;
      548 		     if node_block.low_key_pos > 4096  then go to FAIL8;
      549 						/* Keys may not be stored beyond end of page.	*/
      550 		     if node_block.low_key_pos < 4*(currentsize(node_block)-2)  then go to FAIL9;
      551 						/* Keys may not be stored on top of node_block	*/
      552 						/*   structure.				*/
      553 		     if node_block.scat_space > 4096-node_block.low_key_pos+1  then go to FAIL10;
      554 						/* Scattered free key storage space must not be	*/
      555 						/*   larger than key storage region of the node.	*/
      556 		     if node_block.scat_space < 0 then go to FAIL11;
      557 						/*   nor can scattered space be negative.	*/
      558 		     Nkey_bytes_in_node = 0;
      559 		     do Ibranch = 1 to node_block.last_branch_num-1;
      560 			Nkey_bytes_in_node = Nkey_bytes_in_node + node_block.key_length(Ibranch);
      561 			end;			/* Check that scat_space and low_key_pos are	*/
      562 						/*   consistent with all key lengths.		*/
      563 		     if Nkey_bytes_in_node ^= 4096 - node_block.low_key_pos + 1 - node_block.scat_space then
      564 			go to FAIL12;
      565 		     end;
      566 
      567 		if Smode.key_loc | Smode.key_order then
      568 		do Ibranch = 1 to node_block.last_branch_num-1;
      569 		     if Smode.key_loc then do;
      570 			if node_block.key_pos(Ibranch) < node_block.low_key_pos  then go to FAIL13;
      571 			if node_block.key_pos(Ibranch)+node_block.key_length(Ibranch)-1  >  4096  then go to FAIL14;
      572 			end;			/* Each key's storage must be in the key storage	*/
      573 						/*   region of the node.			*/
      574 
      575 		     if Smode.key_order then do;
      576 			if Ibranch < node_block.last_branch_num - 1 then
      577 			if substr(keys, node_block.key_pos(Ibranch), node_block.key_length(Ibranch)) >
      578 			   substr(keys, node_block.key_pos(Ibranch+1), node_block.key_length(Ibranch+1)) then
      579 			     go to FAIL16;		/* Make sure keys are in ascending ASCII 	*/
      580 			end;			/*   collating sequence in node.		*/
      581 		     end;
      582 
      583 		if Smode.key_overlap then do;
      584 		     node_bits = ""b;
      585 		     do Ibranch = 1 to node_block.last_branch_num - 1;
      586 			Pnode_bit_overlay = addr(node_bit_array(node_block.key_pos(Ibranch)));
      587 			Lnode_bit_overlay = node_block.key_length(Ibranch);
      588 			if node_bit_overlay ^= ""b then go to FAIL15;
      589 			node_bit_overlay = ^node_bit_overlay;
      590 			end;			/* Make sure each by of key storage is used for	*/
      591 		     end;				/*   only one key.				*/
      592 
      593 		if Smode.node_tree then do;
      594 		     aki.descrip = 0;		/* Add a key to temp vfile_ for each node as it	*/
      595 						/*   is processed.				*/
      596 		     if comp_num = root_numb_key.comp then
      597 		     if (Inode-1)*1024 = root_numb_key.node then do;
      598 			numb_key.comp = -1;		/* Root node has no parent.			*/
      599 			numb_key.node = 0;
      600 			aki.descrip = numb_key_numb;
      601 			end;
      602 		     numb_key.comp = comp_num;
      603 		     numb_key.node = (Inode-1) * 1024;
      604 		     aki.key = numb_key_str;
      605 		     call iox_$control (Piocb_node_tree, "add_key", addr(aki), code);
      606 						/* It is not an error if the key already exists	*/
      607 						/*   since node may have been referenced by 	*/
      608 						/*   sons_ptr of its parent node (checked 	*/
      609 						/*   earlier), and the key would have been created*/
      610 						/*   at that earlier reference.		*/
      611 
      612 		     do Ibranch = 1 to node_block.last_branch_num;
      613 						/* Now check all sons_ptrs of this node.	*/
      614 			if node_block.branch(Ibranch) ^= 0 then do;
      615 			     branch_numb_key_numb = node_block.branch(Ibranch);
      616 			     if branch_numb_key_numb = root_numb_key_numb then
      617 				call tell$root_sons_ptr;
      618 						/* Error for sons_ptr to reference root node.	*/
      619 			     else do;
      620 				do temp_comp_num = 0,
      621 				     index_state_block.index_tail_comp_num
      622 				     repeat (comp_table(temp_comp_num).comp_link)
      623 				     while (temp_comp_num ^= 0);
      624 				     if temp_comp_num = branch_numb_key.comp then
      625 					go to SON_OK_SO_FAR;
      626 				     end;
      627 				call tell$non_node_comp_son();
      628 						/* Error for sons_ptr to reference a component	*/
      629 						/*   which contains records rather than key nodes.*/
      630 				go to SKIP_SON;
      631 
      632 SON_OK_SO_FAR:			Pnode1 = get_ptr (branch_numb_key_numb);
      633 				if Pfree_nodes ^= null then do;
      634 						/* See if son is a free node.			*/
      635 				     do Ifn = 1 to free_nodes.N while (Pnode1 ^= free_nodes.node(Ifn));
      636 					end;
      637 				     if Ifn <= free_nodes.N then do;
      638 					call tell$free_son();
      639 					go to SKIP_SON;
      640 					end;	/* Error for sons_ptr to reference freed node.	*/
      641 				     end;
      642 				if Pnode1 -> node_block.last_branch_num = 0 then do;
      643 				     call tell$empty_son();
      644 				     go to SKIP_SON;
      645 				     end;		/* Error for sons_ptr to reference an empty node. */
      646 
      647 				aki.key = branch_numb_key_str;
      648 						/* Now add key relating this node (parent) to its */
      649 						/*   son.					*/
      650 				aki.descrip = numb_key_numb;
      651 				call iox_$control (Piocb_node_tree, "add_key", addr(aki), code);
      652 				if code = error_table_$key_duplication then do;
      653 				     gki.key = aki.key;
      654 				     call iox_$control (Piocb_node_tree, "get_key", addr(gki), code);
      655 				     if code = 0 then 
      656 				     if gki.descrip ^= 0 then 
      657 					call tell$dup_son_ptr ();
      658 						/* Error if node is son of another parent.	*/
      659 				     else do;	/* If key already exists with zero descriptor,	*/
      660 						/*   that means it was created earlier during	*/
      661 						/*   checking of the sons node.  We'll set the	*/
      662 						/*   key's descriptor to establish parent/son map.*/
      663 					rki.old_descrip = gki.descrip;
      664 					rki.new_descrip = aki.descrip;
      665 					rki.key = aki.key;
      666 					call iox_$control (Piocb_node_tree, "reassign_key",
      667 					     addr(rki), code);
      668 					end;
      669 				     end;
      670 SKIP_SON:				end;
      671 			     end;
      672 			end;
      673 		     end;
      674 
      675 		go to NEXT_NODE;			/* All tests passed if we get here.		*/
      676 
      677 FAIL6:		call tell ("branch_count > 313", 6);
      678 		go to NEXT_NODE;
      679 		
      680 FAIL7:		call tell ("branch_count < 0", 7);
      681 		go to NEXT_NODE;
      682 
      683 FAIL8:		call tell ("start_of_key_region > character position 4096", 8);
      684 		go to NEXT_NODE;
      685 		
      686 FAIL9:		call tell ("start_of_key_region overlays node_block structure", 9);
      687 		go to NEXT_NODE;
      688 		
      689 FAIL10:		call tell ("scattered_free_key_space > 4096-start_of_key_region", 10);
      690 		go to NEXT_NODE;
      691 
      692 FAIL11:		call tell ("scattered_free_key_space < 0", 11);
      693 		go to NEXT_NODE;
      694 
      695 FAIL12:		call tell ("4096 - start_of_key_region - scattered_free_space ^= sum(key_lengths)", 12);
      696 		go to NEXT_NODE;
      697 
      698 FAIL13:		call tell ("Key(" || ltrim(char(Ibranch)) ||
      699 		     ") begins before start_of_key_region", 13);
      700 		go to NEXT_NODE;
      701 		
      702 FAIL14:		call tell ("Key(" || ltrim(char(Ibranch)) ||
      703 		     ") extends beyond end of node", 14);
      704 		go to NEXT_NODE;
      705 
      706 FAIL15:		call tell ("Key(" || ltrim(char(Ibranch)) ||
      707 		     ") overlaps storage for other keys in node", 15);
      708 		go to NEXT_NODE;
      709 
      710 FAIL16:		call tell ("Key(" || ltrim(char(Ibranch)) || ") > Key(" ||
      711 		     ltrim(char(Ibranch+1)) || ")", 16);
      712 		go to NEXT_NODE;
      713 
      714 NEXT_NODE:	end;
      715 
      716 	     if Nbad_nodes_in_comp > 0 then		/* Report findings in this component of file.	*/
      717 		call ioa_ ("^/^d bad node^[s^] in comp ^d",
      718 		     Nbad_nodes_in_comp, Nbad_nodes_in_comp^=1, comp_num);
      719 	     end;
      720 
      721 	fs_info.info_version = vfs_version_1;
      722 	if Smode.node_tree then do;			/* Now check to be sure that each non-empty	*/
      723 						/*   node but root is son of some parent node.	*/
      724 	     call iox_$control (Piocb_node_tree, "file_status", addr(fs_info), code);
      725 	     call ioa_ ("^/Begin checking references between ^d non-empty tree nodes:",
      726 		fs_info.num_keys);
      727 	     call iox_$position (Piocb_node_tree, -1, 0, code);
      728 	     gki.input_key = FALSE;
      729 	     gki.current = TRUE;
      730 	     call iox_$control (Piocb_node_tree, "get_key", addr(gki), code);
      731 	     Inode = 0;
      732 	     do while (code = 0);
      733 	          Inode = Inode + 1;
      734 	          if mod(Inode,100) = 0 then
      735 		     call ioa_$nnl (" ^d", Inode);
      736 		numb_key_str = gki.key;
      737 		if numb_key_numb = root_numb_key_numb then;
      738 		else if gki.descrip = 0 then 
      739 		     call tell$unreferenced_node();
      740 		call iox_$position (Piocb_node_tree, 0, 1, code);
      741 		if code = 0 then
      742 		     call iox_$control (Piocb_node_tree, "get_key", addr(gki), code);
      743 		end;
      744 	     end;
      745 	call iox_$control (Piocb, "file_status", addr(fs_info), code);
      746 	if Nnon_empty_nodes ^= fs_info.nodes then
      747 	     call tell$bad_node_count_in_header();
      748 	if Nkeys ^= fs_info.num_keys then
      749 	     call tell$bad_key_count_in_header();
      750 	if Nkey_bytes ^= fs_info.key_bytes then
      751 	     call tell$bad_key_byte_count_in_header();
      752 
      753 QUIT:	if Nbad_nodes > 0 then			/* Report findings for the entire file.		*/
      754 	     call ioa_ ("^/^d key node^[s were^; was^] damaged.", Nbad_nodes,
      755 	          Nbad_nodes^=1);
      756 	else call ioa_ ("^/No damaged nodes.");
      757 FINISH:	call janitor();
      758 	if ^Scommand then				/* Return true/false when invoked as active fcn.	*/
      759 	     if Nbad_nodes > 0 then
      760 		ret = "true";
      761 	     else ret = "false";
      762 	return;
      763 
      764 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      765 
      766 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      767 
      768 
      769 janitor:	proc;
      770 
      771 	if Piocb_node_tree ^= null then do;
      772 	     call iox_$close (Piocb_node_tree, code);
      773 	     call iox_$detach_iocb (Piocb_node_tree, code);
      774 	     call iox_$destroy_iocb (Piocb_node_tree, code);
      775 	     call delete_$path (get_pdir_(), "vfbn." || unique, "100100"b, proc, code);
      776 	     end;
      777 
      778 	if Piocb ^= null then do;
      779 	     if Sopened then
      780 		call iox_$close (Piocb, code);
      781 	     if Sattached then do;
      782 		call iox_$detach_iocb (Piocb, code);
      783 		call iox_$destroy_iocb (Piocb, code);
      784 		end;
      785 	     end;
      786 	if Pfree_nodes ^= null then
      787 	     call release_temp_segment_ (proc, Pfree_nodes, code);
      788 	if mode_string_info_ptr ^= null then
      789 	     free mode_string_info in (area);
      790 
      791 	end janitor;
      792 
      793 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      794 
      795 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      796 
      797 
      798 get_ptr:	proc (descriptor) returns(ptr);		/* Given a vfile_ descriptor, this procedure	*/
      799 						/*   returns a corresponding pointer.		*/
      800     dcl	descriptor		fixed (35);
      801     dcl	1 desc			like designator_struct aligned based (addr (descriptor));
      802 
      803 	if desc.comp_num < lbound(seg_ptr_array,1) then do;
      804 	     call tell$bad_desc ("Bad descriptor ignored", 25, descriptor);
      805 	     return (null);				/* Component number in descriptor must be within	*/
      806 	     end;					/*   bounds of the set_ptr_array in file base.	*/
      807 	if desc.comp_num > hbound(seg_ptr_array,1) then do;
      808 	     call tell$bad_desc ("Descriptor with segno > " || ltrim(char(hbound(seg_ptr_array,1))),
      809 		     26, descriptor);
      810 	     return(null);
      811 	     end;
      812 
      813 	return (addr (seg_ptr_array (desc.comp_num) -> seg_array (fixed (desc.offset))));
      814 
      815      end get_ptr;
      816 
      817 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      818 
      819 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      820 
      821 
      822 tell:	proc (msg, fail_num);			/* This procedure reports errors on a node-by-node*/
      823 						/*   basis, and managed the request loop.	*/
      824 
      825      dcl	msg			char(*),
      826 	fail_num			fixed bin;
      827      
      828 	Nbad_nodes = Nbad_nodes + 1;			/* Increment counts and report errors.		*/
      829 	Nbad_nodes_in_comp = Nbad_nodes_in_comp + 1;
      830 	if Stotal then return;
      831 	call ioa_ ("^/ERROR ^d in Comp ^d, node ^d (node_ptr = ^p)
      832 ^a
      833     branch_count = ^d keys
      834     start_of_key_region = char position ^d
      835     key_space = ^d chars,
      836     scattered_free_key_space = ^d chars",
      837 	     fail_num, comp_num, Inode, node_ptr, msg,
      838 	     node_block.last_branch_num, node_block.low_key_pos,
      839 	     4096-node_block.low_key_pos+1, node_block.scat_space);
      840 
      841 REQUEST_LOOP:
      842 	if ^Srequest_loop then return;
      843 	on program_interrupt go to INPUT;
      844 INPUT:	call ioa_$nnl ("vfile_find_bad_nodes:  ");
      845 	call iox_$get_line (iox_$user_input, addr(LINE), length(LINE), Lread, code);
      846 	line = ltrim(rtrim(substr(LINE,1,Lread), HT_SP_NL), HT_SP);
      847 
      848 	if substr(line,1,2) = ".." then do;
      849 	     substr(line,1,2) = "  ";
      850 	     call cu_$cp (addr(substr(line,1)), length(line), code);
      851 	     go to INPUT;
      852 	     end;
      853 	else if line = "?" then do;
      854 PROMPT:	     call ioa_ ("Respond: quit(q), continue(c), total(tt), ., ?, ..");
      855 	     go to INPUT;
      856 	     end;
      857 	else if line = "q" | line = "quit" then go to QUIT;
      858 	else if line = "c" | line = "continue" then;
      859 	else if line = "tt" | line = "total" then
      860 	     Stotal = TRUE;
      861 	else if line = "." then do;
      862 	     call ioa_ ("vfile_find_bad_nodes 1.0, Referencing ^[file ^a^s^;switch ^s^a^].",
      863 		Spathname, pathname, input_switch_name);
      864 	     go to INPUT;
      865 	     end;
      866 	else do;
      867 	     call ioa_$nnl ("Incorrect response.  ");
      868 	     go to PROMPT;
      869 	     end;
      870 	revert program_interrupt;
      871 	return;
      872 
      873 tell$bad_desc:
      874 	entry (msg, fail_num, descriptor);
      875 
      876      dcl	descriptor		fixed bin(35);
      877 
      878 	call ioa_ ("^/ERROR ^d in converting record descriptor ^w: ^a",
      879 	     fail_num, descriptor, msg);
      880 	go to REQUEST_LOOP;
      881 
      882 
      883 tell$bad_free_node:
      884 	entry (msg, fail_num, Pfree_node);
      885 
      886      dcl	Pfree_node		ptr;
      887 
      888 	call ioa_ ("^/ERROR ^d in processing free node (node_ptr = ^p): ^a",
      889 	     fail_num, Pfree_node, msg);
      890 	Nbad_nodes = Nbad_nodes + 1;
      891 	go to REQUEST_LOOP;
      892 
      893 
      894 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      895 	/*									*/
      896 	/* The next three error routines simply report errors in the file_base without entering	*/
      897 	/* the request loop.							*/
      898 	/*									*/
      899 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      900 
      901 tell$bad_key_byte_count_in_header:
      902 	entry();
      903 
      904 	call ioa_ ("
      905 ERROR 2, Counted key bytes (^d) ^= file_state_block.total_key_length (^d)
      906 Header of the file (file_base) may have been damaged.",
      907 	     Nkey_bytes, fs_info.key_bytes);
      908 	return;
      909 	
      910 
      911 tell$bad_key_count_in_header:
      912 	entry();
      913 
      914 	call ioa_ ("
      915 ERROR 3, Counted keys (^d) ^= file_state_block.number_of_keys (^d).
      916 Header of the file (file_base) may have been damaged.",
      917 	     Nkeys, fs_info.num_keys);
      918 	return;
      919 
      920 
      921 tell$bad_node_count_in_header:
      922 	entry();
      923 
      924 	call ioa_ ("
      925 ERROR 1, Counted nodes (^d) ^= index_state_block.number_of_nodes (^d)
      926 Header of the file (file_base) may have been damaged.",
      927 	     Nnon_empty_nodes, fs_info.nodes);
      928 	return;
      929 
      930 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      931 	/*									*/
      932 	/* The following errors are non-fatal.  Checking of the node containing the error	*/
      933 	/* continues after return from request loop.					*/
      934 	/*									*/
      935 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      936 
      937 tell$dup_son_ptr:
      938 	entry;
      939 
      940 	Nbad_nodes = Nbad_nodes + 1;
      941 	Nbad_nodes_in_comp = Nbad_nodes_in_comp + 1;
      942 	if Stotal then return;
      943 	save_numb_key_numb = numb_key_numb;
      944 	Pnode1 = get_ptr (aki.descrip);
      945 	Pnode2 = get_ptr (gki.descrip);
      946 	call ioa_ ("
      947 ERROR 22 in Comp ^d, node ^d (node_ptr = ^p)", comp_num, Inode, node_ptr);
      948 	numb_key_numb = aki.descrip;
      949 	numb_key.node = divide(numb_key.node, 1024, 18, 0) + 1;
      950 	call ioa_ ("Branch ^d has same sons_ptr (node_block.branch)
      951             Comp ^d, node ^d (node_ptr = ^p)",  numb_key.comp, numb_key.node, Pnode1);
      952 	numb_key_numb = gki.descrip;
      953 	numb_key.node = divide(numb_key.node, 1024, 18, 0) + 1;
      954 	call ioa_ ("         as Comp ^d, node ^d (node_ptr = ^p)", numb_key.comp, numb_key.node, Pnode2);
      955 	numb_key_numb = save_numb_key_numb;
      956 	go to REQUEST_LOOP;
      957 
      958 tell$empty_son:
      959 	entry();
      960 
      961 	Nbad_nodes = Nbad_nodes + 1;
      962 	Nbad_nodes_in_comp = Nbad_nodes_in_comp + 1;
      963 	if Stotal then return;
      964 	save_numb_key_numb = numb_key_numb;
      965 	numb_key_numb = gki.descrip;
      966 	numb_key.node = divide(numb_key.node, 1024, 18, 0) + 1;
      967 	Pnode1 = get_ptr (gki.descrip);
      968 	call ioa_ ("
      969 ERROR 18 in Comp ^d, node ^d (node_ptr = ^p)
      970 Branch ^d has sons_ptr (node_block.branch) pointing to an empty node
      971             Comp ^d, node ^d (node_ptr = ^p)",
      972 	     comp_num, Inode, node_ptr, Ibranch,
      973 	   numb_key.comp, numb_key.node, Pnode1);
      974 	numb_key_numb = save_numb_key_numb;
      975 	go to REQUEST_LOOP;
      976 
      977 tell$free_son:
      978 	entry ();
      979 
      980 	Nbad_nodes = Nbad_nodes + 1;
      981 	Nbad_nodes_in_comp = Nbad_nodes_in_comp + 1;
      982 	if Stotal then return;
      983 	save_numb_key_numb = numb_key_numb;
      984 	numb_key_numb = gki.descrip;
      985 	numb_key.node = divide(numb_key.node, 1024, 18, 0) + 1;
      986 	Pnode1 = get_ptr (gki.descrip);
      987 	call ioa_ ("
      988 ERROR 19 in Comp ^d, node ^d (node_ptr = ^p)
      989 Branch ^d has sons_ptr (node_block.branch) which is a freed node
      990 	  Comp ^d, node ^d (node_ptr = ^p)",
      991 	     comp_num, Inode, node_ptr, Ibranch, numb_key.comp,
      992 	   numb_key.node, Pnode1);
      993 	numb_key_numb = save_numb_key_numb;
      994 	go to REQUEST_LOOP;
      995 
      996 
      997 tell$non_node_comp_son:
      998 	entry ();
      999 
     1000 	Nbad_nodes = Nbad_nodes + 1;
     1001 	Nbad_nodes_in_comp = Nbad_nodes_in_comp + 1;
     1002 	if Stotal then return;
     1003 	save_numb_key_numb = numb_key_numb;
     1004 	numb_key_numb = gki.descrip;
     1005 	numb_key.node = divide(numb_key.node, 1024, 18, 0) + 1;
     1006 	Pnode1 = get_ptr (gki.descrip);
     1007 	call ioa_ ("
     1008 ERROR 17 in Comp ^d, node ^d (node_ptr = ^p)
     1009 Branch ^d has sons_ptr (node_block.branch) pointing to non-node component
     1010             Comp ^d, node ^d (node_ptr = ^p)",
     1011 	     comp_num, Inode, node_ptr, Ibranch, numb_key.comp,
     1012 	     numb_key.node, Pnode1);
     1013 	numb_key_numb = save_numb_key_numb ;
     1014 	go to REQUEST_LOOP;
     1015 
     1016 tell$root_sons_ptr:
     1017 	entry();
     1018 
     1019 	Nbad_nodes_in_comp = Nbad_nodes_in_comp + 1;
     1020 	Nbad_nodes = Nbad_nodes + 1;
     1021 	if Stotal then return;
     1022 	Pnode1 = get_ptr (branch_numb_key_numb);
     1023 	branch_numb_key.node = divide(branch_numb_key.node, 1024, 18, 0) + 1;
     1024 	call ioa_ ("
     1025 ERROR 20 in Comp ^d, node ^d (node_ptr = ^p)
     1026 Branch ^d sons_ptr (node_block.branch) points to root node
     1027             Comp ^d, node ^d (node_ptr = ^p)",
     1028 	     comp_num, Inode, node_ptr, Ibranch, branch_numb_key.comp,
     1029 	     branch_numb_key.node, Pnode1);
     1030 	go to REQUEST_LOOP;
     1031 
     1032 
     1033 tell$unreferenced_node:
     1034 	entry();
     1035 
     1036 	Nbad_nodes = Nbad_nodes + 1;
     1037 	if Stotal then return;
     1038 	node_ptr = get_ptr (numb_key_numb);
     1039 	call ioa_ ("
     1040 ERROR 21, Comp ^d, node ^d (node_ptr = ^p) never referenced by 
     1041 superior node and it is not the root node.",
     1042 	     numb_key.comp, divide(numb_key.node,1024,18,0) + 1, node_ptr);
     1043 	go to REQUEST_LOOP;
     1044 
     1045 	end tell;
     1046 
     1047 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
     1048 
  1     1 /* ak_info -- include file for info structures used by the following vfile_
  1     2*   control orders: "add_key", "delete_key", "get_key", and "reassign_key".
  1     3*   Created by M. Asherman 3/23/76
  1     4*   Modified 5/13/77 to add separate gk_info structure */
  1     5 
  1     6      dcl	   1 ak_info	      based (ak_info_ptr),
  1     7 	     2 header	      like ak_header,
  1     8 	     2 key	      char (ak_key_len refer (ak_info.header.key_len));
  1     9 
  1    10      dcl	   1 ak_header	      based (ak_info_ptr),
  1    11 	     2 flags	      aligned,
  1    12 	       3 input_key	      bit (1) unal,		/* set if key is input arg */
  1    13 	       3 input_desc	      bit (1) unal,		/* set if descriptor is an input arg */
  1    14 	       3 mbz	      bit (34) unal,	/* not used for the present */
  1    15 	     2 descrip	      fixed (35),		/* record designator */
  1    16 	     2 key_len	      fixed;
  1    17 
  1    18      dcl	   ak_info_ptr	      ptr;
  1    19      dcl	   ak_key_len	      fixed;
  1    20 
  1    21 
  1    22      dcl	   1 rk_info	      based (rk_info_ptr),
  1    23 	     2 header	      like rk_header,
  1    24 	     2 key	      char (rk_key_len refer (rk_info.header.key_len));
  1    25 
  1    26      dcl	   1 rk_header	      based (rk_info_ptr),
  1    27 	     2 flags	      aligned,
  1    28 	       3 input_key	      bit (1) unal,		/* same as above */
  1    29 	       3 input_old_desc   bit (1) unal,		/* set if specified entry has initial descrip
  1    30*						   given by old_descrip */
  1    31 	       3 input_new_desc   bit (1) unal,		/* set if new val for descrip is input in this struc */
  1    32 	       3 mbz	      bit (33) unal,
  1    33 	     2 old_descrip	      fixed (35),		/* used if first flag is set */
  1    34 	     2 new_descrip	      fixed (35),		/* used only if second flag is set */
  1    35 	     2 key_len	      fixed;
  1    36 
  1    37      dcl	   rk_info_ptr	      ptr;
  1    38      dcl	   rk_key_len	      fixed;
  1    39 
  1    40 
  1    41      dcl	   1 gk_info	      based (gk_info_ptr),	/* structure for get_key order */
  1    42 	     2 header	      like gk_header,
  1    43 	     2 key	      char (gk_key_len refer (gk_info.header.key_len));
  1    44 						/* may be Input as well as Output */
  1    45 
  1    46      dcl	   1 gk_header	      based (gk_info_ptr),
  1    47 	     2 flags	      aligned,
  1    48 	       3 input_key	      bit (1) unal,		/* if set, use key in this structure */
  1    49 	       3 input_desc	      bit (1) unal,		/* if set, descriptor given in this structure */
  1    50 	       3 desc_code	      fixed (2) unal,	/* 0=any, 1=current -- applies when input_desc="0"b */
  1    51 	       3 position_specification
  1    52 			      unal,
  1    53 	         4 current	      bit (1) unal,		/* otherwise next */
  1    54 	         4 rel_type	      fixed (2) unal,	/* as in seek_head, if input_key = "1"b */
  1    55 	         4 head_size      fixed bin (9) unsigned unaligned,
  1    56 						/* size of head for initial seek */
  1    57 	       3 reset_pos	      bit (1) unal,		/* if set, final position unchanged by this operation */
  1    58 	       3 pad	      bit (8) unal,
  1    59 	       3 version	      fixed (8) unal,
  1    60 	     2 descrip	      fixed (35),		/* Output, except when input_desc="1"b */
  1    61 	     2 key_len	      fixed;		/* Input when input_key="1"b, also Output in all cases */
  1    62 
  1    63      dcl	   gk_info_ptr	      ptr;
  1    64      dcl	   gk_key_len	      fixed;
  1    65 
  1    66      dcl	   gk_info_version_0      internal static fixed options (constant) init (0);
  1    67 
  1    68 /* end ak_info.incl.pl1 */
     1049 
     1050 
     1051     dcl	1 aki			aligned,
     1052 	  2 header		like ak_header,
     1053 	  2 key			char(4),
     1054 	1 gki			aligned,
     1055 	  2 header		like gk_header,
     1056 	  2 key			char(4),
     1057 	1 rki			aligned,
     1058 	  2 header		like rk_header,
     1059 	  2 key			char(4);
     1060 
  2     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  2     2 
  2     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  2     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  2     5 
  2     6 declare	mode_value_ptr		ptr,
  2     7 	number_of_modes		fixed bin;
  2     8 
  2     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  2    10 	  2 version		fixed bin,
  2    11 	  2 number		fixed bin,
  2    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  2    13 
  2    14 declare	mode_string_info_ptr	ptr;
  2    15 
  2    16 declare	1 mode_value		aligned based (mode_value_ptr),
  2    17 	  2 version		fixed bin,
  2    18 	  2 mode_name		char (32) unaligned,
  2    19 	  2 flags,
  2    20 	    3 boolean_valuep	bit (1) unaligned,
  2    21 	    3 numeric_valuep	bit (1) unaligned,
  2    22 	    3 char_valuep		bit (1) unaligned,
  2    23 	    3 boolean_value		bit (1) unaligned,
  2    24 	    3 pad1		bit (32) unaligned,
  2    25 	  2 numeric_value		fixed bin (35),
  2    26 	  2 char_value		char (32) varying,
  2    27 	  2 code			fixed bin (35),
  2    28 	  2 pad2			bit (36);
  2    29 
  2    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  2    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  2    32 
  2    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
     1061 
     1062 
  3     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  3     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  3     3*      version number to IOX2. */
  3     4 /* format: style2 */
  3     5 
  3     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  3     7 	     2 version	      character (4) aligned,	/* IOX2 */
  3     8 	     2 name	      char (32),		/* I/O name of this block. */
  3     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  3    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  3    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  3    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  3    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  3    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  3    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  3    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  3    17 						/* open(p,mode,not_used,s) */
  3    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  3    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  3    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  3    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    24 						/* put_chars(p,bufptr,buflen,s) */
  3    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  3    26 						/* modes(p,newmode,oldmode,s) */
  3    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  3    28 						/* position(p,u1,u2,s) */
  3    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  3    30 						/* control(p,order,infptr,s) */
  3    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  3    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  3    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  3    34 						/* write_record(p,bufptr,buflen,s) */
  3    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  3    36 						/* rewrite_record(p,bufptr,buflen,s) */
  3    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  3    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    39 						/* seek_key(p,key,len,s) */
  3    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  3    41 						/* read_key(p,key,len,s) */
  3    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  3    43 						/* read_length(p,len,s) */
  3    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  3    45 						/* open_file(p,mode,desc,not_used,s) */
  3    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  3    47 						/* close_file(p,desc,s) */
  3    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  3    49 						/* detach(p,desc,s) */
  3    50 
  3    51      declare iox_$iocb_version_sentinel
  3    52 			      character (4) aligned external static;
  3    53 
  3    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
     1063 
     1064 
  4     1 /* Begin include file ..... iox_modes.incl.pl1 */
  4     2 
  4     3 /* Written by C. D. Tavares, 03/17/75 */
  4     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  4     5 
  4     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  4     7     ("stream_input", "stream_output", "stream_input_output",
  4     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  4     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  4    10      "direct_input", "direct_output", "direct_update");
  4    11 
  4    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  4    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  4    14 
  4    15 dcl (Stream_input initial (1),
  4    16      Stream_output initial (2),
  4    17      Stream_input_output initial (3),
  4    18      Sequential_input initial (4),
  4    19      Sequential_output initial (5),
  4    20      Sequential_input_output initial (6),
  4    21      Sequential_update initial (7),
  4    22      Keyed_sequential_input initial (8),
  4    23      Keyed_sequential_output initial (9),
  4    24      Keyed_sequential_update initial (10),
  4    25      Direct_input initial (11),
  4    26      Direct_output initial (12),
  4    27      Direct_update initial (13)) fixed bin int static options (constant);
  4    28 
  4    29 /* End include file ..... iox_modes.incl.pl1 */
     1065 
     1066 
  5     1 /* the control block */
  5     2      dcl	   indx_cb_ptr	      ptr;
  5     3      dcl	   1 indx_cb	      based (indx_cb_ptr),	/* except as noted, init by create cb */
  5     4 	     2 fcb_ptr	      ptr,
  5     5 	     2 file_base_ptr      ptr,
  5     6 	     2 node_length	      fixed,		/* number of bytes in node, init by create_seg_ptrs */
  5     7 	     2 half_node_length   fixed,		/* init by create_seg_ptrs */
  5     8 	     2 max_record_size    fixed (21),		/* init by create_seg_ptrs */
  5     9 	     2 seg_ptr_array_ptr  ptr,		/* init by create seg_ptrs */
  5    10 	     2 seg_ptr_array_limit
  5    11 			      fixed,		/* init by create seg_ptrs */
  5    12 	     2 mode	      fixed,
  5    13 	     2 is_sequential_open bit (1) aligned,
  5    14 	     2 is_read_only	      bit (1) aligned,
  5    15 	     2 is_ks_out	      bit (1) aligned,	/* position info */
  5    16 	     2 position_stack_ptr ptr,		/* init by create_position stack */
  5    17 	     2 position_stack_height
  5    18 			      fixed,		/* init by create position stack */
  5    19 	     2 root_position_ptr  ptr,		/* init by create_position_stack */
  5    20 	     2 file_position_ptr  ptr,		/* not init */
  5    21 	     2 change_position_ptr
  5    22 			      ptr,		/* not init */
  5    23 						/* auxiliary variables  */
  5    24 	     2 rover_seg_ptr      ptr,		/* init by create_seg_ptrs */
  5    25 	     2 index_state_ptr    ptr,		/* init by create_seg_ptrs */
  5    26 	     2 old_index_height   fixed,
  5    27 	     2 old_last_comp_num  fixed,
  5    28 	     2 last_change_count  fixed (35),
  5    29 	     2 wait_time	      fixed (35),
  5    30 	     2 old_rover_comp_num fixed,
  5    31 	     2 file_state_ptr     ptr,
  5    32 	     2 o_s_ptr	      ptr,
  5    33 	     2 repeating	      bit (1) aligned,
  5    34 	     2 next_substate      fixed,
  5    35 	     2 file_program_version
  5    36 			      fixed,		/* used for record_lock compatibility */
  5    37 	     2 leave_locked	      bit (1) aligned,	/* indicates use of set_file_lock order */
  5    38 	     2 dup_ok	      bit (1) aligned,	/* if set, duplicate keys may occur */
  5    39 	     2 read_exclu	      bit (1) aligned,	/* set when lock excludes readers */
  5    40 	     2 pos_incorrect      bit (1) aligned,	/* indicates index position is not current */
  5    41 	     2 saved_lock_copy    bit (36) aligned,	/* copy of process lock_id */
  5    42 	     2 min_key_len	      fixed,		/* non-zero only in old programs */
  5    43 	     2 stat	      bit (1) aligned,	/* causes write_record to create stationary records */
  5    44 	     2 current_subset     fixed (34),		/* used with select order */
  5    45 	     2 last_subset	      fixed (34),
  5    46 	     2 subset_count	      fixed (34),		/* count of descriptors in current subset */
  5    47 	     2 temp_iocbp	      ptr,		/* temporary file used to implement select order */
  5    48 	     2 trans	      bit (1) aligned,	/* set if -transaction attachment */
  5    49 	     2 transaction_code   fixed (35),		/* set for control switch only */
  5    50 	     2 tcfp	      ptr,		/* ptr to iocb for transaction control switch--if applicable */
  5    51 	     2 reflp	      ptr,		/* ptr to ref list file, set only in transaction control file */
  5    52 	     2 uid	      bit (36) aligned,	/* used under -transaction */
  5    53 	     2 collection_delay_time
  5    54 			      fixed (35),		/* microseconds to wait before garbage removal */
  5    55 	     2 min_res	      fixed (21),		/* for min_block_size order */
  5    56 	     2 min_cap	      fixed (21),		/* also for min_block_size order */
  5    57 	     2 subset_selected    bit (2) aligned,	/* first bit for select, second
  5    58*						   bit is for exclude */
  5    59 	     2 error,				/* for error_status order */
  5    60 	       3 type	      fixed,		/* only one error type supported now */
  5    61 	       3 requested	      fixed (34),		/* skip arg given to position entry */
  5    62 	       3 received	      fixed (34),		/* actual successful skips */
  5    63 	     2 state_vars,
  5    64 	       3 fixed_state_part,
  5    65 	         4 shared	      bit (1) aligned,
  5    66 	         4 next_record_position
  5    67 			      fixed,		/* 0, 1, or 2 */
  5    68 	         4 current_record_is_valid
  5    69 			      bit (1) aligned,
  5    70 	         4 ready_to_write bit (1) aligned,
  5    71 	         4 at_eof_or_bof,
  5    72 		 5 at_bof	      bit (1) unal,
  5    73 		 5 at_eof	      bit (1) unal,
  5    74 		 5 pad	      bit (36) unal,
  5    75 	         4 outside_index  bit (1) aligned,	/* set after deleting current key or after use of record_status with locate switch */
  5    76 	         4 current_descrip
  5    77 			      fixed (35),		/* needed when outside index */
  5    78 	         4 saved_descrip  fixed (35),		/* for restoring index position */
  5    79 	         4 skip_state     fixed,		/* controls scanning of deleted entries */
  5    80 	       3 new_key	      char (256) var;
  5    81 
  5    82      dcl	   current_t_code	      fixed (35) based (addr (indx_cb.tcfp -> iocb.open_data_ptr -> indx_cb.transaction_code));
  5    83 
  5    84 /* component locator structures */
  5    85      dcl	   seg_ptr_array	      (0:seg_ptr_array_limit) ptr based (seg_ptr_array_ptr);
  5    86      dcl	   seg_ptr	      ptr;
  5    87      dcl	   seg_array	      (0:262143) fixed (19) based (seg_ptr) aligned;
  5    88      dcl	   designator	      fixed (35);
  5    89      dcl	   1 ind_des_structure    based,
  5    90 	     2 comp	      fixed (17) unal,
  5    91 	     2 offset	      bit (18) unal;
  5    92      dcl	   1 stat_structure	      based,
  5    93 	     2 pad	      bit (26) unal,
  5    94 	     2 ref_count_after    fixed (16) unsigned unal,
  5    95 	     2 ind_comp	      fixed (13) unal,
  5    96 	     2 ref_count	      fixed (16) unsigned unal,
  5    97 	     2 record_lock	      bit (36) aligned,
  5    98 	     2 modifier	      fixed (35),
  5    99 	     2 time_stamp_words   fixed (71) aligned,
  5   100 	     2 prev_mod	      fixed (35),
  5   101 	     2 record	      char (1000000) var;
  5   102      dcl	   1 ind_structure	      based,
  5   103 	     2 pad	      bit (26) unal,
  5   104 	     2 ref_count_after    fixed (16) unsigned unal,
  5   105 	     2 ind_comp	      fixed (13) unal,
  5   106 	     2 ref_count	      fixed (16) unsigned unal,
  5   107 	     2 record_lock	      bit (36) aligned,
  5   108 	     2 modifier	      fixed (35),
  5   109 	     2 time_stamp_words   fixed (71) aligned,
  5   110 	     2 prev_mod	      fixed (35),
  5   111 	     2 prev_desc	      fixed (35);
  5   112      dcl	   1 time_stamp_structure based,
  5   113 	     2 ind_offset	      bit (18) unal,
  5   114 	     2 time_last_modified fixed (54) unsigned unal;
  5   115      dcl	   1 record_block_structure
  5   116 			      based,
  5   117 	     2 reserved	      aligned,		/* data used by change_record_list */
  5   118 	       3 pad	      bit (2) unal,
  5   119 	       3 block_size	      fixed (19) unal,
  5   120 	       3 lock_flag	      bit (1) unal,		/* record lock flag */
  5   121 	       3 stationary	      bit (1) unal,
  5   122 	       3 indirect	      bit (1) unal,
  5   123 	       3 after_applies    bit (1) unal,
  5   124 	       3 mbz	      bit (10) unal,
  5   125 	     2 block_tail,				/* structure varies with record type */
  5   126 	       3 record	      char (1000000) var;	/* non-stat record location */
  5   127      dcl	   1 designator_struct    aligned based (addr (designator)),
  5   128 	     2 comp_num	      fixed (17) unal,
  5   129 	     2 offset	      bit (18) unal;
  5   130 
  5   131 /* position and node templates */
  5   132      dcl	   1 position_frame	      based (pos_ptr),	/* ref8 */
  5   133 	     2 parent_position_ptr
  5   134 			      ptr,
  5   135 	     2 son_position_ptr   ptr,
  5   136 	     2 node_ptr	      ptr,
  5   137 	     2 node	      fixed (35),
  5   138 	     2 branch_num	      fixed;
  5   139      dcl	   1 node_block	      based (node_ptr),	/* ref9) */
  5   140 	     2 last_branch_num    fixed,
  5   141 	     2 low_key_pos	      fixed,
  5   142 	     2 scat_space	      fixed,
  5   143 	     2 branch_and_descrip (1 refer (node_block.last_branch_num)),
  5   144 						/* in last element only branch is used */
  5   145 	       3 branch	      fixed (35),
  5   146 	       3 descrip,
  5   147 	         4 key_descrip,
  5   148 		 5 key_pos      fixed (17) unal,
  5   149 		 5 key_length   fixed (17) unal,
  5   150 	         4 record_descrip,
  5   151 		 5 record_designator
  5   152 			      fixed (35);
  5   153      dcl	   keys		      char (4096 /* 4*node_size */) based (node_ptr);
  5   154 
  5   155 /* file base and states */
  5   156      dcl	   f_b_ptr	      ptr;
  5   157      dcl	   1 file_base	      based (f_b_ptr),	/* ref10 */
  5   158 	     2 common_header,
  5   159 	       3 file_code	      fixed (35),
  5   160 	       3 lock_word	      bit (36) aligned,
  5   161 	       3 words	      (2) fixed,
  5   162 	     2 file_version	      fixed,
  5   163 	     2 program_version    fixed,
  5   164 	     2 node_size	      fixed (19),
  5   165 	     2 minimum_key_length fixed,
  5   166 	     2 minimum_block_size fixed (19),
  5   167 	     2 max_seg_limit      fixed (19),
  5   168 	     2 root_node_block,
  5   169 	       3 last_branch_num_root
  5   170 			      fixed,		/* =1 */
  5   171 	       3 word	      fixed,
  5   172 	       3 reserved	      fixed,
  5   173 	       3 only_branch_in_root
  5   174 			      fixed (35),
  5   175 	     2 file_state	      fixed,
  5   176 	     2 change_count	      fixed (34),		/* record state info, ref12 */
  5   177 	     2 old_number_of_free_blocks
  5   178 			      fixed (34),
  5   179 	     2 prior_block_size   fixed (19),
  5   180 	     2 old_record_length  fixed (21),
  5   181 	     2 need_new_seg	      bit (1) aligned,
  5   182 	     2 old_residue	      fixed,
  5   183 	     2 new_last_comp_num  fixed,
  5   184 	     2 old_prev_free_block
  5   185 			      fixed (18),
  5   186 	     2 old_next_free_block
  5   187 			      fixed (18),
  5   188 	     2 new_record_length  fixed (21),
  5   189 	     2 old_record_designator
  5   190 			      fixed (35),
  5   191 	     2 prec_block_was_free
  5   192 			      bit (1) aligned,
  5   193 	     2 next_block_was_free
  5   194 			      bit (1) aligned,
  5   195 	     2 former_block_size  fixed (19),
  5   196 	     2 old_init_offset    fixed (18),
  5   197 	     2 old_block_size     fixed (19),
  5   198 	     2 prev_block_size    fixed (19),
  5   199 	     2 former_rover_comp_num
  5   200 			      fixed,
  5   201 	     2 former_rover_offset
  5   202 			      fixed (18),
  5   203 	     2 next_block_size    fixed (19),
  5   204 	     2 next_prev_free_block
  5   205 			      fixed (18),
  5   206 	     2 next_next_free_block
  5   207 			      fixed (18),
  5   208 	     2 saved_ks_out	      bit (1) aligned,
  5   209 	     2 new_descriptor     fixed (35),
  5   210 	     2 old_last_branch_num
  5   211 			      fixed,
  5   212 	     2 old_low_key_pos    fixed,
  5   213 	     2 old_scat_space     fixed,
  5   214 	     2 old_key_pos	      fixed,
  5   215 	     2 rover_comp_num     fixed,
  5   216 	     2 rover_offset	      fixed (18),
  5   217 	     2 old_key_length     fixed,
  5   218 	     2 b_space	      fixed,
  5   219 	     2 last_b_num	      fixed,
  5   220 	     2 count	      fixed,
  5   221 	     2 first_count	      fixed,
  5   222 	     2 second_count	      fixed,
  5   223 	     2 split_num	      fixed,
  5   224 	     2 must_compact_dest  bit (1) aligned,
  5   225 	     2 first_branch	      fixed (35),
  5   226 	     2 min_source_key_pos fixed,
  5   227 	     2 min_dest_key_pos   fixed,
  5   228 	     2 new_low_key_pos    fixed,
  5   229 	     2 new_scat_space     fixed,
  5   230 	     2 old_seg_lim	      fixed (19),
  5   231 	     2 old_number_of_free_nodes
  5   232 			      fixed,
  5   233 	     2 old_next_node_designator
  5   234 			      fixed (35),
  5   235 	     2 new_index_comp_num fixed,
  5   236 	     2 out_of_index	      bit (1) aligned,
  5   237 	     2 saved_min_res      fixed (21),
  5   238 	     2 saved_min_cap      fixed (21),
  5   239 	     2 was_stat	      bit (1) aligned,
  5   240 	     2 was_ind	      bit (1) aligned,
  5   241 	     2 old_ind_desc	      fixed (35),
  5   242 	     2 after_desc	      fixed (35),
  5   243 	     2 old_ref_count      fixed (34),
  5   244 	     2 new_ref_count      fixed (34),
  5   245 	     2 old_num_free	      fixed (34),
  5   246 	     2 old_file_ch_count  fixed (35),
  5   247 	     2 y_count,				/* for conversion of pre-MR6.9 files */
  5   248 	     2 old_modifier	      fixed (35),
  5   249 	     2 was_transaction    bit (1) aligned,	/* state blocks */
  5   250 	     2 index_state	      fixed,
  5   251 	     2 index_state_blocks (0:1),
  5   252 	       3 words	      (104),
  5   253 	     2 reserved	      (30),		/* this free space might come in handy */
  5   254 	     2 old_prev_mod	      fixed (35),
  5   255 	     2 needed_blksz	      fixed (35),
  5   256 	     2 new_desc_val	      fixed (35),
  5   257 	     2 is_partial_deletion
  5   258 			      bit (1) aligned,
  5   259 	     2 reserved2	      (42),
  5   260 	     2 file_state_blocks  (0:1),
  5   261 	       3 words	      (size (file_state_block)) fixed,
  5   262 						/* component info */
  5   263 	     2 max_comp_num	      fixed,
  5   264 	     2 last_comp_num      fixed,
  5   265 	     2 first_free_comp_num,			/* not yet supported */
  5   266 	     2 comp_table_start   (size (comp_table));	/* start of comp_array */
  5   267 
  5   268      dcl	   1 comp_table	      (0:true_max_comp_num) based (addr (file_base.comp_table_start)) aligned,
  5   269 	     2 seg_limit	      fixed (19),		/* abs value is offset of first free word in seg, max val=max
  5   270*						   seg_limit and this indicates full seg */
  5   271 	     2 comp_link	      fixed (17) unal,
  5   272 	     2 init_offset	      fixed (18) unsigned unal;
  5   273 
  5   274      dcl	   1 file_header	      based (f_b_ptr),
  5   275 	     2 first_three_pages  (3, 1024) fixed,
  5   276 	     2 spare_node	      char (4096) aligned;
  5   277 
  5   278 /* The File State */
  5   279      dcl	   fs_ptr		      ptr;
  5   280      dcl	   1 file_state_block     based (fs_ptr),
  5   281 	     2 file_action	      fixed,
  5   282 	     2 file_substate      fixed,
  5   283 	     2 number_of_keys     fixed (34),
  5   284 	     2 duplicate_keys     fixed (34),		/* 0 if no duplications */
  5   285 	     2 dup_key_bytes      fixed (34),
  5   286 	     2 total_key_length   fixed (34),
  5   287 	     2 number_of_records  fixed (34),
  5   288 	     2 total_record_length
  5   289 			      fixed (34),
  5   290 	     2 number_of_allocated_records
  5   291 			      fixed (34),
  5   292 	     2 number_of_free_blocks
  5   293 			      fixed (34),
  5   294 	     2 words	      (2) fixed;
  5   295 
  5   296 /* The Index State */
  5   297      dcl	   is_ptr		      ptr;
  5   298      dcl	   1 index_state_block    based (is_ptr),	/* if this declaration is changed,
  5   299*						   index_state_blocks must be adjusted */
  5   300 	     2 number_of_nodes    fixed (34),
  5   301 	     2 free_node_designator
  5   302 			      fixed (35),
  5   303 	     2 index_tail_comp_num
  5   304 			      fixed,
  5   305 	     2 index_height	      fixed,
  5   306 	     2 index_action	      fixed,
  5   307 	     2 index_substate     fixed,
  5   308 	     2 current_node	      fixed (35),
  5   309 	     2 change_node	      fixed (35),
  5   310 	     2 fake_node,				/* equivalent to a short node because of storage map. It holds
  5   311*						   the new key, new record descrip, and new branch in a fashion
  5   312*						   convenient for overflow-underflow in change_index. */
  5   313 	       3 fake_head_and_descrip,
  5   314 	         4 word1	      fixed,		/* last_branch_num in real node */
  5   315 	         4 word2	      fixed,		/* low_key_pos in real node */
  5   316 	         4 word3	      fixed,		/* normally scat_space */
  5   317 	         4 word4	      fixed,		/* first branch in real node */
  5   318 	         4 new_key_pos    fixed (17) unal,	/* set by initializefile to denote first char
  5   319*						   in new_key_string, never changed */
  5   320 	         4 new_key_length fixed (17) unal,
  5   321 	         4 new_record_descrip,
  5   322 		 5 new_record_designator
  5   323 			      fixed (35),
  5   324 	         4 new_branch     fixed (35),
  5   325 	       3 new_key_string   char (256),
  5   326 	     2 branch_num_adjust  fixed,
  5   327 	     2 pos_array	      (10),
  5   328 	       3 saved_node	      fixed (35),
  5   329 	       3 saved_branch_num fixed;
  5   330 
  5   331      dcl	   1 old_file_base	      based (f_b_ptr),
  5   332 	     2 words1	      (15) fixed,		/* same in both file versions */
  5   333 	     2 old_file_state_blocks
  5   334 			      (0:1),
  5   335 	       3 words	      (5) fixed,
  5   336 	     2 words2	      (7) fixed,
  5   337 	     2 record_state	      fixed,
  5   338 	     2 record_state_blocks
  5   339 			      (0:1),
  5   340 	       3 words	      (4) fixed,
  5   341 	     2 words3	      (14) fixed,		/* rover info same in both versions */
  5   342 	     2 old_version_index_height
  5   343 			      fixed,
  5   344 	     2 old_version_number_of_nodes
  5   345 			      fixed (34),
  5   346 	     2 words4	      (157) fixed,
  5   347 	     2 old_version_index_tail_comp_num
  5   348 			      fixed,
  5   349 	     2 old_version_free_node_designator
  5   350 			      fixed (35),
  5   351 	     2 words5	      (10) fixed,
  5   352 	     2 old_version_comp_info
  5   353 			      fixed,
  5   354 	     2 word,
  5   355 	     2 x_count	      fixed;		/* always zero in old version files */
  5   356 
  5   357 /* External Procedures */
  5   358      dcl	   clock_		      entry returns (fixed (71));
  5   359      dcl	   alloc_cb_file	      entry (fixed,		/* size of block in words */
  5   360 			      ptr);		/* ptr to block */
  5   361      dcl	   free_cb_file	      entry (fixed, ptr);
  5   362      dcl	   get_seg_ptr	      entry (ptr, fixed) returns (ptr);
  5   363      dcl	   make_designator	      entry (fixed, fixed (18), fixed (35));
  5   364      dcl	   create_seg_ptrs	      entry (ptr);
  5   365      dcl	   free_seg_ptrs	      entry (ptr);
  5   366      dcl	   get_new_seg	      entry (ptr, fixed, ptr, fixed, label);
  5   367      dcl	   free_seg	      entry (ptr, fixed, ptr);
  5   368      dcl	   set_bitcounts	      entry (ptr);
  5   369      dcl	   create_position_stack  entry (ptr);
  5   370      dcl	   extend_position_stack  entry (ptr);
  5   371      dcl	   free_position_stack    entry (ptr);
  5   372      dcl	   change_index	      entry (ptr, label);
  5   373      dcl	   change_record_list     entry (ptr, fixed, ptr, label);
  5   374 
  5   375 /* State Constants */
  6     1      dcl	   bumping_count	      static internal options (constant) init (-14);
  6     2      dcl	   rollback_action	      static options (constant) init (-13);
  6     3      dcl	   adjust_action	      static options (constant) init (-12);
  6     4      dcl	   unshared_opening	      static internal fixed options (constant) init (-11);
  6     5      dcl	   non_eof_delete	      static internal fixed options (constant) init (-10);
  6     6      dcl	   free_action	      static options (constant) init (-10);
  6     7      dcl	   write_trunc	      static internal fixed options (constant) init (-9);
  6     8      dcl	   allocate_action	      static options (constant) init (-9);
  6     9      dcl	   reassigning_key	      static options (constant) init (-8);
  6    10      dcl	   read_exclude	      static options (constant) init (-7);
  6    11      dcl	   adding_record	      static options (constant) init (-6);
  6    12      dcl	   deleting_key	      static options (constant) init (-5);
  6    13      dcl	   adding_key	      static options (constant) init (-4);
  6    14      dcl	   delete_action	      static options (constant) init (-3);
  6    15      dcl	   eof_delete	      static internal fixed options (constant) init (-3);
  6    16      dcl	   replace_action	      static options (constant) init (-2);
  6    17      dcl	   rewrite_action	      static internal fixed options (constant) init (-2);
  6    18      dcl	   insert_action	      static options (constant) init (-1);
  6    19      dcl	   append_action	      static internal fixed options (constant) init (-1);
  6    20      dcl	   truncate_action	      static internal fixed options (constant) init (1);
  6    21      dcl	   must_adjust	      static internal fixed options (constant) init (2);
  6    22      dcl	   must_rollback	      static internal fixed options (constant) init (3);
  5   376 
  5   377 
  5   378 /* Other constants */
  5   379      dcl	   true_max_comp_num      static options (constant) init (1250);
  5   380      dcl	   stat_header_size	      static internal fixed options (constant) init (8);
  5   381 
  5   382 /* builtins */
  5   383      dcl	   (verify, reverse)      builtin;
  5   384      dcl	   addr		      builtin;
  5   385      dcl	   divide		      builtin;
  5   386      dcl	   length		      builtin;
  5   387      dcl	   null		      builtin;
  5   388      dcl	   substr		      builtin;
  5   389      dcl	   size		      builtin;
  5   390      dcl	   abs		      builtin;
  5   391      dcl	   unspec		      builtin;
  5   392      dcl	   fixed		      builtin;
  5   393      dcl	   bit		      builtin;
  5   394      dcl	   max		      builtin;
  5   395      dcl	   min		      builtin;
  5   396      dcl	   rel		      builtin;
  5   397 
     1067 
     1068 
  7     1      dcl	   1 uns_info	      based (addr (info)),	/* info structure for unstructured files */
  7     2 	     2 info_version	      fixed,		/* (Input) must =1--only one version
  7     3*						   currently supported */
  7     4 	     2 type	      fixed,		/* =1 */
  7     5 	     2 end_pos	      fixed (34),		/* length (bytes) not including header */
  7     6 	     2 flags	      aligned,
  7     7 	       3 pad1	      bit (2) unal,		/* used for lock_status in other files */
  7     8 	       3 header_present   bit (1) unal,		/* on if file code is set */
  7     9 	       3 pad2	      bit (33) unal,
  7    10 	     2 header_id	      fixed (35);		/* meaning is user defined */
  7    11      dcl	   1 seq_info	      based (addr (info)),	/* info structure for sequential files */
  7    12 	     2 info_version	      fixed,
  7    13 	     2 type	      fixed,		/* =2 */
  7    14 	     2 end_pos	      fixed (34),		/* record count */
  7    15 	     2 flags	      aligned,
  7    16 	       3 lock_status      bit (2) unal,		/* 0,1,2, or 3 to indicate not locked,
  7    17*						   locked by (other,this,dead) process */
  7    18 	       3 pad	      bit (34) unal,
  7    19 	     2 version	      fixed,		/* end_pos valid only in latest version */
  7    20 	     2 action	      fixed;		/* indicates if adjustment or rollback is needed */
  7    21      dcl	   1 blk_info	      based (addr (info)),	/* info structure for blocked files */
  7    22 	     2 info_version	      fixed,
  7    23 	     2 type	      fixed,		/* =3 */
  7    24 	     2 end_pos	      fixed (34),		/* record count */
  7    25 	     2 flags	      aligned,
  7    26 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  7    27 	       3 pad	      bit (34) unal,
  7    28 	     2 version	      fixed,		/* only one currently supported */
  7    29 	     2 action	      fixed,		/* non-zero if truncation in progress, else =0 */
  7    30 	     2 max_rec_len	      fixed (21),		/* bytes--determines characteristiWc block size */
  7    31 	     2 pad	      fixed,		/* not used at this time */
  7    32 	     2 time_last_modified fixed (71);		/* time stamp for synchronization */
  7    33      dcl	   1 indx_info	      based (addr (info)),	/* info structure for indexed files */
  7    34 	     2 info_version	      fixed,
  7    35 	     2 type	      fixed,		/* =4 */
  7    36 	     2 records	      fixed (34),		/* record count */
  7    37 	     2 flags	      aligned,
  7    38 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  7    39 	       3 pad	      bit (34) unal,
  7    40 	     2 version_info	      aligned,
  7    41 	       3 file_version     fixed (17) unal,	/* headers differ */
  7    42 	       3 program_version  fixed (17) unal,	/* may indicate bugs */
  7    43 	     2 action	      fixed,		/* non-zero code indicates update in progress */
  7    44 	     2 non_null_recs      fixed (34),		/* count of allocated recs */
  7    45 	     2 record_bytes	      fixed (34),		/* total record length */
  7    46 	     2 free_blocks	      fixed,		/* available record blocks */
  7    47 	     2 index_height	      fixed,		/* height of index tree (0 if empty) */
  7    48 	     2 nodes	      fixed,		/* nodes being used in the index */
  7    49 	     2 key_bytes	      fixed (34),		/* total length of keys */
  7    50 	     2 change_count	      fixed (35),		/* bumped on each file modification */
  7    51 	     2 num_keys	      fixed (34),		/* number of index entries */
  7    52 	     2 dup_keys	      fixed (34),		/* 0 if all keys are distinct, else 1 for each dup */
  7    53 	     2 dup_key_bytes      fixed (34),		/* total bytes of duplicate keys */
  7    54 	     2 word	      (1) fixed;		/* reserved for future use */
  7    55      dcl	   1 vbl_info	      based (addr (info)),	/* info structure for variable files */
  7    56 	     2 info_version	      fixed,
  7    57 	     2 type	      fixed,		/* =5 */
  7    58 	     2 end_pos	      fixed (34),		/* logical end of file--not necessarily allocation count */
  7    59 	     2 flags	      aligned,
  7    60 	       3 lock_status      bit (2) unal,		/* same as seq_info.= */
  7    61 	       3 pad	      bit (34) unal,
  7    62 	     2 version	      fixed,		/* only one currently supported */
  7    63 	     2 action	      fixed,		/* same as in indexed files */
  7    64 	     2 first_nz	      fixed (34),		/* position (numeric key) for first allocated record */
  7    65 	     2 last_nz	      fixed (34),		/* last allocated record position */
  7    66 	     2 change_count	      fixed (35);		/* used for synchronization */
  7    67      dcl	   vfs_version_1	      static internal fixed init (1);
  7    68 						/* should be used in
  7    69*						   assignments to info_version */
     1069 
     1070 
     1071     dcl	1 fs_info			aligned like indx_info,
     1072 	info			fixed bin;
     1073 
     1074 	end vfile_find_bad_nodes;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/23/83  1104.1  vfile_find_bad_nodes.pl1          >spec>on>06/23/83>vfile_find_bad_nodes.pl1
1049         1    07/19/79  1547.0  ak_info.incl.pl1                  >ldd>include>ak_info.incl.pl1
1061         2    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
1063         3    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
1065         4    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
1067         5    07/19/79  1547.0  vfile_indx.incl.pl1               >ldd>include>vfile_indx.incl.pl1
5-376        6    07/19/79  1547.0  vfile_action_codes.incl.pl1       >ldd>include>vfile_action_codes.incl.pl1
1069         7    07/19/79  1547.0  vfs_info.incl.pl1                 >ldd>include>vfs_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FALSE                                  constant        bit(1)                   initial unaligned dcl 152 ref 174 175 179 180 183
                                                                                  190 191 228 260 419 421 425 432 511 728
HT_SP                                  constant        char(2)                  initial unaligned dcl 152 ref 846
HT_SP_NL                        000123 constant        char(3)                  initial unaligned dcl 152 ref 846
Iarg                            000100 automatic       fixed bin(17,0)          dcl 30 set ref 202* 203* 212* 212 213 220* 232* 232
                                                                                  233 239*
Ibranch                         000101 automatic       fixed bin(17,0)          dcl 30 set ref 559* 560* 567* 570 571 571 576 576
                                                                                  576 576 576* 585* 586 587* 612* 614 615* 698 702
                                                                                  706 710 710 968* 987* 1007* 1024*
Ifn                             000102 automatic       fixed bin(17,0)          dcl 30 set ref 479* 481* 523* 523* 525 635* 635* 637
Imode                           000103 automatic       fixed bin(17,0)          dcl 30 set ref 263* 264 265 265 267 267 269 269 271
                                                                                  271 273 273 275 275 277 277 282 282 290 296*
Inode                           000104 automatic       fixed bin(17,0)          dcl 30 set ref 506* 507* 517* 517* 518 520 520* 596
                                                                                  603* 731* 733* 733 734 734* 831* 946* 968* 987*
                                                                                  1007* 1024*
Keyed_sequential_input          000163 constant        fixed bin(17,0)          initial dcl 4-15 set ref 214 349* 351 374* 376 383
                                                                                  386
Keyed_sequential_update         000202 constant        fixed bin(17,0)          initial dcl 4-15 set ref 214 383 386 407*
LINE                            000112 automatic       char(256)                unaligned dcl 30 set ref 845 845 845 845 846
Larg                            000105 automatic       fixed bin(21,0)          dcl 30 set ref 203* 205 205 207 207 214 214 225 225
                                                                                  228 228 231 231 234 234 244 244 311 312 312 320
                                                                                  320 325
Lnode_bit_overlay               000106 automatic       fixed bin(17,0)          dcl 30 set ref 587* 588 589 589
Lop                             000107 automatic       fixed bin(21,0)          dcl 30 set ref 220* 221 239* 242 242 244 244
Lread                           000110 automatic       fixed bin(21,0)          dcl 30 set ref 436* 845* 846
Lret                            000111 automatic       fixed bin(21,0)          dcl 30 set ref 188* 758 761
N                                      based           fixed bin(17,0)          level 2 in structure "fn" dcl 94 in procedure
                                                                                  "vfile_find_bad_nodes" ref 469 473 479
N                                      based           fixed bin(17,0)          level 2 in structure "free_nodes" dcl 94
                                                                                  in procedure "vfile_find_bad_nodes" set ref 462*
                                                                                  477* 477 478 480* 480 481 484* 487* 523 525 635
                                                                                  637
Nargs                           000212 automatic       fixed bin(17,0)          dcl 30 set ref 188* 202 213 233
Nbad_nodes                      000213 automatic       fixed bin(17,0)          dcl 30 set ref 446* 753 753* 753 758 828* 828 890*
                                                                                  890 940* 940 961* 961 980* 980 1000* 1000 1020*
                                                                                  1020 1036* 1036
Nbad_nodes_in_comp              000214 automatic       fixed bin(17,0)          dcl 30 set ref 512* 716 716* 716 829* 829 941* 941
                                                                                  962* 962 981* 981 1001* 1001 1019* 1019
Nkey_bytes                      000216 automatic       fixed bin(34,0)          dcl 30 set ref 501* 532* 532 750 904*
Nkey_bytes_in_node              000217 automatic       fixed bin(17,0)          dcl 30 set ref 558* 560* 560 563
Nkeys                           000215 automatic       fixed bin(34,0)          dcl 30 set ref 500* 531* 531 748 914*
Nnon_empty_nodes                000220 automatic       fixed bin(17,0)          dcl 30 set ref 499* 530* 530 746 924*
Parea                           000010 internal static pointer                  initial dcl 152 set ref 240 240* 242* 307 788
Parg                            000222 automatic       pointer                  dcl 30 set ref 203* 205 205 207 214 225 225 228 228
                                                                                  231 231 234 244 311 312 320 325
Pfn                             000224 automatic       pointer                  dcl 30 set ref 463* 464 465 466* 466 467 468* 469
                                                                                  470* 473 474* 478 479 481
Pfree_node                             parameter       pointer                  dcl 886 set ref 883 888*
Pfree_nodes                     000226 automatic       pointer                  dcl 30 set ref 171* 457* 462 477 477 478 478 480 480
                                                                                  481 481 484 487 522 523 523 525 633 635 635 637
                                                                                  786 786*
Piocb                           000230 automatic       pointer                  dcl 30 set ref 172* 341* 349* 359* 367 373 374* 383
                                                                                  383 386 436* 447 745* 778 779* 782* 783*
Piocb_node_tree                 000232 automatic       pointer                  dcl 30 set ref 173* 399* 407* 605* 651* 654* 666*
                                                                                  724* 727* 730* 740* 741* 771 772* 773* 774*
Pnode1                          000234 automatic       pointer                  dcl 30 set ref 632* 635 642 944* 950* 967* 968* 986*
                                                                                  987* 1006* 1007* 1022* 1024*
Pnode2                          000236 automatic       pointer                  dcl 30 set ref 945* 954*
Pnode_array                     000240 automatic       pointer                  dcl 30 set ref 505* 517 518
Pnode_bit_overlay               000242 automatic       pointer                  dcl 30 set ref 586* 588 589 589
Pop                             000244 automatic       pointer                  dcl 30 set ref 220* 221 239* 242 244
Pret                            000246 automatic       pointer                  dcl 30 set ref 188* 758 761
Sattached                       000250 automatic       bit(1)                   unaligned dcl 30 set ref 174* 348* 781
Scommand                        000251 automatic       bit(1)                   unaligned dcl 30 set ref 190* 196* 758
Sinput_switch                   000252 automatic       bit(1)                   unaligned dcl 30 set ref 179* 222* 319 329
Smode                           000253 automatic       structure                level 1 dcl 30 set ref 183* 260*
Sopened                         000254 automatic       bit(1)                   unaligned dcl 30 set ref 175* 355* 380* 779
Spathname                       000255 automatic       bit(1)                   unaligned dcl 30 set ref 180* 206 326* 329 339 438*
                                                                                  862*
Srequest_loop                   000256 automatic       bit(1)                   unaligned dcl 30 set ref 191* 197* 225* 228* 841
Stotal                          000257 automatic       bit(1)                   unaligned dcl 30 set ref 511* 830 859* 942 963 982
                                                                                  1002 1021 1037
TRUE                                   constant        bit(1)                   initial unaligned dcl 152 ref 184 185 186 196 197
                                                                                  222 225 291 297 326 348 355 380 414 415 418 424
                                                                                  429 430 431 729 859
active_fnc_err_                 000012 constant        entry                    external dcl 122 ref 193
addr                                                   builtin function         dcl 5-384 ref 445 495 518 586 586 600 604 605 605
                                                                                  615 616 616 626 632 647 647 650 651 651 654 654
                                                                                  666 666 719 724 724 730 730 736 737 737 741 741
                                                                                  745 745 803 807 813 813 813 845 845 850 850 943
                                                                                  948 952 955 964 965 974 983 984 993 1003 1004 1013
                                                                                  1022 1038
ak_header                              based           structure                level 1 unaligned dcl 1-10
aki                             001102 automatic       structure                level 1 dcl 1051 set ref 605 605 651 651
area                                   based           area(1024)               dcl 94 ref 307 788
arg                                    based           char                     unaligned dcl 94 set ref 205 205 207* 214* 225 225
                                                                                  228 228 231 231 234* 244* 311 312* 320* 325
arg_ptr                         001072 automatic       entry variable           dcl 122 set ref 192* 198* 203 220 239
attach_descrip_ptr       14            based           pointer                  level 2 dcl 3-6 ref 367
bad_mode_name             0(06) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 291* 301 303
bad_mode_value            0(07) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 297* 301 303
boolean_value            13(03)        based           bit(1)                   array level 4 packed unaligned dcl 2-9 ref 265 267
                                                                                  269 271 273 275 277 282
boolean_valuep           13            based           bit(1)                   array level 4 packed unaligned dcl 2-9 ref 264
branch                    3            based           fixed bin(35,0)          array level 3 dcl 5-139 ref 614 615
branch_and_descrip        3            based           structure                array level 2 unaligned dcl 5-139
branch_numb_key                 000260 automatic       structure                level 1 dcl 30 set ref 615 616 632 647 1022
branch_numb_key_numb                   based           fixed bin(35,0)          dcl 94 set ref 615* 616 632* 647 1022*
branch_numb_key_str                    based           char(4)                  dcl 94 ref 647
char                                                   builtin function         dcl 117 ref 698 702 706 710 710 808
cleanup                         001056 stack reference condition                dcl 120 ref 177
code                     26            based           fixed bin(35,0)          array level 3 in structure "mode_string_info"
                                                                                  dcl 2-9 in procedure "vfile_find_bad_nodes" set
                                                                                  ref 262* 290* 296*
code                            000261 automatic       fixed bin(35,0)          dcl 30 in procedure "vfile_find_bad_nodes" set ref
                                                                                  188* 189 203* 220* 239* 242* 243 244* 261* 292*
                                                                                  298* 303* 341* 343 344* 349* 350 351* 359* 360
                                                                                  361* 374* 375 376* 399* 402 403* 407* 408 409*
                                                                                  436* 437 438* 457* 458 459* 605* 651* 652 654* 655
                                                                                  666* 724* 727* 730* 732 740* 741 741* 745* 772*
                                                                                  773* 774* 775* 779* 782* 783* 786* 845* 850*
com_err_                        000014 constant        entry                    external dcl 122 ref 199
comp                            000757 automatic       fixed bin(17,0)          level 2 in structure "numb_key" packed unaligned
                                                                                  dcl 30 in procedure "vfile_find_bad_nodes" set ref
                                                                                  598* 602* 950* 954* 968* 987* 1007* 1039*
comp                            001046 automatic       fixed bin(17,0)          level 2 in structure "root_numb_key" packed
                                                                                  unaligned dcl 30 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 596
comp                            000260 automatic       fixed bin(17,0)          level 2 in structure "branch_numb_key" packed
                                                                                  unaligned dcl 30 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 624 1024*
comp_link                 1            based           fixed bin(17,0)          array level 2 packed unaligned dcl 5-268 ref 626 719
comp_num                        000262 automatic       fixed bin(17,0)          dcl 30 in procedure "vfile_find_bad_nodes" set ref
                                                                                  502* 505 506 509* 596 602 716* 719 719* 831* 946*
                                                                                  968* 987* 1007* 1024*
comp_num                               based           fixed bin(17,0)          level 2 in structure "desc" packed unaligned dcl 801
                                                                                  in procedure "get_ptr" ref 803 807 813
comp_table                             based           structure                array level 1 dcl 5-268
comp_table_start                       based           fixed bin(17,0)          array level 2 dcl 5-157 set ref 626 719
cu_$af_arg_ptr                  000020 constant        entry                    external dcl 122 ref 192
cu_$af_return_arg               000016 constant        entry                    external dcl 122 ref 188
cu_$arg_ptr                     000022 constant        entry                    external dcl 122 ref 198
cu_$cp                          000024 constant        entry                    external dcl 122 ref 850
current                   0(05) 001106 automatic       bit(1)                   level 5 packed unaligned dcl 1051 set ref 421* 729*
currentsize                                            builtin function         dcl 117 ref 550
delete_$path                    000026 constant        entry                    external dcl 122 ref 775
desc                                   based           structure                level 1 dcl 801
desc_code                 0(02) 001106 automatic       fixed bin(2,0)           level 4 packed unaligned dcl 1051 set ref 420*
descrip                   1     001102 automatic       fixed bin(35,0)          level 3 in structure "aki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 594* 600* 650* 664
                                                                                  944* 948
descrip                   1     001106 automatic       fixed bin(35,0)          level 3 in structure "gki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 655 663 738 945*
                                                                                  952 965 967* 984 986* 1004 1006*
descrip                   4            based           structure                array level 3 in structure "node_block" unaligned
                                                                                  dcl 5-139 in procedure "vfile_find_bad_nodes"
descriptor                             parameter       fixed bin(35,0)          dcl 800 in procedure "get_ptr" set ref 798 803 804*
                                                                                  807 808* 813 813
descriptor                             parameter       fixed bin(35,0)          dcl 876 in procedure "tell" set ref 873 878*
designator_struct                      based           structure                level 1 dcl 5-127
dimension                                              builtin function         dcl 117 ref 517
divide                                                 builtin function         dcl 5-385 ref 949 953 966 985 1005 1023 1039
err                             001076 automatic       entry variable           dcl 122 set ref 193* 199* 207 214 234 244 248 255
                                                                                  303 312 320 331 344 351 361 368 376 386 403 409
                                                                                  438 450 459
error_table_$bad_mode           000100 external static fixed bin(35,0)          dcl 152 set ref 290 386*
error_table_$bad_mode_value     000102 external static fixed bin(35,0)          dcl 152 ref 292 296 298
error_table_$badopt             000104 external static fixed bin(35,0)          dcl 152 set ref 312*
error_table_$inconsistent       000106 external static fixed bin(35,0)          dcl 152 set ref 207* 320*
error_table_$key_duplication    000110 external static fixed bin(35,0)          dcl 152 ref 652
error_table_$noarg              000112 external static fixed bin(35,0)          dcl 152 set ref 214* 234*
error_table_$not_attached       000114 external static fixed bin(35,0)          dcl 152 set ref 368*
error_table_$unimplemented_version
                                000116 external static fixed bin(35,0)          dcl 152 set ref 248* 255*
error_table_$wrong_no_of_args   000120 external static fixed bin(35,0)          dcl 152 set ref 331*
f_b_ptr                         001124 automatic       pointer                  dcl 5-156 set ref 448* 449 495 626 719
fail_num                               parameter       fixed bin(17,0)          dcl 825 set ref 822 831* 873 878* 883 888*
file_base                              based           structure                level 1 unaligned dcl 5-157
file_base_ptr             2            based           pointer                  level 2 dcl 5-3 ref 448
file_state_block                       based           structure                level 1 unaligned dcl 5-280 ref 626 719
file_version              4            based           fixed bin(17,0)          level 2 dcl 5-157 ref 449
fixed                                                  builtin function         dcl 5-392 ref 813
flags                    13            based           structure                array level 3 in structure "mode_string_info"
                                                                                  dcl 2-9 in procedure "vfile_find_bad_nodes"
flags                           001112 automatic       structure                level 3 in structure "rki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes"
flags                           001106 automatic       structure                level 3 in structure "gki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes"
flags                           001102 automatic       structure                level 3 in structure "aki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes"
fn                                     based           structure                level 1 dcl 94
free_node_designator      1            based           fixed bin(35,0)          level 2 dcl 5-298 ref 456
free_nodes                             based           structure                level 1 dcl 94
fs_info                         001130 automatic       structure                level 1 dcl 1071 set ref 724 724 745 745
fs_ptr                                 automatic       pointer                  dcl 5-279 ref 626 719
get_pdir_                       000030 constant        entry                    external dcl 122 ref 399 399 775 775
get_system_free_area_           000032 constant        entry                    external dcl 122 ref 240
get_temp_segment_               000034 constant        entry                    external dcl 122 ref 457
gk_header                              based           structure                level 1 unaligned dcl 1-46
gk_info_version_0                      constant        fixed bin(17,0)          initial dcl 1-66 ref 426
gki                             001106 automatic       structure                level 1 dcl 1051 set ref 654 654 730 730 741 741
hbound                                                 builtin function         dcl 117 ref 807 808
head_size                 0(09) 001106 automatic       fixed bin(9,0)           level 5 packed unsigned unaligned dcl 1051 set ref
                                                                                  423*
header                          001102 automatic       structure                level 2 in structure "aki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes"
header                          001112 automatic       structure                level 2 in structure "rki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes"
header                          001106 automatic       structure                level 2 in structure "gki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes"
index                                                  builtin function         dcl 117 ref 311
index_state_block                      based           structure                level 1 unaligned dcl 5-298
index_state_ptr          34            based           pointer                  level 2 dcl 5-3 ref 454
index_tail_comp_num       2            based           fixed bin(17,0)          level 2 dcl 5-298 ref 502 620
indx_cb                                based           structure                level 1 unaligned dcl 5-3
indx_cb_ptr                     001122 automatic       pointer                  dcl 5-2 set ref 447* 448 454 505 803 807 807 808 808
                                                                                  813
indx_info                              based           structure                level 1 unaligned dcl 7-33
info_version                    001130 automatic       fixed bin(17,0)          level 2 dcl 1071 set ref 721*
input_desc                0(01) 001106 automatic       bit(1)                   level 4 in structure "gki" packed unaligned dcl 1051
                                                                                  in procedure "vfile_find_bad_nodes" set ref 419*
input_desc                0(01) 001102 automatic       bit(1)                   level 4 in structure "aki" packed unaligned dcl 1051
                                                                                  in procedure "vfile_find_bad_nodes" set ref 415*
input_key                       001102 automatic       bit(1)                   level 4 in structure "aki" packed unaligned dcl 1051
                                                                                  in procedure "vfile_find_bad_nodes" set ref 414*
input_key                       001106 automatic       bit(1)                   level 4 in structure "gki" packed unaligned dcl 1051
                                                                                  in procedure "vfile_find_bad_nodes" set ref 418*
                                                                                  728*
input_key                       001112 automatic       bit(1)                   level 4 in structure "rki" packed unaligned dcl 1051
                                                                                  in procedure "vfile_find_bad_nodes" set ref 429*
input_new_desc            0(02) 001112 automatic       bit(1)                   level 4 packed unaligned dcl 1051 set ref 431*
input_old_desc            0(01) 001112 automatic       bit(1)                   level 4 packed unaligned dcl 1051 set ref 430*
input_switch_name               000263 automatic       char(32)                 unaligned dcl 30 set ref 181* 221* 340* 341* 359*
                                                                                  361* 368* 376* 386* 438* 862*
ioa_                            000036 constant        entry                    external dcl 122 ref 468 484 487 509 716 725 753 756
                                                                                  831 854 862 878 888 904 914 924 946 950 954 968
                                                                                  987 1007 1024 1039
ioa_$nnl                        000040 constant        entry                    external dcl 122 ref 520 734 844 867
iocb                                   based           structure                level 1 dcl 3-6
iox_$attach_name                000042 constant        entry                    external dcl 122 ref 341 399
iox_$close                      000044 constant        entry                    external dcl 122 ref 772 779
iox_$control                    000046 constant        entry                    external dcl 122 ref 605 651 654 666 724 730 741 745
iox_$destroy_iocb               000052 constant        entry                    external dcl 122 ref 774 783
iox_$detach_iocb                000050 constant        entry                    external dcl 122 ref 773 782
iox_$get_line                   000054 constant        entry                    external dcl 122 ref 845
iox_$look_iocb                  000056 constant        entry                    external dcl 122 ref 359
iox_$open                       000060 constant        entry                    external dcl 122 ref 349 374 407
iox_$position                   000062 constant        entry                    external dcl 122 ref 727 740
iox_$read_key                   000064 constant        entry                    external dcl 122 ref 436
iox_$user_input                 000122 external static pointer                  dcl 152 set ref 845*
iox_modes                       000000 constant        char(24)                 initial array dcl 4-6 set ref 214* 214* 351* 376*
                                                                                  383 383 386* 386*
is_ptr                          001126 automatic       pointer                  dcl 5-297 set ref 454* 456 463 502 620
key                       4     001112 automatic       char(4)                  level 2 in structure "rki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 665*
key                       3     001106 automatic       char(4)                  level 2 in structure "gki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 653* 736
key                             000273 automatic       varying char(256)        dcl 30 in procedure "vfile_find_bad_nodes" set ref
                                                                                  436* 444*
key                       3     001102 automatic       char(4)                  level 2 in structure "aki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 604* 647* 653 665
key_bytes                13     001130 automatic       fixed bin(34,0)          level 2 dcl 1071 set ref 750 904*
key_descrip               4            based           structure                array level 4 packed unaligned dcl 5-139
key_len                   3     001112 automatic       fixed bin(17,0)          level 3 in structure "rki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 433*
key_len                   2     001102 automatic       fixed bin(17,0)          level 3 in structure "aki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 416*
key_len                   2     001106 automatic       fixed bin(17,0)          level 3 in structure "gki" dcl 1051 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 427*
key_length                4(18)        based           fixed bin(17,0)          array level 5 packed unaligned dcl 5-139 ref 560 571
                                                                                  576 576 587
key_loc                   0(02) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 186* 269*
                                                                                  277* 282* 567 569
key_order                 0(04) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 273* 282*
                                                                                  567 575
key_overlap               0(03) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 271* 282*
                                                                                  583
key_pos                   4            based           fixed bin(17,0)          array level 5 packed unaligned dcl 5-139 ref 570 571
                                                                                  576 576 586
key_region                0(01) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 185* 267*
                                                                                  277* 282* 547
keys                                   based           char(4096)               unaligned dcl 5-153 ref 576 576
last_branch_num                        based           fixed bin(17,0)          level 2 dcl 5-139 set ref 527 531 541 543 550 559
                                                                                  567 576 585 612 642 831*
lbound                                                 builtin function         dcl 117 ref 803
length                                                 builtin function         dcl 5-386 ref 845 845 850 850
line                            000374 automatic       varying char(256)        dcl 30 set ref 846* 848 849* 850 850 850 850 853 857
                                                                                  857 858 858 859 859 861
low_key_pos               1            based           fixed bin(17,0)          level 2 dcl 5-139 set ref 532 548 550 553 563 570
                                                                                  831* 831
ltrim                                                  builtin function         dcl 117 ref 698 702 706 710 710 808 846
mbz                       0(03) 001112 automatic       bit(33)                  level 4 packed unaligned dcl 1051 set ref 432*
mod                                                    builtin function         dcl 117 ref 520 734
mode_name                 3            based           char(32)                 array level 3 packed unaligned dcl 2-9 ref 265 267
                                                                                  269 271 273 275 277 282
mode_string                     000475 automatic       char(256)                unaligned dcl 30 set ref 302* 303*
mode_string_$get_error          000066 constant        entry                    external dcl 122 ref 302
mode_string_$parse              000070 constant        entry                    external dcl 122 ref 242
mode_string_info                       based           structure                level 1 dcl 2-9 set ref 307 788
mode_string_info_ptr            001120 automatic       pointer                  dcl 2-14 set ref 176* 242* 247 248 253 253 255 262
                                                                                  263 264 265 265 267 267 269 269 271 271 273 273
                                                                                  275 275 277 277 282 282 290 296 302* 307 308* 788
                                                                                  788
mode_string_info_version_2      000253 constant        fixed bin(17,0)          initial dcl 2-30 set ref 247 248*
mode_value                             based           structure                level 1 dcl 2-16
mode_value_version_3            000247 constant        fixed bin(17,0)          initial dcl 2-30 set ref 253 255*
modes                     2            based           structure                array level 2 dcl 2-9
msg                                    parameter       char                     unaligned dcl 825 set ref 822 831* 873 878* 883 888*
new_descrip               2     001112 automatic       fixed bin(35,0)          level 3 dcl 1051 set ref 664*
next_free_node_designator
                          1            based           fixed bin(35,0)          level 2 dcl 94 set ref 465 466*
node                      2            based           pointer                  array level 2 in structure "free_nodes" dcl 94
                                                                                  in procedure "vfile_find_bad_nodes" set ref 478*
                                                                                  481* 523 635
node                      0(18) 000260 automatic       fixed bin(18,0)          level 2 in structure "branch_numb_key" packed
                                                                                  unsigned unaligned dcl 30 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 1023* 1023 1024*
node                      2            based           fixed bin(35,0)          array level 2 in structure "fn" dcl 94 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 481*
node                      0(18) 001046 automatic       fixed bin(18,0)          level 2 in structure "root_numb_key" packed unsigned
                                                                                  unaligned dcl 30 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 596
node                      0(18) 000757 automatic       fixed bin(18,0)          level 2 in structure "numb_key" packed unsigned
                                                                                  unaligned dcl 30 in procedure
                                                                                  "vfile_find_bad_nodes" set ref 599* 603* 949* 949
                                                                                  950* 953* 953 954* 966* 966 968* 985* 985 987*
                                                                                  1005* 1005 1007* 1039
node_array                             based           char(4096)               array dcl 94 set ref 517 518
node_bit_array                         based           bit(1)                   array unaligned dcl 94 set ref 586
node_bit_overlay                       based           bit                      unaligned dcl 94 set ref 588 589* 589
node_bits                       000575 automatic       bit(4096)                unaligned dcl 30 set ref 584* 586
node_block                             based           structure                level 1 unaligned dcl 5-139 set ref 550
node_branch                     000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 184* 265*
                                                                                  277* 282* 540
node_ptr                  4            based           pointer                  level 2 dcl 5-132 set ref 518* 523 527 531 532 532
                                                                                  541 543 548 550 550 553 553 556 559 560 563 563
                                                                                  567 570 570 571 571 576 576 576 576 576 576 576
                                                                                  585 586 587 612 614 615 831* 831 831 831 831 946*
                                                                                  968* 987* 1007* 1024* 1038* 1039*
node_tree                 0(05) 000253 automatic       bit(1)                   level 2 packed unaligned dcl 30 set ref 275* 282*
                                                                                  397 593 722
nodes                    12     001130 automatic       fixed bin(17,0)          level 2 dcl 1071 set ref 746 924*
null                                                   builtin function         dcl 5-387 ref 171 172 173 176 240 308 341 341 367
                                                                                  373 399 399 464 467 522 633 771 778 786 788 805
                                                                                  810
num_keys                 15     001130 automatic       fixed bin(34,0)          level 2 dcl 1071 set ref 725* 748 914*
numb_key                        000757 automatic       structure                level 1 dcl 30 set ref 600 604 650 736 737 943 948
                                                                                  952 955 964 965 974 983 984 993 1003 1004 1013
                                                                                  1038
numb_key_numb                          based           fixed bin(35,0)          dcl 94 set ref 600 650 737 943 948* 952* 955* 964
                                                                                  965* 974* 983 984* 993* 1003 1004* 1013* 1038*
numb_key_str                           based           char(4)                  dcl 94 set ref 604 736*
number                    1            based           fixed bin(17,0)          level 2 dcl 2-9 ref 253 262 263 307 788
offset                    0(18)        based           bit(18)                  level 2 packed unaligned dcl 801 ref 813
old_descrip               1     001112 automatic       fixed bin(35,0)          level 3 dcl 1051 set ref 663*
only_branch_in_root      15            based           fixed bin(35,0)          level 3 dcl 5-157 ref 495
op                                     based           char                     unaligned dcl 94 set ref 221 242* 244*
open_data_ptr            22            based           pointer                  level 2 dcl 3-6 ref 447
open_descrip                           based           varying char(100)        dcl 94 set ref 383 383 386*
open_descrip_ptr         20            based           pointer                  level 2 dcl 3-6 ref 373 383 383 386
pad                       0(19) 001106 automatic       bit(8)                   level 4 packed unaligned dcl 1051 set ref 425*
pathname                        000760 automatic       varying char(168)        dcl 30 set ref 182* 325* 341 344* 351* 438* 862*
pathname_                       000072 constant        entry                    external dcl 122 ref 399
pos_frame                       001034 automatic       pointer                  array dcl 30 set ref 445
pos_ptr                         001044 automatic       pointer                  dcl 30 set ref 445* 518 523 527 531 532 532 541 543
                                                                                  548 550 550 553 553 556 559 560 563 563 567 570
                                                                                  570 571 571 576 576 576 576 576 576 576 585 586
                                                                                  587 612 614 615 831 831 831 831 831 946 968 987
                                                                                  1007 1024 1038 1039
position_frame                         based           structure                level 1 unaligned dcl 5-132
position_specification
                          0(05) 001106 automatic       structure                level 4 packed unaligned dcl 1051
proc                            000116 constant        char(20)                 initial unaligned dcl 152 set ref 207* 214* 234*
                                                                                  234* 244* 248* 255* 303* 312* 320* 331* 340 344*
                                                                                  351* 361* 368* 376* 386* 386* 403* 409* 438* 450*
                                                                                  457* 459* 775* 786*
program_interrupt               001064 stack reference condition                dcl 120 ref 510 843 870
rel_type                  0(06) 001106 automatic       fixed bin(2,0)           level 5 packed unaligned dcl 1051 set ref 422*
release_temp_segment_           000074 constant        entry                    external dcl 122 ref 786
reset_pos                 0(18) 001106 automatic       bit(1)                   level 4 packed unaligned dcl 1051 set ref 424*
ret                                    based           varying char             dcl 94 set ref 758* 761*
rk_header                              based           structure                level 1 unaligned dcl 1-26
rki                             001112 automatic       structure                level 1 dcl 1051 set ref 666 666
root_node_block          12            based           structure                level 2 unaligned dcl 5-157
root_numb_key                   001046 automatic       structure                level 1 dcl 30 set ref 495 616 737
root_numb_key_numb                     based           fixed bin(35,0)          dcl 94 set ref 495* 616 737
rtrim                                                  builtin function         dcl 117 ref 846
save_numb_key_numb              001047 automatic       fixed bin(35,0)          dcl 30 set ref 943* 955 964* 974 983* 993 1003* 1013
scat_space                2            based           fixed bin(17,0)          level 2 dcl 5-139 set ref 532 553 556 563 831*
seg_array                              based           fixed bin(19,0)          array dcl 5-87 set ref 813
seg_ptr_array                          based           pointer                  array dcl 5-85 ref 505 803 807 808 813
seg_ptr_array_limit      12            based           fixed bin(17,0)          level 2 dcl 5-3 ref 807 808
seg_ptr_array_ptr        10            based           pointer                  level 2 dcl 5-3 ref 505 803 807 808 813
size                                                   builtin function         dcl 5-389 ref 626 719
substr                                                 builtin function         dcl 5-388 set ref 576 576 846 848 849* 850 850
temp_comp_num                   001050 automatic       fixed bin(17,0)          dcl 30 set ref 620* 624* 626 626*
unique                          001051 automatic       char(15)                 unaligned dcl 30 set ref 338* 340 399 399 775
unique_chars_                   000076 constant        entry                    external dcl 122 ref 338
version                   0(27) 001106 automatic       fixed bin(8,0)           level 4 in structure "gki" packed unaligned dcl 1051
                                                                                  in procedure "vfile_find_bad_nodes" set ref 426*
version                                based           fixed bin(17,0)          level 2 in structure "mode_string_info" dcl 2-9
                                                                                  in procedure "vfile_find_bad_nodes" set ref 247
                                                                                  248*
version                   2            based           fixed bin(17,0)          array level 3 in structure "mode_string_info"
                                                                                  dcl 2-9 in procedure "vfile_find_bad_nodes" set
                                                                                  ref 253 255*
vfs_version_1                          constant        fixed bin(17,0)          initial dcl 7-67 ref 721

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Direct_input                           internal static fixed bin(17,0)          initial dcl 4-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 4-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 4-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 4-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 4-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 4-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 4-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 4-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 4-15
Stream_output                          internal static fixed bin(17,0)          initial dcl 4-15
abs                                                    builtin function         dcl 5-390
adding_key                             internal static fixed bin(17,0)          initial dcl 6-13
adding_record                          internal static fixed bin(17,0)          initial dcl 6-11
adjust_action                          internal static fixed bin(17,0)          initial dcl 6-3
ak_info                                based           structure                level 1 unaligned dcl 1-6
ak_info_ptr                            automatic       pointer                  dcl 1-18
ak_key_len                             automatic       fixed bin(17,0)          dcl 1-19
alloc_cb_file                   000000 constant        entry                    external dcl 5-359
allocate_action                        internal static fixed bin(17,0)          initial dcl 6-8
append_action                          internal static fixed bin(17,0)          initial dcl 6-19
bit                                                    builtin function         dcl 5-393
blk_info                               based           structure                level 1 unaligned dcl 7-21
bumping_count                          internal static fixed bin(17,0)          initial dcl 6-1
change_index                    000000 constant        entry                    external dcl 5-372
change_record_list              000000 constant        entry                    external dcl 5-373
clock_                          000000 constant        entry                    external dcl 5-358
create_position_stack           000000 constant        entry                    external dcl 5-369
create_seg_ptrs                 000000 constant        entry                    external dcl 5-364
current_t_code                         based           fixed bin(35,0)          dcl 5-82
delete_action                          internal static fixed bin(17,0)          initial dcl 6-14
deleting_key                           internal static fixed bin(17,0)          initial dcl 6-12
designator                             automatic       fixed bin(35,0)          dcl 5-88
eof_delete                             internal static fixed bin(17,0)          initial dcl 6-15
extend_position_stack           000000 constant        entry                    external dcl 5-370
file_header                            based           structure                level 1 unaligned dcl 5-274
free_action                            internal static fixed bin(17,0)          initial dcl 6-6
free_cb_file                    000000 constant        entry                    external dcl 5-361
free_position_stack             000000 constant        entry                    external dcl 5-371
free_seg                        000000 constant        entry                    external dcl 5-367
free_seg_ptrs                   000000 constant        entry                    external dcl 5-365
get_new_seg                     000000 constant        entry                    external dcl 5-366
get_seg_ptr                     000000 constant        entry                    external dcl 5-362
gk_info                                based           structure                level 1 unaligned dcl 1-41
gk_info_ptr                            automatic       pointer                  dcl 1-63
gk_key_len                             automatic       fixed bin(17,0)          dcl 1-64
ind_des_structure                      based           structure                level 1 packed unaligned dcl 5-89
ind_structure                          based           structure                level 1 unaligned dcl 5-102
info                                   automatic       fixed bin(17,0)          dcl 1071
insert_action                          internal static fixed bin(17,0)          initial dcl 6-18
iox_$iocb_version_sentinel             external static char(4)                  dcl 3-51
make_designator                 000000 constant        entry                    external dcl 5-363
max                                                    builtin function         dcl 5-394
min                                                    builtin function         dcl 5-395
mode_value_ptr                         automatic       pointer                  dcl 2-6
must_adjust                            internal static fixed bin(17,0)          initial dcl 6-21
must_rollback                          internal static fixed bin(17,0)          initial dcl 6-22
non_eof_delete                         internal static fixed bin(17,0)          initial dcl 6-5
number_of_modes                        automatic       fixed bin(17,0)          dcl 2-6
old_file_base                          based           structure                level 1 unaligned dcl 5-331
read_exclude                           internal static fixed bin(17,0)          initial dcl 6-10
reassigning_key                        internal static fixed bin(17,0)          initial dcl 6-9
record_block_structure                 based           structure                level 1 unaligned dcl 5-115
rel                                                    builtin function         dcl 5-396
replace_action                         internal static fixed bin(17,0)          initial dcl 6-16
reverse                                                builtin function         dcl 5-383
rewrite_action                         internal static fixed bin(17,0)          initial dcl 6-17
rk_info                                based           structure                level 1 unaligned dcl 1-22
rk_info_ptr                            automatic       pointer                  dcl 1-37
rk_key_len                             automatic       fixed bin(17,0)          dcl 1-38
rollback_action                        internal static fixed bin(17,0)          initial dcl 6-2
seg_ptr                                automatic       pointer                  dcl 5-86
seq_info                               based           structure                level 1 unaligned dcl 7-11
set_bitcounts                   000000 constant        entry                    external dcl 5-368
short_iox_modes                        internal static char(4)                  initial array dcl 4-12
stat_header_size                       internal static fixed bin(17,0)          initial dcl 5-380
stat_structure                         based           structure                level 1 unaligned dcl 5-92
time_stamp_structure                   based           structure                level 1 packed unaligned dcl 5-112
true_max_comp_num                      internal static fixed bin(17,0)          initial dcl 5-379
truncate_action                        internal static fixed bin(17,0)          initial dcl 6-20
uns_info                               based           structure                level 1 unaligned dcl 7-1
unshared_opening                       internal static fixed bin(17,0)          initial dcl 6-4
unspec                                                 builtin function         dcl 5-391
vbl_info                               based           structure                level 1 unaligned dcl 7-55
verify                                                 builtin function         dcl 5-383
write_trunc                            internal static fixed bin(17,0)          initial dcl 6-7

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_FREE_NODES                005312 constant        label                    dcl 487 ref 464 467 471 475
END_FREE_NODE_PROCESSING        005332 constant        label                    dcl 492 ref 485
FAIL10                          006472 constant        label                    dcl 689 ref 553
FAIL11                          006514 constant        label                    dcl 692 set ref 556
FAIL12                          006536 constant        label                    dcl 695 ref 563
FAIL13                          006560 constant        label                    dcl 698 ref 570
FAIL14                          006646 constant        label                    dcl 702 ref 571
FAIL15                          006734 constant        label                    dcl 706 ref 588
FAIL16                          007022 constant        label                    dcl 710 ref 576
FAIL6                           006361 constant        label                    dcl 677 ref 541
FAIL7                           006403 constant        label                    dcl 680 ref 543
FAIL8                           006426 constant        label                    dcl 683 ref 548
FAIL9                           006450 constant        label                    dcl 686 ref 550
FINISH                          007637 constant        label                    dcl 757 ref 210 218 237 245 251 258 305 315 323 334
                                                                                  346 353 365 371 378 392 405 411 441 452 460
INPUT                           010426 constant        label                    dcl 844 set ref 843 851 855 864
NEXT_NODE                       007160 constant        label                    dcl 714 ref 525 527 675 678 681 684 687 690 693 696
                                                                                  700 704 708 712
PROMPT                          010556 constant        label                    dcl 854 ref 868
QUIT                            007566 constant        label                    dcl 753 ref 857
REQUEST_LOOP                    010404 constant        label                    dcl 841 ref 880 891 956 975 994 1014 1030 1043
SKIP_SON                        006356 constant        label                    dcl 670 ref 630 639 644
SON_OK_SO_FAR                   006141 constant        label                    dcl 632 ref 624
get_ptr                         010124 constant        entry                    internal dcl 798 ref 466 481 632 944 945 967 986
                                                                                  1006 1022 1038
janitor                         007674 constant        entry                    internal dcl 769 ref 177 757
tell                            010302 constant        entry                    internal dcl 822 ref 677 680 683 686 689 692 695 698
                                                                                  702 706 710
tell$bad_desc                   010723 constant        entry                    internal dcl 873 ref 804 808
tell$bad_free_node              010772 constant        entry                    internal dcl 883 ref 470 474
tell$bad_key_byte_count_in_header
                                011043 constant        entry                    internal dcl 901 ref 750
tell$bad_key_count_in_header    011076 constant        entry                    internal dcl 911 ref 748
tell$bad_node_count_in_header   011131 constant        entry                    internal dcl 921 ref 746
tell$dup_son_ptr                011164 constant        entry                    internal dcl 937 ref 655
tell$empty_son                  011365 constant        entry                    internal dcl 958 ref 643
tell$free_son                   011477 constant        entry                    internal dcl 977 ref 638
tell$non_node_comp_son          011611 constant        entry                    internal dcl 997 ref 627
tell$root_sons_ptr              011723 constant        entry                    internal dcl 1016 ref 616
tell$unreferenced_node          012026 constant        entry                    internal dcl 1033 ref 738
vfile_find_bad_nodes            002264 constant        entry                    external dcl 27

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13362       13506   12542       13372
Length     14162   12542       124         437     620           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
vfile_find_bad_nodes                955 external procedure  is an external procedure.  
on unit on line 177                  64 on unit               
on unit on line 510                  64 on unit               
janitor                             136 internal procedure  is called by several nonquick procedures.  
get_ptr                              96 internal procedure  is called by several nonquick procedures.  
tell               335 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      336 
      337 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      338 
      339 
      340 out:	proc (L);
      341 	
      342      dcl	L			fixed bin(21),
      343 	Lstr			fixed bin(21),
      344 	Pstr			ptr,
      345 	str			char(Lstr) based(Pstr),
      346 	str_array (Lstr)		char(1) based(Pstr);
      347 
      348 	Nvert_tabs = 0;
      349 	Pstr = Pch;
      350 	Lstr = L;
      351 	do while(Lstr > 0);
      352 	     Cop = find_char_$translate_first_in_table (str, break_table, J);
      353 	     if J = 0 then do;
      354 		call iox_$put_chars (POD.switch, Pstr, Lstr, code);
      355 		if code ^= 0 then go to FATAL_ERROR;
      356 		Lstr = 0;
      357 		end;
      358 	     else do;
      359 		op = binary (unspec(Cop), 9);
      360 		go to OUT(op);
      361 		
      362 OUT(49):						/* IGNORE					*/
      363 OUT(51):						/* BS					*/
      364 OUT(52):						/* HT					*/
      365 OUT(53):						/* NL					*/
      366 OUT(54):						/* NP (should never process one of these.	*/
      367 OUT(55):						/* CR					*/
      368 		call iox_$put_chars (POD.switch, Pstr, J, code);
      369 		if code ^= 0 then go to FATAL_ERROR;
      370 		go to END_OUT;
      371 		
      372 OUT(50):		if J > 1 then do;			/* ESCAPE SEQUENCE.				*/
      373 		     call iox_$put_chars (POD.switch, Pstr, J-1, code);
      374 		     if code ^= 0 then go to FATAL_ERROR;
      375 		     end;
      376 		call ioa_$ioa_switch_nnl (POD.switch, "\^3.3b", unspec(str_array(J)));
      377 		go to END_OUT;
      378 		
      379 OUT(56):		if J > 1 then do;			/* VT					*/
      380 		     call iox_$put_chars (POD.switch, Pstr, J-1, code);
      381 		     if code ^= 0 then go to FATAL_ERROR;
      382 		     end;
      383 		Nvert_tabs = Nvert_tabs + 1;
      384 		call ioa_$ioa_switch_nnl (POD.switch, "^v/", vert_tab_lines(Nvert_tabs));
      385 		go to END_OUT;
      386 
      387 END_OUT:		if J < Lstr then
      388 		     Pstr = addr(str_array(J+1));
      389 		Lstr = Lstr - J;
      390 		end;
      391 	     end;
      392 	end out;
      393 
      394 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      395 
      396 
      397 	end lib_paged_output_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    06/16/86  1344.1  lib_paged_output_.pl1             >udd>m>Farley>audit_dir>hardcore>tct>lib_paged_output_.pl1
80           1    02/28/77  1409.2  lib_paged_output_data_.incl.pl1   >ldd>include>lib_paged_output_data_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALch                                   parameter       fixed bin(21,0)          dcl 33 ref 30 144
APch                                   parameter       pointer                  dcl 33 ref 30 143
Acode                                  parameter       fixed bin(35,0)          dcl 33 set ref 30 139* 142* 331*
BS                              000030 constant        char(1)                  initial unaligned dcl 91 ref 123
CR                              000024 constant        char(1)                  initial unaligned dcl 91 ref 128
Cbreak                          000100 automatic       varying char(512)        dcl 40 set ref 120* 121* 121 122* 122 123* 123 124*
                                                                                  124 125* 125 126* 126 127* 127 128* 128 129* 129
                                                                                  130* 130 131* 131 132* 132 133* 133 134
Cop                             000301 automatic       char(1)                  unaligned dcl 40 set ref 209* 215 352* 359
ESCAPE                          000031 constant        char(1)              000757 numb_key                    vfile_find_bad_nodes
                         000760 pathname                    vfile_find_bad_nodes
                         001034 pos_frame                   vfile_find_bad_nodes
                         001044 pos_ptr                     vfile_find_bad_nodes
                         001046 root_numb_key               vfile_find_bad_nodes
                         001047 save_numb_key_numb          vfile_find_bad_nodes
                         001050 temp_comp_num               vfile_find_bad_nodes
                         001051 unique                      vfile_find_bad_nodes
                         001072 arg_ptr                     vfile_find_bad_nodes
                         001076 err                         vfile_find_bad_nodes
                         001102 aki                         vfile_find_bad_nodes
                         001106 gki                         vfile_find_bad_nodes
                         001112 rki                         vfile_find_bad_nodes
                         001120 mode_string_info_ptr        vfile_find_bad_nodes
                         001122 indx_cb_ptr                 vfile_find_bad_nodes
                         001124 f_b_ptr                     vfile_find_bad_nodes
                         001126 is_ptr                      vfile_find_bad_nodes
                         001130 fs_info                     vfile_find_bad_nodes

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_cs            alloc_bs            cat_realloc_cs      call_var_desc       call_var
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other_desc call_int_other
return              tra_ext             mod_fx1             enable              shorten_stack       ext_entry
int_entry           int_entry_desc      free_based

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               com_err_                      cu_$af_arg_ptr                cu_$af_return_arg
cu_$arg_ptr                   cu_$cp                        delete_$path                  get_pdir_
get_system_free_area_         get_temp_segment_             ioa_                          ioa_$nnl
iox_$attach_name              iox_$close                    iox_$control                  iox_$destroy_iocb
iox_$detach_iocb              iox_$get_line                 iox_$look_iocb                iox_$open
iox_$position                 iox_$read_key                 mode_string_$get_error        mode_string_$parse
pathname_                     release_temp_segment_         unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mode         error_table_$bad_mode_value   error_table_$badopt           error_table_$inconsistent
error_table_$key_duplication  error_table_$noarg            error_table_$not_attached
error_table_$unimplemented_version                          error_table_$wrong_no_of_args iox_$user_input




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 002263       171 002271       172 002273       173 002274       174 002275       175 002276       176 002277
    177 002300       179 002322       180 002323       181 002324       182 002327       183 002330       184 002350
    185 002352       186 002354       188 002356       189 002373       190 002375       191 002376       192 002377
    193 002404       194 002407       196 002410       197 002412       198 002413       199 002420       202 002423
    203 002433       205 002447       206 002461       207 002464       210 002517       212 002520       213 002521
    214 002524       218 002572       220 002573       221 002607       222 002614       223 002616       225 002617
    228 002632       231 002644       232 002654       233 002655       234 002660       237 002716       239 002717
    240 002733       242 002746       243 002775       244 002777       245 003037       247 003040       248 003043
    251 003076       253 003077       255 003106       258 003144       260 003145       261 003165       262 003166
    263 003200       264 003207       265 003215       267 003230       269 003242       271 003254       273 003265
    275 003277       277 003311       282 003337       290 003404       291 003410       292 003412       294 003414
    296 003415       297 003421       298 003423       300 003425       301 003427       302 003435       303 003457
    305 003524       307 003525       308 003533       309 003535       311 003536       312 003550       315 003603
    319 003604       320 003606       323 003641       325 003642       326 003652       328 003654       329 003656
    331 003664       334 003710       338 003711       339 003726       340 003731       341 003751       343 004031
    344 004034       346 004064       348 004065       349 004067       350 004106       351 004110       353 004144
    355 004145       356 004147       359 004150       360 004171       361 004173       365 004222       367 004223
    368 004230       371 004260       373 004261       374 004265       375 004304       376 004306       378 004342
    380 004343       381 004345       383 004346       386 004371       392 004437       397 004440       399 004443
    402 004547       403 004551       405 004574       407 004575       408 004614       409 004616       411 004641
    414 004642       415 004644       416 004646       418 004650       419 004652       420 004654       421 004660
    422 004662       423 004666       424 004670       425 004672       426 004674       427 004676       429 004677
    430 004701       431 004703       432 004705       433 004707       436 004710       437 004725       438 004727
    441 004766       444 004767       445 004770       446 004772       447 004773       448 004776       449 005000
    450 005003       452 005027       454 005030       456 005032       457 005034       458 005055       459 005057
    460 005102       462 005103       463 005104       464 005106       465 005112       466 005115       467 005125
    468 005131       469 005151       470 005153       471 005203       473 005204       474 005206       475 005233
    477 005234       478 005235       479 005241       480 005251       481 005252       482 005266       483 005270
    484 005271       485 005311       487 005312       495 005332       499 005335       500 005336       501 005337
    502 005340       505 005343       506 005351       507 005356       509 005360       510 005400       511 005415
    512 005416       517 005417       518 005425       520 005432       522 005455       523 005461       524 005500
    525 005502       527 005505       530 005510       531 005511       532 005521       540 005537       541 005542
    543 005545       547 005547       548 005552       550 005555       553 005563       556 005570       558 005572
    559 005573       560 005603       561 005612       563 005614       567 005624       569 005637       570 005642
    571 005653       575 005663       576 005666       581 005713       583 005715       584 005720       585 005723
    586 005735       587 005745       588 005751       589 005755       590 005765       593 005770       594 005773
    596 005774       598 006010       599 006012       600 006014       602 006016       603 006021       604 006025
    605 006027       612 006057       614 006067       615 006074       616 006075       620 006104       624 006107
    626 006113       627 006134       630 006140       632 006141       633 006151       635 006155       636 006173
    637 006175       638 006200       639 006204       642 006205       643 006207       644 006213       647 006214
    650 006216       651 006220       652 006250       653 006254       654 006256       655 006305       663 006316
    664 006317       665 006321       666 006323       672 006356       675 006360       677 006361       678 006402
    680 006403       681 006425       683 006426       684 006447       686 006450       687 006471       689 006472
    690 006513       692 006514       693 006535       695 006536       696 006557       698 006560       700 006644
    702 006646       704 006732       706 006734       708 007020       710 007022       712 007156       714 007160
    716 007162       719 007216       721 007236       722 007240       724 007243       725 007275       727 007315
    728 007335       729 007337       730 007341       731 007371       732 007372       733 007374       734 007375
    736 007420       737 007422       738 007426       740 007434       741 007454       743 007506       745 007507
    746 007541       748 007550       750 007557       753 007566       756 007620       757 007637       758 007643
    761 007661       762 007672       769 007673       771 007701       772 007706       773 007716       774 007730
    775 007742       778 010013       779 010020       781 010033       782 010036       783 010047       786 010061
    788 010107       791 010122       798 010123       803 010131       804 010140       805 010166       807 010172
    808 010200       810 010261       813 010266       822 010301       828 010315       829 010317       830 010320
    831 010322       841 010404       843 010407       844 010426       845 010442       846 010466       848 010523
    849 010527       850 010531       851 010550       853 010551       854 010556       855 010572       857 010573
    858 010614       859 010630       861 010645       862 010652       864 010702       867 010703       868 010717
    870 010720       871 010721       873 010722       878 010736       880 010770       883 010771       888 011005
    890 011037       891 011041       901 011042       904 011050       908 011074       911 011075       914 011103
    918 011127       921 011130       924 011136       928 011162       937 011163       940 011171       941 011173
    942 011174       943 011176       944 011200       945 011211       946 011223       948 011254       949 011257
    950 011264       952 011316       953 011321       954 011326       955 011360       956 011363       958 011364
    961 011372       962 011374       963 011375       964 011377       965 011401       966 011403       967 011410
    968 011421       974 011472       975 011475       977 011476       980 011504       981 011506       982 011507
    983 011511       984 011513       985 011515       986 011522       987 011533       993 011604       994 011607
    997 011610      1000 011616      1001 011620      1002 011621      1003 011623      1004 011625      1005 011627
   1006 011634      1007 011645      1013 011716      1014 011721      1016 011722      1019 011730      1020 011732
   1021 011733      1022 011735      1023 011746      1024 011754      1030 012024      1033 012025      1036 012033
   1037 012035      1038 012037      1039 012051      1043 012110


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
