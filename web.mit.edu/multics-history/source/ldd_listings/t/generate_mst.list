	COMPILATION LISTING OF SEGMENT generate_mst
	Compiled by: Multics PL/I Compiler, Release 33e, of October 6, 1992
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/21/92  1108.3 mdt Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1992   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 
       16 
       17 /****^  HISTORY COMMENTS:
       18*  1) change(87-01-19,GDixon), approve(87-04-16,MCR7614),
       19*     audit(87-05-21,Farley), install(87-07-15,MR12.1-1040):
       20*     Add support for storing boot program as first segment of MST image stored
       21*     in a file.
       22*  2) change(87-10-19,Farley), approve(88-02-26,MCR7795),
       23*     audit(88-03-03,Fawcett), install(88-03-15,MR12.2-1035):
       24*     Added default_time_zone statement.
       25*  3) change(87-10-19,Farley), approve(88-02-26,MCR7796),
       26*     audit(88-03-03,Fawcett), install(88-03-15,MR12.2-1035):
       27*     Added default_rpv_data statement.
       28*  4) change(87-11-05,Farley), approve(88-05-13,PBF7795),
       29*     audit(88-05-31,Fawcett), install(88-07-05,MR12.2-1053):
       30*     Corrected default_time_zone code to not require a symbol name
       31*     as part of the statement, as the documentation states.
       32*  5) change(87-11-05,Farley), approve(88-05-13,PBF7796),
       33*     audit(88-05-31,Fawcett), install(88-07-05,MR12.2-1053):
       34*     Corrected default_rpv_data code to not require a symbol name
       35*     as part of the statement, as the documentation states.
       36*  6) change(92-09-21,Schroth), approve(92-10-15,MCR8275),
       37*     audit(92-10-15,WAAnderson), install(92-10-21,MR12.5-1033):
       38*     Corrected uninitialized variable error that was causing tapes to be left
       39*     mounted.  phx21281.
       40*                                                   END HISTORY COMMENTS */
       41 
       42 
       43 generate_mst: gm: proc;
       44 
       45 /* format: off */
       46 
       47 /* *	GENERATE_MST
       48*   *
       49*   *	The Multics System Tape generator. This program parses header files and
       50*   *	generates system tapes, performing a lot less error-checking than it should.
       51*   *	Really, this and check_mst ought to be combined, and made reliable, but that
       52*   *	is a project for another day.
       53*   *
       54*   *	Inherited from the dim and distant past; written time and time again by persons
       55*   *	now unknown to us.
       56*   *
       57*   *	Modified 18 February 1981, W. Olin Sibert, to add add_segnames, delete_name,
       58*   *	   and rationalize error message reporting mechanism.
       59*   *	Modified 31 July, 1981, WOS, to add boot_program and data keywords.
       60*   *	Modified: 11 January 1982 by G. Palter to fix add_segnames to not add names
       61*   *	   of components which have no retained entrypoints
       62*          Modified 6/6/82 BIM for boot_program AND first_name.
       63*   *	Modified 8/23/84 JAF to increase name table from 100 to 150 entries
       64*   *	Modified 3/14/85 by Keith Loepere to fix delete_name statement.
       65*   */
       66 
       67 /* declarations */
       68 
       69 /* argument declarations */
       70 
       71 dcl  a_header_path char (argl (1)) unaligned based (argp (1)), /* relative path name of driving header */
       72      tape_no char (argl (2)) unaligned based (argp (2));	/* numerical designation of output tape */
       73 
       74 /* for fetching and aligning arguments */
       75 
       76 dcl  argp (10) ptr,					/* array of pointers to unaligned arguments */
       77      argl (10) fixed bin (17),			/* array of argument lengths */
       78      code fixed bin (35),				/* error code */
       79      acount fixed bin (17),				/* ccmmand argument count */
       80      barg char (argl (i)) unaligned based (argp (i)),
       81 
       82      header_path char (168) aligned,			/* aligned version of argument */
       83 
       84      sysid char (8),				/* system id */
       85      versid char (8);
       86 
       87 dcl  generated_time fixed bin (71);
       88 dcl  generated_time_string char (32);
       89 
       90 dcl     i fixed bin (17);				/* do loop index */
       91 dcl  open_message char (100); 			/* message from gm_util1_$open */
       92 
       93 
       94 /* for attaching */
       95 
       96 dcl  path_list_name char (168) aligned,			/* full path name of list of search paths */
       97      hdrp ptr;					/* pointer to header */
       98 
       99 dcl  path_array (10) char (168) aligned;		/* array of path names to be searched */
      100 
      101 dcl  sys_desig char (24) aligned var;			/* system designation */
      102 dcl  ion2 char (32) aligned;				/* ioname2 for attaching and detaching tape */
      103 
      104 /* for reading */
      105 
      106 dcl  numc fixed bin (17),				/* number of characters read */
      107      ndir fixed bin (17);				/* number of directories to be searched */
      108 
      109 dcl  error_label label;				/* for error recovery */
      110 
      111 dcl  out_sgna char (32) aligned;
      112 
      113 /* for parsing header */
      114 
      115 dcl  symp ptr init (null),				/* pointer to current symbol */
      116      arg char (numc) unaligned based (symp);		/* mask for looking at symbol */
      117 
      118 dcl  seg_name char (32)aligned init (""),		/* reference name of segment */
      119      nnam fixed bin (17);				/* number of names found in header entry */
      120 
      121 /* for processing keyword arguments */
      122 
      123 
      124 /* for creating segment blocks */
      125 
      126 dcl  in_p ptr,					/* pointer to segment in searched directory */
      127      segp ptr,					/* pointer to segment to be written on tape */
      128 
      129      bitcnt fixed bin (24),				/* bit count of segment as found */
      130      sg_b fixed bin (24),				/* bit count of block to be written */
      131 
      132      tx_l fixed bin (17),				/* length of text section */
      133      sg_l fixed bin (17);				/* length of block to be written */
      134 
      135 dcl  cur_len_for_bitcnt fixed bin (18);			/* current length in words */
      136 
      137 
      138 dcl  path_ptr ptr,
      139 
      140      1 path aligned based (path_ptr),			/* path name structure */
      141      2 size fixed bin (17),
      142      2 name char (168);
      143 
      144 dcl  names_ptr ptr,
      145 
      146      1 seg_name_array aligned based (names_ptr),		/* name structure */
      147      2 count fixed bin (17),
      148      2 names (max_count),
      149      3 size fixed bin (17),
      150      3 name char (32);
      151 
      152 dcl  acl_count_ptr ptr,
      153      acl_block_ptr ptr,
      154      acl_count fixed bin (17) based (acl_count_ptr);
      155 
      156 
      157 dcl 1 acla based (acl_block_ptr) aligned,
      158     2 userid char (32),
      159     2 mode bit (36),
      160     2 pad bit (36),
      161     2 code fixed bin;
      162 
      163 
      164 dcl  max_count fixed bin (17) static init (150),
      165      seg_name_l fixed bin (17);			/* to remember length of seg name */
      166 
      167 
      168 dcl  seg_header_length fixed bin,			/* length of header data in words */
      169      header_words fixed bin (35),			/* number of words to be written in header write */
      170      wr_w fixed bin (17),				/* number of wds written in seg write */
      171      seg_hdrp ptr;					/* pointer to header info */
      172 
      173 dcl 1 control_word based aligned,
      174     2 ident fixed bin (17) unal,			/* identifier portion of control word */
      175     2 length fixed bin (17) unal,			/* 2 length portion */
      176     2 col_no fixed bin (17) unal,			/* for 2 collection mark unal,number */
      177     2 col_sub_no fixed bin (17) unal;			/* for collection mark; */
      178 
      179 dcl  cw_ptr ptr,					/* pointer to segment control word */
      180 
      181      header_max_size fixed bin static init (1500),	/* size of header data array */
      182      header_data (1500) fixed bin (35);			/* actual header data */
      183 
      184 dcl (addr, addrel, after, before, bin, bit, clock, divide, fixed, index, length,
      185      maxlength, null, reverse, rtrim, substr, translate, unspec) builtin;
      186 
      187 dcl  o_ln char (132) aligned;
      188 
      189 dcl  last_path char (32) aligned;			/* for setting path_found */
      190 
      191 dcl  oa_ptr ptr;					/* dcls for setting access in output line */
      192 
      193 dcl  error_in_object_segment bit (1) aligned;
      194 
      195 dcl  mst_tape_iocbp ptr init (null);
      196 dcl  gm_output_iocbp ptr init (null);
      197 
      198 dcl 1 output_access unaligned based (oa_ptr),
      199     2 (read, execute, write, privileged) bit (1);
      200 
      201 dcl  output_access_word char (8) aligned;
      202 
      203 dcl  tape_er_count fixed bin (17);			/* for keeping track of tape errors */
      204 
      205 /* for system_id feature */
      206 
      207 dcl  movewds bit (bitcnt) aligned based,		/* array to move seg into temp */
      208      real_in_p ptr,					/* save for original seg ptr */
      209      symbol_name char (32),				/* name of symbol to be overlaid with sysid */
      210      based_char_32 char (32) based,			/* for moving name  */
      211      based_bit_72 bit (72) based,
      212      time_as_bit bit (72),
      213      id_ptr pointer,
      214      default_rpv_data char (24) var,
      215      default_time_zone char (4),
      216     (lang_index, zone_index) fixed bin,
      217      unique_name char (15);				/* name of copied segment */
      218 
      219 dcl 1 oi aligned like object_info;
      220 
      221 dcl  object_segment bit (1) aligned;			/* flag to indicate whether oi is valid for current segment */
      222 
      223 
      224 /* flag declarations */
      225 
      226 dcl (sysid_hit,
      227      versid_hit,
      228      db_hit,
      229      hd_hit,
      230      do_hit,
      231      dr_hit,
      232      path_name_found,
      233      no_error_was_found,
      234      cur_length_found,
      235      bit_count_found,
      236      cache_found,
      237      acl_found,
      238      linkage_found,
      239      end_found,
      240      boot_program_has_been_processed,
      241      segments_have_been_processed
      242      ) bit (1) aligned;
      243 
      244 dcl  sym_is_a_break fixed bin (1),
      245      eof_was_found fixed bin (1);
      246 
      247 /* external declarations */
      248 
      249 dcl  cu_$arg_count entry (fixed bin);
      250 dcl  cu_$arg_ptr entry (fixed bin, pointer, fixed bin, fixed bin (35));
      251 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin);
      252 dcl  date_time_$format entry (char (*), fixed bin (71), char (*), char (*)) returns (char (250) var);
      253 dcl  decode_definition_$full entry (pointer, pointer, pointer) returns (bit (1) aligned);
      254 dcl  delete_$ptr entry (pointer, bit (6), char (*), fixed bin (35));
      255 dcl  gm_error_ entry (fixed bin (35), char (32) aligned, pointer, pointer, char (*),
      256      pointer, bit (1) aligned, bit (1) aligned, bit (1) aligned, pointer, pointer);
      257 dcl  gm_util_ entry (char (32) aligned, fixed bin (17), pointer, pointer, bit (1) aligned, bit (1) aligned);
      258 dcl  gm_util1_$close entry (pointer, pointer, bit (1) aligned);
      259 dcl  gm_util1_$open entry (pointer, char (168) aligned, fixed bin, char (168) aligned, pointer, char (32) aligned,
      260      pointer, pointer, char (32) aligned, fixed bin (35), char (*), bit (1) aligned, bit (1) aligned, char (8));
      261 dcl  gm_write_first_seg_ entry (pointer, fixed bin (24), pointer, pointer, bit (1) aligned, fixed bin (35));
      262 dcl  gm_write_boot_program_ entry (ptr, fixed bin(24), char(*), ptr, bit(1) aligned,
      263 				     bit(1) aligned, fixed bin(35));
      264 dcl  hcs_$initiate_count entry (char (*) aligned, char (*) aligned, char (*),
      265      fixed bin (24), fixed bin, pointer, fixed bin (35));
      266 dcl  hcs_$make_ptr entry (pointer, char (*), char (*), pointer, fixed bin (35));
      267 dcl  hcs_$make_seg entry (char (*), char (*), char (*), fixed bin (5), pointer, fixed bin (35));
      268 dcl  hcs_$set_bc_seg entry (pointer, fixed bin (24), fixed bin (35));
      269 dcl  hcs_$terminate_noname entry (pointer, fixed bin (35));
      270 dcl  ioa_ entry options (variable);
      271 dcl  iox_$control entry (pointer, char (*), pointer, fixed bin (35));
      272 dcl  iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35));
      273 dcl  object_info_$brief entry (pointer, fixed bin (24), pointer, fixed bin (35));
      274 dcl  parse_file_$parse_file_ptr entry (pointer, fixed bin (17), fixed bin (1), fixed bin (1));
      275 dcl  parse_file_$parse_file_unset_break entry (char (*));
      276 dcl  print_gen_info_ entry (pointer, fixed bin (24), char (*), fixed bin (35));
      277 dcl  unique_chars_ entry (bit (*) aligned) returns (char (15));
      278 
      279 dcl  gm_data_$default_path_list_name char (168) varying external static;
      280 
      281 dcl  date_time_ entry (fixed bin(71), char(*));
      282 
      283 
      284 dcl (error_table_$noarg,
      285      error_table_$noentry,
      286      error_table_$badopt) fixed bin (35) external static;
      287 
      288 dcl  cleanup condition;
      289 
      290 /*  */
      291 
      292 /* initializations */
      293 
      294           generated_time = clock ();
      295 	segments_have_been_processed = "0"b;
      296 	boot_program_has_been_processed = "0"b;
      297 
      298 	ndir,
      299 	code = 0;
      300 
      301 	real_in_p,
      302 	in_p = null;
      303 
      304 	seg_hdrp = addr (header_data);
      305 
      306 	sltep = addrel (seg_hdrp, 1);
      307 
      308 	names_ptr = addrel (seg_hdrp, 5);
      309 
      310 	seg_hdrp -> control_word.ident = 0;
      311 
      312 	oa_ptr = addr (sltep -> slte.access);
      313 
      314 	last_path = " ";
      315 
      316 	oi.version_number = object_info_version_2;
      317 
      318 	on cleanup call CLEANUP_CONDITION_HANDLER;
      319 
      320 /*  */
      321 
      322 /* preliminary work */
      323 
      324 	sysid_hit, versid_hit, db_hit, dr_hit, do_hit, hd_hit = "0"b;
      325 	call cu_$arg_count (acount);
      326 	do i = 1 to acount;				/* fetch arguments */
      327 	     call cu_$arg_ptr (i, argp (i), argl (i), code);
      328 	end;
      329 
      330 	if acount < 2 then do;
      331 noarg:	     code = error_table_$noarg;
      332 	     call ERROR ("Argument missing.", "1"b);
      333 	end;
      334 
      335 	do i = 3 to acount while (i <= acount);		/* process optional args */
      336 	     if barg = "-dr" | barg = "-directory" then dr_hit = "1"b;
      337 	     else if barg = "-file" | barg = "-f" then db_hit = "1"b;
      338 	     else if barg = "-notape" | barg = "notape" then do_hit = "1"b;
      339 	     else if barg = "-hold" | barg = "-hd" then hd_hit = "1"b;
      340 	     else if barg = "-sysid" | barg = "-sys_id" then do;
      341 		if i = acount then go to noarg;
      342 		i = i + 1;
      343 		sysid_hit = "1"b;
      344 		sysid = barg;
      345 	     end;
      346 	     else if barg = "-versid" | barg = "-vers_id" then do;
      347 		if i = acount then go to noarg;
      348 		i = i + 1;
      349 		versid_hit = "1"b;
      350 		versid = barg;
      351 	     end;
      352 	     else do;
      353 		code = error_table_$badopt;
      354 		call ERROR ("Invalid option specified.", "1"b);
      355 	     end;
      356 	end;
      357 
      358 	header_path = a_header_path || ".header";	/* make the header name */
      359 	i = index (reverse (a_header_path), ">") - 1;	/* locate last ">" */
      360 	if i = -1 then sys_desig = a_header_path;
      361 	else sys_desig = substr (a_header_path, argl (1) - i + 1, i); /* use it as the system designation */
      362 	if ^sysid_hit then sysid = sys_desig;
      363 	if ^versid_hit then versid = sysid;
      364 	ion2 = tape_no;				/* create ioname 2 */
      365 	out_sgna = sys_desig || ".list";		/* create the output listing file name */
      366 
      367 	if dr_hit then path_list_name = sys_desig || ".search"; /* create special path list name if used */
      368 	else path_list_name = gm_data_$default_path_list_name;
      369 
      370 	call gm_util1_$open (addr (path_array), path_list_name, ndir, header_path, hdrp, ion2,
      371 	     mst_tape_iocbp, gm_output_iocbp, out_sgna, code, open_message, db_hit, do_hit, sysid);
      372 	if open_message ^= "" then
      373 	     call ERROR (open_message, "1"b);
      374 
      375 	call parse_file_$parse_file_unset_break (">_!*""."); /* ">","_","!","*",""","." should not be breaks */
      376 
      377 /*  */
      378 
      379 next_segment:
      380 	path_name_found,
      381 	acl_found,
      382 	cur_length_found,
      383 	bit_count_found,
      384 	cache_found,
      385 	linkage_found,
      386 	end_found = "0"b;
      387 	no_error_was_found = "1"b;
      388 
      389 	error_label = skip_to_next_seg;
      390 
      391 	call GET_NEXT_ARG;				/* Look at next keyword. */
      392 
      393 	if arg = "fini" then do;			/* If end of tape ... */
      394 close_out:     call gm_util1_$close (gm_output_iocbp, mst_tape_iocbp, hd_hit);
      395 	     return;				/* This is the end. */
      396 	end;
      397 
      398 	else if arg = "collection" then do;		/* If end of collection ... */
      399 	     call TEST_BREAK (":");
      400 
      401 	     sltep -> control_word.length = 1;		/* set length */
      402 	     sltep -> control_word.ident = 2;		/* set identifying portion */
      403 	     call GET_NEXT_ARG;
      404 
      405 	     if index (arg, ".") = 0
      406 	     then do;
      407 		sltep -> control_word.col_no = cv_dec_check_ (arg, code);
      408 		if code ^= 0 then 
      409 C_ERROR:		do;
      410 		     call ERROR ("Malformed collection number " || arg, "1"b);
      411 		end;
      412 		sltep -> control_word.col_sub_no = 0;
      413 	     end;
      414 	     else do;
      415 		sltep -> control_word.col_no = cv_dec_check_ (before (arg, "."), code);
      416 		if code ^= 0 then go to C_ERROR;
      417 		sltep -> control_word.col_sub_no = cv_dec_check_ (after (arg, "."), code);
      418 		if code ^= 0 then go to C_ERROR;
      419 	     end;
      420 
      421 	     call TEST_BREAK (";");
      422 	     call ioa_ ("Writing collection ^d.^d mark.", sltep -> control_word.col_no, sltep -> control_word.col_sub_no);
      423 	     call WRITE_COLLECTION;
      424 	end;
      425 
      426 	else if arg = "name" then			/* If beginning of segment. */
      427 	     call PROCESS_SEGMENT (NORMAL_SEG);
      428 
      429 	else if arg = "object" then
      430 	     call PROCESS_SEGMENT (WHOLE_OBJECT_SEG);
      431 
      432 	else if arg = "text" then
      433 	     call PROCESS_SEGMENT (TEXT_ONLY_SEG);
      434 
      435 	else if arg = "data" then
      436 	     call PROCESS_SEGMENT (DATA_SEG);
      437 
      438 	else if arg = "first_name" then do;
      439 	     if segments_have_been_processed then	/* Should be first thing in header. */
      440 		call ERROR ("first_name statement encountered after other segment definitions.", "0"b);
      441 	     call PROCESS_SEGMENT (FIRST_SEG);
      442 	end;
      443 
      444 	else if (arg = "boot_program") then do; 	/* Must come first */
      445 	     if segments_have_been_processed | boot_program_has_been_processed then
      446 		call ERROR ("boot_program statement encountered after other segment definitions.", "0"b);
      447 	     call PROCESS_SEGMENT (BOOT_PROGRAM_SEG);
      448 	end;
      449 
      450 	else if arg = "fabricate" then
      451 	     call PROCESS_SEGMENT (FABRICATED_SEG);
      452 
      453 	else					/* Error. */
      454 	     call ERROR ("Unrecognized primary keyword.", "0"b);
      455 
      456 
      457 	go to next_segment;
      458 
      459 /*  */
      460 
      461 PROCESS_SEGMENT: proc (seg_type);
      462 
      463 dcl  seg_type fixed bin;				/* segment type */
      464 
      465 
      466 /* This next allows first_name to follow boot_program */
      467 
      468           if seg_type = BOOT_PROGRAM_SEG
      469 	then boot_program_has_been_processed = "1"b;
      470 	else segments_have_been_processed = "1"b;
      471 
      472 	call TEST_BREAK (":");
      473 
      474 	call GATHER_NAMES;				/* Gather up the names. */
      475 
      476 	call INIT_SEGMENT;				/* Initiate segment and get lengths. */
      477 
      478 	error_label = skip_to_next_statement;
      479 
      480 seg_loop:
      481 	call GET_NEXT_ARG;				/* Get next keyword. */
      482 
      483 /* add_segnames statement */
      484 
      485 	if (arg = "add_segnames") | (arg = "include_segnames") then /* Add all segnames to the list of names */
      486 	     call GATHER_SEGNAMES ();
      487 
      488 /* delete_name statement */
      489 
      490 	else if (arg = "delete_name") | (arg = "delete_names") then
      491 	     call DELETE_NAMES ();
      492 
      493 /* pathname statement */
      494 
      495 	else if (arg = "path_name") | (arg = "pathname") then do;
      496 	     if acl_found then
      497 		call ERROR ("""path_name"" keyword found after ""acl"" keyword.", "0"b);
      498 	     path_name_found = "1"b;
      499 	     call TEST_BREAK (":");
      500 
      501 	     call GET_NEXT_ARG;
      502 	     path.size = numc;
      503 	     path.name = arg;			/* take path name from arg because it may be > 32 chars */
      504 	     slte.branch_required = "1"b;
      505 
      506 	     seg_header_length = seg_header_length + 1 + divide (numc + 3, 4, 17, 0); /* add it to header length */
      507 	     if seg_header_length > header_max_size then
      508 		call ERROR ("Header buffer area overflow.", "0"b);
      509 	     cw_ptr = addrel (sltep, seg_header_length); /* set control word mask */
      510 	     call TEST_BREAK (";");
      511 	end;
      512 
      513 /* access statement */
      514 
      515 	else if arg = "access" then do;
      516 	     call TEST_BREAK (":");
      517 	     slte.access = "0000"b;
      518 	     do while (arg ^= ";");
      519 		call GET_NEXT_ARG;
      520 		if arg = "read" then substr (slte.access, 1, 1) = "1"b;
      521 		else if arg = "write" then substr (slte.access, 3, 1) = "1"b;
      522 		else if arg = "execute" then substr (slte.access, 2, 1) = "1"b;
      523 		else if arg = "privileged" then substr (slte.access, 4, 1) = "1"b;
      524 		else call ERROR ("Invalid argument.", "0"b);
      525 
      526 		call GET_NEXT_BREAK;
      527 		if (arg ^= ",") & (arg ^= ";") then
      528 		     call ERROR ("Invalid break.", "0"b);
      529 	     end;
      530 	end;
      531 
      532 /* per_process statement */
      533 
      534 	else if arg = "per_process" then
      535 	     slte.per_process = YES_NO ();
      536 
      537 /* wired statement */
      538 
      539 	else if arg = "wired" then do;
      540 	     slte.wired = YES_NO ();
      541 	     if slte.wired then slte.link_sect_wired = "1"b;
      542 	     if ^path_name_found then slte.paged = ^slte.wired;
      543 	end;
      544 
      545 /* init_seg statement */
      546 
      547 	else if arg = "init_seg" then do;
      548 	     slte.init_seg = YES_NO ();
      549 	     if slte.init_seg then slte.paged = "1"b;
      550 	end;
      551 
      552 /* temp_seg statement */
      553 
      554 	else if arg = "temp_seg" then do;
      555 	     slte.temp_seg = YES_NO ();
      556 	     if slte.temp_seg then slte.paged = "1"b;
      557 	     slte.init_seg = slte.temp_seg;
      558 	end;
      559 
      560 /* firmware */
      561 
      562 	else if arg = "firmware" then do;
      563 	     slte.firmware_seg = YES_NO ();
      564 	     if slte.firmware_seg
      565 	     then slte.wired = "1"b;
      566 	end;
      567 
      568 /* paged statement */
      569 
      570 	else if arg = "paged" then
      571 	     slte.paged = YES_NO ();
      572 
      573 /* cur_length statement */
      574 
      575 	else if arg = "cur_length" then do;
      576 	     call TEST_BREAK (":");
      577 	     cur_len_for_bitcnt = GET_NUM ();
      578 	     call TEST_BREAK (";");
      579 	     slte.cur_length = bit (divide (cur_len_for_bitcnt + 1023, 1024, 9, 0), 9);
      580 	     if ^bit_count_found then
      581 		slte.bit_count = bit (bin (cur_len_for_bitcnt * 36, 24));
      582 	     cur_length_found = "1"b;
      583 	end;
      584 
      585 /* ringbrack statement */
      586 
      587 	else if arg = "ringbrack" then do;
      588 	     call TEST_BREAK (":");
      589 	     slte.ringbrack (1) = bit (bin (GET_NUM (), 3));
      590 	     call GET_NEXT_BREAK;
      591 	     if arg = "," then do;
      592 		slte.ringbrack (2) = bit (bin (GET_NUM (), 3));
      593 		call GET_NEXT_BREAK;
      594 		if arg = "," then do;
      595 		     slte.ringbrack (3) = bit (bin (GET_NUM (), 3));
      596 		     call TEST_BREAK (";");
      597 		end;
      598 		else if arg = ";" then
      599 		     slte.ringbrack (3) = slte.ringbrack (2);
      600 		else
      601 		     call ERROR ("Invalid break.", "0"b);
      602 	     end;
      603 	     else if arg = ";" then
      604 		slte.ringbrack (3), slte.ringbrack (2) = slte.ringbrack (1);
      605 	     else
      606 		call ERROR ("Invalid break.", "0"b);
      607 	end;
      608 
      609 /* wired_link statement */
      610 
      611 	else if arg = "wired_link" then
      612 	     slte.link_sect_wired = YES_NO ();
      613 
      614 /* combine_link statement */
      615 
      616 	else if arg = "combine_link" then
      617 	     slte.combine_link = YES_NO ();
      618 
      619 /* acl statement */
      620 
      621 	else if arg = "acl" then do;
      622 	     call TEST_BREAK (":");
      623 
      624 	     if ^acl_found then do;
      625 		acl_count_ptr = cw_ptr;		/* set pointer to ACL entry count */
      626 		acl_count = 0;
      627 		cw_ptr = addrel (cw_ptr, 1);		/* set pointer to scw */
      628 		seg_header_length = seg_header_length + 1;
      629 		if seg_header_length > header_max_size then
      630 		     call ERROR ("Header buffer area overflow.", "0"b);
      631 		acl_found = "1"b;
      632 		slte.acl_provided = "1"b;
      633 	     end;
      634 
      635 	     acl_count = acl_count + 1;
      636 	     acl_block_ptr = cw_ptr;			/* set pointer for ACL fill-in */
      637 	     seg_header_length = seg_header_length + 11;
      638 	     if seg_header_length > header_max_size then
      639 		call ERROR ("Header buffer area overflow.", "0"b);
      640 	     cw_ptr = addrel (cw_ptr, 11);
      641 
      642 	     call GET_NEXT_ARG;
      643 	     acl_block_ptr -> acla.mode = "0"b;
      644 	     if arg ^= "null" then do i = 1 to numc;
      645 		if substr (arg, i, 1) = "r" then
      646 		     substr (acl_block_ptr -> acla.mode, 1, 1) = "1"b;
      647 		else if substr (arg, i, 1) = "e" then
      648 		     substr (acl_block_ptr -> acla.mode, 2, 1) = "1"b;
      649 		else if substr (arg, i, 1) = "w" then
      650 		     substr (acl_block_ptr -> acla.mode, 3, 1) = "1"b;
      651 		else
      652 		     call ERROR ("Invalid argument.", "0"b);
      653 	     end;
      654 
      655 	     acl_block_ptr -> acla.pad = "0"b;
      656 	     acl_block_ptr -> acla.code = 0;
      657 
      658 	     call TEST_BREAK (",");
      659 
      660 	     call GET_NEXT_ARG;
      661 	     acl_block_ptr -> acla.userid = arg;
      662 
      663 	     call TEST_BREAK (";");
      664 	end;
      665 
      666 /* bit_count statement */
      667 
      668 	else if arg = "bit_count" then do;
      669 	     call TEST_BREAK (":");
      670 	     slte.bit_count = bit (bin (GET_NUM (), 24));
      671 	     call TEST_BREAK (";");
      672 	     if ^cur_length_found then
      673 		slte.cur_length = bit (divide (divide (bin (slte.bit_count, 24) + 35, 36, 18, 0) + 1023, 1024, 9, 0));
      674 	     bit_count_found = "1"b;
      675 	end;
      676 
      677 /* max_length statement */
      678 
      679 	else if arg = "max_length" then do;
      680 	     call TEST_BREAK (":");
      681 	     slte.max_length = bit (bin (GET_NUM (), 9));
      682 	     call TEST_BREAK (";");
      683 	end;
      684 
      685 /* cache statement */
      686 
      687 	else if arg = "cache" then do;
      688 	     slte.cache = YES_NO ();
      689 	     cache_found = "1"b;
      690 	end;
      691 
      692 /* sys_id statement */
      693 
      694 	else if (arg = "sys_id") | (arg = "sysid") then do;
      695 	     call TEST_BREAK (":");
      696 	     call GET_NEXT_ARG;
      697 	     symbol_name = arg;
      698 	     if real_in_p = null then
      699 		call COPY_SEGMENT;
      700 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      701 	     if code ^= 0 then
      702 		call ERROR ("Unable to find sysid symbol.", "1"b);
      703 	     id_ptr -> based_char_32 = sysid;
      704 	     call TEST_BREAK (";");
      705 	end;
      706 
      707 /* vers_id statement */
      708 
      709 	else if (arg = "vers_id") | (arg = "versid") then do;
      710 	     call TEST_BREAK (":");
      711 	     call GET_NEXT_ARG;
      712 	     symbol_name = arg;
      713 	     if real_in_p = null then
      714 		call COPY_SEGMENT;
      715 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      716 	     if code ^= 0 then
      717 		call ERROR ("Unable to find versid symbol.", "1"b);
      718 	     id_ptr -> based_char_32 = versid;
      719 	     call TEST_BREAK (";");
      720 	end;
      721 
      722 /* generation_time statement */
      723 
      724 	else if (arg = "generation_time") then do;
      725 	     call TEST_BREAK (":");
      726 	     call GET_NEXT_ARG;
      727 	     symbol_name = arg;
      728 	     if real_in_p = null then
      729 		call COPY_SEGMENT;
      730 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      731 	     if code ^= 0 then
      732 		call ERROR ("Unable to find generation_time symbol.", "1"b);
      733 	     time_as_bit = unspec (generated_time);
      734 	     id_ptr -> based_bit_72 = time_as_bit;
      735 	     call TEST_BREAK (";");
      736 	end;
      737 
      738 /* generation_time_string statement */
      739 
      740 	else if (arg = "generation_time_string") then do;
      741 	     call TEST_BREAK (":");
      742 	     call GET_NEXT_ARG;
      743 	     symbol_name = arg;
      744 	     if real_in_p = null then
      745 		call COPY_SEGMENT;
      746 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      747 	     if code ^= 0 then
      748 		call ERROR ("Unable to find generation_time_string symbol.", "1"b);
      749 	     call date_time_ (generated_time, generated_time_string);
      750 	     generated_time_string = translate (generated_time_string,
      751 		" ", /* SPACE */
      752 		"	"/* TAB */);
      753 	     id_ptr -> based_char_32 = generated_time_string;
      754 	     call TEST_BREAK (";");
      755 	end;
      756 
      757 /* default_time_zone statement */
      758 
      759 	else if (arg = "default_time_zone") then do;
      760 	     symbol_name = "default_time_zone";
      761 	     if real_in_p = null then
      762 		call COPY_SEGMENT;
      763 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      764 	     if code ^= 0 then
      765 		call ERROR ("Unable to find default_time_zone symbol.", "1"b);
      766 	     call GET_NEXT_BREAK;
      767 	     if (arg ^= ":") & (arg ^= ";") then
      768 		call ERROR ("Invalid break.", "0"b);
      769 	     if arg = ":" then do;			/* value defined */
      770 		call GET_NEXT_ARG;
      771 		default_time_zone = arg;
      772 		call TEST_BREAK (";");
      773 	     end;
      774 	     else default_time_zone = date_time_$format ("^za", generated_time, "", "");
      775 						/* use current perprocess time zone */
      776 	     substr (id_ptr -> based_char_32, 1, 4) = default_time_zone;
      777 	     symbol_name = rtrim (symbol_name) || "_delta";
      778 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      779 	     if code ^= 0 then
      780 		call ERROR ("Unable to find default_time_zone delta symbol.", "1"b);
      781 	     do lang_index = 1 to ti_zone.number_lang;
      782 		do zone_index = 1 to ti_zone.number_zone;
      783 		     if ti_zone.short (lang_index, zone_index) = default_time_zone then goto found_time_zone;
      784 		end;
      785 	     end;
      786 	     call ERROR ("Unable to find default_time_zone in time_info_.", "1"b);
      787 found_time_zone:
      788 	     time_as_bit = unspec (ti_zone.delta (lang_index, zone_index));
      789 	     id_ptr -> based_bit_72 = time_as_bit;
      790 	end;
      791 
      792 /* default_rpv_data statement */
      793 
      794 	else if (arg = "default_rpv_data") then do;
      795 	     call TEST_BREAK (":");
      796 	     symbol_name = "default_rpv_data";
      797 	     if real_in_p = null then
      798 		call COPY_SEGMENT;
      799 	     call hcs_$make_ptr (in_p, unique_name, symbol_name, id_ptr, code);
      800 	     if code ^= 0 then
      801 		call ERROR ("Unable to find default_rpv_data symbol.", "1"b);
      802 	     default_rpv_data = "";
      803 	     call GET_NEXT_SYM;
      804 	     do while (arg ^= ";");
      805 		if length (default_rpv_data) + length (arg) + 1 > maxlength (default_rpv_data) then
      806 		     call ERROR ("Maximum length of default_rpv_data has been exceeded.", "1"b);
      807 		default_rpv_data = default_rpv_data || arg || " ";
      808 		call GET_NEXT_SYM;
      809 	     end;
      810 	     substr (id_ptr -> based_char_32, 1, 24) = default_rpv_data;
      811 	end;
      812 
      813 /* abs_seg statement */
      814 
      815 	else if arg = "abs_seg" then
      816 	     slte.abs_seg = YES_NO ();
      817 
      818 /* linkage statement */
      819 
      820 	else if arg = "linkage" then do;
      821 	     call TEST_BREAK (";");
      822 	     if (seg_type ^= NORMAL_SEG) & (seg_type ^= WHOLE_OBJECT_SEG) then   /* "linkage" illegal others */
      823 		call ERROR ("Linkage keyword with no segment block.", "0"b);
      824 	     slte.link_provided = "1"b;
      825 
      826 	     if seg_type = NORMAL_SEG then do;		/* name followed by linkage,want text only */
      827 		sg_l, wr_w = oi.tlng;
      828 		sg_b = sg_l * 36;
      829 	     end;
      830 
      831 	     if no_error_was_found then
      832 		call WRITE_SEGMENT (seg_type);
      833 
      834 	     sg_l, wr_w = oi.llng;			/* set link block length, words to be written */
      835 	     sg_b = oi.llng * 36;			/* set linkage block bit count */
      836 
      837 	     segp = oi.linkp;
      838 	     seg_name = substr (seg_name, 1, seg_name_l) || ".link";
      839 	     seg_name_array.count, nnam = 1;
      840 	     seg_name_array.names (1).name = seg_name;
      841 	     seg_name_array.names (1).size = seg_name_array.names (1).size + 5;
      842 	     cw_ptr, path_ptr = addrel (names_ptr, 10);
      843 	     seg_header_length = 14;
      844 
      845 	     call gm_util_ (seg_name, seg_type, sltep, segp, "1"b, "0"b); /* initiate linkage slte */
      846 
      847 	     acl_found,
      848 	     cur_length_found,
      849 	     bit_count_found,
      850 	     cache_found = "0"b;
      851 	     linkage_found = "1"b;
      852 	end;
      853 
      854 /* end statement */
      855 
      856 	else if arg = "end" then do;
      857 	     end_found = "1"b;
      858 	     call TEST_BREAK (";");
      859 
      860 	     if no_error_was_found then
      861 		call WRITE_SEGMENT (seg_type);
      862 
      863 	     if linkage_found then do;		/* Now do defs. */
      864 		sg_l, wr_w = oi.dlng;
      865 		sg_b = oi.dlng * 36;
      866 
      867 		segp = oi.defp;
      868 		seg_name = substr (seg_name, 1, seg_name_l) || ".defs";
      869 		seg_name_array.names (1).name = seg_name;
      870 		cw_ptr = addrel (names_ptr, 10);
      871 		seg_header_length = 14;
      872 
      873 		call gm_util_ (seg_name, seg_type, sltep, segp, "0"b, "1"b);
      874 
      875 		acl_found,
      876 		cur_length_found,
      877 		bit_count_found,
      878 		cache_found = "0"b;
      879 
      880 		if no_error_was_found then
      881 		     call WRITE_SEGMENT (seg_type);
      882 	     end;
      883 
      884 	     call TERM_SEGMENT;
      885 	     return;				/* Back to caller. */
      886 	end;
      887 
      888 	else
      889 	     call ERROR ("Illegal keyword.", "0"b);
      890 
      891 	go to seg_loop;
      892 
      893 
      894 
      895 skip_to_next_statement:
      896 	do while (arg ^= ";");
      897 	     call GET_NEXT_SYM;
      898 	end;
      899 
      900 	go to seg_loop;
      901 
      902 
      903 /*  */
      904 
      905 GATHER_NAMES: proc;
      906 
      907 	do nnam = 1 by 1 while (nnam <= max_count);	/* Pick up names one by one. */
      908 	     call GET_NEXT_ARG;
      909 	     seg_name_array.names (nnam).size = numc;
      910 	     seg_name_array.names (nnam).name = arg;
      911 	     seg_name_array.count = nnam;
      912 
      913 	     call GET_NEXT_BREAK;
      914 	     if arg = ";" then do;			/* Return when names are finished. */
      915 		seg_header_length = 5 + nnam * 9;
      916 		path_ptr, cw_ptr = addrel (names_ptr, nnam * 9 + 1);
      917 		return;
      918 	     end;
      919 	     else if arg ^= "," then
      920 		call ERROR ("Invalid break.", "0"b);
      921 	end;
      922 
      923 	call ERROR ("Too many names.", "0"b);
      924 
      925 
      926      end GATHER_NAMES;
      927 
      928 /*  */
      929 
      930 GATHER_SEGNAMES: proc ();
      931 
      932 /* This procedure adds all the segmames in a bound object segment to the list of names
      933*   in the SLTE, thus avoiding the necessity of updating the header every time a component
      934*   is added to a bound segment, and making the header considerably smaller as well.
      935*   */
      936 
      937 dcl  idx fixed bin;
      938 dcl  current_name_count fixed bin;
      939 dcl 1 def aligned like decode_definition_full;
      940 dcl  defp pointer;
      941 dcl  segname char (32);
      942 
      943 
      944 	call TEST_BREAK (";");			/* No arguments may follow */
      945 
      946 	defp = oi.defp;
      947 	if (defp = null ()) | (^oi.bound) | (^object_segment) then	/* Must be both valid obj seg & bound. */
      948 	     call ERROR ("The add_segnames statement may only be used with bound object segments.", "0"b);
      949 
      950 	if (acl_found | path_name_found) then		/* Since names array is built before ACL or pathname */
      951 	     call ERROR ("The add_segnames statement must come before either of ""acl"" or ""path_name"".", "0"b);
      952 
      953 	current_name_count = seg_name_array.count;	/* So we can check that we aren't duplicating names */
      954 	nnam = seg_name_array.count;			/* Remember it here, in case we don't find anything */
      955 
      956 	do while (^decode_definition_$full (defp, addr (def), addr (oi))); /* loop through all definitions in the seg */
      957 	     defp = def.next_def;			/* continue to next one, next time */
      958 	     if ^def.ignore & (def.section = "segn")
      959 	     then do;				/* It's a segname definition, so process it */
      960 		segname = substr (def.symbol, 1, def.symbol_lng);
      961 		do idx = 1 to current_name_count;	/* Is it already in the name array? */
      962 		     if seg_name_array.names (idx).name = segname then
      963 			goto TRY_NEXT_DEFINITION;	/* Yes. Ignore it. */
      964 		     end;
      965 
      966 		nnam = seg_name_array.count + 1;	/* Otherwise, add it to the array */
      967 		if nnam > max_count then
      968 		     call ERROR ("Too many names.", "0"b);
      969 
      970 		seg_name_array.names (nnam).size = length (rtrim (segname));
      971 		seg_name_array.names (nnam).name = segname;
      972 		seg_name_array.count = nnam;
      973 		end;
      974 TRY_NEXT_DEFINITION:				/* skip to next one */
      975 	     end;
      976 
      977 	seg_header_length = 5 + nnam * 9;		/* update the size */
      978 	path_ptr, cw_ptr = addrel (names_ptr, nnam * 9 + 1);
      979 
      980 	return;
      981 	end GATHER_SEGNAMES;
      982 
      983 /*  */
      984 
      985 DELETE_NAMES: proc;
      986 
      987 /* This procedure is used to remove names from the name array if they are not to be
      988*   included; it is used to eliminate extraneous segnames which were included by a
      989*   previous add_segnames statement.
      990*   */
      991 
      992 dcl (idx, jdx) fixed bin;
      993 dcl  segname char (32);
      994 
      995 
      996 	call TEST_BREAK (":");
      997 
      998 	if (acl_found | path_name_found) then		/* Since names array is built before ACL or pathname */
      999 	     call ERROR ("The delete_name statement must come before either of ""acl"" or ""path_name"".", "0"b);
     1000 
     1001 	nnam = seg_name_array.count;
     1002 
     1003 	do while (arg ^= ";");			/* Find all the names to delete */
     1004 	     call GET_NEXT_ARG ();
     1005 
     1006 	     segname = arg;
     1007 	     do idx = 1 to seg_name_array.count;	/* See if we can find the specified name */
     1008 		if seg_name_array.names (idx).name = segname then do; /* Found it */
     1009 		     if nnam = 1 then		/* You'd make it invisible, would you.... */
     1010 			call ERROR ("The delete_name statement would leave no names on the segment.", "0"b);
     1011 
     1012 		     do jdx = idx to nnam - 1;	/* percolate all the other names down */
     1013 			seg_name_array.names (jdx) = seg_name_array.names (jdx + 1);
     1014 			end;
     1015 
     1016 		     nnam = nnam - 1;		/* record the change in number of names */
     1017 		     seg_name_array.count = nnam;
     1018 		     goto GET_NEXT_NAME_TO_DELETE;	/* All done with this one */
     1019 		     end;
     1020 		end;
     1021 
     1022 	     call ERROR ("Name to be deleted is not in name array for segment.", "0"b); /* Sorry */
     1023 
     1024 GET_NEXT_NAME_TO_DELETE:
     1025 	     call GET_NEXT_BREAK ();
     1026 
     1027 	     if (arg ^= ",") & (arg ^= ";") then
     1028 		call ERROR ("Invalid break.", "0"b);
     1029 	     end;
     1030 
     1031 	seg_header_length = 5 + nnam * 9;
     1032 	path_ptr, cw_ptr = addrel (names_ptr, nnam * 9 + 1);
     1033 
     1034 	return;					/* All done deleting names */
     1035 	end DELETE_NAMES;
     1036 
     1037 /*  */
     1038 
     1039 INIT_SEGMENT: proc;
     1040 
     1041 
     1042 	seg_name = seg_name_array.names (1).name;
     1043 	seg_name_l = seg_name_array.names (1).size;
     1044 
     1045 	object_segment = "0"b;			/* until shown otherwise, assume it's not */
     1046 
     1047 	if seg_type ^= FABRICATED_SEG then do;
     1048 	     do i = 1 to ndir while (in_p = null ());
     1049 		call hcs_$initiate_count (path_array (i), seg_name, "", bitcnt, 0, in_p, code);
     1050 		if (in_p = null ()) & (code ^= error_table_$noentry) then
     1051 		     call ERROR ("Invalid pathname in path list.", "1"b);
     1052 	     end;
     1053 	     if in_p = null () then
     1054 		call ERROR ("Missing segment.", "0"b);
     1055 
     1056 	     call print_gen_info_ (in_p, bitcnt, "gm_output", code);
     1057 	end;
     1058 
     1059 	else do;					/* no seg block,prepare to write out 0 length scw */
     1060 	     sg_l = 0;
     1061 	     slte.bit_count = "0"b;
     1062 	     slte.cur_length = "0"b;
     1063 	end;
     1064 
     1065 	call gm_util_ (seg_name, seg_type, sltep, segp, "0"b, "0"b); /* initiate segment block slte */
     1066 
     1067 	if seg_type ^= FABRICATED_SEG then do;
     1068 	     if seg_type ^= DATA_SEG then do;		/* Get object info for anything but pure data */
     1069 		call object_info_$brief (in_p, bitcnt, addr (oi), code);
     1070 		if (oi.linkp = null) | (code ^= 0) then do;
     1071 		     call ERROR ("Bad object segment.", "0"b);
     1072 		     slte.combine_link = "0"b;
     1073 		end;
     1074 		else object_segment = "1"b;		/* segment is a legitimate object segment, so oi is valid. */
     1075 	     end;
     1076 	     else slte.combine_link = "0"b;		/* Certainly don't combine for non-object */
     1077 
     1078 	     if seg_type = TEXT_ONLY_SEG then do;	/* text keyword, set up text segment */
     1079 		tx_l = oi.tlng;			/* set block length from linkage pointer offset */
     1080 		wr_w, sg_l = tx_l;			/* set up text segment */
     1081 		sg_b = sg_l * 36;			/* set bit count of "t" or "tl" seg block */
     1082 	     end;
     1083 	     else do;				/* not object,take whole segment for now */
     1084 		sg_b = bitcnt;
     1085 		sg_l, wr_w = divide (bitcnt+35, 36, 17, 0);
     1086 	     end;
     1087 
     1088 	     segp = in_p;
     1089 	end;
     1090 
     1091 
     1092      end INIT_SEGMENT;
     1093 
     1094 
     1095 /*  */
     1096 
     1097 COPY_SEGMENT: proc;
     1098 
     1099 
     1100 	real_in_p = in_p;
     1101 	unique_name = unique_chars_ ("0"b);
     1102 	call hcs_$make_seg ("", unique_name, unique_name, 1010b, in_p, code);
     1103 	if in_p = null () then
     1104 	     call ERROR ("Unable to create segment in process directory.", "1"b);
     1105 	in_p -> movewds = real_in_p -> movewds;		/* make new segment */
     1106 	call hcs_$set_bc_seg (in_p, bitcnt, code);
     1107 	segp = in_p;
     1108 
     1109 
     1110      end COPY_SEGMENT;
     1111 
     1112 
     1113 
     1114 TERM_SEGMENT: proc;
     1115 
     1116 
     1117 	if in_p ^= null then do;
     1118 	     if real_in_p ^= null then do;		/* sysid seg, must delete */
     1119 		call delete_$ptr (in_p, "100100"b, "generate_mst", code);
     1120 		if code ^= 0 then
     1121 		     call ERROR ("Unable to terminate segment in process directory.", "1"b);
     1122 		in_p = real_in_p;			/*  reset to original ptr */
     1123 		real_in_p = null;
     1124 	     end;
     1125 	     call hcs_$terminate_noname (in_p, code);	/* terminate the found segment */
     1126 	     if code ^= 0 then
     1127 		call ERROR ("Unable to terminate found segment.", "1"b);
     1128 	     else in_p = null;
     1129 	end;
     1130 
     1131 
     1132      end TERM_SEGMENT;
     1133 
     1134      end PROCESS_SEGMENT;
     1135 
     1136 
     1137 /*  */
     1138 
     1139 WRITE_SEGMENT: proc (seg_type);
     1140 
     1141 dcl  seg_type fixed bin;
     1142 
     1143 
     1144 /* insert access in output line */
     1145 
     1146 	output_access_word = "";			/* initialize all access fields to blank */
     1147 	if output_access.read then substr (output_access_word, 1, 1) = "R";
     1148 	if output_access.execute then substr (output_access_word, 2, 1) = "E";
     1149 	if output_access.write then substr (output_access_word, 3, 1) = "W";
     1150 	if output_access.privileged then substr (output_access_word, 4, 1) = "P";
     1151 	if output_access_word = "" then
     1152 	     call ERROR ("Invalid argument.", "0"b);
     1153 
     1154 /* set bit count, cur_length if necessary */
     1155 
     1156 	if ^(cur_length_found | bit_count_found) then
     1157 	if seg_type ^= FABRICATED_SEG then do;
     1158 		slte.bit_count = bit (sg_b, 24);
     1159 		slte.cur_length = bit (divide (divide (sg_b + 35, 36, 18, 0) + 1023, 1024, 9, 0), 9);
     1160 	     end;
     1161 
     1162 
     1163 /* Compute cache access */
     1164 
     1165 	if ^cache_found				/* believe given spec */
     1166 	then if slte.per_process then slte.cache = "1"b;
     1167 	     else if output_access.write
     1168 	     | slte.init_seg
     1169 	     | slte.temp_seg then slte.cache = "0"b;
     1170 	     else slte.cache = "1"b;
     1171 
     1172 	cw_ptr -> control_word.ident = 1;		/* set identity of segment control word */
     1173 	cw_ptr -> control_word.length = sg_l;
     1174 	header_words = seg_header_length+2;		/* add hcw,scw length */
     1175 	seg_hdrp -> control_word.length = seg_header_length;
     1176 
     1177 /* write first segment */
     1178 
     1179 	if (seg_type = FIRST_SEG) | (seg_type = BOOT_PROGRAM_SEG) then do;
     1180 	     if seg_type = FIRST_SEG then
     1181 		call gm_write_first_seg_ (sltep, sg_b, in_p, mst_tape_iocbp, error_in_object_segment, code);
     1182 	     else if do_hit then;			/* Do nothing if -notape specified */
     1183 	     else call gm_write_boot_program_ (in_p, sg_b, (seg_name), mst_tape_iocbp, db_hit, error_in_object_segment, code);
     1184 
     1185 	     if code ^= 0 then do;
     1186 TAPE_ER:		if error_in_object_segment then
     1187 		     call ERROR ("Bad object segment.", "1"b);
     1188 		else call ERROR ("Unrecoverable tape error.", "1"b);
     1189 	     end;
     1190 
     1191 	     if (db_hit | do_hit) then
     1192 		tape_er_count = 0;
     1193 	     else call iox_$control (mst_tape_iocbp, "error_count", addr (tape_er_count), code);
     1194 
     1195 	     if tape_er_count ^= 0 then call ERROR ("Error writing first segment.", "1"b);
     1196 	end;
     1197 
     1198 /* write out the header */
     1199 
     1200 	else do;
     1201 	     call iox_$put_chars (mst_tape_iocbp, seg_hdrp, header_words*4, code);
     1202 	     if code ^= 0 then go to TAPE_ER;
     1203 
     1204 /* now write out the segment */
     1205 
     1206 	     if (seg_type = NORMAL_SEG)
     1207 	      | (seg_type = WHOLE_OBJECT_SEG)
     1208 	      | (seg_type = TEXT_ONLY_SEG)
     1209 	      | (seg_type = DATA_SEG) then do;
     1210 
     1211 		call iox_$put_chars (mst_tape_iocbp, segp, wr_w * 4, code);
     1212 		if code ^= 0 then go to TAPE_ER;
     1213 	     end;
     1214 	end;
     1215 
     1216 	return;
     1217 
     1218 
     1219 
     1220 WRITE_COLLECTION: entry;
     1221 
     1222 
     1223 	call iox_$put_chars (mst_tape_iocbp, sltep, 8, code);
     1224 	if code ^= 0 then go to TAPE_ER;
     1225 
     1226 	return;
     1227 
     1228 
     1229      end WRITE_SEGMENT;
     1230 
     1231 
     1232 /*  */
     1233 
     1234 GET_NEXT_SYM: proc;
     1235 
     1236 
     1237 	call parse_file_$parse_file_ptr (symp, numc, sym_is_a_break, eof_was_found);
     1238 	if eof_was_found = 1 then			/* error,eof found before "fini" */
     1239 	     call ERROR ("Physical end of header reached before logical end.", "1"b);
     1240 
     1241 	return;
     1242 
     1243 
     1244      end GET_NEXT_SYM;
     1245 
     1246 
     1247 
     1248 GET_NEXT_ARG: proc;
     1249 
     1250 
     1251 	call GET_NEXT_SYM;
     1252 
     1253 	if sym_is_a_break = 1 then			/* Should not be a break. */
     1254 	     call ERROR ("Break found when keyword or argument expected.", "0"b);
     1255 
     1256 	return;
     1257 
     1258 
     1259 GET_NEXT_BREAK: entry;
     1260 
     1261 	call GET_NEXT_SYM;
     1262 
     1263 	if sym_is_a_break = 0 then			/* Must be a break. */
     1264 	     call ERROR ("Invalid break.", "0"b);
     1265 
     1266 	return;
     1267 
     1268 
     1269      end GET_NEXT_ARG;
     1270 
     1271 
     1272 
     1273 TEST_BREAK: proc (break);
     1274 
     1275 dcl  break char (1) aligned;				/* break char to be checked */
     1276 
     1277 	call GET_NEXT_BREAK;
     1278 
     1279 	if arg ^= break then
     1280 	     call ERROR ("Invalid break.", "0"b);
     1281 
     1282 	return;
     1283 
     1284 
     1285      end TEST_BREAK;
     1286 
     1287 
     1288 /*  */
     1289 
     1290 YES_NO:	proc returns (bit (1) unal);
     1291 
     1292 dcl  switch bit (1) aligned;
     1293 
     1294 
     1295 	call TEST_BREAK (":");
     1296 	call GET_NEXT_ARG;
     1297 	if arg = "yes" then switch = "1"b;
     1298 	else if arg = "no" then switch = "0"b;
     1299 	else call ERROR ("Invalid argument.", "0"b);
     1300 
     1301 	call TEST_BREAK (";");
     1302 
     1303 	return (switch);
     1304 
     1305 
     1306      end YES_NO;
     1307 
     1308 
     1309 
     1310 GET_NUM:	proc returns (fixed bin);
     1311 
     1312 
     1313 	call GET_NEXT_ARG;
     1314 	return (bin (fixed (arg, 6), 17));
     1315 
     1316 
     1317      end GET_NUM;
     1318 
     1319 
     1320 /*  */
     1321 
     1322 CLEANUP_CONDITION_HANDLER: proc;
     1323 
     1324 
     1325 	call gm_error_ (0, seg_name, symp, hdrp, "Cleanup handler invoked.", addr (o_ln), "1"b, end_found,
     1326 	     "0"b, in_p, gm_output_iocbp);
     1327 
     1328 	call gm_util1_$close (gm_output_iocbp, mst_tape_iocbp, hd_hit);
     1329 
     1330 
     1331      end CLEANUP_CONDITION_HANDLER;
     1332 
     1333 
     1334 
     1335 ERROR:	proc (gm_message, fatal);		/* normal error handler */
     1336 
     1337 dcl  gm_message char (*),				/* gm error message */
     1338      fatal bit (1) aligned;				/* fatal error switch */
     1339 
     1340 
     1341 	call gm_error_ (code, seg_name, symp, hdrp, gm_message, addr (o_ln),
     1342 	     fatal, end_found, "0"b, in_p, gm_output_iocbp);
     1343 
     1344 	if ^fatal then
     1345 	     go to error_label;
     1346 	else
     1347 	     go to close_out;
     1348 
     1349 
     1350      end ERROR;
     1351 
     1352 
     1353 
     1354 skip_to_next_seg:
     1355 	if end_found then do while (sym_is_a_break = 0);
     1356 	     call GET_NEXT_SYM;
     1357 	end;
     1358 	else do;
     1359 	     do while (arg ^= "end");
     1360 		call GET_NEXT_SYM;
     1361 	     end;
     1362 	     call GET_NEXT_SYM;
     1363 	end;
     1364 	end_found = "0"b;
     1365 	if arg ^= ";" then
     1366 	     go to skip_to_next_seg;
     1367 	else
     1368 	go to next_segment;
     1369 
     1370 
     1371  /* BEGIN INCLUDE FILE ... gm_data.incl.pl1 ... 31 July 1981 ... WOS */
  1     2 /* Assorted data and structures used by the generate_mst subsystem */
  1     3 
  1     4 dcl  NORMAL_SEG		init (1) fixed bin internal static options (constant);
  1     5 dcl  WHOLE_OBJECT_SEG	init (2) fixed bin internal static options (constant);
  1     6 dcl  TEXT_ONLY_SEG		init (3) fixed bin internal static options (constant);
  1     7 dcl  FABRICATED_SEG 	init (4) fixed bin internal static options (constant);
  1     8 dcl  DATA_SEG		init (5) fixed bin internal static options (constant);
  1     9 dcl  FIRST_SEG		init (6) fixed bin internal static options (constant);
  1    10 dcl  BOOT_PROGRAM_SEG	init (7) fixed bin internal static options (constant);
  1    11 
  1    12 /* END INCLUDE FILE ... gm_data.incl.pl1 */
     1371 
     1372  /* BEGIN INCLUDE FILE slte.incl.pl1 */
  2     2 /* Declaration for Segment Loading Table Entry structure.
  2     3*   Used by Initialization, MST Generation, and MST Checker subroutines */
  2     4 /* modified 5/4/76 by Noel I. Morris	*/
  2     5 /* last modified 12/12/83 by Keith Loepere for breakpointable */
  2     6 /* format: style3 */
  2     7 
  2     8 dcl	sltep		ptr;
  2     9 
  2    10 dcl	1 slte_uns	based (sltep) aligned,
  2    11 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    12 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    13 /**** End of word 1 */
  2    14 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    15 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    16 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    17 	  2 firmware_seg	bit (1),			/* load in low 256 */
  2    18 	  2 layout_seg	bit (1),			/* mailbox & such */
  2    19 	  2 breakpointable  bit (1),			/* includes breakpoint_page */
  2    20 	  2 pad1		bit (3),			/* unused */
  2    21 	  2 wired		bit (1),			/* segment is wired if ON */
  2    22 	  2 paged		bit (1),			/* segment is paged if ON */
  2    23 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    24 	  2 pad3		bit (2),
  2    25 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    26 /**** End of 1st half of word 2 */
  2    27 	  2 pad4		bit (3),
  2    28 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    29 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    30 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    31 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    32 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    33 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    34 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    35 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    36 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    37 /***** End of word 2 */
  2    38 	  2 pad5		bit (6),
  2    39 	  2 cur_length	fixed bin (9) uns,		/* current length of segment (in 1024 word blocks) */
  2    40 	  2 ringbrack	(3) fixed bin (3) uns,	/* ringbrackets */
  2    41 	  2 segno		fixed bin (18) uns,		/* text/link segment number */
  2    42 /***** End of word 3 */
  2    43 	  2 pad7		bit (3),
  2    44 	  2 max_length	fixed bin (9) uns,		/* maximum length for segment */
  2    45 	  2 bit_count	fixed bin (24) uns
  2    46 	  )		unaligned;		/* bitcount of segment */
  2    47 
  2    48 dcl	1 slte		based (sltep) aligned,
  2    49 	( 2 names_ptr	bit (18),			/* rel pointer to thread of names */
  2    50 	  2 path_ptr	bit (18),			/* rel pointer to pathname (if present) */
  2    51 	  2 access	bit (4),			/* SDW access bit (REWP) */
  2    52 	  2 cache		bit (1),			/* Segment to be allowed in cache */
  2    53 	  2 abs_seg	bit (1),			/* segment is an abs seg if ON */
  2    54 	  2 firmware_seg    bit (1),
  2    55 	  2 layout_seg      bit (1),
  2    56 	  2 breakpointable  bit (1),
  2    57 	  2 pad2		bit (3),
  2    58 	  2 wired		bit (1),			/* segment is wired if ON */
  2    59 	  2 paged		bit (1),			/* segment is paged if ON */
  2    60 	  2 per_process	bit (1),			/* segment is per-process if ON */
  2    61 	  2 pad3		bit (2),
  2    62 	  2 acl_provided	bit (1),			/* ON if acl structure follows path_name on MST */
  2    63 	  2 pad4		bit (3),
  2    64 	  2 branch_required bit (1),			/* path name supplied if ON */
  2    65 	  2 init_seg	bit (1),			/* segment is init_seg if ON */
  2    66 	  2 temp_seg	bit (1),			/* segment is temp_seg if ON */
  2    67 	  2 link_provided	bit (1),			/* linkage segment provided if ON */
  2    68 	  2 link_sect	bit (1),			/* segment is linkage segment if ON */
  2    69 	  2 link_sect_wired bit (1),			/* linkage segment is wired if ON */
  2    70 	  2 combine_link	bit (1),			/* linkage is combined if ON */
  2    71 	  2 pre_linked	bit (1),			/* lot entry has been made if ON */
  2    72 	  2 defs		bit (1),			/* segment is definitions segment if ON */
  2    73 	  2 pad5		bit (6),
  2    74 	  2 cur_length	bit (9),			/* current length of segment (in 1024 word blocks) */
  2    75 	  2 ringbrack	(3) bit (3),		/* ringbrackets */
  2    76 	  2 segno		bit (18),			/* text/link segment number */
  2    77 	  2 pad6		bit (3),
  2    78 	  2 max_length	bit (9),			/* maximum length for segment */
  2    79 	  2 bit_count	bit (24)
  2    80 	  )		unaligned;		/* bitcount of segment */
  2    81 
  2    82 /* END INCLUDE FILE slte.incl.pl1 */
     1372 
     1373  /* BEGIN INCLUDE FILE ... object_info.incl.pl1
  3     2*coded February 8, 1972 by Michael J. Spier	*/
  3     3 /* modified May 26, 1972 by M. Weaver */
  3     4 /* modified 15 April, 1975 by M. Weaver */
  3     5 
  3     6 declare	1 object_info aligned based,		/* structure containing object info based, returned by object_info_ */
  3     7 	2 version_number fixed bin,		/* version number of current structure format (=2) */
  3     8 	2 textp pointer,			/* pointer to beginning of text section */
  3     9 	2 defp pointer,			/* pointer to beginning of definition section */
  3    10 	2 linkp pointer,			/* pointer to beginning of linkage section */
  3    11 	2 statp pointer,			/* pointer to beginning of static section */
  3    12 	2 symbp pointer,			/* pointer to beginning of symbol section */
  3    13 	2 bmapp pointer,			/* pointer to beginning of break map (may be null) */
  3    14 	2 tlng fixed bin,			/* length in words of text section */
  3    15 	2 dlng fixed bin,			/* length in words of definition section */
  3    16 	2 llng fixed bin,			/* length in words of linkage section */
  3    17 	2 ilng fixed bin,			/* length in words of static section */
  3    18 	2 slng fixed bin,			/* length in words of symbol section */
  3    19 	2 blng fixed bin,			/* length in words of break map */
  3    20 	2 format,				/* word containing bit flags about object type */
  3    21 	  3 old_format bit(1) unaligned,	/* on if segment isn't in new format, i.e. has old style object map */
  3    22 	  3 bound bit(1) unaligned,		/* on if segment is bound */
  3    23 	  3 relocatable bit(1) unaligned,	/* on if seg has relocation info in its first symbol block */
  3    24 	  3 procedure bit(1) unaligned,	/* on if segment is an executable object program */
  3    25 	  3 standard bit(1) unaligned,	/* on if seg is in standard format (more than just standard map) */
  3    26 	  3 gate bit(1) unaligned,		/* on if segment is a gate */
  3    27 	  3 separate_static bit(1) unaligned,	/* on if static not in linkage */
  3    28 	  3 links_in_text bit(1) unaligned,	/* on if there are threaded links in text */
  3    29 	  3 perprocess_static bit (1) unaligned, /* on if static is not to be per run unit */
  3    30 	  3 pad bit(27) unaligned,
  3    31 	2 entry_bound fixed bin,		/* entry bound if segment is a gate */
  3    32 	2 textlinkp pointer,		/* ptr to first link in text */
  3    33 
  3    34 	/* LIMIT OF BRIEF STRUCTURE */
  3    35 
  3    36 	2 compiler char(8) aligned,		/* name of processor which generated segment */
  3    37 	2 compile_time fixed bin(71),		/* clock reading of date/time object was generated */
  3    38 	2 userid char(32) aligned,		/* standard Multics id of creator of object segment */
  3    39 	2 cvers aligned,			/* generator version name in printable char string form */
  3    40 	  3 offset bit(18) unaligned,		/* offset of name in words relative to base of symbol section */
  3    41 	  3 length bit(18) unaligned,		/* length of name in characters */
  3    42 	2 comment aligned,			/* printable comment concerning generator or generation of segment */
  3    43 	  3 offset bit(18) unaligned,		/* offset of comment in words relative to base of symbol section */
  3    44 	  3 length bit(18) unaligned,		/* length of comment in characters */
  3    45 	2 source_map fixed bin,		/* offset, relative to base of symbol section, of source map structure */
  3    46 
  3    47 	/* LIMIT OF DISPLAY STRUCTURE */
  3    48 
  3    49 	2 rel_text pointer,			/* pointer to text section relocation info */
  3    50 	2 rel_def pointer,			/* pointer to definition section relocation info */
  3    51 	2 rel_link pointer,			/* pointer to linkage section relocation info */
  3    52 	2 rel_static pointer,		/* pointer to static section relocation info */
  3    53 	2 rel_symbol pointer,		/* pointer to symbol section relocation info */
  3    54 	2 text_boundary fixed bin,		/* specifies mod  of text section base boundary */
  3    55 	2 static_boundary fixed bin,		/* specifies mod of internal static base boundary */
  3    56 					/* currently not used by system */
  3    57 	2 default_truncate fixed bin,		/* offset rel to symbp for binder to automatically trunc. symb sect. */
  3    58 	2 optional_truncate fixed bin;	/* offset rel to symbp for binder to optionally trunc. symb sect. */
  3    59 
  3    60 declare	object_info_version_2 fixed bin int static init(2);
  3    61 
  3    62 /* END INCLUDE FILE ... object_info.incl.pl1 */
     1373 
     1374  /* BEGIN INCLUDE FILE ... decode_definition_str.incl.pl1
  4     2*
  4     3*   describes the output structures used by decode_definition
  4     4*   James R. Davis 25 Mar 79 */
  4     5 
  4     6 dcl 1 decode_definition_common_header based aligned,
  4     7      2 next_def	      ptr,		/* to next def in list */
  4     8      2 prev_def	      ptr,		/* to previous def in list */
  4     9      2 block_ptr	      ptr,		/* to either defblock or segname */
  4    10      2 section	      char (4) aligned,	/* "text", "link", "symb", "segn" */
  4    11      2 offset	      fixed bin,		/* if section isnt "segn", offset of def in section */
  4    12      2 entrypoint	      fixed bin;		/* if entrypoint non0 offset of entry in text section */
  4    13 
  4    14 dcl 1 decode_definition_str based aligned,	/* for callers of decode_definition_ */
  4    15      2 header	      like decode_definition_common_header,
  4    16      2 symbol	      char (32) aligned;	/* for symbolic name */
  4    17 
  4    18 dcl 1 decode_definition_full based aligned,	/* for callers of decode_definition_$full */
  4    19      2 header	      like decode_definition_common_header,
  4    20      2 symbol	      char (256) aligned,	/* symbolic name */
  4    21      2 symbol_lng	      fixed bin,		/* actual length of the symbol */
  4    22      2 flags,				/* same as in definition */
  4    23        3 new_format	      bit (1) unal,		/* def is in new format */
  4    24        3 ignore	      bit (1) unal,		/* linker should ignore this def */
  4    25        3 entrypt_flag     bit (1) unal,		/*  this def is for an entrypoint */
  4    26        3 retain	      bit (1) unal,
  4    27        3 arg_count	      bit (1) unal,		/* there is an arg count for entry */
  4    28        3 desc_sw	      bit (1) unal,		/* there are descriptors */
  4    29        3 unused	      bit (30) unal,
  4    30      2 nargs	      fixed bin,		/* number of args entry expects */
  4    31      2 desc_ptr	      ptr;		/* to array of rel ptrs to descriptors */
  4    32 
  4    33 
  4    34 dcl 1 decode_definition_acc based aligned,	/* for callers of decode_cref entry */
  4    35      2 header	      like decode_definition_common_header,
  4    36      2 acc_ptr	      ptr;		/* to ACC string of symbolic name */
  4    37 
  4    38 /* END INCLUDE FILE  decode_definition_str.incl.pl1 */
     1374 
     1375  	/* START OF:	time_names_.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* Name:  time_names_.incl.pl1						*/
  5     6 	/*									*/
  5     7 	/* This include file defines the structure of values in the time_table_.  The table	*/
  5     8 	/* includes a list of time zones known to the system, as well as lists of month names	*/
  5     9 	/* and names of days of the week.  All names are expressed in several different languages */
  5    10 	/* to facilitate transliteration of dates into these languages.  The table includes	*/
  5    11 	/* the list of languages in which dates may be expressed.				*/
  5    12 	/*									*/
  5    13 	/* Status									*/
  5    14 	/*									*/
  5    15 	/* 0) Created  06/07/78:  J. Falksen						*/
  5    16 	/* 1) Modified 07/04/78:  G. Dixon						*/
  5    17 	/*									*/
  5    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    19 
  5    20 
  5    21 dcl time_info_$version	char (8) ext static;	/* Version number of all structures in the	*/
  5    22 						/* time_info_.  Currently = 1.		*/
  5    23 dcl Vtime_info_2		char (8) int static options(constant) init("tinfo002");




  5    24 
  5    25 dcl time_info_$gmt_zone_index fixed bin (17) ext static;
  5    26 dcl time_info_$default_language_index fixed bin (17) ext static;
  5    27 
  5    28 dcl time_info_$date_time_keywords fixed bin ext static;	/* Table of named date/time format strings	*/
  5    29 dcl 1 ti_keyword	based (addr (time_info_$date_time_keywords)),
  5    30       2 number_kwd		fixed bin,		/* number of keywords present		*/
  5    31       2 pad		fixed bin,
  5    32       2 e (0 refer (ti_keyword.number_kwd)),
  5    33         3 name		char (32),
  5    34         3 str		char (128)var;
  5    35 dcl (site_date	init (1),
  5    36      site_date_time init (2),
  5    37      site_time	init (3)
  5    38     )		fixed bin int static options (constant);
  5    39 
  5    40 dcl time_info_$language_names fixed bin ext static;	/* Table of language names, in various languages	*/
  5    41 
  5    42 dcl 1 ti_language	based (addr (time_info_$language_names)),
  5    43       2 number_lang		fixed bin,		/* number of language names present 		*/
  5    44       2 pad		fixed bin,
  5    45       2 name (0 refer (ti_language.number_lang), 0 refer (ti_language.number_lang))
  5    46 			char(32) varying;		/* Name of the language.			*/
  5    47 			/* All language names are expressed in all languages.  name(i,j) gives the	*/
  5    48 			/*  jth language name in language i.  name(i,i) gives a language name in its	*/
  5    49 			/*  own language.							*/




  5    50 dcl time_info_$month_names   fixed bin ext static;	/* Table of month  names in various languages. 	*/
  5    51 
  5    52 dcl 1 ti_month based (addr (time_info_$month_names)),
  5    53       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  5    54       2 pad		fixed bin,
  5    55       2 e (0 refer (ti_month.number_lang), 12),
  5    56         3 short       	char(8) var,		/* short form of a month name, i.e., Nov 	*/
  5    57         3 long        	char(32) var;		/* long form of a month name, i.e. November 	*/




  5    58 dcl time_info_$day_names     fixed bin ext static;	/* Table of day names in various languages.	*/
  5    59 
  5    60 dcl 1 ti_day based (addr (time_info_$day_names)),
  5    61       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  5    62       2 pad		fixed bin,
  5    63       2 e (0 refer (ti_day.number_lang), 7),
  5    64         3 short       	char(8) var,		/* short for of a day name, i.e. Sat 		*/
  5    65         3 long        	char(32) var;		/* long form of a day name, i.e. Saturday 	*/




  5    66 dcl time_info_$offset_names  fixed bin ext static;	/* Table of offset names in various languages.	*/
  5    67 
  5    68 dcl 1 ti_offset based (addr (time_info_$offset_names)),
  5    69       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  5    70       2 number_offset	fixed bin,
  5    71       2 e (0 refer (ti_offset.number_lang), 0 refer (ti_offset.number_offset)),
  5    72         3 short        	char(32) var,		/* short form of an offset name, i.e. min 	*/
  5    73         3 plural        	char(32) var,		/* plural form of an offset name, i.e. minutes 	*/
  5    74         3 singular       	char(32) var,		/* singular for of an offset name, i.e. minute	*/
  5    75         3 this		char(32) var;		/* "this" which goes with singular		*/




  5    76 dcl time_info_$word_names    fixed bin ext static;	/* Table of word names in various languages.	*/
  5    77 
  5    78 dcl 1 ti_word based (addr (time_info_$word_names)),
  5    79       2 number_lang		fixed bin,		/* number of languages in the table.		*/
  5    80       2 number_word		fixed bin,
  5    81       2 short (0 refer (ti_word.number_lang), 0 refer (ti_word.number_word))
  5    82 			char (8) var,
  5    83       2 word (0 refer (ti_word.number_lang), 0 refer (ti_word.number_word))
  5    84 			char(32) var;		/* a "word", i.e. Midnight			*/
  5    85 
  5    86 dcl time_info_$zone_names    fixed bin ext static;	/* Table of known time zones.			*/
  5    87 
  5    88 dcl 1 ti_zone based (addr (time_info_$zone_names)),
  5    89       2 number_lang    	fixed bin,		/* number of languages in which zone names	*/
  5    90 						/* are defined.				*/
  5    91       2 number_zone       	fixed bin,		/* number of zone names in the table.		*/
  5    92       2 e (0 refer (ti_zone.number_lang), 0 refer (ti_zone.number_zone)),
  5    93         3 short		char(4) var,		/* short form of the zone name.		*/
  5    94         3 long        	char(64) var,		/* long form of the zone name 		*/
  5    95         3 pad		fixed bin,
  5    96         3 delta		fixed bin(71);		/* offset, in microseconds, of this time zone	*/
  5    97 						/* from GMT (Greenwich mean time).  This value	*/
  5    98 						/* should be subtracted from a clock value	*/
  5    99 						/* (which is expressed in GMT by definition).	*/
  5   100 						/* to obtain a date/time expressed in the	*/
  5   101 						/* named time zone.				*/
  5   102 						/* NOTE:  zones are listed in order of descending */
  5   103 						/* delta, from +11 to -12.  print_time_zones	*/
  5   104 						/* requires this.				*/
  5   105 
  5   106 
  5   107 dcl (tiw_FiscalIndicator init (11)
  5   108     )		fixed bin int static options (constant);
  5   109 
  5   110 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  5   111 /* NOTE TO MAINTAINER: Before changing this file, see the comments in	       */
  5   112 /*		        time_info_cds.incl.pl1		       */
  5   113 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
  5   114 
  5   115 /* END OF:	time_names_.incl.pl1	  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
     1375 
     1376 
     1377      end generate_mst;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/21/92  1108.3  generate_mst.pl1                  >spec>install>1033>generate_mst.pl1
1371         1    03/27/82  0529.7  gm_data.incl.pl1                  >ldd>include>gm_data.incl.pl1
1372         2    07/11/84  1037.3  slte.incl.pl1                     >ldd>include>slte.incl.pl1
1373         3    08/05/77  1122.5  object_info.incl.pl1              >ldd>include>object_info.incl.pl1
1374         4    06/28/79  1304.8  decode_definition_str.incl.pl1    >ldd>include>decode_definition_str.incl.pl1
1375         5    09/06/84  0950.2  time_names.incl.pl1               >ldd>include>time_names.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BOOT_PROGRAM_SEG                       constant        fixed bin(17,0)          initial dcl 1-10 set ref 447* 468 1179
DATA_SEG                               constant        fixed bin(17,0)          initial dcl 1-8 set ref 435* 1068 1206
FABRICATED_SEG                         constant        fixed bin(17,0)          initial dcl 1-7 set ref 450* 1047 1067 1156
FIRST_SEG                              constant        fixed bin(17,0)          initial dcl 1-9 set ref 441* 1179 1180
NORMAL_SEG                             constant        fixed bin(17,0)          initial dcl 1-4 set ref 426* 822 826 1206
TEXT_ONLY_SEG                          constant        fixed bin(17,0)          initial dcl 1-6 set ref 432* 1078 1206
WHOLE_OBJECT_SEG                       constant        fixed bin(17,0)          initial dcl 1-5 set ref 429* 822 1206
a_header_path                          based           char                     packed unaligned dcl 71 ref 358 359 360 361
abs_seg                   1(05)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  815*
access                    1            based           bit(4)                   level 2 packed packed unaligned dcl 2-48 set ref 312
                                                                                  517* 520* 521* 522* 523*
acl_block_ptr                   001274 automatic       pointer                  dcl 152 set ref 636* 643 645 647 649 655 656 661
acl_count                              based           fixed bin(17,0)          dcl 152 set ref 626* 635* 635
acl_count_ptr                   001272 automatic       pointer                  dcl 152 set ref 625* 626 635 635
acl_found                       004466 automatic       bit(1)                   dcl 226 set ref 379* 496 624 631* 847* 875* 950 998
acl_provided              1(17)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  632*
acla                                   based           structure                level 1 dcl 157
acount                          000137 automatic       fixed bin(17,0)          dcl 76 set ref 325* 326 330 335 335 341 347
addr                                                   builtin function         dcl 184 ref 304 312 370 370 781 782 783 787 956 956
                                                                                  956 956 1069 1069 1193 1193 1325 1325 1341 1341
addrel                                                 builtin function         dcl 184 ref 306 308 509 627 640 842 870 916 978 1032
after                                                  builtin function         dcl 184 ref 417 417
arg                                    based           char                     packed unaligned dcl 115 set ref 393 398 405 407*
                                                                                  410 415 415 417 417 426 429 432 435 438 444 450
                                                                                  485 485 490 490 495 495 503 515 518 520 521 522
                                                                                  523 527 527 534 539 547 554 562 570 575 587 591
                                                                                  594 598 603 611 616 621 644 645 647 649 661 668
                                                                                  679 687 694 694 697 709 709 712 724 727 740 743
                                                                                  759 767 767 769 771 794 804 805 807 815 820 856
                                                                                  895 910 914 919 1003 1006 1027 1027 1279 1297 1298
                                                                                  1314 1359 1365
argl                            000124 automatic       fixed bin(17,0)          array dcl 76 set ref 327* 336 336 337 337 338 338
                                                                                  339 339 340 340 344 346 346 350 358 359 360 361
                                                                                  361 364
argp                            000100 automatic       pointer                  array dcl 76 set ref 327* 336 336 337 337 338 338
                                                                                  339 339 340 340 344 346 346 350 358 359 360 361
                                                                                  364
barg                                   based           char                     packed unaligned dcl 76 ref 336 336 337 337 338 338
                                                                                  339 339 340 340 344 346 346 350
based_bit_72                           based           bit(72)                  packed unaligned dcl 207 set ref 734* 789*
based_char_32                          based           char(32)                 packed unaligned dcl 207 set ref 703* 718* 753* 776*
                                                                                  810*
before                                                 builtin function         dcl 184 ref 415 415
bin                                                    builtin function         dcl 184 ref 580 589 592 595 670 672 681 1314
bit                                                    builtin function         dcl 184 ref 579 580 589 592 595 670 672 681 1158
                                                                                  1159
bit_count                 3(12)        based           bit(24)                  level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  580* 670* 672 1061* 1158*
bit_count_found                 004464 automatic       bit(1)                   dcl 226 set ref 379* 580 674* 847* 875* 1156
bitcnt                          001260 automatic       fixed bin(24,0)          dcl 126 set ref 1049* 1056* 1069* 1084 1085 1105
                                                                                  1105 1106*
boot_program_has_been_processed 004471 automatic       bit(1)                   dcl 226 set ref 296* 445 468*
bound                    24(01) 004364 automatic       bit(1)                   level 3 packed packed unaligned dcl 219 set ref 947
branch_required           1(21)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  504*
break                                  parameter       char(1)                  dcl 1275 ref 1273 1279
cache                     1(04)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  688* 1165* 1167* 1170*
cache_found                     004465 automatic       bit(1)                   dcl 226 set ref 379* 689* 847* 875* 1165
cleanup                         004476 stack reference condition                dcl 288 ref 318
clock                                                  builtin function         dcl 184 ref 294
code                            000136 automatic       fixed bin(35,0)          dcl 76 in procedure "gm" set ref 298* 327* 331* 353*
                                                                                  370* 407* 408 415* 416 417* 418 700* 701 715* 716
                                                                                  730* 731 746* 747 763* 764 778* 779 799* 800 1049*
                                                                                  1050 1056* 1069* 1070 1102* 1106* 1119* 1120 1125*
                                                                                  1126 1180* 1183* 1185 1193* 1201* 1202 1211* 1212
                                                                                  1223* 1224 1341*
code                     12            based           fixed bin(17,0)          level 2 in structure "acla" dcl 157 in procedure
                                                                                  "gm" set ref 656*
col_no                    1            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 173 set ref 407*
                                                                                  415* 422*
col_sub_no                1(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 173 set ref 412*
                                                                                  417* 422*
combine_link              1(27)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  616* 1072* 1076*
control_word                           based           structure                level 1 dcl 173
count                                  based           fixed bin(17,0)          level 2 dcl 144 set ref 839* 911* 953 954 966 972*
                                                                                  1001 1007 1017*
cu_$arg_count                   000010 constant        entry                    external dcl 249 ref 325
cu_$arg_ptr                     000012 constant        entry                    external dcl 250 ref 327
cur_len_for_bitcnt              001264 automatic       fixed bin(18,0)          dcl 135 set ref 577* 579 580
cur_length                2            based           bit(9)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  579* 672* 1062* 1159*
cur_length_found                004463 automatic       bit(1)                   dcl 226 set ref 379* 582* 672 847* 875* 1156
current_name_count              004537 automatic       fixed bin(17,0)          dcl 938 set ref 953* 961
cv_dec_check_                   000014 constant        entry                    external dcl 251 ref 407 415 417
cw_ptr                          001304 automatic       pointer                  dcl 179 set ref 509* 625 627* 627 636 640* 640 842*
                                                                                  870* 916* 978* 1032* 1172 1173
date_time_                      000074 constant        entry                    external dcl 281 ref 749
date_time_$format               000016 constant        entry                    external dcl 252 ref 774
db_hit                          004455 automatic       bit(1)                   dcl 226 set ref 324* 337* 370* 1183* 1191
decode_definition_$full         000020 constant        entry                    external dcl 253 ref 956
decode_definition_common_header        based           structure                level 1 dcl 4-6
decode_definition_full                 based           structure                level 1 dcl 4-18
def                             004540 automatic       structure                level 1 dcl 939 set ref 956 956
default_rpv_data                004346 automatic       varying char(24)         dcl 207 set ref 802* 805 805 807* 807 810
default_time_zone               004355 automatic       char(4)                  packed unaligned dcl 207 set ref 771* 774* 776 783
defp                            004656 automatic       pointer                  dcl 940 in procedure "GATHER_SEGNAMES" set ref 946*
                                                                                  947 956* 957*
defp                      4     004364 automatic       pointer                  level 2 in structure "oi" dcl 219 in procedure "gm"
                                                                                  set ref 867 946
delete_$ptr                     000022 constant        entry                    external dcl 254 ref 1119
delta                    26            based           fixed bin(71,0)          array level 3 dcl 5-88 ref 787
divide                                                 builtin function         dcl 184 ref 506 579 672 672 1085 1159 1159
dlng                     17     004364 automatic       fixed bin(17,0)          level 2 dcl 219 set ref 864 865
do_hit                          004457 automatic       bit(1)                   dcl 226 set ref 324* 338* 370* 1182 1191
dr_hit                          004460 automatic       bit(1)                   dcl 226 set ref 324* 336* 367
e                         2            based           structure                array level 2 unaligned dcl 5-88
end_found                       004470 automatic       bit(1)                   dcl 226 set ref 379* 857* 1325* 1341* 1354 1364*
eof_was_found                   004474 automatic       fixed bin(1,0)           dcl 244 set ref 1237* 1238
error_in_object_segment         004316 automatic       bit(1)                   dcl 193 set ref 1180* 1183* 1186
error_label                     001224 automatic       label variable           dcl 109 set ref 389* 478* 1344
error_table_$badopt             000102 external static fixed bin(35,0)          dcl 284 ref 353
error_table_$noarg              000076 external static fixed bin(35,0)          dcl 284 ref 331
error_table_$noentry            000100 external static fixed bin(35,0)          dcl 284 ref 1050
execute                   0(01)        based           bit(1)                   level 2 packed packed unaligned dcl 198 ref 1148
fatal                                  parameter       bit(1)                   dcl 1337 set ref 1335 1341* 1344
firmware_seg              1(06)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  563* 564
fixed                                                  builtin function         dcl 184 ref 1314
flags                   112     004540 automatic       structure                level 2 dcl 939
format                   24     004364 automatic       structure                level 2 dcl 219
generated_time                  000216 automatic       fixed bin(71,0)          dcl 87 set ref 294* 733 749* 774*
generated_time_string           000220 automatic       char(32)                 packed unaligned dcl 88 set ref 749* 750* 750 753
gm_data_$default_path_list_name 000072 external static varying char(168)        dcl 279 ref 368
gm_error_                       000024 constant        entry                    external dcl 255 ref 1325 1341
gm_message                             parameter       char                     packed unaligned dcl 1337 set ref 1335 1341*
gm_output_iocbp                 004322 automatic       pointer                  initial dcl 196 set ref 196* 370* 394* 1325* 1328*
                                                                                  1341*
gm_util1_$close                 000030 constant        entry                    external dcl 258 ref 394 1328
gm_util1_$open                  000032 constant        entry                    external dcl 259 ref 370
gm_util_                        000026 constant        entry                    external dcl 257 ref 845 873 1065
gm_write_boot_program_          000036 constant        entry                    external dcl 262 ref 1183
gm_write_first_seg_             000034 constant        entry                    external dcl 261 ref 1180
hcs_$initiate_count             000040 constant        entry                    external dcl 264 ref 1049
hcs_$make_ptr                   000042 constant        entry                    external dcl 266 ref 700 715 730 746 763 778 799
hcs_$make_seg                   000044 constant        entry                    external dcl 267 ref 1102
hcs_$set_bc_seg                 000046 constant        entry                    external dcl 268 ref 1106
hcs_$terminate_noname           000050 constant        entry                    external dcl 269 ref 1125
hd_hit                          004456 automatic       bit(1)                   dcl 226 set ref 324* 339* 394* 1328*
hdrp                            000334 automatic       pointer                  dcl 96 set ref 370* 1325* 1341*
header                          004540 automatic       structure                level 2 dcl 939
header_data                     001306 automatic       fixed bin(35,0)          array dcl 179 set ref 304
header_max_size                        constant        fixed bin(17,0)          initial dcl 179 ref 507 629 638
header_path                     000140 automatic       char(168)                dcl 76 set ref 358* 370*
header_words                    001300 automatic       fixed bin(35,0)          dcl 168 set ref 1174* 1201
i                               000230 automatic       fixed bin(17,0)          dcl 90 set ref 326* 327* 327 327* 335* 335* 336 336
                                                                                  336 336 337 337 337 337 338 338 338 338 339 339
                                                                                  339 339 340 340 340 340 341 342* 342 344 344 346
                                                                                  346 346 346 347 348* 348 350 350* 359* 360 361 361
                                                                                  644* 645 647 649* 1048* 1049*
id_ptr                          004344 automatic       pointer                  dcl 207 set ref 700* 703 715* 718 730* 734 746* 753
                                                                                  763* 776 778* 789 799* 810
ident                                  based           fixed bin(17,0)          level 2 packed packed unaligned dcl 173 set ref 310*
                                                                                  402* 1172*
idx                             004700 automatic       fixed bin(17,0)          dcl 992 in procedure "DELETE_NAMES" set ref 1007*
                                                                                  1008 1012*
idx                             004536 automatic       fixed bin(17,0)          dcl 937 in procedure "GATHER_SEGNAMES" set ref 961*
                                                                                  962*
ignore                  112(01) 004540 automatic       bit(1)                   level 3 packed packed unaligned dcl 939 set ref 958
in_p                            001254 automatic       pointer                  dcl 126 set ref 301* 700* 715* 730* 746* 763* 778*
                                                                                  799* 1048 1049* 1050 1053 1056* 1069* 1088 1100
                                                                                  1102* 1103 1105 1106* 1107 1117 1119* 1122* 1125*
                                                                                  1128* 1180* 1183* 1325* 1341*
index                                                  builtin function         dcl 184 ref 359 405
init_seg                  1(22)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  548* 549 557* 1167
ioa_                            000052 constant        entry                    external dcl 270 ref 422
ion2                            001211 automatic       char(32)                 dcl 102 set ref 364* 370*
iox_$control                    000054 constant        entry                    external dcl 271 ref 1193
iox_$put_chars                  000056 constant        entry                    external dcl 272 ref 1201 1211 1223
jdx                             004701 automatic       fixed bin(17,0)          dcl 992 set ref 1012* 1013 1013*
lang_index                      004356 automatic       fixed bin(17,0)          dcl 207 set ref 781* 783* 787
last_path                       004303 automatic       char(32)                 dcl 189 set ref 314*
length                                                 builtin function         dcl 184 in procedure "gm" ref 805 805 970
length                    0(18)        based           fixed bin(17,0)          level 2 in structure "control_word" packed packed
                                                                                  unaligned dcl 173 in procedure "gm" set ref 401*
                                                                                  1173* 1175*
link_provided             1(24)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  824*
link_sect_wired           1(26)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  541* 611*
linkage_found                   004467 automatic       bit(1)                   dcl 226 set ref 379* 851* 863
linkp                     6     004364 automatic       pointer                  level 2 dcl 219 set ref 837 1070
llng                     20     004364 automatic       fixed bin(17,0)          level 2 dcl 219 set ref 834 835
max_count                              constant        fixed bin(17,0)          initial dcl 164 ref 907 967
max_length                3(03)        based           bit(9)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  681*
maxlength                                              builtin function         dcl 184 ref 805
mode                     10            based           bit(36)                  level 2 dcl 157 set ref 643* 645* 647* 649*
movewds                                based           bit                      dcl 207 set ref 1105* 1105
mst_tape_iocbp                  004320 automatic       pointer                  initial dcl 195 set ref 195* 370* 394* 1180* 1183*
                                                                                  1193* 1201* 1211* 1223* 1328*
name                      2            based           char(32)                 array level 3 in structure "seg_name_array" dcl 144
                                                                                  in procedure "gm" set ref 840* 869* 910* 962 971*
                                                                                  1008 1042
name                      1            based           char(168)                level 2 in structure "path" dcl 138 in procedure
                                                                                  "gm" set ref 503*
names                     1            based           structure                array level 2 dcl 144 set ref 1013* 1013
names_ptr                       001270 automatic       pointer                  dcl 144 set ref 308* 839 840 841 841 842 869 870 909
                                                                                  910 911 916 953 954 962 966 970 971 972 978 1001
                                                                                  1007 1008 1013 1013 1017 1032 1042 1043
ndir                            001222 automatic       fixed bin(17,0)          dcl 106 set ref 298* 370* 1048
next_def                        004540 automatic       pointer                  level 3 dcl 939 set ref 957
nnam                            001252 automatic       fixed bin(17,0)          dcl 118 set ref 839* 907* 907* 909 910 911 915 916*
                                                                                  954* 966* 967 970 971 972 977 978 1001* 1009 1012
                                                                                  1016* 1016 1017 1031 1032
no_error_was_found              004462 automatic       bit(1)                   dcl 226 set ref 387* 831 860 880
null                                                   builtin function         dcl 184 ref 115 195 196 301 698 713 728 744 761 797
                                                                                  947 1048 1050 1053 1070 1103 1117 1118 1123 1128
number_lang                            based           fixed bin(17,0)          level 2 dcl 5-88 ref 781
number_zone               1            based           fixed bin(17,0)          level 2 dcl 5-88 ref 782 783 783 787 787
numc                            001221 automatic       fixed bin(17,0)          dcl 106 set ref 393 398 405 407 407 410 415 415 417
                                                                                  417 426 429 432 435 438 444 450 485 485 490 490
                                                                                  495 495 502 503 506 515 518 520 521 522 523 527
                                                                                  527 534 539 547 554 562 570 575 587 591 594 598
                                                                                  603 611 616 621 644 644 645 647 649 661 668 679
                                                                                  687 694 694 697 709 709 712 724 727 740 743 759
                                                                                  767 767 769 771 794 804 805 807 815 820 856 895
                                                                                  909 910 914 919 1003 1006 1027 1027 1237* 1279
                                                                                  1297 1298 1314 1359 1365
o_ln                            004242 automatic       char(132)                dcl 187 set ref 1325 1325 1341 1341
oa_ptr                          004314 automatic       pointer                  dcl 191 set ref 312* 1147 1148 1149 1150 1167
object_info                            based           structure                level 1 dcl 3-6
object_info_$brief              000060 constant        entry                    external dcl 273 ref 1069
object_info_version_2                  constant        fixed bin(17,0)          initial dcl 3-60 ref 316
object_segment                  004452 automatic       bit(1)                   dcl 221 set ref 947 1045* 1074*
oi                              004364 automatic       structure                level 1 dcl 219 set ref 956 956 1069 1069
open_message                    000231 automatic       char(100)                packed unaligned dcl 91 set ref 370* 372 372*
out_sgna                        001230 automatic       char(32)                 dcl 111 set ref 365* 370*
output_access                          based           structure                level 1 packed packed unaligned dcl 198
output_access_word              004324 automatic       char(8)                  dcl 201 set ref 1146* 1147* 1148* 1149* 1150* 1151
pad                      11            based           bit(36)                  level 2 dcl 157 set ref 655*
paged                     1(13)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  542* 549* 556* 570*
parse_file_$parse_file_ptr      000062 constant        entry                    external dcl 274 ref 1237
parse_file_$parse_file_unset_break
                                000064 constant        entry                    external dcl 275 ref 375
path                                   based           structure                level 1 dcl 138
path_array                      000336 automatic       char(168)                array dcl 99 set ref 370 370 1049*
path_list_name                  000262 automatic       char(168)                dcl 96 set ref 367* 368* 370*
path_name_found                 004461 automatic       bit(1)                   dcl 226 set ref 379* 498* 542 950 998
path_ptr                        001266 automatic       pointer                  dcl 138 set ref 502 503 842* 916* 978* 1032*
per_process               1(14)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  534* 1165
print_gen_info_                 000066 constant        entry                    external dcl 276 ref 1056
privileged                0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 198 ref 1150
read                                   based           bit(1)                   level 2 packed packed unaligned dcl 198 ref 1147
real_in_p                       004330 automatic       pointer                  dcl 207 set ref 301* 698 713 728 744 761 797 1100*
                                                                                  1105 1118 1122 1123*
reverse                                                builtin function         dcl 184 ref 359
ringbrack                 2(09)        based           bit(3)                   array level 2 packed packed unaligned dcl 2-48 set
                                                                                  ref 589* 592* 595* 598* 598 603 603* 603*
rtrim                                                  builtin function         dcl 184 ref 777 970
section                   6     004540 automatic       char(4)                  level 3 dcl 939 set ref 958
seg_hdrp                        001302 automatic       pointer                  dcl 168 set ref 304* 306 308 310 1175 1201*
seg_header_length               001277 automatic       fixed bin(17,0)          dcl 168 set ref 506* 506 507 509 628* 628 629 637*
                                                                                  637 638 843* 871* 915* 977* 1031* 1174 1175
seg_name                        001242 automatic       char(32)                 initial dcl 118 set ref 118* 838* 838 840 845* 868*
                                                                                  868 869 873* 1042* 1049* 1065* 1183 1325* 1341*
seg_name_array                         based           structure                level 1 dcl 144
seg_name_l                      001276 automatic       fixed bin(17,0)          dcl 164 set ref 838 868 1043*
seg_type                               parameter       fixed bin(17,0)          dcl 1141 in procedure "WRITE_SEGMENT" ref 1139 1156
                                                                                  1179 1179 1180 1206 1206 1206 1206
seg_type                               parameter       fixed bin(17,0)          dcl 463 in procedure "PROCESS_SEGMENT" set ref 461
                                                                                  468 822 822 826 831* 845* 860* 873* 880* 1047
                                                                                  1065* 1067 1068 1078
segments_have_been_processed    004472 automatic       bit(1)                   dcl 226 set ref 295* 439 445 470*
segname                         004702 automatic       char(32)                 packed unaligned dcl 993 in procedure "DELETE_NAMES"
                                                                                  set ref 1006* 1008
segname                         004660 automatic       char(32)                 packed unaligned dcl 941 in procedure
                                                                                  "GATHER_SEGNAMES" set ref 960* 962 970 971
segp                            001256 automatic       pointer                  dcl 126 set ref 837* 845* 867* 873* 1065* 1088*
                                                                                  1107* 1211*
sg_b                            001261 automatic       fixed bin(24,0)          dcl 126 set ref 828* 835* 865* 1081* 1084* 1158 1159
                                                                                  1180* 1183*
sg_l                            001263 automatic       fixed bin(17,0)          dcl 126 set ref 827* 828 834* 864* 1060* 1080* 1081
                                                                                  1085* 1173
short                     2            based           varying char(4)          array level 3 dcl 5-88 ref 783
size                      1            based           fixed bin(17,0)          array level 3 in structure "seg_name_array" dcl 144
                                                                                  in procedure "gm" set ref 841* 841 909* 970* 1043
size                                   based           fixed bin(17,0)          level 2 in structure "path" dcl 138 in procedure
                                                                                  "gm" set ref 502*
slte                                   based           structure                level 1 dcl 2-48
sltep                           004504 automatic       pointer                  dcl 2-8 set ref 306* 312 401 402 407 412 415 417 422
                                                                                  422 504 509 517 520 521 522 523 534 540 541 541
                                                                                  542 542 548 549 549 555 556 556 557 557 563 564
                                                                                  564 570 579 580 589 592 595 598 598 603 603 603
                                                                                  611 616 632 670 672 672 681 688 815 824 845* 873*
                                                                                  1061 1062 1065* 1072 1076 1158 1159 1165 1165 1167
                                                                                  1167 1167 1170 1180* 1223*
substr                                                 builtin function         dcl 184 set ref 361 520* 521* 522* 523* 645 645* 647
                                                                                  647* 649 649* 776* 810* 838 868 960 1147* 1148*
                                                                                  1149* 1150*
switch                          004776 automatic       bit(1)                   dcl 1292 set ref 1297* 1298* 1303
sym_is_a_break                  004473 automatic       fixed bin(1,0)           dcl 244 set ref 1237* 1253 1263 1354
symbol                   11     004540 automatic       char(256)                level 2 dcl 939 set ref 960
symbol_lng              111     004540 automatic       fixed bin(17,0)          level 2 dcl 939 set ref 960
symbol_name                     004332 automatic       char(32)                 packed unaligned dcl 207 set ref 697* 700* 712* 715*
                                                                                  727* 730* 743* 746* 760* 763* 777* 777 778* 796*
                                                                                  799*
symp                            001240 automatic       pointer                  initial dcl 115 set ref 115* 393 398 405 407 410 415
                                                                                  415 417 417 426 429 432 435 438 444 450 485 485
                                                                                  490 490 495 495 503 515 518 520 521 522 523 527
                                                                                  527 534 539 547 554 562 570 575 587 591 594 598
                                                                                  603 611 616 621 644 645 647 649 661 668 679 687
                                                                                  694 694 697 709 709 712 724 727 740 743 759 767
                                                                                  767 769 771 794 804 805 807 815 820 856 895 910
                                                                                  914 919 1003 1006 1027 1027 1237* 1279 1297 1298
                                                                                  1314 1325* 1341* 1359 1365
sys_desig                       001202 automatic       varying char(24)         dcl 101 set ref 360* 361* 362 365 367
sysid                           000212 automatic       char(8)                  packed unaligned dcl 76 set ref 344* 362* 363 370*
                                                                                  703
sysid_hit                       004453 automatic       bit(1)                   dcl 226 set ref 324* 343* 362
tape_er_count                   004326 automatic       fixed bin(17,0)          dcl 203 set ref 1191* 1193 1193 1195
tape_no                                based           char                     packed unaligned dcl 71 ref 364
temp_seg                  1(23)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  555* 556 557 1167
ti_zone                                based           structure                level 1 unaligned dcl 5-88
time_as_bit                     004342 automatic       bit(72)                  packed unaligned dcl 207 set ref 733* 734 787* 789
time_info_$zone_names           000104 external static fixed bin(17,0)          dcl 5-86 set ref 781 782 783 787
tlng                     16     004364 automatic       fixed bin(17,0)          level 2 dcl 219 set ref 827 1079
translate                                              builtin function         dcl 184 ref 750
tx_l                            001262 automatic       fixed bin(17,0)          dcl 126 set ref 1079* 1080
unique_chars_                   000070 constant        entry                    external dcl 277 ref 1101
unique_name                     004360 automatic       char(15)                 packed unaligned dcl 207 set ref 700* 715* 730* 746*
                                                                                  763* 778* 799* 1101* 1102* 1102*
unspec                                                 builtin function         dcl 184 ref 733 787
userid                                 based           char(32)                 level 2 dcl 157 set ref 661*
versid                          000214 automatic       char(8)                  packed unaligned dcl 76 set ref 350* 363* 718
versid_hit                      004454 automatic       bit(1)                   dcl 226 set ref 324* 349* 363
version_number                  004364 automatic       fixed bin(17,0)          level 2 dcl 219 set ref 316*
wired                     1(12)        based           bit(1)                   level 2 packed packed unaligned dcl 2-48 set ref
                                                                                  540* 541 542 564*
wr_w                            001301 automatic       fixed bin(17,0)          dcl 168 set ref 827* 834* 864* 1080* 1085* 1211
write                     0(02)        based           bit(1)                   level 2 packed packed unaligned dcl 198 ref 1149
                                                                                  1167
zone_index                      004357 automatic       fixed bin(17,0)          dcl 207 set ref 782* 783* 787

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
Vtime_info_2                           internal static char(8)                  initial packed unaligned dcl 5-23
decode_definition_acc                  based           structure                level 1 dcl 4-34
decode_definition_str                  based           structure                level 1 dcl 4-14
site_date                              internal static fixed bin(17,0)          initial dcl 5-35
site_date_time                         internal static fixed bin(17,0)          initial dcl 5-35
site_time                              internal static fixed bin(17,0)          initial dcl 5-35
slte_uns                               based           structure                level 1 dcl 2-10
ti_day                                 based           structure                level 1 unaligned dcl 5-60
ti_keyword                             based           structure                level 1 unaligned dcl 5-29
ti_language                            based           structure                level 1 unaligned dcl 5-42
ti_month                               based           structure                level 1 unaligned dcl 5-52
ti_offset                              based           structure                level 1 unaligned dcl 5-68
ti_word                                based           structure                level 1 unaligned dcl 5-78
time_info_$date_time_keywords          external static fixed bin(17,0)          dcl 5-28
time_info_$day_names                   external static fixed bin(17,0)          dcl 5-58
time_info_$default_language_index      external static fixed bin(17,0)          dcl 5-26
time_info_$gmt_zone_index              external static fixed bin(17,0)          dcl 5-25
time_info_$language_names              external static fixed bin(17,0)          dcl 5-40
time_info_$month_names                 external static fixed bin(17,0)          dcl 5-50
time_info_$offset_names                external static fixed bin(17,0)          dcl 5-66
time_info_$version                     external static char(8)                  packed unaligned dcl 5-21
time_info_$word_names                  external static fixed bin(17,0)          dcl 5-76
tiw_FiscalIndicator                    internal static fixed bin(17,0)          initial dcl 5-107

NAMES DECLARED BY EXPLICIT CONTEXT.
CLEANUP_CONDITION_HANDLER       010622 constant        entry                    internal dcl 1322 ref 318
COPY_SEGMENT                    007327 constant        entry                    internal dcl 1097 ref 698 713 728 744 761 797
C_ERROR                         002163 constant        label                    dcl 408 set ref 416 418
DELETE_NAMES                    006507 constant        entry                    internal dcl 985 ref 490
ERROR                           010733 constant        entry                    internal dcl 1335 ref 332 354 372 410 439 445 453
                                                                                  496 507 524 527 600 605 629 638 651 701 716 731
                                                                                  747 764 767 779 786 800 805 822 888 919 923 947
                                                                                  950 967 998 1009 1022 1027 1050 1053 1071 1103
                                                                                  1120 1126 1151 1186 1188 1195 1238 1253 1263 1279
                                                                                  1299
GATHER_NAMES                    006121 constant        entry                    internal dcl 905 ref 474
GATHER_SEGNAMES                 006245 constant        entry                    internal dcl 930 ref 485
GET_NEXT_ARG                    010400 constant        entry                    internal dcl 1248 ref 391 403 480 501 519 642 660
                                                                                  696 711 726 742 770 908 1004 1296 1313
GET_NEXT_BREAK                  010427 constant        entry                    internal dcl 1259 ref 526 590 593 766 913 1024 1277
GET_NEXT_NAME_TO_DELETE         006675 constant        label                    dcl 1024 ref 1018
GET_NEXT_SYM                    010335 constant        entry                    internal dcl 1234 ref 803 808 897 1251 1261 1356
                                                                                  1360 1362
GET_NUM                         010600 constant        entry                    internal dcl 1310 ref 577 589 592 595 670 681
INIT_SEGMENT                    006750 constant        entry                    internal dcl 1039 ref 476
PROCESS_SEGMENT                 002605 constant        entry                    internal dcl 461 ref 426 429 432 435 441 447 450
TAPE_ER                         010074 constant        label                    dcl 1186 ref 1202 1212 1224
TERM_SEGMENT                    007457 constant        entry                    internal dcl 1114 ref 884
TEST_BREAK                      010456 constant        entry                    internal dcl 1273 ref 399 421 472 499 510 516 576
                                                                                  578 588 596 622 658 663 669 671 680 682 695 704
                                                                                  710 719 725 735 741 754 772 795 821 858 944 996
                                                                                  1295 1301
TRY_NEXT_DEFINITION             006471 constant        label                    dcl 974 ref 962
WRITE_COLLECTION                010312 constant        entry                    internal dcl 1220 ref 423
WRITE_SEGMENT                   007613 constant        entry                    internal dcl 1139 ref 831 860 880
YES_NO                          010514 constant        entry                    internal dcl 1290 ref 534 540 548 555 563 570 611
                                                                                  616 688 815
close_out                       002063 constant        label                    dcl 394 ref 1346
found_time_zone                 005307 constant        label                    dcl 787 ref 783
generate_mst                    001175 constant        entry                    external dcl 43
gm                              001165 constant        entry                    external dcl 43
next_segment                    002040 constant        label                    dcl 379 ref 457 1367
noarg                           001323 constant        label                    dcl 331 ref 341 347
seg_loop                        002630 constant        label                    dcl 480 ref 891 900
skip_to_next_seg                002552 constant        label                    dcl 1354 ref 389 1365
skip_to_next_statement          006110 constant        label                    dcl 895 ref 478

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11756       12064   11353       11766
Length     12430   11353       106         327     403           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
gm                                 3341 external procedure  is an external procedure.  
on unit on line 318                 128 on unit               
PROCESS_SEGMENT                         internal procedure  shares stack frame of external procedure gm.  
GATHER_NAMES                            internal procedure  shares stack frame of external procedure gm.  
GATHER_SEGNAMES                         internal procedure  shares stack frame of external procedure gm.  
DELETE_NAMES                            internal procedure  shares stack frame of external procedure gm.  
INIT_SEGMENT                            internal procedure  shares stack frame of external procedure gm.  
COPY_SEGMENT                            internal procedure  shares stack frame of external procedure gm.  
TERM_SEGMENT                            internal procedure  shares stack frame of external procedure gm.  
WRITE_SEGMENT                           internal procedure  shares stack frame of external procedure gm.  
GET_NEXT_SYM                            internal procedure  shares stack frame of external procedure gm.  
GET_NEXT_ARG                            internal procedure  shares stack frame of external procedure gm.  
TEST_BREAK                              internal procedure  shares stack frame of external procedure gm.  
YES_NO                                  internal procedure  shares stack frame of external procedure gm.  
GET_NUM                                 internal procedure  shares stack frame of external procedure gm.  
CLEANUP_CONDITION_HANDLER               internal procedure  shares stack frame of on unit on line 318.  
ERROR                               114 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
gm                       000100 argp                        gm
                         000124 argl                        gm
                         000136 code                        gm
                         000137 acount                      gm
                         000140 header_path                 gm
                         000212 sysid                       gm
                         000214 versid                      gm
                         000216 generated_time              gm
                         000220 generated_time_string       gm
                         000230 i                           gm
                         000231 open_message                gm
                         000262 path_list_name              gm
                         000334 hdrp                        gm
                         000336 path_array                  gm
                         001202 sys_desig                   gm
                         001211 ion2                        gm
                         001221 numc                        gm
                         001222 ndir                        gm
                         001224 error_label                 gm
                         001230 out_sgna                    gm
                         001240 symp                        gm
                         001242 seg_name                    gm
                         001252 nnam                        gm
                         001254 in_p                        gm
                         001256 segp                        gm
                         001260 bitcnt                      gm
                         001261 sg_b                        gm
                         001262 tx_l                        gm
                         001263 sg_l                        gm
                         001264 cur_len_for_bitcnt          gm
                         001266 path_ptr                    gm
                         001270 names_ptr                   gm
                         001272 acl_count_ptr               gm
                         001274 acl_block_ptr               gm
                         001276 seg_name_l                  gm
                         001277 seg_header_length           gm
                         001300 header_words                gm
                         001301 wr_w                        gm
                         001302 seg_hdrp                    gm
                         001304 cw_ptr                      gm
                         001306 header_data                 gm
                         004242 o_ln                        gm
                         004303 last_path                   gm
                         004314 oa_ptr                      gm
                         004316 error_in_object_segment     gm
                         004320 mst_tape_iocbp              gm
                         004322 gm_output_iocbp             gm
                         004324 output_access_word          gm
                         004326 tape_er_count               gm
                         004330 real_in_p                   gm
                         004332 symbol_name                 gm
                         004342 time_as_bit                 gm
                         004344 id_ptr                      gm
                         004346 default_rpv_data            gm
                         004355 default_time_zone           gm
                         004356 lang_index                  gm
                         004357 zone_index                  gm
                         004360 unique_name                 gm
                         004364 oi                          gm
                         004452 object_segment              gm
                         004453 sysid_hit                   gm
                         004454 versid_hit                  gm
                         004455 db_hit                      gm
                         004456 hd_hit                      gm
                         004457 do_hit                      gm
                         004460 dr_hit                      gm
                         004461 path_name_found             gm
                         004462 no_error_was_found          gm
                         004463 cur_length_found            gm
                         004464 bit_count_found             gm
                         004465 cache_found                 gm
                         004466 acl_found                   gm
                         004467 linkage_found               gm
                         004470 end_found                   gm
                         004471 boot_program_has_been_processed
                                                            gm
                         004472 segments_have_been_processed
                                                            gm
                         004473 sym_is_a_break              gm
                         004474 eof_was_found               gm
                         004504 sltep                       gm
                         004536 idx                         GATHER_SEGNAMES
                         004537 current_name_count          GATHER_SEGNAMES
                         004540 def                         GATHER_SEGNAMES
                         004656 defp                        GATHER_SEGNAMES
                         004660 segname                     GATHER_SEGNAMES
                         004700 idx                         DELETE_NAMES
                         004701 jdx                         DELETE_NAMES
                         004702 segname                     DELETE_NAMES
                         004776 switch                      YES_NO

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac
tra_ext_1           tra_ext_2           enable_op           shorten_stack       ext_entry           int_entry
int_entry_desc      any_to_any_truncate_clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_                 date_time_
date_time_$format             decode_definition_$full       delete_$ptr                   gm_error_
gm_util1_$close               gm_util1_$open                gm_util_                      gm_write_boot_program_
gm_write_first_seg_           hcs_$initiate_count           hcs_$make_ptr                 hcs_$make_seg
hcs_$set_bc_seg               hcs_$terminate_noname         ioa_                          iox_$control
iox_$put_chars                object_info_$brief            parse_file_$parse_file_ptr
parse_file_$parse_file_unset_break                          print_gen_info_               unique_chars_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$noarg            error_table_$noentry
gm_data_$default_path_list_name                             time_info_$zone_names




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
    115 001153       118 001155       195 001160       196 001161        43 001164       294 001203       295 001205
    296 001206       298 001207       301 001211       304 001214       306 001216       308 001221       310 001224
    312 001226       314 001230       316 001233       318 001235       324 001253       325 001261       326 001270
    327 001277       328 001316       330 001320       331 001323       332 001326       335 001347       336 001361
    337 001401       338 001414       339 001427       340 001442       341 001452       342 001455       343 001456
    344 001460       345 001470       346 001471       347 001501       348 001504       349 001505       350 001507
    351 001517       353 001520       354 001523       356 001544       358 001546       359 001564       360 001575
    361 001610       362 001624       363 001632       364 001636       365 001643       367 001661       368 001703
    370 001712       372 002003       375 002025       379 002040       387 002047       389 002051       391 002054
    393 002055       394 002063       395 002076       398 002077       399 002103       401 002107       402 002112
    403 002115       405 002116       407 002131       408 002161       410 002163       411 002217       412 002220
    413 002223       415 002224       416 002265       417 002270       418 002340       421 002343       422 002347
    423 002375       424 002376       426 002377       429 002406       432 002415       435 002424       438 002433
    439 002437       441 002462       442 002464       444 002465       445 002471       447 002516       448 002520
    450 002521       453 002530       457 002551      1354 002552      1356 002560      1357 002561      1359 002563
   1360 002572      1361 002573      1362 002574      1364 002575      1365 002576      1367 002604       461 002605
    468 002607       470 002615       472 002617       474 002623       476 002624       478 002625       480 002630
    485 002631       490 002645       495 002657       496 002667       498 002712       499 002714       501 002720
    502 002721       503 002723       504 002731       506 002734       507 002744       509 002767       510 002773
    511 002777       515 003000       516 003004       517 003010       518 003013       519 003022       520 003023
    521 003035       522 003045       523 003055       524 003065       526 003111       527 003112       529 003146
    530 003147       534 003150       539 003166       540 003172       541 003203       542 003211       543 003223
    547 003224       548 003230       549 003241       550 003247       554 003250       555 003254       556 003265
    557 003273       558 003300       562 003301       563 003305       564 003316       566 003324       570 003325
    575 003343       576 003347       577 003353       578 003357       579 003363       580 003374       582 003406
    583 003410       587 003411       588 003415       589 003421       590 003434       591 003435       592 003443
    593 003456       594 003457       595 003465       596 003500       597 003504       598 003505       600 003520
    602 003542       603 003543       605 003566       607 003610       611 003611       616 003627       621 003645
    622 003651       624 003655       625 003657       626 003661       627 003662       628 003664       629 003665
    631 003711       632 003713       635 003716       636 003717       637 003721       638 003723       640 003747
    642 003752       643 003753       644 003755       645 003773       647 004006       649 004014       651 004022
    653 004046       655 004050       656 004052       658 004053       660 004057       661 004060       663 004066
    664 004072       668 004073       669 004077       670 004103       671 004113       672 004117       674 004135
    675 004137       679 004140       680 004144       681 004150       682 004163       683 004167       687 004170
    688 004174       689 004205       690 004207       694 004210       695 004220       696 004224       697 004225
    698 004232       700 004237       701 004267       703 004312       704 004316       705 004322       709 004323
    710 004333       711 004337       712 004340       713 004345       715 004352       716 004402       718 004425
    719 004431       720 004435       724 004436       725 004442       726 004446       727 004447       728 004454
    730 004461       731 004511       733 004534       734 004536       735 004542       736 004546       740 004547
    741 004553       742 004557       743 004560       744 004565       746 004572       747 004622       749 004645
    750 004662       753 004673       754 004700       755 004704       759 004705       760 004711       761 004714
    763 004721       764 004751       766 004774       767 004775       769 005031       770 005037       771 005040
    772 005045       773 005051       774 005052       776 005110       777 005114       778 005142       779 005173
    781 005216       782 005227       783 005241       784 005262       785 005264       786 005266       787 005307
    789 005326       790 005332       794 005333       795 005337       796 005343       797 005346       799 005353
    800 005403       802 005426       803 005427       804 005430       805 005436       807 005464       808 005521
    809 005523       810 005524       811 005531       815 005532       820 005550       821 005554       822 005560
    824 005607       826 005612       827 005616       828 005621       831 005623       834 005633       835 005636
    837 005640       838 005642       839 005657       840 005663       841 005667       842 005671       843 005676
    845 005700       847 005726       851 005732       852 005734       856 005735       857 005741       858 005743
    860 005747       863 005760       864 005762       865 005765       867 005767       868 005771       869 006006
    870 006013       871 006016       873 006020       875 006046       880 006052       884 006063       885 006064
    888 006065       891 006107       895 006110       897 006116       898 006117       900 006120       905 006121
    907 006122       908 006127       909 006130       910 006136       911 006144       913 006146       914 006147
    915 006155       916 006162       917 006171       919 006172       921 006220       923 006222       926 006244
    930 006245       944 006246       946 006252       947 006254       950 006306       953 006333       954 006335
    956 006336       957 006362       958 006364       960 006372       961 006376       962 006405       964 006414
    966 006416       967 006421       970 006445       971 006463       972 006467       974 006471       977 006472
    978 006477       980 006506       985 006507       996 006510       998 006514      1001 006541      1003 006543
   1004 006552      1006 006553      1007 006560      1008 006567      1009 006577      1012 006623      1013 006633
   1014 006643      1016 006645      1017 006647      1018 006651      1020 006652      1022 006654      1024 006675
   1027 006676      1029 006732      1031 006733      1032 006740      1034 006747      1039 006750      1042 006751
   1043 006755      1045 006757      1047 006760      1048 006764      1049 006777      1050 007043      1052 007074
   1053 007076      1056 007124      1057 007155      1060 007156      1061 007157      1062 007162      1065 007164
   1067 007211      1068 007215      1069 007217      1070 007236      1071 007244      1072 007270      1073 007273
   1074 007274      1075 007276      1076 007277      1078 007302      1079 007306      1080 007310      1081 007312
   1082 007314      1084 007315      1085 007317      1088 007324      1092 007326      1097 007327      1100 007330
   1101 007332      1102 007351      1103 007406      1105 007433      1106 007441      1107 007454      1110 007456
   1114 007457      1117 007460      1118 007464      1119 007470      1120 007524      1122 007547      1123 007551
   1125 007553      1126 007564      1128 007610      1132 007612      1139 007613      1146 007615      1147 007617
   1148 007626      1149 007634      1150 007642      1151 007650      1156 007700      1158 007710      1159 007716
   1165 007730      1167 007741      1170 007754      1172 007756      1173 007761      1174 007764      1175 007767
   1179 007772      1180 010000      1182 010024      1183 010030      1185 010072      1186 010074      1188 010124
   1191 010145      1193 010155      1195 010207      1196 010232      1201 010233      1202 010253      1206 010255
   1211 010267      1212 010307      1216 010311      1220 010312      1223 010313      1224 010332      1226 010334
   1234 010335      1237 010336      1238 010353      1241 010377      1248 010400      1251 010401      1253 010402
   1256 010426      1259 010427      1261 010430      1263 010431      1266 010455      1273 010456      1277 010460
   1279 010461      1282 010513      1290 010514      1295 010516      1296 010522      1297 010523      1298 010534
   1299 010542      1301 010566      1303 010572      1310 010600      1313 010602      1314 010603      1322 010622
   1325 010623      1328 010715      1331 010731      1335 010732      1341 010746      1344 011027      1346 011036


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
