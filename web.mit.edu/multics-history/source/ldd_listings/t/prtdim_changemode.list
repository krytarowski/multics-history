	COMPILATION LISTING OF SEGMENT prtdim_changemode
	Compiled by: Multics PL/I Compiler, Release 31a, of October 12, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 10/28/88  1321.7 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /* Change/return modes for the printer DIM */
       15 
       16 /* Created:  28 October 1974 by Noel I. Morris */
       17 /* Modified: 15 March 1977 by Noel I. Morris */
       18 /* Modified: September 1979 by D. Vinograd to add the remote_printer_modes_ entry */
       19 /* Modified: Februrary 1979 by J. Whitmore to fix order dependent if statement bug and check ranges of modes */
       20 /* Rewritten: 9 December 1981 by G. Palter to convert to mode_string_ and add "ctl_char" mode */
       21 /* Modified: 9 August 1982 by G. Palter to not append a newline to the returned old modes string */
       22 /* Modified: 26 August 1982 by G. Palter to make indent=N work */
       23 /* Modified: 25 June 1984 by C. Marker changed so that the left margin must be to the left of the right margin or an error code is returned. */
       24 
       25 
       26 /****^  HISTORY COMMENTS:
       27*  1) change(87-05-11,Gilcrease), approve(87-07-31,MCR7686),
       28*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
       29*     Added the line numbers (line_nbrs) mode.
       30*                                                   END HISTORY COMMENTS */
       31 
       32 
       33 /* format: style4,delnl,insnl,ifthenstmt,ifthen */
       34 
       35 
       36 prtdim_changemode:
       37      procedure (P_sdb_ptr, P_new_modes, P_old_modes, P_iostatus);
       38 
       39 
       40 /* Parameters */
       41 
       42 dcl  P_new_modes character (*) parameter;		/* new modes to be set (if any) */
       43 dcl  P_old_modes character (*) parameter;		/* set to modes in effect prior to change */
       44 
       45 dcl  P_sdb_ptr pointer parameter;			/* prtdim_changemode: -> the stream's SDB (data block) */
       46 dcl  P_iostatus bit (72) aligned;			/* prtdim_changemode: set to ios_ status */
       47 
       48 dcl  P_iocb_ptr pointer parameter;			/* remote_printer_modes_: -> switch's I/O control block */
       49 dcl  P_code fixed binary (35) parameter;		/* remote_printer_modes_: set to system status code */
       50 
       51 
       52 /* Local copies of parameters */
       53 
       54 dcl  code fixed binary (35);
       55 
       56 
       57 /* Remaining declarations */
       58 
       59 dcl  ios_interface bit (1) aligned;			/* ON => caller used ios_; OFF => caller used iox_ */
       60 
       61 dcl  system_area area based (system_area_ptr);
       62 dcl  system_area_ptr pointer;
       63 
       64 dcl  (single_page_bit, print_bit) bit (1) aligned;	/* copies to build old modes string */
       65 dcl  stop_every_value fixed binary;
       66 dcl  old_modes_lth fixed binary (21);			/* used to construct old modes string */
       67 dcl  i fixed binary (21);
       68 
       69 dcl  (mode_idx, array_idx, idx) fixed binary;
       70 dcl  legal_mode bit (1) aligned;
       71 
       72 /* format: off */
       73 dcl  save_rmarg fixed bin static;
       74 dcl  BOOLEAN_MODE_NAMES (-3:9) character (32) static options (constant) initial (
       75 	"in",	     "indent",     "stop",	     "default",	/* -2,-1,0: special cased boolean modes */
       76 	"noskip",	     "single",	"non_edited",  "truncate",	"esc",
       77 	"ctl_char",     "line_nbrs",    "1pg",	"print");
       78 
       79 dcl  NUMERIC_MODE_NAMES (1:5) character (32) static options (constant) initial (
       80 	"stop",	     "in",	"indent",	     "ll",	"pl");
       81 
       82 dcl  NUMERIC_MODE_RANGES (1:5, 2) fixed binary static options (constant) initial (
       83 	0,	9999,				/* stop:   0 through 9999 */
       84 	0,	 250,				/* in:     0 through  250 */
       85 	0,	 250,				/* indent: 0 through  250 */
       86 	2,	 250,				/* ll:	 2 through  250 */
       87 	2,	 127);				/* pl:	 2 through  127 */
       88 /* format: on */
       89 
       90 dcl  error_table_$bad_mode fixed binary (35) external;
       91 dcl  error_table_$inconsistent fixed binary (35) external;
       92 
       93 dcl  get_system_free_area_ entry () returns (pointer);
       94 dcl  ioa_$rsnnl entry () options (variable);
       95 dcl  mode_string_$parse entry (character (*), pointer, pointer, fixed binary (35));
       96 
       97 dcl  (addr, divide, hbound, index, lbound, length, min, null, reverse, rtrim, substr, unspec) builtin;
       98 
       99 dcl  cleanup condition;
      100 
      101 /**/
      102 
      103 /* prtdim_changemode: entry (P_sdb_ptr, P_new_modes, P_old_modes, P_iostatus); */
      104 
      105 	ios_interface = "1"b;			/* ios_ calling sequence */
      106 
      107 	P_iostatus = ""b;				/* clear returned status */
      108 	substr (P_iostatus, 41, 1) = "1"b;		/* set transaction terminated bit */
      109 
      110 	sdb_ptr = P_sdb_ptr;
      111 	adp = null ();				/* iox_ attach description isn't used here */
      112 
      113 	pcip = addr (sdb.conv_info);			/* get pointer to conversion info */
      114 	go to COMMON;
      115 
      116 
      117 /* Change/return modes for a remote printer/teleprinter */
      118 
      119 remote_printer_modes_:
      120      entry (P_iocb_ptr, P_new_modes, P_old_modes, P_code);
      121 
      122 	ios_interface = "0"b;			/* iox_ calling sequence */
      123 
      124 	P_code = 0;				/* clear return code */
      125 
      126 	sdb_ptr = null ();				/* no ios_ stream data block */
      127 	adp = P_iocb_ptr -> iocb.attach_data_ptr;
      128 
      129 	pcip = addr (ad.remote_pci);
      130 
      131 
      132 /* Setup */
      133 
      134 COMMON:
      135 	system_area_ptr = get_system_free_area_ ();
      136 	mode_string_info_ptr = null ();		/* for cleanup handler */
      137 
      138 	on condition (cleanup)
      139 	     begin;
      140 	     if mode_string_info_ptr ^= null () then free mode_string_info in (system_area);
      141 	end;
      142 
      143 
      144 /* Build the current mode string and return it to the caller */
      145 
      146 	if ios_interface then do;			/* get modes in the attach data ... */
      147 	     single_page_bit = sdb.single_page;
      148 	     print_bit = ^sdb.noprint;
      149 	     stop_every_value = sdb.stop_every;
      150 	end;
      151 	else do;					/* ... for either local or remote printer */
      152 	     single_page_bit = ad.single_page;
      153 	     print_bit = ^ad.noprint;
      154 	     stop_every_value = ad.stop_every;
      155 	end;
      156 
      157 	if length (P_old_modes) > 0 then do;		/* only return something if there's some room */
      158 	     call ioa_$rsnnl (
      159 		"^[^;^^^]noskip,^[^;^^^]single,^[^;^^^]non_edited,^[^;^^^]truncate,^[^;^^^]esc,^[^;^^^]ctl_char,^[^;^^^]line_nbrs,^[^;^^^]1pg,^[^;^^^]print,stop=^d,ll=^d,indent=^d,pl=^d."
      160 		, P_old_modes, old_modes_lth, pci.overflow_off, pci.single_space, pci.non_edited, pci.truncate,
      161 		pci.esc, pci.ctl_char, pci.line_nbrs, single_page_bit, print_bit, stop_every_value, pci.rmarg, pci.lmarg,
      162 		pci.page_length);
      163 	     if old_modes_lth > length (P_old_modes) then do;
      164 						/* mode string is too long: truncate at nearest mode */
      165 		i = index (reverse (P_old_modes), ","); /* look for the last comma */
      166 		if (i > 0) then			/* returning some modes: turn last "," into a "." */
      167 		     substr (P_old_modes, (length (P_old_modes) - i + 1)) = ".";
      168 		else P_old_modes = "";		/* nothing fits */
      169 	     end;
      170 	end;
      171 
      172 
      173 /* Process the new modes (if any) */
      174 
      175 	if length (rtrim (P_new_modes)) ^= 0 then do;	/* there are new modes ... */
      176 
      177 	     call mode_string_$parse (P_new_modes, system_area_ptr, mode_string_info_ptr, code);
      178 	     if code ^= 0 then go to ERROR_RETURN;
      179 
      180 
      181 /* Validate that all modes are recognized and have valid values */
      182 
      183 	     do mode_idx = 1 to mode_string_info.number;
      184 		mode_value_ptr = addr (mode_string_info.modes (mode_idx));
      185 		if mode_value.char_valuep then	/* ... no mode may be a character value */
      186 		     go to BAD_MODE_VALUE;
      187 		else if mode_value.boolean_valuep then do;
      188 		     legal_mode = "0"b;		/* assume it's not valid */
      189 		     do idx = lbound (BOOLEAN_MODE_NAMES, 1) to hbound (BOOLEAN_MODE_NAMES, 1) while (^legal_mode);
      190 			if mode_value.mode_name = BOOLEAN_MODE_NAMES (idx) then legal_mode = "1"b;
      191 		     end;
      192 		     if ^legal_mode then go to BAD_MODE_VALUE;
      193 		     if (mode_value.mode_name = "default") & (^mode_value.boolean_value) then go to BAD_MODE_VALUE;
      194 						/* default mode can not be negated... */
      195 		     if (mode_value.mode_name = "stop") & (mode_value.boolean_value) then go to BAD_MODE_VALUE;
      196 						/* "^stop" is accepted as a synonym of "stop=0" */
      197 		     if (mode_value.mode_name = "in") & (mode_value.boolean_value) then go to BAD_MODE_VALUE;
      198 						/* "^in" is accepted as a synonym of "in=0" */
      199 		     if (mode_value.mode_name = "indent") & (mode_value.boolean_value) then go to BAD_MODE_VALUE;
      200 						/* "^indent" is accepted as a synonym of "indent=0" */
      201 		end;
      202 		else /* if mode_value.numeric_valuep then */ do;
      203 						/* must be a numeric mode */
      204 		     legal_mode = "0"b;		/* assume it's not valid */
      205 		     do idx = lbound (NUMERIC_MODE_NAMES, 1) to hbound (NUMERIC_MODE_NAMES, 1) while (^legal_mode);
      206 			if mode_value.mode_name = NUMERIC_MODE_NAMES (idx) then legal_mode = "1"b;
      207 		     end;
      208 		     if ^legal_mode then go to BAD_MODE_VALUE;
      209 		     idx = idx - 1;			/* that's the nature of PL/I */
      210 		     if (mode_value.numeric_value < NUMERIC_MODE_RANGES (idx, 1))
      211 			| (mode_value.numeric_value > NUMERIC_MODE_RANGES (idx, 2)) then
      212 			go to BAD_MODE_VALUE;
      213 		end;
      214 	     end;
      215 
      216 
      217 /* Modes are valid: update the I/O switch's data structures to relect the new modes */
      218 
      219 	     do mode_idx = 1 to mode_string_info.number;
      220 		mode_value_ptr = addr (mode_string_info.modes (mode_idx));
      221 		if mode_value.boolean_valuep then do;
      222 		     legal_mode = "0"b;
      223 		     do idx = lbound (BOOLEAN_MODE_NAMES, 1) to hbound (BOOLEAN_MODE_NAMES, 1) while (^legal_mode);
      224 			if mode_value.mode_name = BOOLEAN_MODE_NAMES (idx) then do;
      225 			     legal_mode = "1"b;
      226 			     array_idx = idx;
      227 			end;
      228 		     end;
      229 		     if legal_mode then
      230 			go to SET_BOOLEAN_MODE (array_idx);
      231 		     else go to BAD_MODE_VALUE;	/* shouldn't happen, but... */
      232 		end;
      233 		else /* if mode_value.numeric_valuep then */ do;
      234 		     legal_mode = "0"b;
      235 		     do idx = lbound (NUMERIC_MODE_NAMES, 1) to hbound (NUMERIC_MODE_NAMES, 1) while (^legal_mode);
      236 			if mode_value.mode_name = NUMERIC_MODE_NAMES (idx) then do;
      237 			     legal_mode = "1"b;
      238 			     array_idx = idx;
      239 			end;
      240 		     end;
      241 		     if legal_mode then		/* go set it */
      242 			go to SET_NUMERIC_MODE (array_idx);
      243 		     else go to BAD_MODE_VALUE;	/* shouldn't happen, but ... */
      244 		end;
      245 		go to BAD_MODE_VALUE;		/* should never get here */
      246 
      247 SET_BOOLEAN_MODE (0):				/* default */
      248 		if ^mode_value.boolean_value then go to BAD_MODE_VALUE;
      249 						/* was already tested, but ... */
      250 		pci.modes = ""b;			/* reset all modes */
      251 		if ios_interface then do;
      252 		     sdb.mode = ""b;
      253 		     sdb.stop_every = 0;
      254 		end;
      255 		else do;
      256 		     ad.output_modes = ""b;
      257 		     ad.stop_every = 0;
      258 		end;
      259 		pci.top_label_length, pci.bot_label_length = 0;
      260 						/* flush any labels */
      261 		pci.rmarg = pci.phys_line_length;	/* reset line and page lengths also */
      262 		pci.lmarg = 0;
      263 		pci.page_length = pci.phys_page_length - pci.lpi;
      264 		go to SET_NEXT_MODE;
      265 
      266 SET_BOOLEAN_MODE (1):				/* noskip */
      267 		pci.overflow_off = mode_value.boolean_value;
      268 		go to SET_NEXT_MODE;
      269 
      270 SET_BOOLEAN_MODE (2):				/* single */
      271 		pci.single_space = mode_value.boolean_value;
      272 		go to SET_NEXT_MODE;
      273 
      274 SET_BOOLEAN_MODE (3):				/* non_edited */
      275 		pci.non_edited = mode_value.boolean_value;
      276 		go to SET_NEXT_MODE;
      277 
      278 SET_BOOLEAN_MODE (4):				/* truncate */
      279 		pci.truncate = mode_value.boolean_value;
      280 		go to SET_NEXT_MODE;
      281 
      282 SET_BOOLEAN_MODE (5):				/* esc */
      283 		pci.esc = mode_value.boolean_value;
      284 		go to SET_NEXT_MODE;
      285 
      286 SET_BOOLEAN_MODE (6):				/* ctl_char */
      287 		pci.ctl_char = mode_value.boolean_value;
      288 		go to SET_NEXT_MODE;
      289 
      290 SET_BOOLEAN_MODE (7):				/* line_nbrs */
      291 	 	pci.line_nbrs = mode_value.boolean_value;
      292 		if pci.line_nbrs then do;		/* set */
      293 		     save_rmarg = pci.rmarg;
      294 		     pci.rmarg = min (pci.rmarg - 10, pci.phys_line_length -10 );
      295 		     pci.line_count = 1;
      296 		     pci.eol = "1"b;
      297 		     pci.eof = "0"b;
      298 		end;
      299 		else do;
      300 		     pci.rmarg = save_rmarg;
      301 		end;
      302 		go to SET_NEXT_MODE;
      303 
      304 SET_BOOLEAN_MODE (8):				/* 1pg */
      305 		if ios_interface then
      306 		     sdb.single_page = mode_value.boolean_value;
      307 		else ad.single_page = mode_value.boolean_value;
      308 		go to SET_NEXT_MODE;
      309 
      310 SET_BOOLEAN_MODE (9):				/* print: sets the noprint switch which is the inverse */
      311 		if ios_interface then
      312 		     sdb.noprint = ^mode_value.boolean_value;
      313 		else ad.noprint = ^mode_value.boolean_value;
      314 		go to SET_NEXT_MODE;
      315 
      316 SET_BOOLEAN_MODE (-1):				/* "^stop" is equivalent to "stop=0" */
      317 		mode_value.numeric_value = 0;
      318 SET_NUMERIC_MODE (1):				/* stop */
      319 		if ios_interface then do;
      320 		     sdb.stop_every = mode_value.numeric_value;
      321 		     sdb.stop_counter = 0;
      322 		end;
      323 		else do;
      324 		     ad.stop_every = mode_value.numeric_value;
      325 		     ad.stop_counter = 0;
      326 		end;
      327 		go to SET_NEXT_MODE;
      328 
      329 SET_BOOLEAN_MODE (-3):				/* "^indent" is equivalent to "indent=0" */
      330 SET_BOOLEAN_MODE (-2):				/* "^in" is equivalent to "in=0" */
      331 		mode_value.numeric_value = 0;
      332 SET_NUMERIC_MODE (2):				/* in */
      333 SET_NUMERIC_MODE (3):				/* indent */
      334 		pci.lmarg = mode_value.numeric_value;
      335 		go to SET_NEXT_MODE;
      336 
      337 SET_NUMERIC_MODE (4):				/* ll */
      338 		pci.rmarg = mode_value.numeric_value;
      339 		go to SET_NEXT_MODE;
      340 
      341 SET_NUMERIC_MODE (5):				/* pl */
      342 		pci.page_length = mode_value.numeric_value;
      343 		go to SET_NEXT_MODE;
      344 
      345 SET_NEXT_MODE:
      346 	     end;
      347 
      348 	     free mode_string_info in (system_area);	/* no longer need this data structure */
      349 	     mode_string_info_ptr = null ();
      350 	end;
      351 
      352 
      353 /* Insure consistency in the prt_conv_info data structure given the new mode settings */
      354 
      355 	pci.rmarg = min (pci.rmarg, pci.phys_line_length);/* insure that line is not too long */
      356 	if pci.lmarg >= pci.rmarg then do;		/* left margin must be to left of right margin */
      357 	     code = error_table_$inconsistent;
      358 	     if length (P_old_modes) > 0 then		/* only return something if there's some room */
      359 		call ioa_$rsnnl ("ll=^d,indent=^d.", P_old_modes, old_modes_lth, pci.rmarg, pci.lmarg);
      360 	     goto ERROR_RETURN;
      361 	end;
      362 
      363 	if pci.overflow_off then do;
      364 	     pci.top_label_length,			/* "noskip" and page labels are inconsistent */
      365 		pci.bot_label_length = 0;
      366 	     pci.sheets_per_page = 1;			/* one sheet per page in noskip mode */
      367 	     pci.page_length = pci.phys_page_length - pci.lpi;
      368 						/* reset logical page length */
      369 	end;
      370 
      371 	else					/* if "^noskip" mode ... */
      372 	     pci.sheets_per_page =
      373 		divide (pci.page_length + pci.lpi - 1 + pci.phys_page_length, pci.phys_page_length, 17, 0);
      374 						/* compute physical sheets of paper per page */
      375 
      376 	return;
      377 
      378 
      379 /* Error returns */
      380 
      381 BAD_MODE_VALUE:
      382 	code = error_table_$bad_mode;
      383 
      384 
      385 ERROR_RETURN:
      386 	if mode_string_info_ptr ^= null () then free mode_string_info in (system_area);
      387 
      388 	if ios_interface then
      389 	     substr (P_iostatus, 1, 36) = unspec (code);
      390 	else P_code = code;
      391 
      392 	return;
      393 
      394 /**/
      395 
  1     1 /* BEGIN INCLUDE FILE ... prt_sdb.incl.pl1 */
  1     2 /* Note: there is a corresponding prt_sdb.incl.alm */
  1     3 
  1     4 /* Created 10/28/74 by Noel I. Morris	*/
  1     5 /* Modified 3/15/77 by Noel I. Morris	*/
  1     6 /* Modified 1/25/78 by J. C. Whitmore to merge prtdim and spooling_dim versions */
  1     7 /* Modified: 27 November 1981 by G. Palter to add reload_vfc_train_after_special flag */
  1     8 /* Modified: 16 August 1983 by E. N. Kittlitz for new printer dim */
  1     9 
  1    10 dcl  sdb_ptr ptr;					/* pointer to stream data block */
  1    11 
  1    12 dcl 1 sdb aligned based (sdb_ptr),			/* printer stream data block */
  1    13     2 outer_module_name char (32) aligned,
  1    14     2 device_name_list_ptr pointer,
  1    15     2 device_name,
  1    16       3 next_device_ptr pointer,
  1    17       3 name_size fixed bin (17),
  1    18       3 name char (32) aligned,
  1    19     2 ev_list aligned,				/* Event list for ipc_ */
  1    20       3 count fixed bin (17),				/* Event count = Always one */
  1    21       3 evchan fixed bin (71),			/* Event channel name */
  1    22     2 stream_name char (32),				/* stream name of this attachment */
  1    23     2 areap ptr,					/* pointer to system free area */
  1    24     2 info like prt_info aligned,			/* printer info */
  1    25     2 conv_info like pci aligned,			/* conversion info */
  1    26     2 chars_printed fixed bin (35),			/* input chars processed since "reset" */
  1    27     2 stop_every fixed bin,				/* non-zero to stop after number of pages */
  1    28     2 stop_counter fixed bin,				/* page stop counter */
  1    29     2 mode,					/* additional modes */
  1    30      (3 single_page bit (1),				/* "1"b to stop after each page */
  1    31       3 noprint bit (1),				/* "1"b to suppress printing */
  1    32       3 pad bit (34)) unal,
  1    33     2 rcp_id bit (36),				/* RCP attachment ID */
  1    34     2 wsegp ptr,					/* pointer to IOI working segment */
  1    35     2 running bit (1),				/* "1"b if channel running */
  1    36     2 bgin fixed bin (18),				/* index to oldest print line */
  1    37     2 stop fixed bin (18),				/* index to next print line */
  1    38     2 prev fixed bin (18),				/* index to previous print line */
  1    39     2 wait_flag bit (1) aligned,			/* non-zero if waiting for special */
  1    40     2 marker_count fixed bin,				/* counter for marker status insertion */
  1    41     2 paper_low bit (1) aligned,			/* "1"b if paper low */
  1    42     2 error_count fixed bin,				/* error counter */
  1    43     2 buffer_ptr ptr,				/* pointer to output buffer (spooler) */
  1    44     2 spool_info (56) fixed bin,			/* place to store spooling_info */
  1    45     2 reload_vfc_train_after_special bit (1) aligned,	/* "1"b if VFC/train images should be reloaded after next
  1    46*						   special interrupt */
  1    47     2 max_dcw_size fixed bin (12) uns unal,		/* max wordcount of dcw */
  1    48     2 max_dcws fixed bin (6) uns unal,			/* max dcws per idcw/buffer */
  1    49     2 n_dcws fixed bin (6) uns unal,			/* current limit of dcws/buffer */
  1    50     2 b_begin fixed bin (3) uns unal,			/* buffer index */
  1    51     2 b_stop fixed bin (3) uns unal,			/* likewise */
  1    52     2 max_buffers fixed bin (3) uns unal,		/* number of buffers allocated */
  1    53     2 n_buffers fixed bin (3) uns unal,			/* number of buffers in use now */
  1    54     2 data_begin fixed bin (18) uns unal,		/* first data word */
  1    55     2 data_end fixed bin (18) uns unal,			/* size of working space in words */
  1    56     2 status_ptr ptr unal,				/* ioi status area */
  1    57     2 flags aligned,
  1    58       3 aborting bit (1) unal,			/* next attempt to do i/o gets error and resets */
  1    59       3 eurc bit (1) unal,				/* true if we know we are using EURC */
  1    60       3 flags_pad bit (16) unal,
  1    61     2 version fixed bin unal,      
  1    62     2 status_table ptr unal,				/* for analyze_device_stat_ */
  1    63     2 null_line_data bit (36) aligned,
  1    64     2 null_line_dcw bit (36) aligned,
  1    65     2 alarm_time fixed bin (71) unaligned;		/* current timer_manager_ limit */
  1    66 dcl  prt_bufferp ptr;
  1    67 
  1    68 dcl 1 prt_buffer aligned based (prt_bufferp),
  1    69     2 header,
  1    70       3 number fixed bin (6) uns unal,
  1    71       3 busy bit (1) unal,
  1    72       3 pad bit (4) unal,
  1    73       3 dcw_count fixed bin (7) uns unal,
  1    74       3 data_ends fixed bin (18) uns unal,
  1    75     2 idcw bit (36),
  1    76     2 ddcw (sdb.max_dcws + 1) bit (36) aligned;
  1    77 
  1    78 dcl  wseg (0:sdb.data_end - 1) bit (36) aligned based (sdb.wsegp);	/* the IOI buffer segment */
  1    79 dcl 1 prt_buffers (0:sdb.max_buffers - 1) aligned like prt_buffer based (sdb.wsegp);
  1    80 
  1    81 /* NOTE:	The Spooling_dim IO Module also uses this include file,
  1    82*	as it uses the printer stream also. If changes are made to this include file,
  1    83*	see to it that the changes are also reflected in the Spooling_dim procedures.
  1    84*	The spooling_dim uses the standard printer_dim order and changemode procedures.
  1    85*	JCW 1/25/78  */
  1    86 
  1    87 /* END INCLUDE FILE ... prt_sdb.incl.pl1 */
      396 
      397 
  2     1 
  2     2 /* Begin include file ...... prt_info.incl.pl1 */
  2     3 /* last modified 6/12/75 by Noel I. Morris	*/
  2     4 
  2     5 dcl  pip ptr;					/* pointer to printer info structure */
  2     6 
  2     7 dcl 1 prt_info based (pip) aligned,			/* printer info structure */
  2     8     2 devname char (4),				/* name of device */
  2     9     2 devx fixed bin,				/* device index */
  2    10     2 model fixed bin,				/* printer model number */
  2    11     2 type fixed bin,				/* printer type number */
  2    12     2 train fixed bin,				/* print train ID */
  2    13     2 line_length fixed bin,				/* max length of printed line */
  2    14     2 print_idcw bit (36),				/* IDCW to print 1 line */
  2    15     2 term_idcw bit (36);				/* IDCW to stop printer channel */
  2    16 
  2    17 /* End of include file ...... prt_info.incl.pl1 */
  2    18 
      398 
      399 
  3     1 
  3     2 /* BEGIN INCLUDE FILE ... prt_conv_info.incl.pl1 */
  3     3 /* Modified: 12 September 1980 by G. Palter */
  3     4 
  3     5 
  3     6 /****^  HISTORY COMMENTS:
  3     7*  1) change(87-05-10,Gilcrease), approve(87-07-31,MCR7686),
  3     8*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  3     9*     Add modes.line_nbrs, flags.(eol eof)  bits for eor -nb.
  3    10*                                                   END HISTORY COMMENTS */
  3    11 
  3    12 
  3    13 dcl  pcip ptr;					/* pointer to conversion info structure */
  3    14 
  3    15 dcl 1 pci based (pcip) aligned,			/* printer conversion info structure */
  3    16     2 cv_proc ptr,					/* pointer to character conversion procedure */
  3    17     2 lmarg fixed bin,				/* left margin indentation */
  3    18     2 rmarg fixed bin,				/* right margin limit */
  3    19     2 page_length fixed bin,				/* number of lines on page */
  3    20     2 phys_line_length fixed bin,			/* physical width of paper */
  3    21     2 phys_page_length fixed bin,			/* physical length of paper */
  3    22     2 lpi fixed bin,				/* lines per inch */
  3    23     2 sheets_per_page fixed bin,			/* sheets of paper per logical page */
  3    24     2 line_count fixed bin,				/* count of converted lines */
  3    25     2 page_count fixed bin,				/* count of converted pages */
  3    26     2 func fixed bin,				/* special conversion function */
  3    27 						/* 0 => normal conversion */
  3    28 						/* 1 => change NL to FF */
  3    29 						/* 2 => change NL to top inside page */
  3    30 						/* 3 => change NL to end of page */
  3    31                                                             /* 4 => change NL to top of outside page */
  3    32     (2 modes,					/* conversion modes */
  3    33      3 overflow_off bit (1),				/* "1"b to suppress end of page overflow */
  3    34       3 single_space bit (1),				/* "1"b to change all forms advance chars to NL */
  3    35       3 non_edited bit (1),				/* "1"b to print ASCII control chars */
  3    36       3 truncate bit (1),				/* "1"b to truncate lines that are too long */
  3    37       3 esc bit (1),				/* "1"b to process ESC character */
  3    38       3 ctl_char bit (1),				/* "1"b to output control characters */
  3    39       3 line_nbrs bit (1),				/* "1"b to output line numbers */
  3    40       3 pci_pad bit (5),
  3    41     2 flags,					/* flags internal to prt_conv_ */
  3    42       3 ignore_next_ff bit (1),			/* ON => prt_conv_ just output a FF; ignore next character if
  3    43*						   it's a FF */
  3    44       3 eol bit (1),				/* "1"b = end-of-line encountered */
  3    45       3 eof bit (1),				/* "1"b = end-of-segment encountered */
  3    46       3 flags_pad bit (3),
  3    47     2 coroutine_modes,
  3    48       3 upper_case bit(1),				/* "1"b to convert to upper case */
  3    49       3 ht bit(1),					/* "1"b to skip tab conversion */
  3    50       3 coroutine_pad bit(13),
  3    51       3 slew_table_idx bit(3) ) unal,			/* slew table index */
  3    52     2 top_label_line char (136),			/* contains an optional top of page label */
  3    53     2 bot_label_line char (136),			/* contains an optional bottom of page label */
  3    54     2 top_label_length fixed bin,			/* length of top label line */
  3    55     2 bot_label_length fixed bin,			/* length of bottom label line */
  3    56     2 form_stops (256) unal,				/* logical form stops */
  3    57       3 lbits bit (9),				/* leftmost bits */
  3    58       3 rbits bit (9),				/* rightmost bits */
  3    59 
  3    60 /* The following items are for internal use by the print conversion procedure.
  3    61*   They should be zeroed once and then never referenced again.		*/
  3    62 
  3    63     2 level fixed bin,				/* overstrike level */
  3    64     2 pos fixed bin,				/* print position at end of incomplete line */
  3    65     2 line fixed bin,				/* current line number */
  3    66     2 slew_residue fixed bin,				/* number of lines remaining to be slewed */
  3    67     2 label_nelem fixed bin,				/* characters remaining in label */
  3    68     2 label_wksp ptr,				/* pointer to label being processed */
  3    69     2 sav_pos fixed bin,				/* position saved during label processing */
  3    70     2 esc_state fixed bin,				/* state of ESC processing */
  3    71     2 esc_num fixed bin,				/* number following ESC sequence */
  3    72     2 temp bit (36);				/* conversion proc temporary */
  3    73 
  3    74 /* End of include file ...... prt_conv_info.incl.pl1 */
  3    75 
      400 
      401 
  4     1 /* BEGIN INCLUDE FILE ... remote_attach_data.incl.pl1 ... 3/77 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-06-07,Brunelle), approve(88-06-07,MCR7911),
  4     7*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4     8*     Model field and static overstrike_data_ptr added for laser printer
  4     9*     support.
  4    10*                                                   END HISTORY COMMENTS */
  4    11 
  4    12 
  4    13 /* format: style4 */
  4    14 
  4    15 dcl  adp ptr;					/* local copy of pointer to attach data */
  4    16 
  4    17 dcl  1 ad aligned based (adp),
  4    18        2 fixed,
  4    19          3 runout_spacing fixed bin,
  4    20          3 stop_every fixed bin,			/* stop every n pages of printing */
  4    21          3 stop_counter fixed bin,
  4    22          3 char_mode fixed bin,
  4    23          3 record_len fixed bin,			/* length of output record in characters */
  4    24          3 line_length fixed bin,			/* length of printer line */
  4    25          3 chars_printed fixed bin (35),		/* input chars processed since "reset" order */
  4    26          3 device_type fixed bin,			/* terminal_io_record device_type code for this attachment
  4    27*						   (See terminal_io_record.incl.pl1) */
  4    28          3 fb_pad fixed bin,
  4    29        2 bits,
  4    30          3 binary bit (1) unal,
  4    31          3 record_io bit (1) unal,			/* TRUE - if the iox_ record interface to terminal is used */
  4    32          3 other_bits_padded bit (34) unal,
  4    33          3 output_modes,
  4    34 	 4 single_page bit (1) unal,
  4    35 	 4 noprint bit (1) unal,			/* if on don't print */
  4    36 	 4 pad bit (34) unal,
  4    37          3 transparent bit (1),			/* Set if in transparent mode */
  4    38          3 input_modes bit (36),
  4    39        2 ptrs,
  4    40          3 terminal_iocbp ptr,			/* iocb ptr  to terminal dim  */
  4    41          3 static_overstrike_data_ptr ptr,		/* ptr to overstrike_data */
  4    42        2 chars,
  4    43          3 terminal char (32) var,
  4    44          3 attach_desc char (256) var,
  4    45          3 open_description char (24) var,
  4    46          3 model char (32) var,
  4    47        2 info like prt_info aligned,
  4    48        2 remote_pci like pci aligned;
  4    49 
  4    50 
  4    51 /* END INCLUDE FILE ... remote_attach_data.incl.pl1 */
      402 
      403 
  5     1 /* BEGIN INCLUDE FILE ..... iocb.incl.pl1 ..... 13 Feb 1975, M. Asherman */
  5     2 /* Modified 11/29/82 by S. Krupp to add new entries and to change
  5     3*      version number to IOX2. */
  5     4 /* format: style2 */
  5     5 
  5     6      dcl	   1 iocb		      aligned based,	/* I/O control block. */
  5     7 	     2 version	      character (4) aligned,	/* IOX2 */
  5     8 	     2 name	      char (32),		/* I/O name of this block. */
  5     9 	     2 actual_iocb_ptr    ptr,		/* IOCB ultimately SYNed to. */
  5    10 	     2 attach_descrip_ptr ptr,		/* Ptr to printable attach description. */
  5    11 	     2 attach_data_ptr    ptr,		/* Ptr to attach data structure. */
  5    12 	     2 open_descrip_ptr   ptr,		/* Ptr to printable open description. */
  5    13 	     2 open_data_ptr      ptr,		/* Ptr to open data structure (old SDB). */
  5    14 	     2 reserved	      bit (72),		/* Reserved for future use. */
  5    15 	     2 detach_iocb	      entry (ptr, fixed (35)),/* detach_iocb(p,s) */
  5    16 	     2 open	      entry (ptr, fixed, bit (1) aligned, fixed (35)),
  5    17 						/* open(p,mode,not_used,s) */
  5    18 	     2 close	      entry (ptr, fixed (35)),/* close(p,s) */
  5    19 	     2 get_line	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    20 						/* get_line(p,bufptr,buflen,actlen,s) */
  5    21 	     2 get_chars	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    22 						/* get_chars(p,bufptr,buflen,actlen,s) */
  5    23 	     2 put_chars	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    24 						/* put_chars(p,bufptr,buflen,s) */
  5    25 	     2 modes	      entry (ptr, char (*), char (*), fixed (35)),
  5    26 						/* modes(p,newmode,oldmode,s) */
  5    27 	     2 position	      entry (ptr, fixed, fixed (21), fixed (35)),
  5    28 						/* position(p,u1,u2,s) */
  5    29 	     2 control	      entry (ptr, char (*), ptr, fixed (35)),
  5    30 						/* control(p,order,infptr,s) */
  5    31 	     2 read_record	      entry (ptr, ptr, fixed (21), fixed (21), fixed (35)),
  5    32 						/* read_record(p,bufptr,buflen,actlen,s) */
  5    33 	     2 write_record	      entry (ptr, ptr, fixed (21), fixed (35)),
  5    34 						/* write_record(p,bufptr,buflen,s) */
  5    35 	     2 rewrite_record     entry (ptr, ptr, fixed (21), fixed (35)),
  5    36 						/* rewrite_record(p,bufptr,buflen,s) */
  5    37 	     2 delete_record      entry (ptr, fixed (35)),/* delete_record(p,s) */
  5    38 	     2 seek_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    39 						/* seek_key(p,key,len,s) */
  5    40 	     2 read_key	      entry (ptr, char (256) varying, fixed (21), fixed (35)),
  5    41 						/* read_key(p,key,len,s) */
  5    42 	     2 read_length	      entry (ptr, fixed (21), fixed (35)),
  5    43 						/* read_length(p,len,s) */
  5    44 	     2 open_file	      entry (ptr, fixed bin, char (*), bit (1) aligned, fixed bin (35)),
  5    45 						/* open_file(p,mode,desc,not_used,s) */
  5    46 	     2 close_file	      entry (ptr, char (*), fixed bin (35)),
  5    47 						/* close_file(p,desc,s) */
  5    48 	     2 detach	      entry (ptr, char (*), fixed bin (35));
  5    49 						/* detach(p,desc,s) */
  5    50 
  5    51      declare iox_$iocb_version_sentinel
  5    52 			      character (4) aligned external static;
  5    53 
  5    54 /* END INCLUDE FILE ..... iocb.incl.pl1 ..... */
      404 
      405 
  6     1 /*  BEGIN INCLUDE FILE   mode_string_info.incl.pl1							*/
  6     2 
  6     3 /* Structure for parse_mode_string_ JRDavis 20 October 1980
  6     4*   Last modified 12 January 1981 by J. Spencer Love for version 2, make char_value varying string */
  6     5 
  6     6 declare	mode_value_ptr		ptr,
  6     7 	number_of_modes		fixed bin;
  6     8 
  6     9 declare	1 mode_string_info		aligned based (mode_string_info_ptr),
  6    10 	  2 version		fixed bin,
  6    11 	  2 number		fixed bin,
  6    12 	  2 modes			(number_of_modes refer (mode_string_info.number)) like mode_value;
  6    13 
  6    14 declare	mode_string_info_ptr	ptr;
  6    15 
  6    16 declare	1 mode_value		aligned based (mode_value_ptr),
  6    17 	  2 version		fixed bin,
  6    18 	  2 mode_name		char (32) unaligned,
  6    19 	  2 flags,
  6    20 	    3 boolean_valuep	bit (1) unaligned,
  6    21 	    3 numeric_valuep	bit (1) unaligned,
  6    22 	    3 char_valuep		bit (1) unaligned,
  6    23 	    3 boolean_value		bit (1) unaligned,
  6    24 	    3 pad1		bit (32) unaligned,
  6    25 	  2 numeric_value		fixed bin (35),
  6    26 	  2 char_value		char (32) varying,
  6    27 	  2 code			fixed bin (35),
  6    28 	  2 pad2			bit (36);
  6    29 
  6    30 declare	mode_string_info_version_2	fixed bin static options (constant) initial (2),
  6    31 	mode_value_version_3	fixed bin static options (constant) initial (3);
  6    32 
  6    33 /* END INCLUDE FILE   mode_string_info.incl.pl1								*/
      406 
      407 
      408      end prtdim_changemode;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/28/88  1256.6  prtdim_changemode.pl1             >special_ldd>install>MR12.2-1199>prtdim_changemode.pl1
396          1    11/04/83  1107.6  prt_sdb.incl.pl1                  >ldd>include>prt_sdb.incl.pl1
398          2    08/29/75  1310.5  prt_info.incl.pl1                 >ldd>include>prt_info.incl.pl1
400          3    02/04/88  2009.3  prt_conv_info.incl.pl1            >ldd>include>prt_conv_info.incl.pl1
402          4    10/28/88  1226.7  remote_attach_data.incl.pl1       >special_ldd>install>MR12.2-1199>remote_attach_data.incl.pl1
404          5    05/20/83  1846.4  iocb.incl.pl1                     >ldd>include>iocb.incl.pl1
406          6    03/19/81  1206.8  mode_string_info.incl.pl1         >ldd>include>mode_string_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
BOOLEAN_MODE_NAMES              000104 constant        char(32)                 initial array packed unaligned dcl 74 ref 189 189
                                                                                  190 223 223 224
NUMERIC_MODE_NAMES              000034 constant        char(32)                 initial array packed unaligned dcl 79 ref 205 205
                                                                                  206 235 235 236
NUMERIC_MODE_RANGES             000022 constant        fixed bin(17,0)          initial array dcl 82 ref 210 210
P_code                                 parameter       fixed bin(35,0)          dcl 49 set ref 119 124* 390*
P_iocb_ptr                             parameter       pointer                  dcl 48 ref 119 127
P_iostatus                             parameter       bit(72)                  dcl 46 set ref 36 107* 108* 388*
P_new_modes                            parameter       char                     packed unaligned dcl 42 set ref 36 119 175 177*
P_old_modes                            parameter       char                     packed unaligned dcl 43 set ref 36 119 157 158* 163
                                                                                  165 166 166* 168* 358 358*
P_sdb_ptr                              parameter       pointer                  dcl 45 ref 36 110
ad                                     based           structure                level 1 dcl 4-17
addr                                                   builtin function         dcl 97 ref 113 129 184 220
adp                             000130 automatic       pointer                  dcl 4-15 set ref 111* 127* 129 152 153 154 256 257
                                                                                  307 313 324 325
array_idx                       000112 automatic       fixed bin(17,0)          dcl 69 set ref 226* 229 238* 241
attach_data_ptr          16            based           pointer                  level 2 dcl 5-6 ref 127
bits                     11            based           structure                level 2 dcl 4-17
boolean_value            11(03)        based           bit(1)                   level 3 packed packed unaligned dcl 6-16 ref 193 195
                                                                                  197 199 247 266 270 274 278 282 286 290 304 307
                                                                                  310 313
boolean_valuep           11            based           bit(1)                   level 3 packed packed unaligned dcl 6-16 ref 187 221
bot_label_length        122            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 259* 364*
char_valuep              11(02)        based           bit(1)                   level 3 packed packed unaligned dcl 6-16 ref 185
cleanup                         000116 stack reference condition                dcl 99 ref 138
code                            000100 automatic       fixed bin(35,0)          dcl 54 set ref 177* 178 357* 381* 388 390
conv_info                54            based           structure                level 2 dcl 1-12 set ref 113
ctl_char                 14(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 286*
divide                                                 builtin function         dcl 97 ref 371
eof                      14(14)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  297*
eol                      14(13)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  296*
error_table_$bad_mode           000012 external static fixed bin(35,0)          dcl 90 ref 381
error_table_$inconsistent       000014 external static fixed bin(35,0)          dcl 91 ref 357
esc                      14(04)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 282*
fixed                                  based           structure                level 2 dcl 4-17
flags                    11            based           structure                level 2 in structure "mode_value" dcl 6-16
                                                                                  in procedure "prtdim_changemode"
flags                    14(12)        based           structure                level 2 in structure "pci" packed packed unaligned
                                                                                  dcl 3-15 in procedure "prtdim_changemode"
get_system_free_area_           000016 constant        entry                    external dcl 93 ref 134
hbound                                                 builtin function         dcl 97 ref 189 205 223 235
i                               000110 automatic       fixed bin(21,0)          dcl 67 set ref 165* 166 166
idx                             000113 automatic       fixed bin(17,0)          dcl 69 set ref 189* 190* 205* 206* 209* 209 210 210
                                                                                  223* 224 226* 235* 236 238*
index                                                  builtin function         dcl 97 ref 165
ioa_$rsnnl                      000020 constant        entry                    external dcl 94 ref 158 358
iocb                                   based           structure                level 1 dcl 5-6
ios_interface                   000101 automatic       bit(1)                   dcl 59 set ref 105* 122* 146 251 304 310 318 388
lbound                                                 builtin function         dcl 97 ref 189 205 223 235
legal_mode                      000114 automatic       bit(1)                   dcl 70 set ref 188* 189 190* 192 204* 205 206* 208
                                                                                  222* 223 225* 229 234* 235 237* 241
length                                                 builtin function         dcl 97 ref 157 163 166 175 358
line_count               11            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 295*
line_nbrs                14(06)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 290* 292
lmarg                     2            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 158* 262* 332* 356 358*
lpi                       7            based           fixed bin(17,0)          level 2 dcl 3-15 ref 263 367 371
min                                                    builtin function         dcl 97 ref 294 355
mode                    415            based           structure                level 2 dcl 1-12 set ref 252*
mode_idx                        000111 automatic       fixed bin(17,0)          dcl 69 set ref 183* 184* 219* 220*
mode_name                 1            based           char(32)                 level 2 packed packed unaligned dcl 6-16 ref 190 193
                                                                                  195 197 199 206 224 236
mode_string_$parse              000022 constant        entry                    external dcl 95 ref 177
mode_string_info                       based           structure                level 1 dcl 6-9 set ref 140 348 385
mode_string_info_ptr            000134 automatic       pointer                  dcl 6-14 set ref 136* 140 140 177* 183 184 219 220
                                                                                  348 349* 385 385
mode_value                             based           structure                level 1 dcl 6-16
mode_value_ptr                  000132 automatic       pointer                  dcl 6-6 set ref 184* 185 187 190 193 193 195 195 197
                                                                                  197 199 199 206 210 210 220* 221 224 236 247 266
                                                                                  270 274 278 282 286 290 304 307 310 313 316 320
                                                                                  324 329 332 337 341
modes                     2            based           structure                array level 2 in structure "mode_string_info"
                                                                                  dcl 6-9 in procedure "prtdim_changemode" set ref
                                                                                  184 220
modes                    14            based           structure                level 2 in structure "pci" packed packed unaligned
                                                                                  dcl 3-15 in procedure "prtdim_changemode" set ref
                                                                                  250*
non_edited               14(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 274*
noprint                  12(01)        based           bit(1)                   level 4 in structure "ad" packed packed unaligned
                                                                                  dcl 4-17 in procedure "prtdim_changemode" set ref
                                                                                  153 313*
noprint                 415(01)        based           bit(1)                   level 3 in structure "sdb" packed packed unaligned
                                                                                  dcl 1-12 in procedure "prtdim_changemode" set ref
                                                                                  148 310*
null                                                   builtin function         dcl 97 ref 111 126 136 140 349 385
number                    1            based           fixed bin(17,0)          level 2 dcl 6-9 ref 140 183 219 348 385
numeric_value            12            based           fixed bin(35,0)          level 2 dcl 6-16 set ref 210 210 316* 320 324 329*
                                                                                  332 337 341
old_modes_lth                   000107 automatic       fixed bin(21,0)          dcl 66 set ref 158* 163 358*
output_modes             12            based           structure                level 3 dcl 4-17 set ref 256*
overflow_off             14            based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 266* 363
page_length               4            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 158* 263* 341* 367* 371
pci                                    based           structure                level 1 dcl 3-15
pcip                            000126 automatic       pointer                  dcl 3-13 set ref 113* 129* 158 158 158 158 158 158
                                                                                  158 158 158 158 250 259 259 261 261 262 263 263
                                                                                  263 266 270 274 278 282 286 290 292 293 294 294
                                                                                  294 295 296 297 300 332 337 341 355 355 355 356
                                                                                  356 358 358 363 364 364 366 367 367 367 371 371
                                                                                  371 371 371
phys_line_length          5            based           fixed bin(17,0)          level 2 dcl 3-15 ref 261 294 355
phys_page_length          6            based           fixed bin(17,0)          level 2 dcl 3-15 ref 263 367 371 371
print_bit                       000105 automatic       bit(1)                   dcl 64 set ref 148* 153* 158*
prt_buffer                             based           structure                level 1 dcl 1-68
prt_info                               based           structure                level 1 dcl 2-7
remote_pci              164            based           structure                level 2 dcl 4-17 set ref 129
reverse                                                builtin function         dcl 97 ref 165
rmarg                     3            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 158* 261* 293 294* 294 300*
                                                                                  337* 355* 355 356 358*
rtrim                                                  builtin function         dcl 97 ref 175
save_rmarg                      000010 internal static fixed bin(17,0)          dcl 73 set ref 293* 300
sdb                                    based           structure                level 1 dcl 1-12
sdb_ptr                         000124 automatic       pointer                  dcl 1-10 set ref 110* 113 126* 147 148 149 252 253
                                                                                  304 310 320 321
sheets_per_page          10            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 366* 371*
single_page             415            based           bit(1)                   level 3 in structure "sdb" packed packed unaligned
                                                                                  dcl 1-12 in procedure "prtdim_changemode" set ref
                                                                                  147 304*
single_page              12            based           bit(1)                   level 4 in structure "ad" packed packed unaligned
                                                                                  dcl 4-17 in procedure "prtdim_changemode" set ref
                                                                                  152 307*
single_page_bit                 000104 automatic       bit(1)                   dcl 64 set ref 147* 152* 158*
single_space             14(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 270*
stop_counter            414            based           fixed bin(17,0)          level 2 in structure "sdb" dcl 1-12 in procedure
                                                                                  "prtdim_changemode" set ref 321*
stop_counter              2            based           fixed bin(17,0)          level 3 in structure "ad" dcl 4-17 in procedure
                                                                                  "prtdim_changemode" set ref 325*
stop_every                1            based           fixed bin(17,0)          level 3 in structure "ad" dcl 4-17 in procedure
                                                                                  "prtdim_changemode" set ref 154 257* 324*
stop_every              413            based           fixed bin(17,0)          level 2 in structure "sdb" dcl 1-12 in procedure
                                                                                  "prtdim_changemode" set ref 149 253* 320*
stop_every_value                000106 automatic       fixed bin(17,0)          dcl 65 set ref 149* 154* 158*
substr                                                 builtin function         dcl 97 set ref 108* 166* 388*
system_area                            based           area(1024)               dcl 61 ref 140 348 385
system_area_ptr                 000102 automatic       pointer                  dcl 62 set ref 134* 140 177* 348 385
top_label_length        121            based           fixed bin(17,0)          level 2 dcl 3-15 set ref 259* 364*
truncate                 14(03)        based           bit(1)                   level 3 packed packed unaligned dcl 3-15 set ref
                                                                                  158* 278*
unspec                                                 builtin function         dcl 97 ref 388

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
iox_$iocb_version_sentinel             external static char(4)                  dcl 5-51
mode_string_info_version_2             internal static fixed bin(17,0)          initial dcl 6-30
mode_value_version_3                   internal static fixed bin(17,0)          initial dcl 6-30
number_of_modes                        automatic       fixed bin(17,0)          dcl 6-6
pip                                    automatic       pointer                  dcl 2-5
prt_bufferp                            automatic       pointer                  dcl 1-66
prt_buffers                            based           structure                array level 1 dcl 1-79
wseg                                   based           bit(36)                  array dcl 1-78

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_MODE_VALUE                  001700 constant        label                    dcl 381 ref 185 192 193 195 197 199 208 210 231 243
                                                                                  245 247
COMMON                          000467 constant        label                    dcl 134 ref 114
ERROR_RETURN                    001703 constant        label                    dcl 385 ref 178 360
SET_BOOLEAN_MODE                000000 constant        label                    array(-3:9) dcl 247 ref 229
SET_NEXT_MODE                   001571 constant        label                    dcl 345 ref 264 268 272 276 280 284 288 302 308 314
                                                                                  327 335 339 343
SET_NUMERIC_MODE                000015 constant        label                    array(5) dcl 318 ref 241
prtdim_changemode               000366 constant        entry                    external dcl 36
remote_printer_modes_           000434 constant        entry                    external dcl 119

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2062        2106    1742        2072
Length      2420    1742        24         276     117           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
prtdim_changemode                   212 external procedure  is an external procedure.  
on unit on line 138                  64 on unit               

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 save_rmarg                  prtdim_changemode

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
prtdim_changemode        000100 code                        prtdim_changemode
                         000101 ios_interface               prtdim_changemode
                         000102 system_area_ptr             prtdim_changemode
                         000104 single_page_bit             prtdim_changemode
                         000105 print_bit                   prtdim_changemode
                         000106 stop_every_value            prtdim_changemode
                         000107 old_modes_lth               prtdim_changemode
                         000110 i                           prtdim_changemode
                         000111 mode_idx                    prtdim_changemode
                         000112 array_idx                   prtdim_changemode
                         000113 idx                         prtdim_changemode
                         000114 legal_mode                  prtdim_changemode
                         000124 sdb_ptr                     prtdim_changemode
                         000126 pcip                        prtdim_changemode
                         000130 adp                         prtdim_changemode
                         000132 mode_value_ptr              prtdim_changemode
                         000134 mode_string_info_ptr        prtdim_changemode

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          enable_op           ext_entry_desc      int_entry
op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
get_system_free_area_         ioa_$rsnnl                    mode_string_$parse

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_mode         error_table_$inconsistent




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     36 000361       105 000406       107 000410       108 000415       110 000417       111 000422       113 000424
    114 000426       119 000427       122 000454       124 000455       126 000457       127 000461       129 000465
    134 000467       136 000476       138 000500       140 000514       141 000527       146 000530       147 000532
    148 000536       149 000543       150 000545       152 000546       153 000552       154 000557       157 000561
    158 000563       163 000700       165 000703       166 000717       168 000732       175 000735       177 000752
    178 000777       183 001001       184 001011       185 001015       187 001020       188 001023       189 001024
    190 001033       191 001044       192 001046       193 001050       195 001063       197 001071       199 001077
    201 001105       204 001106       205 001107       206 001117       207 001130       208 001132       209 001134
    210 001136       214 001147       219 001151       220 001161       221 001165       222 001170       223 001171
    224 001201       225 001210       226 001212       228 001214       229 001216       231 001222       234 001223
    235 001224       236 001233       237 001242       238 001244       240 001246       241 001250       243 001254
    247 001255       250 001261       251 001302       252 001304       253 001313       254 001314       256 001315
    257 001324       259 001325       261 001327       262 001331       263 001332       264 001335       266 001336
    268 001345       270 001346       272 001355       274 001356       276 001365       278 001366       280 001374
    282 001375       284 001404       286 001405       288 001414       290 001415       292 001424       293 001427
    294 001432       295 001443       296 001445       297 001447       298 001451       300 001452       302 001455
    304 001456       307 001470       308 001477       310 001500       313 001515       314 001527       316 001530
    318 001532       320 001534       321 001540       322 001541       324 001542       325 001546       327 001547
    329 001550       332 001552       335 001556       337 001557       339 001563       341 001564       343 001570
    345 001571       348 001573       349 001601       355 001603       356 001611       357 001613       358 001616
    360 001655       363 001656       364 001661       366 001663       367 001665       369 001670       371 001671
    376 001677       381 001700       385 001703       388 001715       390 001723       392 001726


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
