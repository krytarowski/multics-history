	COMPILATION LISTING OF SEGMENT analyze_multics
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/05/86  1044.1 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 
        7 analyze_multics: azm: procedure () options (variable);
        8 
        9 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       10 
       11 /* Main procedure for Multics Online Analysis subsystem
       12*   09/07/80 W. Olin Sibert
       13*
       14*   Modified 06/23/83 by B. Braun to update user interface as per MTB-624
       15*
       16*   Modified 03 Nov 83 by B. Braun to fix reference thru null pointer when it 
       17*   encounters an unrecognized variable (phx16285).
       18*
       19*   Modified 22 Oct 84 by B. Braun to add the ssu_ standard requests info dir, and the azm version number.
       20*   Modified 27 Oct 84 by B. Braun to get rid of amu_arglist_ references as it was never used.
       21*   Modified 13 Nov 84 by B. Braun to fix the RQO handler (phx17544).
       22*   Modified 06 Dec 84 by B. Braun to call its start_up after initialization is complete. (phx18527).
       23**/
       24 
       25 dcl  abbrev_sw			bit (1);
       26 dcl  al				fixed bin (21);
       27 dcl  alp				pointer;
       28 dcl  amu_ptr			ptr;
       29 dcl  ap				pointer;
       30 dcl  arg				char (al) based (ap);
       31 dcl  argno			fixed bin;
       32 dcl  1 azm_info_automatic		aligned like azm_info automatic;
       33 dcl  code				fixed bin (35);
       34 dcl  cond_uid			bit(36) aligned;
       35 dcl  debug_sw			bit (1) aligned;
       36 dcl  dirname char(168);
       37 dcl  dn_lth fixed bin;
       38 dcl  ename char(32);
       39 dcl  i				fixed bin;
       40 dcl  info_dir			char (168);
       41 dcl  my_uid			bit(36) aligned;
       42 dcl  nargs			fixed bin;
       43 dcl  profile_len			fixed bin(21);
       44 dcl  profile_ptr			ptr;
       45 dcl  profile_str			char(profile_len) based(profile_ptr);
       46 dcl  prompt_len			fixed bin(21);
       47 dcl  prompt_ptr			ptr;
       48 dcl  prompt_string			char(prompt_len) based (prompt_ptr);
       49 dcl  quit_sw			bit (1);
       50 dcl  request_line			char(request_line_len) based (request_line_ptr);
       51 dcl  request_line_len		fixed bin(21);
       52 dcl  request_line_ptr		ptr;
       53 dcl  rq_sw			bit (1) aligned;
       54 dcl  startup_sw			bit(1);
       55 dcl  temp_ptr			ptr;
       56 dcl  where_ami_dir			char (168);
       57 dcl  where_ami_entry		char (32);
       58 dcl  where_ami_len			fixed bin;
       59 dcl  where_ami_ptr			ptr;
       60 dcl  why_sw			bit (1);
       61 dcl  sci_ptr			pointer;
       62 
       63 
       64 dcl  ssu_request_tables_$standard_requests
       65 				bit(36) aligned external;
       66 dcl ssu_info_directories_$standard_requests char (168) external;
       67 
       68 /* External Static */
       69 
       70 dcl  azm_request_table_$azm_request_table_ fixed bin external static;
       71 dcl  (
       72      error_table_$bad_arg,
       73      error_table_$badopt,
       74      error_table_$noarg,
       75      ssu_et_$null_request_line,
       76      ssu_et_$program_interrupt,
       77      ssu_et_$request_line_aborted,
       78      ssu_et_$subsystem_aborted
       79      ) fixed bin (35) external static;
       80 
       81 dcl  amu_$terminate_translation	entry (ptr),
       82      com_err_			entry options (variable),
       83      continue_to_signal_		entry (fixed bin (35)), 
       84      cu_$arg_count			entry (fixed bin, fixed bin (35)),
       85      cu_$arg_ptr			entry (fixed bin, pointer, fixed bin (21), fixed bin (35)),
       86      expand_pathname_$add_suffix	entry (char(*), char(*), char(*), char(*), fixed bin(35)),
       87      find_condition_frame_		entry (ptr) returns(ptr),
       88      hcs_$fs_get_path_name		entry (ptr, char (*), fixed bin, char (*), fixed bin (35)),
       89      hcs_$get_uid_seg		entry (ptr, bit(36) aligned, fixed bin(35)),
       90      hcs_$make_ptr			entry (ptr, char(*), char(*), ptr, fixed bin(35)),
       91      initiate_file_			entry (char(*), char(*), bit(*), ptr, fixed bin(24), fixed bin(35)),
       92      ioa_				entry () options (variable),
       93      ioa_$nnl			entry() options(variable),
       94      ssu_$add_info_dir		entry (ptr, char(*), fixed bin, fixed bin(35)),
       95      ssu_$add_request_table		entry (ptr, ptr, fixed bin, fixed bin(35)),
       96      ssu_$create_invocation		entry (char (*), char (*), pointer, pointer, char (*), pointer, fixed bin (35)),
       97      ssu_$destroy_invocation		entry (pointer),
       98      ssu_$execute_line		entry (ptr, ptr, fixed bin (21), fixed bin (35)),
       99      ssu_$execute_start_up		entry () options (variable),
      100      ssu_$get_area			entry (ptr, ptr, char(*), ptr),
      101      ssu_$get_default_rp_options	entry (ptr, char(8), ptr, fixed bin(35)),
      102      ssu_$listen			entry (pointer, pointer, fixed bin (35)),
      103      ssu_$set_debug_mode		entry (ptr, bit(1) aligned),
      104      ssu_$set_ec_suffix		entry (ptr, char(32)),
      105      ssu_$set_info_ptr		entry (pointer, pointer),
      106      ssu_$set_prompt		entry (pointer, char (*) varying),
      107      ssu_$set_prompt_mode		entry (ptr, bit(*)),
      108      ssu_$set_request_processor_options
      109 				entry (ptr, ptr, fixed bin(35));
      110 
      111 /* Internal Static */
      112 
      113 dcl (False			bit(1) init("0"b),
      114      True				bit(1) init("1"b)) int static options(constant);
      115 dcl  WHOAMI			char (32) internal static options (constant) init ("analyze_multics");
      116 dcl  CURRENT_VERSION		char(4) init ("2.3 ") int static options(constant);
      117 
      118 /* Condition Handlers */
      119 
      120 dcl  (cleanup, record_quota_overflow)	condition;
      121 
      122 
      123 /*  Builtins */
      124 
      125 dcl  (addr, codeptr, index, 
      126       null, pointer, reverse, rtrim,
      127       substr, unspec)		builtin;
      128 
      129 
      130     where_ami_ptr, amu_ptr, sci_ptr, azm_info_ptr, amu_info_ptr, profile_ptr, request_line_ptr, prompt_ptr = null ();
      131     abbrev_sw, debug_sw, startup_sw, why_sw, quit_sw = "0"b;
      132     prompt_len = -1;
      133     profile_len, request_line_len, where_ami_len = 0;
      134 
      135     code = 0;					/* KLUDGE, because new version of cu_$arg_count not here yet. */
      136 
      137     on condition (cleanup)
      138        begin;
      139           call clean_up();
      140        end;
      141 
      142     on condition (record_quota_overflow)
      143        begin;
      144        /* Did azm signal this?  */
      145        sp = find_condition_frame_ (null());
      146        code = 0;
      147 						/* get UID of owner of condition frame	*/
      148        call hcs_$get_uid_seg(sp->stack_frame.entry_ptr, cond_uid, code);
      149        if code ^= 0 then do;
      150 	call continue_to_signal_(code);
      151 	return;
      152 	end;       
      153 						/* get UID of me				*/
      154        where_ami_ptr = codeptr (analyze_multics);
      155        call hcs_$get_uid_seg(where_ami_ptr, my_uid, code);
      156        if code ^= 0 then do;
      157 	call continue_to_signal_(code);
      158 	return;
      159 	end;       
      160 
      161        if cond_uid ^=  my_uid then do;		/* Not ours to handle			*/
      162 					/* But it is ours if signaled by amu_			*/
      163 					/* get ptr to amu_					*/
      164           call hcs_$make_ptr (null(), "amu_", "", amu_ptr, code);
      165           if amu_ptr = null() then do;
      166 	   call continue_to_signal_(code);
      167 	   return;
      168 	   end;       
      169           call hcs_$get_uid_seg(amu_ptr, my_uid, code);	/* Get UID of amu_				*/
      170           if code ^= 0 then do;
      171 	   call continue_to_signal_(code);
      172 	   return;
      173 	   end;       
      174 	if cond_uid ^=  my_uid then do;		/* Not ours to handle			*/
      175 	   call continue_to_signal_(code);
      176 	   return;
      177 	   end;       
      178           end;
      179 
      180        /* We called it, We'll handle it */
      181 
      182        call ioa_$nnl ("Record_quota_overflow:^2x");
      183        if azm_info_ptr = null () then do;
      184 	/* ok time to punt */
      185 	call ioa_ ();
      186 	call continue_to_signal_ (code);
      187 	end;
      188        amu_info_ptr = azm_info_automatic.aip;
      189        temp_ptr = null;
      190        if amu_info_ptr ^= null () then do;
      191 	/* is current the first */
      192 	if amu_info.chain.prev = null () then do;
      193 	   /* is there a second */
      194 	   if amu_info.chain.next ^= null () then do;
      195 	      /* ok try this one */
      196 	      temp_ptr = amu_info_ptr;
      197 	      amu_info_ptr = amu_info.chain.next;
      198 	      end;
      199 	   else do;
      200 	      /* we are realy out of luck */
      201 	      call continue_to_signal_ (code);
      202 	      end;
      203 	   end;
      204           else do;
      205 	   /* find the first */
      206 	   temp_ptr = amu_info_ptr;
      207 	   do while (temp_ptr -> amu_info.chain.prev ^= null ());
      208 	      temp_ptr = temp_ptr -> amu_info.chain.prev;
      209 	      end;
      210 	   amu_info_ptr = temp_ptr;
      211 	   temp_ptr = null;
      212 	   end;
      213 	if amu_info.type = FDUMP_PROCESS_TYPE then 
      214 	   call ioa_ ("Will try deleting ERF ^a and continue...",fdump_info.erf_name);
      215 	else call ioa_ ("Deleting SAVE_PROC");
      216 	call amu_$terminate_translation (amu_info_ptr);
      217 
      218 	if amu_info_ptr = null () then call continue_to_signal_ (code);
      219 	end;
      220        end;
      221 /* end record_quota_overflow condition */     
      222 
      223     call cu_$arg_count (nargs, code);
      224     if code ^= 0 then do;
      225        call com_err_ (code, WHOAMI);
      226        return;
      227        end;
      228 
      229     do argno = 1 to nargs;
      230        call cu_$arg_ptr (argno, ap, al, (0));
      231        if arg = "-request" | arg = "-rq" then do;
      232           call get_next_arg("request line", request_line_ptr, request_line_len);
      233           rq_sw = True;
      234           end;
      235 
      236        else if arg = "-profile" | arg = "-pf" then do;
      237 	call get_next_arg ("profile path", profile_ptr, profile_len);
      238           call expand_pathname_$add_suffix(profile_str,"profile",dirname,ename,code);
      239 	if code ^= 0 then call report_error(code, "^a",profile_str,"");
      240 	call initiate_file_ (dirname, ename, R_ACCESS,  profile_ptr, (0), code);
      241 	if profile_ptr = null() then do;
      242              call com_err_(code, WHOAMI, " -profile ^a^[>^]^a ", dirname, ename^=">", ename);
      243 	   goto AZM_RETURN;
      244 	   end;
      245 	abbrev_sw = True;
      246 	end;
      247 
      248        else if arg = "-ab" | arg = "-abbrev" then do;
      249 	abbrev_sw = True;
      250 	end;
      251 
      252        else if arg = "-nab" | arg = "-no_abbrev" then do;
      253 	abbrev_sw = False;
      254 	end;
      255 
      256        else if arg = "-start_up" | arg = "-su" then do;
      257 	startup_sw  = True;
      258 	end;
      259 
      260        else if arg = "-nsu" | arg = "-no_start_up" then do;
      261 	startup_sw  = False;;
      262 	end;
      263 
      264        else if arg = "-prompt" then do;
      265 	call get_next_arg ("prompt string", prompt_ptr, prompt_len);
      266 	end;
      267 
      268        else if arg = "-no_prompt" then do;
      269 	prompt_len = 0;
      270           end;
      271 
      272        else if arg = "-db" | arg = "-debug" then debug_sw = "1"b;
      273        else if arg = "-ndb" | arg = "-no_debug" then debug_sw = "0"b;
      274        else if (arg = "-quit") then quit_sw = "1"b;
      275 
      276        else do;
      277           if char(arg,1) = "-" then code = error_table_$badopt;
      278 	else code = error_table_$bad_arg;
      279           call com_err_ (code, WHOAMI, "^a", arg);
      280 	goto AZM_RETURN;
      281 	end;
      282        end;						/* of loop through arguments */
      283 
      284 						/* azm_invocation_list */
      285     where_ami_ptr = pointer (codeptr (analyze_multics), 0);
      286     call hcs_$fs_get_path_name (where_ami_ptr, where_ami_dir, where_ami_len, where_ami_entry, code);
      287     if code ^= 0 then call report_error (code, WHOAMI, "where", "");
      288 
      289     call ssu_$create_invocation ("azm", CURRENT_VERSION, (null ()), addr (azm_request_table_$azm_request_table_),
      290 	     ">documentation>subsystem>analyze_multics", sci_ptr, code);
      291 
      292     if code ^= 0 then call report_error(code,"^/While creating analyze_multics invocation.","", "");
      293 
      294     call ssu_$add_info_dir (sci_ptr, ssu_info_directories_$standard_requests,
      295                         9999, code);
      296     if code ^= 0 then call report_error(code,"^/While adding standard ssu_ info directory.","", "");
      297 
      298     call ssu_$add_request_table(sci_ptr, addr(ssu_request_tables_$standard_requests), 100000, code);
      299     if code ^= 0 then call report_error(code,"^/While adding standard ssu_ request table.","", "");
      300 
      301     if (prompt_len = 0) then call ssu_$set_prompt_mode (sci_ptr, DONT_PROMPT);
      302 						/* Do not prompt				*/
      303     else if prompt_len >0 then do;			/* set the user specified prompt		*/
      304             call ssu_$set_prompt(sci_ptr, (prompt_string));
      305             end;
      306     else do; 					/* set the default prompt			*/
      307        call ssu_$set_prompt (sci_ptr, "^/azm^[ (^d)^]:^2x");
      308        call ssu_$set_prompt_mode (sci_ptr, PROMPT | PROMPT_AFTER_NULL_LINES | DONT_PROMPT_IF_TYPEAHEAD); 
      309        end;
      310 
      311     call ssu_$set_ec_suffix (sci_ptr, "azmec");
      312 
      313     if abbrev_sw then do;
      314        call ssu_$get_default_rp_options(sci_ptr, RP_OPTIONS_VERSION_1, addr(local_rpo), (0));
      315        local_rpo.abbrev_info.expand_request_lines = True;
      316        local_rpo.abbrev_info.default_profile_ptr = profile_ptr;
      317        local_rpo.abbrev_info.profile_ptr = profile_ptr;
      318        call ssu_$set_request_processor_options(sci_ptr, addr(local_rpo), (0));
      319        end;
      320 
      321     azm_info_ptr = addr (azm_info_automatic);
      322 
      323     unspec (azm_info) = ""b;
      324     azm_info.version = AZM_INFO_VERSION_2;
      325     azm_info.aip = amu_info_ptr;
      326     call ssu_$get_area (sci_ptr, null (), "azm_area", azm_info.area_ptr);    
      327     if amu_info_ptr ^= null () then do;
      328        if amu_info.type = FDUMP_TYPE | amu_info.type = FDUMP_PROCESS_TYPE then azm_info.flags.in_erf = "1"b;
      329            end;
      330 
      331     call ssu_$set_info_ptr (sci_ptr, azm_info_ptr);
      332     /* 6/24/83 currently debug mode does nothing, but it may in the future. -B. Braun */
      333     if debug_sw then call ssu_$set_debug_mode(sci_ptr, debug_sw);
      334     
      335     if startup_sw then do;
      336        call ssu_$execute_start_up (sci_ptr, code);
      337        if code ^= 0 then call report_error(code,"^/While executing start_up.","", "");
      338        end;
      339 
      340     if rq_sw then do;			/* just one request line specified 		*/
      341        call ssu_$execute_line (sci_ptr, request_line_ptr, request_line_len, code);
      342        if code ^= 0 then do;
      343           if code = ssu_et_$request_line_aborted  | code = ssu_et_$program_interrupt | code = ssu_et_$null_request_line
      344           then goto INVOKE_LISTEN;			/* enter request loop		*/
      345           if code = ssu_et_$subsystem_aborted then goto AZM_RETURN;
      346           call report_error(code,"^/While executing the request ^a.", (request_line), "");
      347           end;
      348        end;
      349 
      350     if quit_sw then goto AZM_RETURN;
      351 
      352 INVOKE_LISTEN:
      353 
      354     call ssu_$listen(sci_ptr, null(),code);
      355     if code ^= ssu_et_$subsystem_aborted then call com_err_ (code,WHOAMI,"^/Calling subsystem listener.");
      356 
      357 AZM_RETURN:
      358 	call clean_up ();
      359 
      360 	return;
      361 
      362 
      363 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      364 
      365 clean_up:
      366      proc ();
      367 
      368           if azm_info_ptr ^= null() then do;
      369 	   amu_info_ptr = azm_info.aip; 
      370 	   do while (amu_info_ptr ^= null);		/* amu_$terminate_translation should reset the       	*/
      371 						/* amu_info_chain and set amu_info_ptr to that value */
      372 	      call amu_$terminate_translation (amu_info_ptr);
      373 	      end;
      374 	   end;
      375 
      376 	if sci_ptr ^= null () then call ssu_$destroy_invocation (sci_ptr);
      377 
      378 	return;
      379 
      380      end clean_up;
      381 
      382 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      383 
      384 
      385 get_next_arg: proc(Arg_expected, ap1, al1);
      386 
      387 /*  This guy gets the next argument from the argument string, complaining if it's not there  */
      388 
      389 dcl Arg_expected			char(*);
      390 dcl (ap1				ptr,
      391      al1				fixed bin(21));
      392 	    
      393 	if (argno + 1) > nargs then do;
      394 	     call report_error(error_table_$noarg, "A ^a expected after ^a.", Arg_expected, arg);
      395 	     return;
      396 	     end;
      397 
      398 	argno = argno + 1;
      399 	call cu_$arg_ptr (argno, ap1, al1, (0));
      400      
      401 end get_next_arg;
      402 
      403 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      404 
      405 report_error: proc(ecode, message, str1, str2);
      406 
      407 /* reports error messages and aborts the line */
      408 
      409 dcl ecode				fixed bin(35),
      410     (message, str1, str2)		char(*);
      411  
      412    call com_err_(ecode, WHOAMI, message, str1, str2);
      413    goto AZM_RETURN;
      414 
      415 end report_error;
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      416 
  2     1 /*	BEGIN INCLUDE FILE amu_fdump_info.incl.pl1	*/
  2     2 
  2     3 dcl 1 fdump_info aligned based (amu_info.fdump_info_ptr),
  2     4     2 version char (8),
  2     5     2 ref_count fixed bin,				/* number of initiations */
  2     6 
  2     7     2 erf_name char (32),				/* ERF name for this dump */
  2     8     2 dump_dname char (168),				/* location of the dump */
  2     9     2 dump_ename char (32),				/* ename of component zero */
  2    10     2 system_id char (8),				/* the system_id of this erf */
  2    11     2 version_id char (8),				/* the version id of this erf */
  2    12     2 dump_seg_0_uid bit (36) aligned,			/* for determining EQ-ness and gullibility checking */
  2    13 
  2    14     2 n_dump_segs fixed bin,				/* number of real segs in the dump */
  2    15     2 copy_block_ptr pointer, 			/* pointer to chain of temp segment blocks */
  2    16 
  2    17     2 dump_seg_ptr (0:31) pointer,			/* pointer and length arrays */
  2    18     2 dump_seg_lth (0:31) fixed bin (18),
  2    19 
  2    20     2 fdump_process_table_ptr pointer;			/* pointer to array describing processes */
  2    21 
  2    22 
  2    23 dcl 1 fdump_process_table aligned based (fdump_info.fdump_process_table_ptr),
  2    24     2 size fixed bin,				/* number of entries */
  2    25 
  2    26     2 array (0:alloc_fdump_process_table_size - 1 refer (fdump_process_table.size)) like fp_table;
  2    27 
  2    28 dcl 1 fp_table based (fp_table_ptr),
  2    29       2 first_seg fixed bin,
  2    30       2 last_seg fixed bin,
  2    31       2 process_info_ptr pointer unaligned,		/* pointer to process_info structure, if filled in */
  2    32       2 dmp_seg_indx fixed bin,			/* dump seg index where process can be found */
  2    33       2 dmp_seg_offset fixed bin (24),			/* offset in the segment refered to by dmp_seg_indx where process starts */
  2    34       2 cpu_name char (1),
  2    35       2 dbr fixed bin (24),				/* address portion of DBR */
  2    36       2 apte_offset fixed bin (18);
  2    37 
  2    38 dcl fp_table_ptr ptr;
  2    39 
  2    40 dcl  alloc_fdump_process_table_size fixed bin;
  2    41 
  2    42 dcl  AMU_FDUMP_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_erf1");
  2    43 dcl  AMU_FDUMP_INFO_VERSION char (8) internal static options (constant) init ("amu_erf1");
  2    44 
  2    45 /*	END INCLUDE FILE amu_fdump_info.incl.pl1	*/
      417 
  3     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  3     2 
  3     3 dcl 1 amu_info aligned based (amu_info_ptr),
  3     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  3     5     2 flags aligned,
  3     6       3 early_dump bit(1) unal,
  3     7       3 pad  bit(35) unal,
  3     8     2 type fixed bin unal,				/* One of the types below */
  3     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  3    10     2 chain,					/* a chain of all the amu_info's which exist */
  3    11       3 prev pointer unaligned,
  3    12       3 next pointer unaligned,
  3    13 
  3    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  3    15 
  3    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  3    17 						/*   SEE: amu_translation.incl.pl1 */
  3    18     2 fdump_info_ptr pointer, 			
  3    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  3    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  3    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  3    22 						/* See: amu_old_uid_table			*/
  3    23 	
  3    24 
  3    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  3    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  3    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  3    28 						/*   SEE: amu_copy_info.incl.pl1 */
  3    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  3    30 						/*   SEE: amu_process_info.incl.pl1 */
  3    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  3    32 
  3    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  3    34 
  3    35     2 error_info,					/* various info about how amu_error_ is to behave */
  3    36       3 error_flags aligned,
  3    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  3    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  3    39         4 pad bit (34) unaligned,
  3    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  3    41     2 definitions_info_ptr ptr;
  3    42 
  3    43 dcl  amu_area area based (amu_info.area_ptr);
  3    44 
  3    45 dcl  amu_info_ptr pointer;
  3    46 
  3    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  3    48      FDUMP_PROCESS_TYPE	init (1038),
  3    49      ONLINE_TYPE		init (1039),
  3    50      ONLINE_PROCESS_TYPE	init (1040),
  3    51      NETWORK_FDUMP_TYPE	init (1041),
  3    52      NETWORK_ONLINE_TYPE	init (1042),
  3    53      SAVED_PROC_TYPE	init (1043),
  3    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  3    55 
  3    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  3    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  3    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  3    59 
  3    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  3    61 
  3    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      418 
  4     1 /*	BEGIN INCLUDE FILE azm_info.incl.pl1		*/
  4     2 
  4     3 dcl 1 azm_info aligned based (azm_info_ptr),
  4     4     2 version char(8),
  4     5     2 area_ptr ptr,					/* area pointer for azm to use when needed	*/
  4     6     2 aip pointer,					/* pointer for all amu_ calls */
  4     7     2 flags aligned,
  4     8       3 in_erf bit (1) unaligned,			/* examining an FDUMP */
  4     9       3 in_process bit (1) unaligned,			/* some specific process selected in FDUMP */
  4    10       3 online bit (1) unaligned,			/* examining online system, my process */
  4    11       3 saved_proc bit (1) unaligned,			/* examining "deadproc" */
  4    12       3 pad bit (33) unaligned,
  4    13 
  4    14     2 erf_name char (168),				/* name of ERF or deadproc path */
  4    15     2 pad fixed bin;
  4    16 
  4    17 dcl  azm_info_ptr pointer;
  4    18 
  4    19 dcl  AZM_INFO_VERSION_1 char (8) internal static options (constant) init ("azm_v1");
  4    20 dcl  AZM_INFO_VERSION_2 char (8) internal static options (constant) init ("azm_v2");
  4    21 
  4    22 /*	END INCLUDE FILE azm_info.incl.pl1		*/
      419 
  5     1 /* BEGIN INCLUDE FILE ... ssu_rp_options.incl.pl1 */
  5     2 /* Created:  June 1982 by G. Palter */
  5     3 
  5     4 /* Options for the standard subsystem request processor */
  5     5 
  5     6 dcl  1 rp_options aligned based (rp_options_ptr),
  5     7        2 version character (8),
  5     8        2 language_info,				/* defines the request language */
  5     9          3 non_standard_language bit (1) aligned,		/* ... ON => use language defined in following array */
  5    10          3 character_types (0 : 511) fixed binary (9) unaligned unsigned,
  5    11        2 abbrev_info,				/* information related to abbreviation processing ... */
  5    12          3 expand_request_lines bit (1) aligned,		/* ... ON => request processor should expand abbreviations */
  5    13          3 default_profile_ptr pointer,			/* ... -> profile to use if ".u" given without pathname */
  5    14          3 profile_ptr pointer;			/* ... -> abbreviation profile used by this subsystem */
  5    15 
  5    16 dcl  rp_options_ptr pointer;
  5    17 
  5    18 dcl  RP_OPTIONS_VERSION_1 character (8) static options (constant) initial ("rpo_0001");
  5    19 
  5    20 /* END INCLUDE FILE ... ssu_rp_options.incl.pl1 */
      420 
      421 
      422 dcl 1 local_rpo  like rp_options;
  6     1 /* BEGIN INCLUDE FILE ... ssu_prompt_modes.incl.pl1 */
  6     2 /* Created:  15 February 1982 by G. Palter */
  6     3 
  6     4 /* Values for use in calls to ssu_$set_prompt_mode to control prompting by the subsystem listener */
  6     5 
  6     6 dcl  PROMPT bit (1) static options (constant) initial ("0"b);
  6     7 dcl  DONT_PROMPT bit (1) static options (constant) initial ("1"b);
  6     8 
  6     9 dcl  PROMPT_AFTER_NULL_LINES bit (2) static options (constant) initial ("01"b);
  6    10 dcl  DONT_PROMPT_AFTER_NULL_LINES bit (2) static options (constant) initial ("00"b);
  6    11 
  6    12 dcl  PROMPT_IF_TYPEAHEAD bit (3) static options (constant) initial ("000"b);
  6    13 dcl  DONT_PROMPT_IF_TYPEAHEAD bit (3) static options (constant) initial ("001"b);
  6    14 
  6    15 /* For example:
  6    16*      call ssu_$set_prompt_mode (sci_ptr, PROMPT | DONT_PROMPT_AFTER_NULL_LINES | DONT_PROMPT_IF_TYPEAHEAD); */
  6    17 
  6    18 /* END INCLUDE FILE ... ssu_prompt_modes.incl.pl1 */
      423 
  7     1 /* 	BEGIN INCLUDE FILE ... stack_frame.incl.pl1 ... */
  7     2 
  7     3 /* format: off */
  7     4 
  7     5 /* Modified: 16 Dec 1977, D. Levin - to add fio_ps_ptr and pl1_ps_ptr */
  7     6 /* Modified:  3 Feb 1978, P. Krupp - to add run_unit_manager bit & main_proc bit */
  7     7 /* Modified: 21 March 1978, D. Levin - change fio_ps_ptr to support_ptr */
  7     8 /* Modified: 03/01/84, S. Herbst - Added RETURN_PTR_MASK */
  7     9 
  7    10 
  7    11 /****^  HISTORY COMMENTS:
  7    12*  1) change(86-09-15,Kissel), approve(86-09-15,MCR7473),
  7    13*     audit(86-10-01,Fawcett), install(86-11-03,MR12.0-1206):
  7    14*     Modified to add constants for the translator_id field in the stack_frame
  7    15*     structure.
  7    16*                                                   END HISTORY COMMENTS */
  7    17 
  7    18 
  7    19 dcl RETURN_PTR_MASK bit (72) int static options (constant)  /* mask to be AND'd with stack_frame.return_ptr */
  7    20 	init ("777777777777777777000000"b3);		/* when copying, to ignore bits that a call fills */
  7    21 						/* with indicators (nonzero for Fortran hexfp caller) */
  7    22 			/* say: unspec(ptr) = unspec(stack_frame.return_ptr) & RETURN_PTR_MASK; */
  7    23 
  7    24 dcl TRANSLATOR_ID_PL1V2 bit (18) internal static options (constant) init ("000000"b3);
  7    25 dcl TRANSLATOR_ID_ALM bit (18) internal static options (constant) init ("000001"b3);
  7    26 dcl TRANSLATOR_ID_PL1V1 bit (18) internal static options (constant) init ("000002"b3);
  7    27 dcl TRANSLATOR_ID_SIGNAL_CALLER bit (18) internal static options (constant) init ("000003"b3);
  7    28 dcl TRANSLATOR_ID_SIGNALLER bit (18) internal static options (constant) init ("000004"b3);
  7    29 
  7    30 
  7    31 dcl  sp pointer;					/* pointer to beginning of stack frame */
  7    32 
  7    33 dcl  stack_frame_min_length fixed bin static init(48);
  7    34 
  7    35 
  7    36 dcl 1 stack_frame based(sp) aligned,
  7    37     2 pointer_registers(0 : 7) ptr,
  7    38     2 prev_sp pointer,
  7    39     2 next_sp pointer,
  7    40     2 return_ptr pointer,
  7    41     2 entry_ptr pointer,
  7    42     2 operator_and_lp_ptr ptr,			/* serves as both */
  7    43     2 arg_ptr pointer,
  7    44     2 static_ptr ptr unaligned,
  7    45     2 support_ptr ptr unal, /* only used by fortran I/O */
  7    46     2 on_unit_relp1 bit(18) unaligned,
  7    47     2 on_unit_relp2 bit(18) unaligned,
  7    48     2 translator_id bit(18) unaligned,			/* Translator ID (see constants above)
  7    49*						   0 => PL/I version II
  7    50*						   1 => ALM
  7    51*						   2 => PL/I version I   
  7    52*						   3 => signal caller frame
  7    53*						   4 => signaller frame */
  7    54     2 operator_return_offset bit(18) unaligned,
  7    55     2 x(0: 7) bit(18) unaligned,			/* index registers */
  7    56     2 a bit(36),					/* accumulator */
  7    57     2 q bit(36),					/* q-register */
  7    58     2 e bit(36),					/* exponent */
  7    59     2 timer bit(27) unaligned,				/* timer */
  7    60     2 pad bit(6) unaligned,
  7    61     2 ring_alarm_reg bit(3) unaligned;
  7    62 
  7    63 
  7    64 dcl 1 stack_frame_flags based(sp) aligned,
  7    65     2 pad(0 : 7) bit(72),				/* skip over prs */
  7    66     2 xx0 bit(22) unal,
  7    67     2 main_proc bit(1) unal,				/* on if frame belongs to a main procedure */
  7    68     2 run_unit_manager bit(1) unal,			/* on if frame belongs to run unit manager */
  7    69     2 signal bit(1) unal,				/* on if frame belongs to logical signal_ */
  7    70     2 crawl_out bit(1) unal,				/* on if this is a signal caller frame */
  7    71     2 signaller bit(1) unal,				/* on if next frame is signaller's */
  7    72     2 link_trap bit(1) unal,				/* on if this frame was made by the linker */
  7    73     2 support bit(1) unal,				/* on if frame belongs to a support proc */
  7    74     2 condition bit(1) unal,				/* on if condition established in this frame */
  7    75     2 xx0a bit(6) unal,
  7    76     2 xx1 fixed bin,
  7    77     2 xx2 fixed bin,
  7    78     2 xx3 bit(25) unal,
  7    79     2 old_crawl_out bit (1) unal,			/* on if this is a signal caller frame */
  7    80     2 old_signaller bit(1) unal,			/* on if next frame is signaller's */
  7    81     2 xx3a bit(9) unaligned,
  7    82     2 xx4(9) bit(72) aligned,
  7    83     2 v2_pl1_op_ret_base ptr,				/* When a V2 PL/I program calls an operator the
  7    84*						*  operator puts a pointer to the base of
  7    85*						*  the calling procedure here. (text base ptr)  */
  7    86     2 xx5 bit(72) aligned,
  7    87     2 pl1_ps_ptr ptr;				/* ptr to ps for this frame; also used by fio. */
  7    88 
  7    89 /* format: on */
  7    90 
  7    91 /* 	END INCLUDE FILE ... stack_frame.incl.pl1 */
      424 
      425 
      426      end analyze_multics;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/04/86  1042.5  analyze_multics.pl1               >special_ldd>install>MR12.0-1206>analyze_multics.pl1
416          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
417          2    09/22/83  1102.5  amu_fdump_info.incl.pl1           >ldd>include>amu_fdump_info.incl.pl1
418          3    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
419          4    11/20/84  0854.8  azm_info.incl.pl1                 >ldd>include>azm_info.incl.pl1
420          5    09/28/82  1437.6  ssu_rp_options.incl.pl1           >ldd>include>ssu_rp_options.incl.pl1
423          6    04/13/82  1620.2  ssu_prompt_modes.incl.pl1         >ldd>include>ssu_prompt_modes.incl.pl1
424          7    11/03/86  1114.7  stack_frame.incl.pl1              >special_ldd>install>MR12.0-1206>stack_frame.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AZM_INFO_VERSION_2              000002 constant        char(8)                  initial unaligned dcl 4-20 ref 324
Arg_expected                           parameter       char                     unaligned dcl 389 set ref 385 394*
CURRENT_VERSION                 000004 constant        char(4)                  initial unaligned dcl 116 set ref 289*
DONT_PROMPT                     000045 constant        bit(1)                   initial unaligned dcl 6-7 set ref 301*
DONT_PROMPT_IF_TYPEAHEAD               constant        bit(3)                   initial unaligned dcl 6-13 ref 308
FDUMP_PROCESS_TYPE                     constant        fixed bin(17,0)          initial dcl 3-47 ref 213 328
FDUMP_TYPE                             constant        fixed bin(17,0)          initial dcl 3-47 ref 328
False                                  constant        bit(1)                   initial unaligned dcl 113 ref 253 261
PROMPT                                 constant        bit(1)                   initial unaligned dcl 6-6 ref 308
PROMPT_AFTER_NULL_LINES                constant        bit(2)                   initial unaligned dcl 6-9 ref 308
RP_OPTIONS_VERSION_1            000000 constant        char(8)                  initial unaligned dcl 5-18 set ref 314*
R_ACCESS                        000045 constant        bit(3)                   initial unaligned dcl 1-11 set ref 240*
True                                   constant        bit(1)                   initial unaligned dcl 113 ref 233 245 249 257 315
WHOAMI                          000005 constant        char(32)                 initial unaligned dcl 115 set ref 225* 242* 279*
                                                                                  287* 355* 412*
abbrev_info             204     000414 automatic       structure                level 2 unaligned dcl 422
abbrev_sw                       000100 automatic       bit(1)                   unaligned dcl 25 set ref 131* 245* 249* 253* 313
addr                                                   builtin function         dcl 125 ref 289 289 298 298 314 314 318 318 321
aip                       4     000110 automatic       pointer                  level 2 in structure "azm_info_automatic" dcl 32
                                                                                  in procedure "azm" set ref 188
aip                       4            based           pointer                  level 2 in structure "azm_info" dcl 4-3 in procedure
                                                                                  "azm" set ref 325* 369
al                              000101 automatic       fixed bin(21,0)          dcl 26 set ref 230* 231 231 236 236 248 248 252 252
                                                                                  256 256 260 260 264 268 272 272 273 273 274 277
                                                                                  279 279 394 394
al1                                    parameter       fixed bin(21,0)          dcl 390 set ref 385 399*
amu_$terminate_translation      000034 constant        entry                    external dcl 81 ref 216 372
amu_info                               based           structure                level 1 dcl 3-3
amu_info_ptr                    000410 automatic       pointer                  dcl 3-45 set ref 130* 188* 190 192 194 196 197* 197
                                                                                  206 210* 213 213 216* 218 325 327 328 328 369* 370
                                                                                  372*
amu_ptr                         000102 automatic       pointer                  dcl 28 set ref 130* 164* 165 169*
ap                              000104 automatic       pointer                  dcl 29 set ref 230* 231 231 236 236 248 248 252 252
                                                                                  256 256 260 260 264 268 272 272 273 273 274 277
                                                                                  279 394
ap1                                    parameter       pointer                  dcl 390 set ref 385 399*
area_ptr                  2            based           pointer                  level 2 dcl 4-3 set ref 326*
arg                                    based           char                     unaligned dcl 30 set ref 231 231 236 236 248 248 252
                                                                                  252 256 256 260 260 264 268 272 272 273 273 274
                                                                                  277 279* 394*
argno                           000106 automatic       fixed bin(17,0)          dcl 31 set ref 229* 230* 393 398* 398 399*
azm_info                               based           structure                level 1 dcl 4-3 set ref 323*
azm_info_automatic              000110 automatic       structure                level 1 dcl 32 set ref 321
azm_info_ptr                    000412 automatic       pointer                  dcl 4-17 set ref 130* 183 321* 323 324 325 326 328
                                                                                  331* 368 369
azm_request_table_$azm_request_table_
                                000014 external static fixed bin(17,0)          dcl 70 set ref 289 289
chain                     6            based           structure                level 2 dcl 3-3
cleanup                         000374 stack reference condition                dcl 120 ref 137
code                            000173 automatic       fixed bin(35,0)          dcl 33 set ref 135* 146* 148* 149 150* 155* 156 157*
                                                                                  164* 166* 169* 170 171* 175* 186* 201* 218* 223*
                                                                                  224 225* 238* 239 239* 240* 242* 277* 278* 279*
                                                                                  286* 287 287* 289* 292 292* 294* 296 296* 298* 299
                                                                                  299* 336* 337 337* 341* 342 343 343 343 345 346*
                                                                                  352* 355 355*
codeptr                                                builtin function         dcl 125 ref 154 285
com_err_                        000036 constant        entry                    external dcl 81 ref 225 242 279 355 412
cond_uid                        000174 automatic       bit(36)                  dcl 34 set ref 148* 161 174
continue_to_signal_             000040 constant        entry                    external dcl 81 ref 150 157 166 171 175 186 201 218
cu_$arg_count                   000042 constant        entry                    external dcl 81 ref 223
cu_$arg_ptr                     000044 constant        entry                    external dcl 81 ref 230 399
debug_sw                        000175 automatic       bit(1)                   dcl 35 set ref 131* 272* 273* 333 333*
default_profile_ptr     206     000414 automatic       pointer                  level 3 dcl 422 set ref 316*
dirname                         000176 automatic       char(168)                unaligned dcl 36 set ref 238* 240* 242*
ecode                                  parameter       fixed bin(35,0)          dcl 409 set ref 405 412*
ename                           000250 automatic       char(32)                 unaligned dcl 38 set ref 238* 240* 242 242*
entry_ptr                26            based           pointer                  level 2 dcl 7-36 set ref 148*
erf_name                  3            based           char(32)                 level 2 dcl 2-3 set ref 213*
error_table_$bad_arg            000016 external static fixed bin(35,0)          dcl 71 ref 278
error_table_$badopt             000020 external static fixed bin(35,0)          dcl 71 ref 277
error_table_$noarg              000022 external static fixed bin(35,0)          dcl 71 set ref 394*
expand_pathname_$add_suffix     000046 constant        entry                    external dcl 81 ref 238
expand_request_lines    204     000414 automatic       bit(1)                   level 3 dcl 422 set ref 315*
fdump_info                             based           structure                level 1 dcl 2-3
fdump_info_ptr           14            based           pointer                  level 2 dcl 3-3 ref 213
find_condition_frame_           000050 constant        entry                    external dcl 81 ref 145
flags                     6            based           structure                level 2 dcl 4-3
fp_table                               based           structure                level 1 unaligned dcl 2-28
hcs_$fs_get_path_name           000052 constant        entry                    external dcl 81 ref 286
hcs_$get_uid_seg                000054 constant        entry                    external dcl 81 ref 148 155 169
hcs_$make_ptr                   000056 constant        entry                    external dcl 81 ref 164
in_erf                    6            based           bit(1)                   level 3 packed unaligned dcl 4-3 set ref 328*
initiate_file_                  000060 constant        entry                    external dcl 81 ref 240
ioa_                            000062 constant        entry                    external dcl 81 ref 185 213 215
ioa_$nnl                        000064 constant        entry                    external dcl 81 ref 182
local_rpo                       000414 automatic       structure                level 1 unaligned dcl 422 set ref 314 314 318 318
message                                parameter       char                     unaligned dcl 409 set ref 405 412*
my_uid                          000260 automatic       bit(36)                  dcl 41 set ref 155* 161 169* 174
nargs                           000261 automatic       fixed bin(17,0)          dcl 42 set ref 223* 229 393
next                      7            based           pointer                  level 3 packed unaligned dcl 3-3 ref 194 197
null                                                   builtin function         dcl 125 ref 130 145 145 164 164 165 183 189 190 192
                                                                                  194 207 211 218 241 289 326 326 327 352 352 368
                                                                                  370 376
pointer                                                builtin function         dcl 125 ref 285
prev                      6            based           pointer                  level 3 packed unaligned dcl 3-3 ref 192 207 208
profile_len                     000262 automatic       fixed bin(21,0)          dcl 43 set ref 133* 237* 238 238 239 239
profile_ptr             210     000414 automatic       pointer                  level 3 in structure "local_rpo" dcl 422
                                                                                  in procedure "azm" set ref 317*
profile_ptr                     000264 automatic       pointer                  dcl 44 in procedure "azm" set ref 130* 237* 238 239
                                                                                  240* 241 316 317
profile_str                            based           char                     unaligned dcl 45 set ref 238* 239*
prompt_len                      000266 automatic       fixed bin(21,0)          dcl 46 set ref 132* 265* 269* 301 303 304
prompt_ptr                      000270 automatic       pointer                  dcl 47 set ref 130* 265* 304
prompt_string                          based           char                     unaligned dcl 48 ref 304
quit_sw                         000272 automatic       bit(1)                   unaligned dcl 49 set ref 131* 274* 350
record_quota_overflow           000402 stack reference condition                dcl 120 ref 142
request_line                           based           char                     unaligned dcl 50 ref 346
request_line_len                000273 automatic       fixed bin(21,0)          dcl 51 set ref 133* 232* 341* 346
request_line_ptr                000274 automatic       pointer                  dcl 52 set ref 130* 232* 341* 346
rp_options                             based           structure                level 1 dcl 5-6
rq_sw                           000276 automatic       bit(1)                   dcl 53 set ref 233* 340
sci_ptr                         000372 automatic       pointer                  dcl 61 set ref 130* 289* 294* 298* 301* 304* 307*
                                                                                  308* 311* 314* 318* 326* 331* 333* 336* 341* 352*
                                                                                  376 376*
sp                              000626 automatic       pointer                  dcl 7-31 set ref 145* 148
ssu_$add_info_dir               000066 constant        entry                    external dcl 81 ref 294
ssu_$add_request_table          000070 constant        entry                    external dcl 81 ref 298
ssu_$create_invocation          000072 constant        entry                    external dcl 81 ref 289
ssu_$destroy_invocation         000074 constant        entry                    external dcl 81 ref 376
ssu_$execute_line               000076 constant        entry                    external dcl 81 ref 341
ssu_$execute_start_up           000100 constant        entry                    external dcl 81 ref 336
ssu_$get_area                   000102 constant        entry                    external dcl 81 ref 326
ssu_$get_default_rp_options     000104 constant        entry                    external dcl 81 ref 314
ssu_$listen                     000106 constant        entry                    external dcl 81 ref 352
ssu_$set_debug_mode             000110 constant        entry                    external dcl 81 ref 333
ssu_$set_ec_suffix              000112 constant        entry                    external dcl 81 ref 311
ssu_$set_info_ptr               000114 constant        entry                    external dcl 81 ref 331
ssu_$set_prompt                 000116 constant        entry                    external dcl 81 ref 304 307
ssu_$set_prompt_mode            000120 constant        entry                    external dcl 81 ref 301 308
ssu_$set_request_processor_options
                                000122 constant        entry                    external dcl 81 ref 318
ssu_et_$null_request_line       000024 external static fixed bin(35,0)          dcl 71 ref 343
ssu_et_$program_interrupt       000026 external static fixed bin(35,0)          dcl 71 ref 343
ssu_et_$request_line_aborted    000030 external static fixed bin(35,0)          dcl 71 ref 343
ssu_et_$subsystem_aborted       000032 external static fixed bin(35,0)          dcl 71 ref 345 355
ssu_info_directories_$standard_requests
                                000012 external static char(168)                unaligned dcl 66 set ref 294*
ssu_request_tables_$standard_requests
                                000010 external static bit(36)                  dcl 64 set ref 298 298
stack_frame                            based           structure                level 1 dcl 7-36
startup_sw                      000277 automatic       bit(1)                   unaligned dcl 54 set ref 131* 257* 261* 335
str1                                   parameter       char                     unaligned dcl 409 set ref 405 412*
str2                                   parameter       char                     unaligned dcl 409 set ref 405 412*
temp_ptr                        000300 automatic       pointer                  dcl 55 set ref 189* 196* 206* 207 208* 208 210 211*
type                      3            based           fixed bin(17,0)          level 2 packed unaligned dcl 3-3 ref 213 328 328
unspec                                                 builtin function         dcl 125 set ref 323*
version                                based           char(8)                  level 2 dcl 4-3 set ref 324*
where_ami_dir                   000302 automatic       char(168)                unaligned dcl 56 set ref 286*
where_ami_entry                 000354 automatic       char(32)                 unaligned dcl 57 set ref 286*
where_ami_len                   000364 automatic       fixed bin(17,0)          dcl 58 set ref 133* 286*
where_ami_ptr                   000366 automatic       pointer                  dcl 59 set ref 130* 154* 155* 285* 286*
why_sw                          000370 automatic       bit(1)                   unaligned dcl 60 set ref 131*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_FDUMP_INFO_VERSION                 internal static char(8)                  initial unaligned dcl 2-43
AMU_FDUMP_INFO_VERSION_1               internal static char(8)                  initial unaligned dcl 2-42
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 3-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 3-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 3-58
AZM_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 4-19
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
DONT_PROMPT_AFTER_NULL_LINES           internal static bit(2)                   initial unaligned dcl 6-10
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 3-47
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 3-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 3-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 3-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 3-60
PROMPT_IF_TYPEAHEAD                    internal static bit(3)                   initial unaligned dcl 6-12
RETURN_PTR_MASK                        internal static bit(72)                  initial unaligned dcl 7-19
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 3-47
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TRANSLATOR_ID_ALM                      internal static bit(18)                  initial unaligned dcl 7-25
TRANSLATOR_ID_PL1V1                    internal static bit(18)                  initial unaligned dcl 7-26
TRANSLATOR_ID_PL1V2                    internal static bit(18)                  initial unaligned dcl 7-24
TRANSLATOR_ID_SIGNALLER                internal static bit(18)                  initial unaligned dcl 7-28
TRANSLATOR_ID_SIGNAL_CALLER            internal static bit(18)                  initial unaligned dcl 7-27
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
alloc_fdump_process_table_size         automatic       fixed bin(17,0)          dcl 2-40
alp                                    automatic       pointer                  dcl 27
amu_area                               based           area(1024)               dcl 3-43
dn_lth                                 automatic       fixed bin(17,0)          dcl 37
fdump_process_table                    based           structure                level 1 dcl 2-23
fp_table_ptr                           automatic       pointer                  dcl 2-38
i                                      automatic       fixed bin(17,0)          dcl 39
index                                                  builtin function         dcl 125
info_dir                               automatic       char(168)                unaligned dcl 40
reverse                                                builtin function         dcl 125
rp_options_ptr                         automatic       pointer                  dcl 5-16
rtrim                                                  builtin function         dcl 125
stack_frame_flags                      based           structure                level 1 dcl 7-64
stack_frame_min_length                 internal static fixed bin(17,0)          initial dcl 7-33
substr                                                 builtin function         dcl 125

NAMES DECLARED BY EXPLICIT CONTEXT.
AZM_RETURN                      002622 constant        label                    dcl 357 ref 243 280 345 350 413
INVOKE_LISTEN                   002556 constant        label                    dcl 352 set ref 343
analyze_multics                 000344 constant        entry                    external dcl 7 ref 154 285
azm                             000335 constant        entry                    external dcl 7
clean_up                        002630 constant        entry                    internal dcl 365 ref 139 357
get_next_arg                    002677 constant        entry                    internal dcl 385 ref 232 237 265
report_error                    002777 constant        entry                    internal dcl 405 ref 239 287 292 296 299 337 346 394

NAME DECLARED BY CONTEXT OR IMPLICATION.
char                                                   builtin function         ref 277

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3666        4012    3134        3676
Length      4440    3134       124         411     531           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm                                 548 external procedure  is an external procedure.  
on unit on line 137                  64 on unit               
on unit on line 142                 114 on unit               
clean_up                             68 internal procedure  is called by several nonquick procedures.  
get_next_arg                            internal procedure  shares stack frame of external procedure azm.  
report_error                         90 internal procedure  is called during a stack extension.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm                      000100 abbrev_sw                   azm
                         000101 al                          azm
                         000102 amu_ptr                     azm
                         000104 ap                          azm
                         000106 argno                       azm
                         000110 azm_info_automatic          azm
                         000173 code                        azm
                         000174 cond_uid                    azm
                         000175 debug_sw                    azm
                         000176 dirname                     azm
                         000250 ename                       azm
                         000260 my_uid                      azm
                         000261 nargs                       azm
                         000262 profile_len                 azm
                         000264 profile_ptr                 azm
                         000266 prompt_len                  azm
                         000270 prompt_ptr                  azm
                         000272 quit_sw                     azm
                         000273 request_line_len            azm
                         000274 request_line_ptr            azm
                         000276 rq_sw                       azm
                         000277 startup_sw                  azm
                         000300 temp_ptr                    azm
                         000302 where_ami_dir               azm
                         000354 where_ami_entry             azm
                         000364 where_ami_len               azm
                         000366 where_ami_ptr               azm
                         000370 why_sw                      azm
                         000372 sci_ptr                     azm
                         000410 amu_info_ptr                azm
                         000412 azm_info_ptr                azm
                         000414 local_rpo                   azm
                         000626 sp                          azm

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry
int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$terminate_translation    com_err_                      continue_to_signal_           cu_$arg_count
cu_$arg_ptr                   expand_pathname_$add_suffix   find_condition_frame_         hcs_$fs_get_path_name
hcs_$get_uid_seg              hcs_$make_ptr                 initiate_file_                ioa_
ioa_$nnl                      ssu_$add_info_dir             ssu_$add_request_table        ssu_$create_invocation
ssu_$destroy_invocation       ssu_$execute_line             ssu_$execute_start_up         ssu_$get_area
ssu_$get_default_rp_options   ssu_$listen                   ssu_$set_debug_mode           ssu_$set_ec_suffix
ssu_$set_info_ptr             ssu_$set_prompt               ssu_$set_prompt_mode
ssu_$set_request_processor_options

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
azm_request_table_$azm_request_table_                       error_table_$bad_arg          error_table_$badopt
error_table_$noarg            ssu_et_$null_request_line     ssu_et_$program_interrupt     ssu_et_$request_line_aborted
ssu_et_$subsystem_aborted     ssu_info_directories_$standard_requests
ssu_request_tables_$standard_requests




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      7 000334       130 000351       131 000362       132 000367       133 000371       135 000374       137 000375
    139 000411       140 000416       142 000417       145 000433       146 000446       148 000450       149 000464
    150 000467       151 000476       154 000477       155 000501       156 000514       157 000517       158 000526
    161 000527       164 000532       165 000566       166 000573       167 000602       169 000603       170 000616
    171 000621       172 000630       174 000631       175 000634       176 000643       182 000644       183 000660
    185 000665       186 000672       188 000702       189 000706       190 000710       192 000713       194 000717
    196 000722       197 000723       198 000725       201 000726       203 000735       206 000736       207 000737
    208 000745       209 000747       210 000750       211 000751       213 000753       215 001003       216 001017
    218 001027       220 001043       223 001044       224 001055       225 001057       226 001074       229 001075
    230 001105       231 001123       232 001135       233 001144       234 001146       236 001147       237 001157
    238 001167       239 001225       240 001260       241 001316       242 001322       243 001366       245 001367
    246 001371       248 001372       249 001402       250 001404       252 001405       253 001415       254 001416
    256 001417       257 001427       258 001431       260 001432       261 001442       262 001443       264 001444
    265 001450       266 001461       268 001462       269 001466       270 001467       272 001470       273 001503
    274 001515       277 001524       278 001537       279 001542       280 001573       282 001574       285 001576
    286 001601       287 001633       289 001663       292 001733       294 001763       296 002012       298 002042
    299 002063       301 002113       303 002133       304 002134       305 002160       307 002162       308 002204
    311 002225       313 002241       314 002243       315 002263       316 002265       317 002267       318 002270
    321 002306       323 002310       324 002313       325 002316       326 002320       327 002347       328 002353
    331 002366       333 002377       335 002413       336 002415       337 002432       340 002462       341 002464
    342 002501       343 002503       345 002512       346 002514       347 002553       350 002554       352 002556
    355 002573       357 002622       360 002626       365 002627       368 002635       369 002642       370 002645
    372 002653       373 002662       376 002663       378 002676       385 002677       393 002710       394 002714
    395 002754       398 002755       399 002756       401 002775       405 002776       412 003024       413 003055


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
