	COMPILATION LISTING OF SEGMENT get_vol_list_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 01/09/87  1314.5 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        4*        *                                                         *
        5*        *********************************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(86-01-16,Fawcett), approve(86-04-10,MCR7383),
       10*     audit(86-05-27,Wallman), install(86-07-18,MR12.0-1098):
       11*     Add support for subvolumes, 3380 and 3390.
       12*  2) change(86-11-10,Fawcett), approve(86-11-10,MCR7125),
       13*     audit(87-01-08,Farley), install(87-01-09,MR12.0-1266):
       14*     Changed by Tom Oke to conform to documentation.
       15*  3) change(86-11-10,Fawcett), approve(86-11-10,MCR7547),
       16*     audit(87-01-08,Farley), install(87-01-09,MR12.0-1266):
       17*     Changed so disk_meters can display subvolume devices correctly.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 get_vol_list_:
       22      proc (a_pv_list_ptr, a_lv_list_ptr, a_area_ptr, a_version, a_code);
       23 
       24 /* Program to determine logical and physical volume names in a MULTICS
       25*   system and allocate and return structures with this information. */
       26 
       27 /* format: off */
       28 /* Input:
       29*   a_pv_list_ptr	is a pointer to the pv_list structure.  If it is
       30*		non-null, it is taken to point to an existing
       31*		structure which is size checked for validity and
       32*		returned and re-allocated if necessary.
       33*   a_lv_list_ptr	is a pointer to the lv_list structure.  If it is
       34*		non-null, it is taken to point to an existing
       35*		structure which is size checked for validity and
       36*		returned and re-allocated if necessary.
       37*   a_area_ptr	is a pointer to the area to allocate the structures
       38*		in.  If it is null (), system_free_area is used.
       39*   a_version	is an 8 character string of the version of structure
       40*		the calling routine is expecting to receive.
       41*   code		error code.
       42**/
       43 
       44 /* format: on */
       45 
       46 /* Interface declaratons. */
       47 
       48 	dcl     a_pv_list_ptr	 ptr;
       49 	dcl     a_lv_list_ptr	 ptr;
       50 	dcl     a_area_ptr		 ptr;
       51 	dcl     a_version		 char (8);
       52 	dcl     a_code		 fixed bin (35);
       53 
       54 /* Automatic */
       55 
       56 	dcl     area_ptr		 ptr;
       57 	dcl     code		 fixed bin (35);
       58 	dcl     i			 fixed bin;
       59 	dcl     1 ai		 like area_info;
       60 	dcl     max_lvs		 fixed bin;
       61 	dcl     max_pvs		 fixed bin;
       62 	dcl     temp_ptr		 ptr;		/* to temp seg */
       63 
       64 	dcl     (addr, currentsize, length, max, null, rtrim, unspec) builtin;
       65 
       66 	dcl     cleanup		 condition;
       67 
       68 /* Static */
       69 
       70 	dcl     entry_name		 char (32) static options (constant) initial ("get_vol_list_");
       71 
       72 /* Areas */
       73 
       74 	dcl     areas		 area based (area_ptr);
       75 
       76 
       77 /* Structure Funnies */
       78 /* The following array is used to determine the size to allocate
       79*   for the structures to return.  We overlay the lv and pv structures onto the
       80*   array, fill in the size words (which exist within the size of the array)
       81*   and then do a currentsize (of a structure which for the most part doesn't
       82*   exist) to determine its real size to allocate.  We cannot do it with
       83*   allocation, since we need the internal size words correctly set to 
       84*   allocate the true size. */
       85 
       86 	dcl     allocating_array	 (alloc_size) fixed bin (35) based;
       87 	dcl     alloc_size		 fixed bin;	/* currentsize */
       88 	dcl     sizing_array	 (10) fixed bin (35);
       89 
       90 /* Entries */
       91 
       92 	dcl     area_info_		 entry (ptr, fixed bin (35));
       93 	dcl     error_table_$improper_data_format fixed bin (35) ext static;
       94 	dcl     error_table_$unimplemented_version fixed bin (35) ext static;
       95 	dcl     get_temp_segment_	 entry (char (*), ptr, fixed bin (35));
       96 	dcl     mdc_$read_disk_table	 entry (ptr, fixed bin (35));
       97 	dcl     release_temp_segment_	 entry (char (*), ptr, fixed bin (35));
       98 	dcl     get_system_free_area_	 entry () returns (ptr);
       99 
      100 	if a_version ^= get_vol_list_version then do;
      101 BAD_VERSION:	a_code = error_table_$unimplemented_version;
      102 		return;
      103 	     end;
      104 
      105 	if a_area_ptr = null () then
      106 	     area_ptr = get_system_free_area_ ();
      107 	else if valid_area (a_area_ptr) then
      108 	     area_ptr = a_area_ptr;
      109 	else do;
      110 		a_code = error_table_$improper_data_format;
      111 		return;
      112 	     end;
      113 
      114 	temp_ptr = null ();
      115 
      116 	on cleanup begin;
      117 		if temp_ptr ^= null () then call release_temp_segment_ (entry_name, temp_ptr, code);
      118 	     end;
      119 
      120 	call get_temp_segment_ (entry_name, temp_ptr, code);
      121 	if code ^= 0 then do;
      122 		a_code = code;
      123 		return;
      124 	     end;
      125 
      126 	dtp = temp_ptr;				/* setup disk_table */
      127 	call mdc_$read_disk_table (dtp, code);
      128 	if code ^= 0 then do;
      129 		a_code = code;
      130 		goto exit;
      131 	     end;
      132 
      133 /* Determine if we need to allocate pv_list and lv_list. */
      134 
      135 	do i = 1 to dt.max_n_entries;
      136 	     if (dt.array (i).used | dt.array (i).is_sub_vol)
      137 	     then max_pvs = i;
      138 
      139 	     if dt.lv_array (i).used = "1"b
      140 	     then max_lvs = i;
      141 	end;
      142 
      143 	pv_list_ptr = a_pv_list_ptr;
      144 	lv_list_ptr = a_lv_list_ptr;
      145 
      146 	if pv_list_ptr ^= null () then do;
      147 		if pv_list_ptr -> pv_list.version ^= get_vol_list_version then goto BAD_VERSION;
      148 		if pv_list_ptr -> pv_list.pv_name_count ^= max_pvs then do;
      149 			if valid_area (pv_list.area_ptr) then do;
      150 				if ^ai.no_freeing then
      151 				     free pv_list in (pv_list.area_ptr -> areas);
      152 			     end;
      153 			pv_list_ptr = null ();
      154 		     end;
      155 	     end;
      156 
      157 	if lv_list_ptr ^= null () then do;
      158 		if pv_list_ptr -> pv_list.version ^= get_vol_list_version then goto BAD_VERSION;
      159 		if lv_list_ptr -> lv_list.lv_name_count ^= max_lvs then do;
      160 			if valid_area (lv_list.area_ptr) then do;
      161 				if ^ai.no_freeing then
      162 				     free lv_list in (lv_list.area_ptr -> areas);
      163 			     end;
      164 			lv_list_ptr = null ();
      165 		     end;
      166 	     end;
      167 
      168 /* Allocate space if needed. */
      169 
      170 	if pv_list_ptr = null () then do;
      171 		addr (sizing_array) -> pv_list.pv_name_count = max_pvs;
      172 		alloc_size = currentsize (addr (sizing_array) -> pv_list);
      173 		allocate allocating_array in (areas) set (pv_list_ptr);
      174 		pv_list.pv_name_count = max_pvs;
      175 		pv_list.area_ptr = area_ptr;
      176 	     end;
      177 
      178 	if lv_list_ptr = null () then do;
      179 		addr (sizing_array) -> lv_list.lv_name_count = max_lvs;
      180 		alloc_size = currentsize (addr (sizing_array) -> lv_list);
      181 		allocate allocating_array in (areas) set (lv_list_ptr);
      182 		lv_list.lv_name_count = max_lvs;
      183 		lv_list.area_ptr = area_ptr;
      184 	     end;
      185 
      186 	pv_list.version = get_vol_list_version;
      187 	lv_list.version = get_vol_list_version;
      188 
      189 	pv_list.pv_name_max_length = 0;
      190 	do max_pvs = max_pvs by -1 to 1;
      191 	     pv_list.pv_info (max_pvs).used = dt.array (max_pvs).used;
      192 	     pv_list.pv_info (max_pvs).storage_system = dt.array (max_pvs).storage_system;
      193 	     pv_list.pv_info (max_pvs).permanent = dt.array (max_pvs).permanent;
      194 	     pv_list.pv_info (max_pvs).hc_accepted = dt.array (max_pvs).hc_accepted;
      195 	     pv_list.pv_info (max_pvs).rpv = dt.array (max_pvs).rpv;
      196 	     pv_list.pv_info (max_pvs).is_sub_vol = dt.array (max_pvs).is_sub_vol;
      197 	     pv_list.pv_info (max_pvs).num_of_sv = dt.array (max_pvs).num_of_sv;
      198 	     pv_list.pv_info (max_pvs).sv_num = dt.array (max_pvs).sv_num;
      199 	     pv_list.pv_info (max_pvs).device_type = dt.array (max_pvs).device_type;
      200 	     pv_list.pv_info (max_pvs).lvx = dt.array (max_pvs).lvx;
      201 	     pv_list.pv_info (max_pvs).drive_name = dt.array (max_pvs).drive_name;
      202 	     pv_list.pv_info (max_pvs).pvname = dt.array (max_pvs).pvname;
      203 	     if dt.array (max_pvs).used = "1"b then
      204 		pv_list.pv_name_max_length = max (length (rtrim (pv_list.pv_info (max_pvs).pvname)), pv_list.pv_name_max_length);
      205 	end;
      206 
      207 	lv_list.lv_name_max_length = 0;
      208 	do max_lvs = max_lvs by -1 to 1;
      209 	     lv_list.lv_info (max_lvs).used = dt.lv_array (max_lvs).used;
      210 	     lv_list.lv_info (max_lvs).hv_mounted = dt.lv_array (max_lvs).hv_mounted;
      211 	     lv_list.lv_info (max_lvs).public = dt.lv_array (max_lvs).public;
      212 	     lv_list.lv_info (max_lvs).mounting = dt.lv_array (max_lvs).mounting;
      213 	     lv_list.lv_info (max_lvs).demounting = dt.lv_array (max_lvs).demounting;
      214 	     lv_list.lv_info (max_lvs).pdirs_ok = dt.lv_array (max_lvs).pdirs_ok;
      215 	     lv_list.lv_info (max_lvs).prev_bootload = dt.lv_array (max_lvs).prev_bootload;
      216 	     lv_list.lv_info (max_lvs).vacate_pdirs = dt.lv_array (max_lvs).vacate_pdirs;
      217 	     lv_list.lv_info (max_lvs).lvname = dt.lv_array (max_lvs).lvname;
      218 	     if dt.lv_array (max_lvs).used = "1"b then
      219 		lv_list.lv_name_max_length = max (length (rtrim (lv_list.lv_info (max_lvs).lvname)), lv_list.lv_name_max_length);
      220 	end;
      221 
      222 
      223 /* Cleanup and exit routine. */
      224 
      225 exit:	call release_temp_segment_ (entry_name, temp_ptr, code);
      226 	a_pv_list_ptr = pv_list_ptr;
      227 	a_lv_list_ptr = lv_list_ptr;
      228 	return;
      229 
      230 valid_area:
      231      proc (area_ptr) returns (bit (1));
      232 
      233 /* validates and area and leaves area information in ai. */
      234 
      235 	dcl     area_ptr		 ptr;
      236 
      237 	unspec (ai) = "0"b;
      238 	ai.version = area_info_version_1;
      239 	ai.areap = area_ptr;
      240 	call area_info_ (addr (ai), code);
      241 	if code ^= 0 then
      242 	     return ("0"b);
      243 	if ai.version_of_area ^= ai.version then
      244 	     return ("0"b);
      245 	return ("1"b);
      246      end valid_area;
      247 
  1     1 /* BEGIN INCLUDE FILE - get_vol_list_.incl.pl1 */
  1     2 
  1     3 
  1     4 
  1     5 /****^  HISTORY COMMENTS:
  1     6*  1) change(86-03-12,Fawcett), approve(86-05-13,MCR7383),
  1     7*     audit(86-05-27,Wallman), install(86-07-18,MR12.0-1098):
  1     8*     Add support for subvolumes.
  1     9*                                                   END HISTORY COMMENTS */
  1    10 
  1    11 
  1    12 /* Defines structure interface to the routine get_vol_list_, which acquires
  1    13*   information from the system disk_table on physical and logical volume
  1    14*   names allocates the structures if needed and returns control to the
  1    15*   caller.  The area_ptr in each structure is the area the structure was
  1    16*   allocated in, and can be used for freeing the structure. */
  1    17 
  1    18 /* Created November-22- 1984 by Tom Oke - MDC-ACTC. */
  1    19 
  1    20 /* December 17, 1984 by T. Oke, include version and area_ptr. */
  1    21 
  1    22      dcl	   (lv_list_ptr, pv_list_ptr) ptr;
  1    23 
  1    24      dcl	   get_vol_list_version   char (8) static options (constant) initial ("gvlist02");
  1    25 
  1    26      dcl	   1 pv_list	      based (pv_list_ptr),
  1    27 	     2 version	      char (8) unaligned,		/* struct version */
  1    28 	     2 area_ptr	      ptr,		/* area allocated in */
  1    29 	     2 pv_name_max_length fixed bin,
  1    30 	     2 pv_name_count      fixed bin,
  1    31 	     2 pv_info	      (1 refer (pv_list.pv_name_count)) aligned,
  1    32 	       3 used	      bit (1) unaligned,	/* entry in use */
  1    33 	       3 storage_system   bit (1) unaligned,	/* storage system */
  1    34 	       3 permanent	      bit (1) unaligned,	/* cannot demount */
  1    35 	       3 hc_accepted      bit (1) unaligned,	/* vol accpt ring 0 */
  1    36 	       3 rpv	      bit (1) unaligned,
  1    37 	       3 is_sub_vol	      bit (1) unaligned,
  1    38 	       3 pad	      bit (4) unaligned,
  1    39 	       3 device_type      fixed bin (8) unsigned unaligned,
  1    40 	       3 lvx	      fixed bin unaligned,	/* index in lv_list */
  1    41 	       3 drive_name	      char (8) unaligned,		/* like dska_01 */
  1    42 	       3 pvname	      char (32) unaligned,
  1    43 	       3 sv_num	      fixed bin (17),          /* if this is a subvolume then what number */
  1    44 	       3 num_of_sv	      fixed bin (17);	/* if this is a subvolume how many */
  1    45 
  1    46      dcl	   1 lv_list	      based (lv_list_ptr),
  1    47 	     2 version	      char (8) unaligned,		/* struct version */
  1    48 	     2 area_ptr	      ptr,		/* area allocated in */
  1    49 	     2 lv_name_max_length fixed bin,
  1    50 	     2 lv_name_count      fixed bin,
  1    51 	     2 lv_info	      (1 refer (lv_list.lv_name_count)) aligned,
  1    52 	       3 used	      bit (1) unaligned,	/* in use */
  1    53 	       3 hv_mounted	      bit (1) unaligned,	/* hvol OK */
  1    54 	       3 public	      bit (1) unaligned,	/* public use */
  1    55 	       3 mounting	      bit (1) unaligned,	/* mount in progress */
  1    56 	       3 demounting	      bit (1) unaligned,	/* demount in progress */
  1    57 	       3 pdirs_ok	      bit (1) unaligned,	/* can use pdirs */
  1    58 	       3 prev_bootload    bit (1) unaligned,	/* can auto-accept pvs */
  1    59 	       3 vacate_pdirs     bit (1) unaligned,	/* demand move pdirs */
  1    60 	       3 pad	      bit (26) unaligned,
  1    61 	       3 lvname	      char (32) unaligned;
  1    62 
  1    63 /* END INCLUDE FILE - get_vol_list_.incl.pl1 */
      248 
  2     1 /*	BEGIN INCLUDE FILE ... disk_table.incl.pl1 ... Created Oct 75 for NSS */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  2     6*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  2     7*     Add support for subvolumes.
  2     8*                                                   END HISTORY COMMENTS */
  2     9 
  2    10 
  2    11 /*		Modified July 1977 by T. Casey to add pdirs_ok switch in lve */
  2    12 /*		Modified April 1981 by J. Bongiovanni to add shared_spindle_flip */
  2    13 /*		Modified 831122 by E. A. Ranzenbach to add vacate_pdirs bit to lve. */
  2    14 
  2    15 /* The disk table lives in ring 1. Its entries parallel the PVT */
  2    16 
  2    17 dcl  dtp ptr,
  2    18      dtep ptr,
  2    19      lvep ptr;
  2    20 
  2    21      
  2    22 
  2    23 dcl 1 dt based (dtp) aligned,
  2    24 
  2    25     2 n_entries fixed bin (17),			/* number of disk table entries */
  2    26     2 max_n_entries fixed bin (17),			/* max number of disk table entries */
  2    27     2 n_in_use fixed bin (17),			/* number of disk table entries in use */
  2    28     2 rpvx fixed bin,				/* index (pvtx, too) of the RPV */
  2    29     2 version fixed bin init (1),
  2    30     2 n_lv_entries fixed bin,				/* Number of LV entries */
  2    31     2 pad (2) bit (36),
  2    32     2 array (0 refer (dt.max_n_entries)) like dte,
  2    33     2 lv_array (0 refer (dt.max_n_entries)) like lve;
  2    34 
  2    35 dcl 1 dte based (dtep) aligned,
  2    36     2 drive_name char (8),				/* device name */
  2    37     (2 device_type fixed bin (8),			/* device type */
  2    38     2 used bit (1),					/* TRUE if this entry is used for paging */
  2    39     2 known bit (1),				/* TRUE if label has been read and checked */
  2    40     2 storage_system bit (1),				/* TRUE for storage system (vs io disk) */
  2    41     2 permanent bit (1),				/* TRUE if cannot be demounted */
  2    42     2 deleted bit (1),				/* TRUE if deleted by "deld" */
  2    43     2 rpv bit (1),					/* TRUE if the root physical volume */
  2    44     2 demounted bit (1),				/* TRUE if was here or was assumed here */
  2    45     2 need_salvage bit (1),				/* TRUE if this vol was volsalv'd automatic */
  2    46     2 hc_accepted bit (1),				/* TRUE if vol accepted by ring 0 init */
  2    47     2 shared_spindle_flip bit (1),			/* used by ring-4 for shared spindle allocation */
  2    48     2 is_sub_vol bit (1),
  2    49     2 pad bit (3),
  2    50     2 lvx fixed bin (11),				/* index in lv_array of lve */
  2    51     2 pre_accepted bit (1)) unaligned,			/* TRUE if was used in previous bootload */
  2    52     2 sv_num  fixed bin unal,				/* this sv number */
  2    53     2 num_of_sv fixed bin unal,			/* number of sv for this pv */
  2    54     2 sv_name   char (2) aligned,
  2    55     2 pvid bit (36),				/* physical volume ID */
  2    56     2 pvname char (32);				/* Physical volume name. */
  2    57 
  2    58 dcl 1 lve based (lvep) aligned,
  2    59     2 lvid bit (36),				/* logical volume ID */
  2    60     (2 used bit (1),				/* TRUE if entry used */
  2    61     2 hv_mounted bit (1),				/* TRUE if hvol is really OK */
  2    62     2 public bit (1),				/* TRUE for public vol */
  2    63     2 mounting bit (1),				/* TRUE if mhv is in progress */
  2    64     2 demounting bit (1),				/* TRUE if dhv is in progress */
  2    65     2 good_candidate bit (1) unal,			/* used for auto dhv */
  2    66     2 demounted_only bit (1) unal,			/* lve here only to warm demounted pve's */
  2    67     2 pdirs_ok bit (1) unal,				/* TRUE if process directory segments can be on this lv */
  2    68     2 prev_bootload bit (1) unal,			/* TRUE if can auto-accept pvs */
  2    69     2 vacate_pdirs bit (1) unal,			/* if TRUE we will demand move all perprocess segs */
  2    70     2 pad bit (26)) unal,
  2    71     2 lvname char (32),				/* Logical volume name */
  2    72     2 min_access_class bit (72),			/* Security stuff */
  2    73     2 max_access_class bit (72);			/* .. */
  2    74 
  2    75 /*	END INCLUDE FILE ...disk_table.incl.pl1 */
      249 
  3     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  3     2 
  3     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  3     4 
  3     5 dcl  area_infop ptr;
  3     6 
  3     7 dcl 1 area_info aligned based (area_infop),
  3     8     2 version fixed bin,				/* version number for this structure is 1 */
  3     9     2 control aligned like area_control,		/* control bits for the area */
  3    10     2 owner char (32) unal,				/* creator of the area */
  3    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  3    12     2 size fixed bin (18),				/* size of the area in words */
  3    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  3    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  3    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  3    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  3    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  3    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  3    19 
  3    20 dcl 1 area_control aligned based,
  3    21     2 extend bit (1) unal,				/* says area is extensible */
  3    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  3    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  3    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  3    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  3    26     2 system bit (1) unal,				/* says area is managed by system */
  3    27     2 pad bit (30) unal;
  3    28 
  3    29 /* END INCLUDE FILE area_info.incl.pl1 */
      250 
      251      end get_vol_list_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    01/09/87  1314.5  get_vol_list_.pl1                 >spec>install>1266>get_vol_list_.pl1
248          1    07/24/86  2051.8  get_vol_list_.incl.pl1            >ldd>include>get_vol_list_.incl.pl1
249          2    07/24/86  2051.9  disk_table.incl.pl1               >ldd>include>disk_table.incl.pl1
250          3    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_area_ptr                             parameter       pointer                  dcl 50 set ref 21 105 107* 107
a_code                                 parameter       fixed bin(35,0)          dcl 52 set ref 21 101* 110* 122* 129*
a_lv_list_ptr                          parameter       pointer                  dcl 49 set ref 21 144 227*
a_pv_list_ptr                          parameter       pointer                  dcl 48 set ref 21 143 226*
a_version                              parameter       char(8)                  unaligned dcl 51 ref 21 100
addr                                                   builtin function         dcl 64 ref 171 172 179 180 240 240
ai                              000104 automatic       structure                level 1 unaligned dcl 59 set ref 237* 240 240
alloc_size                      000142 automatic       fixed bin(17,0)          dcl 87 set ref 172* 173 180* 181
allocating_array                       based           fixed bin(35,0)          array dcl 86 ref 173 181
area_control                           based           structure                level 1 dcl 3-20
area_info                              based           structure                level 1 dcl 3-7
area_info_                      000010 constant        entry                    external dcl 92 ref 240
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 3-3 ref 238
area_ptr                  2            based           pointer                  level 2 in structure "pv_list" dcl 1-26 in procedure
                                                                                  "get_vol_list_" set ref 149* 150 175*
area_ptr                  2            based           pointer                  level 2 in structure "lv_list" dcl 1-46 in procedure
                                                                                  "get_vol_list_" set ref 160* 161 183*
area_ptr                               parameter       pointer                  dcl 235 in procedure "valid_area" ref 230 239
area_ptr                        000100 automatic       pointer                  dcl 56 in procedure "get_vol_list_" set ref 105*
                                                                                  107* 173 175 181 183
areap                    16     000104 automatic       pointer                  level 2 dcl 59 set ref 239*
areas                                  based           area(1024)               dcl 74 ref 150 161 173 181
array                    10            based           structure                array level 2 dcl 2-23
cleanup                         000134 stack reference condition                dcl 66 ref 116
code                            000102 automatic       fixed bin(35,0)          dcl 57 set ref 117* 120* 121 122 127* 128 129 225*
                                                                                  240* 241
control                   1     000104 automatic       structure                level 2 dcl 59
currentsize                                            builtin function         dcl 64 ref 172 180
demounting                             based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 213
demounting                6(04)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 213*
device_type               6(10)        based           fixed bin(8,0)           array level 3 in structure "pv_list" packed unsigned
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 199*
device_type              12            based           fixed bin(8,0)           array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 199
drive_name               10            based           char(8)                  array level 3 in structure "dt" dcl 2-23
                                                                                  in procedure "get_vol_list_" ref 201
drive_name                7            based           char(8)                  array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 201*
dt                                     based           structure                level 1 dcl 2-23
dte                                    based           structure                level 1 dcl 2-35
dtp                             000162 automatic       pointer                  dcl 2-17 set ref 126* 127* 135 136 136 139 191 192
                                                                                  193 194 195 196 197 198 199 200 201 202 203 209
                                                                                  210 211 212 213 214 215 216 217 218
entry_name                      000002 constant        char(32)                 initial unaligned dcl 70 set ref 117* 120* 225*
error_table_$improper_data_format
                                000012 external static fixed bin(35,0)          dcl 93 ref 110
error_table_$unimplemented_version
                                000014 external static fixed bin(35,0)          dcl 94 ref 101
get_system_free_area_           000024 constant        entry                    external dcl 98 ref 105
get_temp_segment_               000016 constant        entry                    external dcl 95 ref 120
get_vol_list_version            000000 constant        char(8)                  initial unaligned dcl 1-24 ref 100 147 158 186 187
hc_accepted              12(17)        based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 194
hc_accepted               6(03)        based           bit(1)                   array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 194*
hv_mounted                             based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 210
hv_mounted                6(01)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 210*
i                               000103 automatic       fixed bin(17,0)          dcl 58 set ref 135* 136 136 136 139 139*
is_sub_vol               12(19)        based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 136 196
is_sub_vol                6(05)        based           bit(1)                   array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 196*
length                                                 builtin function         dcl 64 ref 203 218
lv_array                               based           structure                array level 2 dcl 2-23
lv_info                   6            based           structure                array level 2 dcl 1-46
lv_list                                based           structure                level 1 unaligned dcl 1-46 set ref 161 180
lv_list_ptr                     000156 automatic       pointer                  dcl 1-22 set ref 144* 157 159 160 161 161 164* 178
                                                                                  181* 182 183 187 207 209 210 211 212 213 214 215
                                                                                  216 217 218 218 218 227
lv_name_count             5            based           fixed bin(17,0)          level 2 dcl 1-46 set ref 159 161 179* 180 182*
lv_name_max_length        4            based           fixed bin(17,0)          level 2 dcl 1-46 set ref 207* 218* 218
lve                                    based           structure                level 1 dcl 2-58
lvname                    7            based           char(32)                 array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 217* 218
lvname                                 based           char(32)                 array level 3 in structure "dt" dcl 2-23
                                                                                  in procedure "get_vol_list_" ref 217
lvx                       6(18)        based           fixed bin(17,0)          array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 200*
lvx                      12(23)        based           fixed bin(11,0)          array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 200
max                                                    builtin function         dcl 64 ref 203 218
max_lvs                         000130 automatic       fixed bin(17,0)          dcl 60 set ref 139* 159 179 182 208* 208* 209 209
                                                                                  210 210 211 211 212 212 213 213 214 214 215 215
                                                                                  216 216 217 217 218 218*
max_n_entries             1            based           fixed bin(17,0)          level 2 dcl 2-23 ref 135 139 209 210 211 212 213 214
                                                                                  215 216 217 218
max_pvs                         000131 automatic       fixed bin(17,0)          dcl 61 set ref 136* 148 171 174 190* 190* 191 191
                                                                                  192 192 193 193 194 194 195 195 196 196 197 197
                                                                                  198 198 199 199 200 200 201 201 202 202 203 203*
mdc_$read_disk_table            000020 constant        entry                    external dcl 96 ref 127
mounting                               based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 212
mounting                  6(03)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 212*
no_freeing                1(04) 000104 automatic       bit(1)                   level 3 packed unaligned dcl 59 set ref 150 161
null                                                   builtin function         dcl 64 ref 105 114 117 146 153 157 164 170 178
num_of_sv                13(18)        based           fixed bin(17,0)          array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 197
num_of_sv                22            based           fixed bin(17,0)          array level 3 in structure "pv_list" dcl 1-26
                                                                                  in procedure "get_vol_list_" set ref 197*
pdirs_ok                               based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 214
pdirs_ok                  6(05)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 214*
permanent                 6(02)        based           bit(1)                   array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 193*
permanent                12(12)        based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 193
prev_bootload                          based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 215
prev_bootload             6(06)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 215*
public                                 based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 211
public                    6(02)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 211*
pv_info                   6            based           structure                array level 2 dcl 1-26
pv_list                                based           structure                level 1 unaligned dcl 1-26 set ref 150 172
pv_list_ptr                     000160 automatic       pointer                  dcl 1-22 set ref 143* 146 147 148 149 150 150 153*
                                                                                  158 170 173* 174 175 186 189 191 192 193 194 195
                                                                                  196 197 198 199 200 201 202 203 203 203 226
pv_name_count             5            based           fixed bin(17,0)          level 2 dcl 1-26 set ref 148 150 171* 172 174*
pv_name_max_length        4            based           fixed bin(17,0)          level 2 dcl 1-26 set ref 189* 203* 203
pvname                   11            based           char(32)                 array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 202* 203
pvname                   16            based           char(32)                 array level 3 in structure "dt" dcl 2-23
                                                                                  in procedure "get_vol_list_" ref 202
release_temp_segment_           000022 constant        entry                    external dcl 97 ref 117 225
rpv                       6(04)        based           bit(1)                   array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 195*
rpv                      12(14)        based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 195
rtrim                                                  builtin function         dcl 64 ref 203 218
sizing_array                    000143 automatic       fixed bin(35,0)          array dcl 88 set ref 171 172 179 180
storage_system           12(11)        based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 192
storage_system            6(01)        based           bit(1)                   array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 192*
sv_num                   21            based           fixed bin(17,0)          array level 3 in structure "pv_list" dcl 1-26
                                                                                  in procedure "get_vol_list_" set ref 198*
sv_num                   13            based           fixed bin(17,0)          array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 198
temp_ptr                        000132 automatic       pointer                  dcl 62 set ref 114* 117 117* 120* 126 225*
unspec                                                 builtin function         dcl 64 set ref 237*
used                                   based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 139 209
                                                                                  218
used                      6            based           bit(1)                   array level 3 in structure "pv_list" packed
                                                                                  unaligned dcl 1-26 in procedure "get_vol_list_"
                                                                                  set ref 191*
used                     12(09)        based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 136 191
                                                                                  203
used                      6            based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 209*
vacate_pdirs                           based           bit(1)                   array level 3 in structure "dt" packed unaligned
                                                                                  dcl 2-23 in procedure "get_vol_list_" ref 216
vacate_pdirs              6(07)        based           bit(1)                   array level 3 in structure "lv_list" packed
                                                                                  unaligned dcl 1-46 in procedure "get_vol_list_"
                                                                                  set ref 216*
version                         000104 automatic       fixed bin(17,0)          level 2 in structure "ai" dcl 59 in procedure
                                                                                  "get_vol_list_" set ref 238* 243
version                                based           char(8)                  level 2 in structure "lv_list" packed unaligned
                                                                                  dcl 1-46 in procedure "get_vol_list_" set ref 187*
version                                based           char(8)                  level 2 in structure "pv_list" packed unaligned
                                                                                  dcl 1-26 in procedure "get_vol_list_" set ref 147
                                                                                  158 186*
version_of_area          14     000104 automatic       fixed bin(17,0)          level 2 dcl 59 set ref 243

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
area_infop                             automatic       pointer                  dcl 3-5
dtep                                   automatic       pointer                  dcl 2-17
lvep                                   automatic       pointer                  dcl 2-17

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_VERSION                     000044 constant        label                    dcl 101 ref 147 158
exit                            001005 constant        label                    dcl 225 ref 130
get_vol_list_                   000031 constant        entry                    external dcl 21
valid_area                      001034 constant        entry                    internal dcl 230 ref 107 149 160

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      1244        1272    1111        1254
Length      1516    1111        26         207     132           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
get_vol_list_                       164 external procedure  is an external procedure.  
on unit on line 116                  78 on unit               
valid_area                              internal procedure  shares stack frame of external procedure get_vol_list_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
get_vol_list_            000100 area_ptr                    get_vol_list_
                         000102 code                        get_vol_list_
                         000103 i                           get_vol_list_
                         000104 ai                          get_vol_list_
                         000130 max_lvs                     get_vol_list_
                         000131 max_pvs                     get_vol_list_
                         000132 temp_ptr                    get_vol_list_
                         000142 alloc_size                  get_vol_list_
                         000143 sizing_array                get_vol_list_
                         000156 lv_list_ptr                 get_vol_list_
                         000160 pv_list_ptr                 get_vol_list_
                         000162 dtp                         get_vol_list_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        return_mac          enable_op           ext_entry           int_entry
op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
area_info_                    get_system_free_area_         get_temp_segment_             mdc_$read_disk_table
release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$improper_data_format                           error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     21 000024       100 000036       101 000044       102 000050       105 000051       107 000064       110 000104
    111 000110       114 000111       116 000113       117 000127       118 000154       120 000155       121 000176
    122 000200       123 000202       126 000203       127 000205       128 000216       129 000220       130 000222
    135 000223       136 000233       139 000243       141 000255       143 000257       144 000263       146 000266
    147 000272       148 000276       149 000301       150 000314       153 000325       157 000327       158 000333
    159 000340       160 000344       161 000357       164 000370       170 000372       171 000376       172 000400
    173 000403       174 000410       175 000412       178 000414       179 000420       180 000422       181 000425
    182 000432       183 000434       186 000436       187 000442       189 000445       190 000446       191 000453
    192 000466       193 000473       194 000500       195 000505       196 000512       197 000517       198 000524
    199 000527       200 000534       201 000542       202 000546       203 000553       205 000601       207 000604
    208 000606       209 000613       210 000634       211 000656       212 000667       213 000700       214 000711
    215 000722       216 000733       217 000744       218 000754       220 001002       225 001005       226 001026
    227 001031       228 001033       230 001034       237 001036       238 001041       239 001043       240 001046
    241 001061       243 001071       245 001102


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
