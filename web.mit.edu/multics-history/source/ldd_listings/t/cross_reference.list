	COMPILATION LISTING OF SEGMENT cross_reference
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 04/09/85  1139.4 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 cross_reference: cref:
       12      procedure options (variable);
       13 
       14 /* CROSS_REFERENCE
       15*
       16*   Program to make a cross reference listing from object
       17*   segments.
       18*
       19*   Modified 741127 by PG for Version II PL/I
       20*   Modified 750411 by PG to handle errors better
       21*   Totally discombobulated to change command syntax by C. D. Tavares, 02/76
       22*   Modified 11/19/76 by CDT to allow output to be an MSF.
       23*   Modified 09/24/78 by CDT to fix a few bugs in input file parsing.
       24*   Modified 10/13/80 by CDT to add -line_length control arg.
       25*   Modified 2/82 BIM for add_suffix.
       26**/
       27 
       28 /* automatic */
       29 
       30 dcl 1 auto_area_info like area_info aligned automatic;	/* see include file below */
       31 
       32 dcl  eof bit (1) aligned,
       33      char_idx fixed bin (21),
       34      temp_dir char (168) varying,
       35      temp_string char (168),
       36      search_dir char (168),
       37      token char (200) varying,
       38      save_token char (200) varying,
       39      master_node pointer,
       40      al fixed bin (21),
       41      bitcount fixed bin (24),
       42      seg_count fixed bin,
       43      char_count fixed bin (21),
       44      code fixed bin (35),
       45     (i, j) fixed bin,
       46      n_pathnames fixed bin,
       47      given_ll fixed bin,
       48      nargs fixed bin,
       49     (input_seg_ptr, test_outseg_ptr, output_seg_ptr, err_seg_ptr, msf_fcb_ptr, ap) ptr,
       50      cur_dir_description char (168) varying;
       51 
       52 dcl  first_pass bit (1) aligned,
       53      cur_all_option bit (1) aligned,
       54      first_switch bit (1) aligned,
       55      do_include_files bit (1) aligned,
       56      short_switch bit (1) aligned,
       57      brief_switch bit (1) aligned;
       58 
       59 dcl (input_filename, output_filename) char (168),
       60     (input_filedir, output_filedir) char (168);
       61 
       62 /* external static */
       63 
       64 dcl (error_table_$noarg,
       65      error_table_$inconsistent,
       66      error_table_$badopt) fixed bin (35) external static;
       67 
       68 dcl  sys_info$max_seg_size ext fixed bin (35) static;
       69 
       70 /* internal static */
       71 
       72 dcl (Segs_only fixed bin initial (2),
       73      Nondir_segment bit (2) initial ("01"b)) static options (constant);
       74 
       75 /* based variables and their pointers */
       76 
       77 dcl 1 star_structure (seg_count) aligned based (star_struc_ptr),
       78     2 type bit (2) unaligned,
       79     2 nnames bit (16) unaligned,
       80     2 nindex bit (18) unaligned;
       81 
       82 dcl  star_struc_ptr pointer;
       83 
       84 dcl  star_names (1000) based (star_names_ptr) char (32);
       85 
       86 dcl  star_names_ptr pointer;
       87 
       88 dcl  system_free_area area based (system_free_ptr),
       89      system_free_ptr pointer;
       90 
       91 dcl 1 search_dir_struc aligned based (search_dir_ptr),
       92     2 make_all_names_external bit (1) aligned,
       93     2 max_dirs fixed bin,
       94     2 n_dirs fixed bin,
       95     2 item (N_DIRS refer (search_dir_struc.max_dirs)),
       96       3 search_dirs char (168),
       97       3 search_dir_descriptions char (168) varying;
       98 
       99 dcl  N_DIRS fixed bin static options (constant) initial (32),
      100      search_dir_ptr pointer;
      101 dcl  CROSSREF char (8) internal static options (constant) init ("crossref");
      102 dcl 1 pathname_struc based (pathname_ptr),
      103     2 xxx fixed bin,
      104     2 array (nargs refer (xxx)),
      105       3 pathname char (168),
      106       3 dirname char (168),
      107       3 ename char (32),
      108       3 dir_description char (168) varying,
      109       3 is_starname bit (1),
      110       3 all_option bit (1) aligned;
      111 
      112 dcl  pathname_ptr pointer;
      113 
      114 
      115 dcl  arg char (al) based (ap);
      116 
  1     1 /* BEGIN INCLUDE FILE area_info.incl.pl1  12/75 */
  1     2 
  1     3 dcl  area_info_version_1 fixed bin static init (1) options (constant);
  1     4 
  1     5 dcl  area_infop ptr;
  1     6 
  1     7 dcl 1 area_info aligned based (area_infop),
  1     8     2 version fixed bin,				/* version number for this structure is 1 */
  1     9     2 control aligned like area_control,		/* control bits for the area */
  1    10     2 owner char (32) unal,				/* creator of the area */
  1    11     2 n_components fixed bin,				/* number of components in the area (returned only) */
  1    12     2 size fixed bin (18),				/* size of the area in words */
  1    13     2 version_of_area fixed bin,			/* version of area (returned only) */
  1    14     2 areap ptr,					/* pointer to the area (first component on multisegment area) */
  1    15     2 allocated_blocks fixed bin,			/* number of blocks allocated */
  1    16     2 free_blocks fixed bin,				/* number of free blocks not in virgin */
  1    17     2 allocated_words fixed bin (30),			/* number of words allocated in the area */
  1    18     2 free_words fixed bin (30);			/* number of words free in area not in virgin */
  1    19 
  1    20 dcl 1 area_control aligned based,
  1    21     2 extend bit (1) unal,				/* says area is extensible */
  1    22     2 zero_on_alloc bit (1) unal,			/* says block gets zerod at allocation time */
  1    23     2 zero_on_free bit (1) unal,			/* says block gets zerod at free time */
  1    24     2 dont_free bit (1) unal,			/* debugging aid, turns off free requests */
  1    25     2 no_freeing bit (1) unal,			/* for allocation method without freeing */
  1    26     2 system bit (1) unal,				/* says area is managed by system */
  1    27     2 pad bit (30) unal;
  1    28 
  1    29 /* END INCLUDE FILE area_info.incl.pl1 */
      117 
  2     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  2     2*
  2     3*   Values for the "access mode" argument so often used in hardcore
  2     4*   James R. Davis 26 Jan 81  MCR 4844
  2     5*   Added constants for SM access 4/28/82 Jay Pattin
  2     6*   Added text strings 03/19/85 Chris Jones
  2     7**/
  2     8 
  2     9 
  2    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  2    11 dcl	(
  2    12 	N_ACCESS		   init ("000"b),
  2    13 	R_ACCESS		   init ("100"b),
  2    14 	E_ACCESS		   init ("010"b),
  2    15 	W_ACCESS		   init ("001"b),
  2    16 	RE_ACCESS		   init ("110"b),
  2    17 	REW_ACCESS	   init ("111"b),
  2    18 	RW_ACCESS		   init ("101"b),
  2    19 	S_ACCESS		   init ("100"b),
  2    20 	M_ACCESS		   init ("010"b),
  2    21 	A_ACCESS		   init ("001"b),
  2    22 	SA_ACCESS		   init ("101"b),
  2    23 	SM_ACCESS		   init ("110"b),
  2    24 	SMA_ACCESS	   init ("111"b)
  2    25 	)		   bit (3) internal static options (constant);
  2    26 
  2    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  2    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  2    29 
  2    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  2    31 			   static options (constant);
  2    32 
  2    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  2    34 			   static options (constant);
  2    35 
  2    36 dcl	(
  2    37 	N_ACCESS_BIN	   init (00000b),
  2    38 	R_ACCESS_BIN	   init (01000b),
  2    39 	E_ACCESS_BIN	   init (00100b),
  2    40 	W_ACCESS_BIN	   init (00010b),
  2    41 	RW_ACCESS_BIN	   init (01010b),
  2    42 	RE_ACCESS_BIN	   init (01100b),
  2    43 	REW_ACCESS_BIN	   init (01110b),
  2    44 	S_ACCESS_BIN	   init (01000b),
  2    45 	M_ACCESS_BIN	   init (00010b),
  2    46 	A_ACCESS_BIN	   init (00001b),
  2    47 	SA_ACCESS_BIN	   init (01001b),
  2    48 	SM_ACCESS_BIN	   init (01010b),
  2    49 	SMA_ACCESS_BIN	   init (01011b)
  2    50 	)		   fixed bin (5) internal static options (constant);
  2    51 
  2    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      118 
  3     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  3     2 /* format: style2,^inddcls,idind32 */
  3     3 
  3     4 declare 1 terminate_file_switches	based,
  3     5 	2 truncate		bit (1) unaligned,
  3     6 	2 set_bc			bit (1) unaligned,
  3     7 	2 terminate		bit (1) unaligned,
  3     8 	2 force_write		bit (1) unaligned,
  3     9 	2 delete			bit (1) unaligned;
  3    10 
  3    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  3    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  3    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  3    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  3    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  3    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  3    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  3    18 
  3    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      119 
      120 
      121 /* entries */
      122 
      123 dcl  define_area_ ext entry (pointer, fixed bin (35)),
      124      release_area_ ext entry (pointer);
      125 
      126 dcl  com_err_ entry options (variable),
      127      cref_sort_ ext entry,
      128      cref_listman_$init ext entry (ptr),
      129      cref_analyze_$init ext entry (bit (1) aligned, bit (1) aligned, pointer),
      130      cu_$arg_ptr entry (fixed, ptr, fixed bin (21), fixed bin (35)),
      131      cu_$arg_count ext entry (fixed bin),
      132      cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35)),
      133      expand_pathname_ entry (char (*), char (*), char (*), fixed bin (35)),
      134      cref_filegen_$init ext entry (ptr, bit (1) aligned, bit (1) aligned, pointer, fixed bin),
      135      cref_filegen_ entry (ptr, ptr),
      136      hcs_$delentry_seg entry (ptr, fixed bin (35)),
      137      initiate_file_ entry (character (*), character (*), bit (*), pointer, fixed binary (24),
      138 	fixed binary (35)),
      139      terminate_file_ entry (pointer, fixed binary (24), bit (*), fixed binary (35)),
      140      absolute_pathname_$add_suffix ext entry (char (*), char (*), char (*), fixed bin (35)),
      141     (get_temp_segment_, release_temp_segment_) ext entry (char (*), pointer, fixed bin (35)),
      142      hcs_$truncate_seg ext entry (pointer, fixed bin, fixed bin (35)),
      143      pathname_ entry (character (*), character (*)) returns(character (168)),
      144      cref_analyze_ entry (char (*), bit (1) aligned);
      145 
      146 dcl  get_system_free_area_ ext entry returns (pointer);
      147 
      148 dcl  hcs_$star_ ext entry (char (*), char (*), fixed bin, pointer, fixed bin, pointer, pointer, fixed bin (35)),
      149      check_star_name_$entry ext entry (char (*), fixed bin (35));
      150 
      151 dcl  cref_listman_$predefine_primary_block_char ext entry (char (*) varying, pointer, pointer,
      152      bit (1) aligned, bit (1) aligned, bit (1) aligned) returns (pointer),
      153      cref_listman_$create_syn_block ext entry (char (*) varying, pointer, pointer, bit (1) aligned, pointer);
      154 
      155 dcl  msf_manager_$open ext entry (char (*), char (*), pointer, fixed bin (35)),
      156      msf_manager_$get_ptr ext entry (pointer, fixed bin, bit (1) aligned, pointer, fixed bin (24), fixed bin (35)),
      157      msf_manager_$adjust ext entry (pointer, fixed bin, fixed bin (24), bit (3) aligned, fixed bin (35)),
      158      msf_manager_$close ext entry (pointer);
      159 
      160 /* builtins */
      161 
      162 dcl (addr, binary, hbound, length, null, rtrim, search, substr, unspec, verify) builtin;
      163 
      164 /* conditions */
      165 
      166 dcl (cleanup, cref_abort_) condition;
      167 
      168 
      169 /* program */
      170 
      171 /* initialize random variables */
      172 
      173 	unspec (auto_area_info) = ""b;
      174 
      175 	test_outseg_ptr, err_seg_ptr, auto_area_info.areap, search_dir_ptr,
      176 	     input_seg_ptr, output_seg_ptr, pathname_ptr, star_struc_ptr, star_names_ptr, msf_fcb_ptr = null;
      177 	input_filename, output_filename = "";
      178 	cur_all_option = ""b;
      179 	given_ll = -1;
      180 
      181 	system_free_ptr = get_system_free_area_ ();
      182 	first_switch = ""b;
      183 	short_switch, do_include_files = ""b;
      184 	brief_switch = ""b;
      185 
      186 	call cu_$arg_count (nargs);
      187 	if nargs = 0 then do;			/* if no args */
      188 	     call com_err_ (error_table_$noarg, "cross_reference", "
      189      Basic usage: cross_reference pathname1 ... pathname_n");
      190 	     return;
      191 	end;
      192 
      193 	auto_area_info.version = area_info_version_1;
      194 	auto_area_info.extend, auto_area_info.no_freeing = "1"b; /* currently doesn't work */
      195 	auto_area_info.size = sys_info$max_seg_size;
      196 	auto_area_info.owner = "cross_reference";
      197 
      198 	call define_area_ (addr (auto_area_info), code);
      199 	if code ^= 0 then call crump (code, "temp area creation.");
      200 
      201 	allocate search_dir_struc in (system_free_area);
      202 
      203 	search_dir_struc.make_all_names_external = ""b;
      204 	search_dir_struc.n_dirs = 0;
      205 
      206 	allocate pathname_struc in (system_free_area);
      207 
      208 	n_pathnames = 0;
      209 	cur_dir_description = "";
      210 
      211 	do i = 1 to nargs;
      212 
      213 	     call cu_$arg_ptr (i, ap, al, code);
      214 
      215 	     if substr (arg, 1, 1) = "-" then do;
      216 
      217 		if (arg = "-input_file") | (arg = "-if") then do;
      218 		     if input_filename ^= "" then call crump (error_table_$inconsistent,
      219 			"Input file may only be specified once.");
      220 		     if i = nargs then call crump (error_table_$noarg,
      221 			"-input_file must be followed by the name of an input file.");
      222 
      223 		     i = i + 1;
      224 		     call cu_$arg_ptr (i, ap, al, code);
      225 		     call absolute_pathname_$add_suffix (arg, "crl", input_filename, code);
      226 		     if code ^= 0 then call crump (code, arg);
      227 		end;
      228 
      229 		else if (arg = "-output_file") | (arg = "-of") then do;
      230 		     if output_filename ^= "" then call crump (error_table_$inconsistent,
      231 			"Output file may only be specified once.");
      232 		     if i = nargs then call crump (error_table_$noarg,
      233 			"-output_file must be followed by the name of an output file.");
      234 
      235 		     i = i + 1;
      236 		     call cu_$arg_ptr (i, ap, al, code);
      237 		     call absolute_pathname_$add_suffix (arg, CROSSREF, output_filename, code);
      238 		     if code ^= 0 then call crump (code, arg);
      239 		end;
      240 
      241 		else if arg = "-first" then first_switch = "1"b;
      242 
      243 		else if (arg = "-brief" | arg = "-bf") then brief_switch = "1"b;
      244 
      245 		else if arg = "-all" then cur_all_option = "1"b;
      246 
      247 		else if (arg = "-library" | arg = "-lb") then do;
      248 		     cur_all_option = ""b;
      249 		     i = i + 1;
      250 		     call cu_$arg_ptr (i, ap, al, code);
      251 		     cur_dir_description = arg;
      252 		end;
      253 
      254 		else if (arg = "-include_files" | arg = "-icf") then do_include_files = "1"b;
      255 
      256 		else if (arg = "-short" | arg = "-sh") then short_switch = "1"b;
      257 
      258 		else if (arg = "-ll" | arg = "-line_length") then do;
      259 		     if i = nargs then call crump (error_table_$noarg,
      260 			"-ll must be followed by number.");
      261 
      262 		     i = i + 1;
      263 		     call cu_$arg_ptr (i, ap, al, code);
      264 		     given_ll = cv_dec_check_ (arg, code);
      265 		     if code ^= 0 then call crump (0, arg || " non-numeric.");
      266 		end;
      267 
      268 		else call crump (error_table_$badopt, arg);
      269 	     end;
      270 
      271 	     else do;
      272 		n_pathnames = n_pathnames + 1;
      273 		pathname (n_pathnames) = arg;
      274 		dir_description (n_pathnames) = cur_dir_description;
      275 		all_option (i) = cur_all_option;
      276 	     end;
      277 	end;
      278 
      279 /* check for wierd and illegal combinations of control args */
      280 
      281 	if input_filename ^= "" then
      282 	     if n_pathnames > 0 then call crump (error_table_$inconsistent,
      283 		"-input_file cannot be specified with explicit pathnames.");
      284 	     else if cur_dir_description ^= "" then call crump (error_table_$inconsistent, "-input_file and -library");
      285 
      286 	if n_pathnames > 0 then
      287 	     if first_switch
      288 	     then call crump (error_table_$inconsistent, "-first meaningless with explicit pathnames.");
      289 
      290 
      291 /* Create temp files, etc. */
      292 
      293 	if output_filename = "" then
      294 	     if input_filename = "" then
      295 		output_filename = "crossref.crossref";
      296 	     else do;
      297 
      298 		call expand_pathname_ (input_filename, (""), output_filename, code);
      299 		if code ^= 0 then call crump (code, output_filename);
      300 
      301 		output_filename = rtrim (before (output_filename, ".crl")) || "." ||
      302 		     CROSSREF;
      303 
      304 	     end;
      305 
      306 
      307 	call get_temp_segment_ ("cross_reference", err_seg_ptr, code);
      308 	if err_seg_ptr = null then call crump (code, "err segment creation.");
      309 
      310 	temp_string = output_filename;
      311 	call expand_pathname_ (temp_string, output_filedir, output_filename, code);
      312 	if code ^= 0 then call crump (code, temp_string);
      313 
      314 	call msf_manager_$open (output_filedir, output_filename, msf_fcb_ptr, code);
      315 	if msf_fcb_ptr = null then goto output_seg_err;
      316 
      317 	call msf_manager_$get_ptr (msf_fcb_ptr, /* component */ 0, "1"b /* ok to create */, test_outseg_ptr, 0, code);
      318 						/* initiate it just to see if everything is OK, but NOT
      319*						   using output_seg_ptr so that we don't delete the seg on
      320*						   an error, in case there is already something in it */
      321 	if test_outseg_ptr = null then do;
      322 output_seg_err:
      323 	     call com_err_ (code, "cross_reference", "^a.", pathname_ (output_filedir, output_filename));
      324 	     goto err_return;
      325 	end;
      326 
      327 	if code = 0 then output_seg_ptr = test_outseg_ptr;
      328 						/* we really did create it, OK to delete on an err */
      329 
      330 
      331 	call cref_listman_$init (auto_area_info.areap);
      332 	call cref_analyze_$init (first_switch, do_include_files, search_dir_ptr);
      333 	call cref_filegen_$init (err_seg_ptr, brief_switch, short_switch,
      334 	     auto_area_info.areap, given_ll);
      335 
      336 
      337 	on cref_abort_ go to unwind_and_abort;		/* handle error case */
      338 	on cleanup call clean_up;			/* and cleanups, too  */
      339 	
      340 	if input_filename ^= "" then do;		/* do the whole thing out of an input file */
      341 
      342 	     temp_string = input_filename;
      343 	     call expand_pathname_ (temp_string, input_filedir, input_filename, code);
      344 	     if code ^= 0 then call crump (code, temp_string);
      345 
      346 	     call initiate_file_ (input_filedir, input_filename, R_ACCESS, input_seg_ptr, bitcount, code);
      347 
      348 	     if code ^= 0 then do;
      349 		if input_seg_ptr ^= null /* zero_length */
      350 		then call terminate_file_ (input_seg_ptr, (0), TERM_FILE_TERM, (0));
      351 		call com_err_ (code, "cross_reference", "^a", pathname_ (input_filedir, input_filename));
      352 		goto err_return;
      353 	     end;
      354 
      355 	     char_count = divide (bitcount, 9, 35, 0);
      356 
      357 	     do first_pass = "1"b, ""b;
      358 		char_idx = 1;			/* char index into driving file */
      359 		eof = ""b;
      360 
      361 		token = get_token ();
      362 
      363 		do while (^eof);
      364 
      365 		     if (token = "-library" | token = "-lb") then do;
      366 
      367 			token = get_token ();
      368 
      369 			if token = "-all" then do;
      370 			     cur_all_option = "1"b;
      371 			     token = get_token ();
      372 			end;
      373 
      374 			else cur_all_option = ""b;
      375 
      376 			if token ^= ":" then call crump (0,
      377 			     "Unexpected token || """ || token || """ in -library statement.");
      378 
      379 			search_dir_struc.make_all_names_external = ""b;
      380 			search_dir_struc.n_dirs = 0;
      381 
      382 			search_dir = get_token ();
      383 
      384 			do while (search_dir ^= ";");
      385 
      386 			     if eof then
      387 				call crump (0, "Unexpected end-of-file while processing search list; possible missing semicolon in input file.");
      388 
      389 			     if search_dir = "-wd" then search_dir = "";
      390 			     else if search_dir = "-working_directory" then search_dir = "";
      391 			     cur_dir_description = rest_of_line ();
      392 			     call expand_pathname_ (search_dir, dirname (1), ename (1), code);
      393 			     if code ^= 0 then if first_pass then call com_err_ (code, "cross_reference",
      394 				     "Directory ^a not searched.", search_dir);
      395 
      396 				else;
      397 
      398 			     else do;
      399 				temp_dir = pathname_ (dirname (1), ename (1));
      400 
      401 				search_dir_struc.n_dirs = search_dir_struc.n_dirs + 1;
      402 
      403 				if search_dir_struc.n_dirs > hbound (search_dir_struc.item, 1) then do;
      404 				     call com_err_ (0, "cross_reference", "More than ^d search paths specified.", hbound (search_dir_struc.item, 1));
      405 				     signal cref_abort_;
      406 				end;
      407 
      408 				if cur_dir_description ^= "" then
      409 				     search_dir_struc.search_dir_descriptions (search_dir_struc.n_dirs) = cur_dir_description;
      410 				else search_dir_struc.search_dir_descriptions (search_dir_struc.n_dirs) = temp_dir;
      411 
      412 				search_dir_struc.search_dirs (search_dir_struc.n_dirs) = temp_dir;
      413 
      414 				search_dir_struc.make_all_names_external = cur_all_option;
      415 
      416 			     end;
      417 
      418 			     search_dir = get_token ();
      419 			end;
      420 
      421 			token = get_token ();
      422 		     end;
      423 
      424 		     if peek_rest_of_line () ^= "" then /* this is a synonym definition line */
      425 			if first_pass then do;	/* define syns on first pass only */
      426 
      427 			     save_token = token;
      428 
      429 			     master_node = cref_listman_$predefine_primary_block_char (token, null, null, "1"b, ""b, "1"b);
      430 
      431 			     do while (peek_rest_of_line () ^= "");
      432 				token = get_token ();
      433 				call cref_listman_$create_syn_block (token, null, null, "1"b, master_node);
      434 			     end;
      435 
      436 			     token = save_token;
      437 			end;			/* but don't analyze seg, may not be freestanding */
      438 
      439 			else temp_string = rest_of_line (); /* throw line away on second pass */
      440 
      441 		     else call cref_analyze_ ((token), first_pass); /* one-token line, analyze seg */
      442 
      443 		     token = get_token ();
      444 		end;
      445 	     end;
      446 	end;
      447 	
      448 	else do;					/* process by argument list */
      449 
      450 	     do i = 1 to n_pathnames;
      451 		call expand_pathname_ (pathname (i), dirname (i), ename (i), code);
      452 		if code ^= 0 then call crump (code, pathname (i));
      453 
      454 		call check_star_name_$entry (ename (i), code);
      455 		if code = 0 then is_starname (i) = ""b;
      456 		else if code < 3 then is_starname (i) = "1"b;
      457 		else call crump (code, ename (i));
      458 	     end;
      459 
      460 	     do first_pass = "1"b, ""b;
      461 
      462 		do i = 1 to n_pathnames;
      463 
      464 		     search_dir_struc.make_all_names_external = ""b;
      465 		     search_dir_struc.n_dirs = 0;
      466 
      467 		     if search_dir_struc.n_dirs > hbound (search_dir_struc.item, 1) then do;
      468 			call com_err_ (0, "cross_reference", "More than ^d search paths specified.", hbound (search_dir_struc.item, 1));
      469 			signal cref_abort_;
      470 		     end;
      471 
      472 		     search_dir_struc.n_dirs = search_dir_struc.n_dirs + 1;
      473 
      474 		     if dir_description (i) ^= "" then
      475 			search_dir_struc.search_dir_descriptions (search_dir_struc.n_dirs) = dir_description (i);
      476 		     else search_dir_struc.search_dir_descriptions (search_dir_struc.n_dirs) = rtrim (dirname (i), " ");
      477 
      478 		     search_dir_struc.search_dirs (search_dir_struc.n_dirs) = dirname (i);
      479 
      480 		     search_dir_struc.make_all_names_external = all_option (i);
      481 
      482 		     if is_starname (i) then do;
      483 
      484 			call hcs_$star_ (dirname (i), ename (i), Segs_only, system_free_ptr,
      485 			     seg_count, star_struc_ptr, star_names_ptr, code);
      486 			if code ^= 0 then
      487 			     if first_pass then call com_err_ (code, "cross_reference", "^a.  Continuing...",
      488 				pathname_ (dirname (i), ename (i)));
      489 
      490 			     else;
      491 
      492 			else do;
      493 			     do j = 1 to seg_count;
      494 
      495 				if star_structure.type (j) = Nondir_segment
      496 				then do;
      497 
      498 				     call cref_analyze_ (star_names (binary (star_structure (j).nindex, 17)),
      499 					first_pass);
      500 				end;
      501 			     end;
      502 
      503 			     free star_names in (system_free_area),
      504 				star_structure in (system_free_area);
      505 
      506 			     star_names_ptr, star_struc_ptr = null;
      507 			end;
      508 		     end;
      509 
      510 		     else do;
      511 			call cref_analyze_ (ename (i), first_pass);
      512 		     end;
      513 		end;
      514 	     end;
      515 
      516 	end;
      517 
      518 	call cref_sort_;				/* make cross ref lists */
      519 
      520 	output_seg_ptr = test_outseg_ptr;		/* now we should delete it if we abort */
      521 	call hcs_$truncate_seg (output_seg_ptr, 0, code); /* This is not the most efficient, but cref_filegen_ may depend on it */
      522 	if code ^= 0 then goto output_seg_err;
      523 
      524 	call cref_filegen_ (output_seg_ptr, msf_fcb_ptr); /* create output seg when done */
      525 
      526 	call msf_manager_$close (msf_fcb_ptr);
      527 	msf_fcb_ptr = null;
      528 
      529 	call terminate_file_ (output_seg_ptr, (0), TERM_FILE_TERM, code);
      530 	output_seg_ptr = null;
      531 
      532 	
      533 err_return:
      534 	call clean_up;
      535 	return;
      536 
      537 unwind_and_abort:
      538 	call com_err_ (0, "cross_reference", "Fatal error. Invocation aborted.");
      539 	call clean_up;
      540 	return;
      541 
      542 clean_up:
      543 	procedure;
      544 
      545 	     if msf_fcb_ptr ^= null then do;		/* output seg never successfully finished */
      546 		call msf_manager_$adjust (msf_fcb_ptr, 0, 0, "110"b, code);
      547 		if output_seg_ptr ^= null then call hcs_$delentry_seg (output_seg_ptr, code);
      548 		call msf_manager_$close (msf_fcb_ptr);
      549 	     end;
      550 	     if auto_area_info.areap ^= null then call release_area_ (auto_area_info.areap);
      551 	     if err_seg_ptr ^= null then call release_temp_segment_ ("cross_reference", err_seg_ptr, code);
      552 	     if input_seg_ptr ^= null then call terminate_file_ (input_seg_ptr, (0), TERM_FILE_TERM, (0));
      553 	     if star_struc_ptr ^= null then free star_structure in (system_free_area);
      554 	     if star_names_ptr ^= null then free star_names in (system_free_area);
      555 	     if pathname_ptr ^= null then free pathname_struc in (system_free_area);
      556 	     if search_dir_ptr ^= null then free search_dir_struc in (system_free_area);
      557 
      558 	end clean_up;
      559 
      560 
      561 crump:	proc (code, reason);
      562 
      563 dcl  code fixed bin (35) parameter,
      564      reason char (*) parameter;
      565 
      566 	     call com_err_ (code, "cross_reference", reason);
      567 	     goto err_return;
      568 	end crump;
      569 
      570 get_token: proc returns (char (200) varying);
      571 
      572 dcl  token char (200) varying;
      573 
      574 dcl  input_seg char (char_count) based (input_seg_ptr);
      575 
      576 dcl  separators char (3) static initial ("
      577 	 "),						/* nl, tab, space */
      578      terminators char (2) static initial ("
      579 ;"),
      580      breaks_and_separators char (5) static initial ("
      581 	 :;");						/* nl, tab, space, colon, semi */
      582 
      583 dcl  i fixed bin (21);
      584 
      585 
      586 	     if char_idx > char_count then goto set_eof;
      587 
      588 	     i = verify (substr (input_seg, char_idx), separators) - 1;
      589 	     if i = -1 then goto set_eof;
      590 
      591 	     char_idx = char_idx + i;
      592 
      593 	     i = search (substr (input_seg, char_idx), breaks_and_separators) - 1;
      594 	     if i = -1 then i = char_count - char_idx + 1;
      595 	     else if i = 0 then i = 1;
      596 
      597 	     token = substr (input_seg, char_idx, i);
      598 
      599 	     char_idx = char_idx + i;
      600 
      601 	     if char_idx > char_count then goto set_eof;
      602 
      603 	     return (token);
      604 
      605 rest_of_line:  entry returns (char (200) varying);
      606 
      607 	     peek_switch = ""b;
      608 	     goto common;
      609 
      610 peek_rest_of_line: entry returns (char (200) varying);
      611 
      612 dcl  peek_switch bit (1);
      613 
      614 dcl  whitespace char (2) static initial ("	 ");		/* tab, space */
      615 
      616 	     peek_switch = "1"b;
      617 
      618 common:
      619 	     if char_idx > char_count then goto set_eof;
      620 
      621 	     i = verify (substr (input_seg, char_idx), whitespace) - 1;
      622 	     if i = -1 then goto set_eof;
      623 
      624 	     char_idx = char_idx + i;
      625 
      626 	     i = search (substr (input_seg, char_idx), terminators) - 1;
      627 	     if i = -1 then token = substr (input_seg, char_idx);
      628 	     else token = substr (input_seg, char_idx, i);
      629 
      630 	     if ^peek_switch then char_idx = char_idx + i;
      631 
      632 	     return (token);
      633 
      634 set_eof:
      635 	     char_idx = char_count + 1;
      636 	     eof = "1"b;
      637 	     return ("");
      638 
      639 	end get_token;
      640 
      641      end cross_reference;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    04/08/85  1133.3  cross_reference.pl1               >spec>on>41-15>cross_reference.pl1
117          1    06/11/76  1043.4  area_info.incl.pl1                >ldd>include>area_info.incl.pl1
118          2    04/09/85  1109.7  access_mode_values.incl.pl1       >spec>on>41-15>access_mode_values.incl.pl1
119          3    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CROSSREF                        000004 constant        char(8)                  initial unaligned dcl 101 set ref 237* 301
N_DIRS                                 constant        fixed bin(17,0)          initial dcl 99 ref 201 201
Nondir_segment                         constant        bit(2)                   initial unaligned dcl 72 ref 495
R_ACCESS                        000057 constant        bit(3)                   initial unaligned dcl 2-11 set ref 346*
Segs_only                       000007 constant        fixed bin(17,0)          initial dcl 72 set ref 484*
TERM_FILE_TERM                  000003 constant        bit(3)                   initial unaligned dcl 3-14 set ref 349* 529* 552*
absolute_pathname_$add_suffix   000056 constant        entry                    external dcl 126 ref 225 237
addr                                                   builtin function         dcl 162 ref 198 198
al                              000476 automatic       fixed bin(21,0)          dcl 32 set ref 213* 215 217 217 224* 225 225 226 226
                                                                                  229 229 236* 237 237 238 238 241 243 243 245 247
                                                                                  247 250* 251 254 254 256 256 258 258 263* 264 264
                                                                                  265 268 268 273
all_option              211            based           bit(1)                   array level 3 dcl 102 set ref 275* 480
ap                              000522 automatic       pointer                  dcl 32 set ref 213* 215 217 217 224* 225 226 229 229
                                                                                  236* 237 238 241 243 243 245 247 247 250* 251 254
                                                                                  254 256 256 258 258 263* 264 265 268 273
area_control                           based           structure                level 1 dcl 1-20
area_info                              based           structure                level 1 dcl 1-7
area_info_version_1                    constant        fixed bin(17,0)          initial dcl 1-3 ref 193
areap                    16     000100 automatic       pointer                  level 2 dcl 30 set ref 175* 331* 333* 550 550*
arg                                    based           char                     unaligned dcl 115 set ref 215 217 217 225* 226* 229
                                                                                  229 237* 238* 241 243 243 245 247 247 251 254 254
                                                                                  256 256 258 258 264* 265 268* 273
array                     1            based           structure                array level 2 unaligned dcl 102
auto_area_info                  000100 automatic       structure                level 1 dcl 30 set ref 173* 198 198
binary                                                 builtin function         dcl 162 ref 498
bitcount                        000477 automatic       fixed bin(24,0)          dcl 32 set ref 346* 355
breaks_and_separators           000000 constant        char(5)                  initial unaligned dcl 576 ref 593
brief_switch                    000604 automatic       bit(1)                   dcl 52 set ref 184* 243* 333*
char_count                      000501 automatic       fixed bin(21,0)          dcl 32 set ref 355* 586 588 593 594 597 601 618 621
                                                                                  626 627 628 634
char_idx                        000125 automatic       fixed bin(21,0)          dcl 32 set ref 358* 586 588 591* 591 593 594 597
                                                                                  599* 599 601 618 621 624* 624 626 627 628 630* 630
                                                                                  634*
check_star_name_$entry          000076 constant        entry                    external dcl 148 ref 454
cleanup                         001070 stack reference condition                dcl 166 ref 338
code                            000502 automatic       fixed bin(35,0)          dcl 32 in procedure "cref" set ref 198* 199 199*
                                                                                  213* 224* 225* 226 226* 236* 237* 238 238* 250*
                                                                                  263* 264* 265 298* 299 299* 307* 308* 311* 312
                                                                                  312* 314* 317* 322* 327 343* 344 344* 346* 348
                                                                                  351* 392* 393 393* 451* 452 452* 454* 455 456 457*
                                                                                  484* 486 486* 521* 522 529* 546* 547* 551*
code                                   parameter       fixed bin(35,0)          dcl 563 in procedure "crump" set ref 561 566*
com_err_                        000024 constant        entry                    external dcl 126 ref 188 322 351 393 404 468 486 537
                                                                                  566
control                   1     000100 automatic       structure                level 2 dcl 30
cref_abort_                     001076 stack reference condition                dcl 166 ref 337 405 469
cref_analyze_                   000070 constant        entry                    external dcl 126 ref 441 498 511
cref_analyze_$init              000032 constant        entry                    external dcl 126 ref 332
cref_filegen_                   000046 constant        entry                    external dcl 126 ref 524
cref_filegen_$init              000044 constant        entry                    external dcl 126 ref 333
cref_listman_$create_syn_block  000102 constant        entry                    external dcl 151 ref 433
cref_listman_$init              000030 constant        entry                    external dcl 126 ref 331
cref_listman_$predefine_primary_block_char
                                000100 constant        entry                    external dcl 151 ref 429
cref_sort_                      000026 constant        entry                    external dcl 126 ref 518
cu_$arg_count                   000036 constant        entry                    external dcl 126 ref 186
cu_$arg_ptr                     000034 constant        entry                    external dcl 126 ref 213 224 236 250 263
cur_all_option                  000600 automatic       bit(1)                   dcl 52 set ref 178* 245* 248* 275 370* 374* 414
cur_dir_description             000524 automatic       varying char(168)        dcl 32 set ref 209* 251* 274 284 391* 408 408
cv_dec_check_                   000040 constant        entry                    external dcl 126 ref 264
define_area_                    000020 constant        entry                    external dcl 123 ref 198
dir_description         135            based           varying char(168)        array level 3 dcl 102 set ref 274* 474 474
dirname                  53            based           char(168)                array level 3 packed unaligned dcl 102 set ref 392*
                                                                                  399* 451* 476 478 484* 486* 486*
do_include_files                000602 automatic       bit(1)                   dcl 52 set ref 183* 254* 332*
ename                   125            based           char(32)                 array level 3 packed unaligned dcl 102 set ref 392*
                                                                                  399* 451* 454* 457* 484* 486* 486* 511*
eof                             000124 automatic       bit(1)                   dcl 32 set ref 359* 363 386 636*
err_seg_ptr                     000516 automatic       pointer                  dcl 32 set ref 175* 307* 308 333* 551 551*
error_table_$badopt             000014 external static fixed bin(35,0)          dcl 64 set ref 268*
error_table_$inconsistent       000012 external static fixed bin(35,0)          dcl 64 set ref 218* 230* 281* 284* 286*
error_table_$noarg              000010 external static fixed bin(35,0)          dcl 64 set ref 188* 220* 232* 259*
expand_pathname_                000042 constant        entry                    external dcl 126 ref 298 311 343 392 451
extend                    1     000100 automatic       bit(1)                   level 3 packed unaligned dcl 30 set ref 194*
first_pass                      000577 automatic       bit(1)                   dcl 52 set ref 357* 393 424 441* 460* 486 498* 511*
first_switch                    000601 automatic       bit(1)                   dcl 52 set ref 182* 241* 286 332*
get_system_free_area_           000072 constant        entry                    external dcl 146 ref 181
get_temp_segment_               000060 constant        entry                    external dcl 126 ref 307
given_ll                        000506 automatic       fixed bin(17,0)          dcl 32 set ref 179* 264* 333*
hbound                                                 builtin function         dcl 162 ref 403 404 404 467 468 468
hcs_$delentry_seg               000050 constant        entry                    external dcl 126 ref 547
hcs_$star_                      000074 constant        entry                    external dcl 148 ref 484
hcs_$truncate_seg               000064 constant        entry                    external dcl 126 ref 521
i                               000503 automatic       fixed bin(17,0)          dcl 32 in procedure "cref" set ref 211* 213* 220
                                                                                  223* 223 224* 232 235* 235 236* 249* 249 250* 259
                                                                                  262* 262 263* 275* 450* 451 451 451 452 454 455
                                                                                  456 457* 462* 474 474 476 478 480 482 484 484 486
                                                                                  486 486 486 511*
i                               001207 automatic       fixed bin(21,0)          dcl 583 in procedure "get_token" set ref 588* 589
                                                                                  591 593* 594 594* 595 595* 597 599 621* 622 624
                                                                                  626* 627 628 630
initiate_file_                  000052 constant        entry                    external dcl 126 ref 346
input_filedir                   000731 automatic       char(168)                unaligned dcl 59 set ref 343* 346* 351* 351*
input_filename                  000605 automatic       char(168)                unaligned dcl 59 set ref 177* 218 225* 281 293 298*
                                                                                  340 342 343* 346* 351* 351*
input_seg                              based           char                     unaligned dcl 574 ref 588 593 597 621 626 627 628
input_seg_ptr                   000510 automatic       pointer                  dcl 32 set ref 175* 346* 349 349* 552 552* 588 593
                                                                                  597 621 626 627 628
is_starname             210            based           bit(1)                   array level 3 packed unaligned dcl 102 set ref 455*
                                                                                  456* 482
item                      3            based           structure                array level 2 dcl 91 set ref 403 404 404 467 468 468
j                               000504 automatic       fixed bin(17,0)          dcl 32 set ref 493* 495 498*
make_all_names_external                based           bit(1)                   level 2 dcl 91 set ref 203* 379* 414* 464* 480*
master_node                     000474 automatic       pointer                  dcl 32 set ref 429* 433*
max_dirs                  1            based           fixed bin(17,0)          level 2 dcl 91 set ref 201* 403 404 404 467 468 468
                                                                                  556
msf_fcb_ptr                     000520 automatic       pointer                  dcl 32 set ref 175* 314* 315 317* 524* 526* 527* 545
                                                                                  546* 548*
msf_manager_$adjust             000110 constant        entry                    external dcl 155 ref 546
msf_manager_$close              000112 constant        entry                    external dcl 155 ref 526 548
msf_manager_$get_ptr            000106 constant        entry                    external dcl 155 ref 317
msf_manager_$open               000104 constant        entry                    external dcl 155 ref 314
n_dirs                    2            based           fixed bin(17,0)          level 2 dcl 91 set ref 204* 380* 401* 401 403 408
                                                                                  410 412 465* 467 472* 472 474 476 478
n_pathnames                     000505 automatic       fixed bin(17,0)          dcl 32 set ref 208* 272* 272 273 274 281 286 450 462
nargs                           000507 automatic       fixed bin(17,0)          dcl 32 set ref 186* 187 206 206 211 220 232 259
nindex                    0(18)        based           bit(18)                  array level 2 packed unaligned dcl 77 ref 498
no_freeing                1(04) 000100 automatic       bit(1)                   level 3 packed unaligned dcl 30 set ref 194*
null                                                   builtin function         dcl 162 ref 175 308 315 321 349 429 429 429 429 433
                                                                                  433 433 433 506 527 530 545 547 550 551 552 553
                                                                                  554 555 556
output_filedir                  001003 automatic       char(168)                unaligned dcl 59 set ref 311* 314* 322* 322*
output_filename                 000657 automatic       char(168)                unaligned dcl 59 set ref 177* 230 237* 293 293* 298*
                                                                                  299* 301* 301 310 311* 314* 322* 322*
output_seg_ptr                  000514 automatic       pointer                  dcl 32 set ref 175* 327* 520* 521* 524* 529* 530*
                                                                                  547 547*
owner                     2     000100 automatic       char(32)                 level 2 packed unaligned dcl 30 set ref 196*
pathname                  1            based           char(168)                array level 3 packed unaligned dcl 102 set ref 273*
                                                                                  451* 452*
pathname_                       000066 constant        entry                    external dcl 126 ref 322 322 351 351 399 486 486
pathname_ptr                    001066 automatic       pointer                  dcl 112 set ref 175* 206* 273 274 275 392 392 399
                                                                                  399 451 451 451 452 454 455 456 457 474 474 476
                                                                                  478 480 482 484 484 486 486 486 486 511 555 555
pathname_struc                         based           structure                level 1 unaligned dcl 102 set ref 206 555
peek_switch                     001210 automatic       bit(1)                   unaligned dcl 612 set ref 607* 616* 630
reason                                 parameter       char                     unaligned dcl 563 set ref 561 566*
release_area_                   000022 constant        entry                    external dcl 123 ref 550
release_temp_segment_           000062 constant        entry                    external dcl 126 ref 551
rtrim                                                  builtin function         dcl 162 ref 301 476
save_token                      000410 automatic       varying char(200)        dcl 32 set ref 427* 436
search                                                 builtin function         dcl 162 ref 593 626
search_dir                      000253 automatic       char(168)                unaligned dcl 32 set ref 382* 384 389 389* 390 390*
                                                                                  392* 393* 418*
search_dir_descriptions
                         55            based           varying char(168)        array level 3 dcl 91 set ref 408* 410* 474* 476*
search_dir_ptr                  001064 automatic       pointer                  dcl 99 set ref 175* 201* 203 204 332* 379 380 401
                                                                                  401 403 403 404 404 408 408 410 410 412 412 414
                                                                                  464 465 467 467 468 468 472 472 474 474 476 476
                                                                                  478 478 480 556 556
search_dir_struc                       based           structure                level 1 dcl 91 set ref 201 556
search_dirs               3            based           char(168)                array level 3 dcl 91 set ref 412* 478*
seg_count                       000500 automatic       fixed bin(17,0)          dcl 32 set ref 484* 493 503 553
separators                      000002 constant        char(3)                  initial unaligned dcl 576 ref 588
short_switch                    000603 automatic       bit(1)                   dcl 52 set ref 183* 256* 333*
size                     13     000100 automatic       fixed bin(18,0)          level 2 dcl 30 set ref 195*
star_names                             based           char(32)                 array unaligned dcl 84 set ref 498* 503 554
star_names_ptr                  001060 automatic       pointer                  dcl 86 set ref 175* 484* 498 503 506* 554 554
star_struc_ptr                  001056 automatic       pointer                  dcl 82 set ref 175* 484* 495 498 503 506* 553 553
star_structure                         based           structure                array level 1 dcl 77 ref 503 553
substr                                                 builtin function         dcl 162 ref 215 588 593 597 621 626 627 628
sys_info$max_seg_size           000016 external static fixed bin(35,0)          dcl 68 ref 195
system_free_area                       based           area(1024)               dcl 88 ref 201 206 503 503 553 554 555 556
system_free_ptr                 001062 automatic       pointer                  dcl 88 set ref 181* 201 206 484* 503 503 553 554 555
                                                                                  556
temp_dir                        000126 automatic       varying char(168)        dcl 32 set ref 399* 410 412
temp_string                     000201 automatic       char(168)                unaligned dcl 32 set ref 310* 311* 312* 342* 343*
                                                                                  344* 439*
terminate_file_                 000054 constant        entry                    external dcl 126 ref 349 529 552
terminators                            constant        char(2)                  initial unaligned dcl 576 ref 626
test_outseg_ptr                 000512 automatic       pointer                  dcl 32 set ref 175* 317* 321 327 520
token                           001124 automatic       varying char(200)        dcl 572 in procedure "get_token" set ref 597* 603
                                                                                  627* 628* 632
token                           000325 automatic       varying char(200)        dcl 32 in procedure "cref" set ref 361* 365 365 367*
                                                                                  369 371* 376 376 421* 427 429* 432* 433* 436* 441
                                                                                  443*
type                                   based           bit(2)                   array level 2 packed unaligned dcl 77 ref 495
unspec                                                 builtin function         dcl 162 set ref 173*
verify                                                 builtin function         dcl 162 ref 588 621
version                         000100 automatic       fixed bin(17,0)          level 2 dcl 30 set ref 193*
whitespace                             constant        char(2)                  initial unaligned dcl 614 ref 621
xxx                                    based           fixed bin(17,0)          level 2 dcl 102 set ref 206* 555

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 2-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 2-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 2-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 2-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 2-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 3-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 3-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 3-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 3-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 3-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 3-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 2-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 2-36
area_infop                             automatic       pointer                  dcl 1-5
length                                                 builtin function         dcl 162
terminate_file_switches                based           structure                level 1 packed unaligned dcl 3-4

NAMES DECLARED BY EXPLICIT CONTEXT.
clean_up                        004427 constant        entry                    internal dcl 542 ref 338 533 539
common                          005037 constant        label                    dcl 618 ref 608
cref                            000431 constant        entry                    external dcl 11
cross_reference                 000440 constant        entry                    external dcl 11
crump                           004660 constant        entry                    internal dcl 561 ref 199 218 220 226 230 232 238 259
                                                                                  265 268 281 284 286 299 308 312 344 376 386 452
                                                                                  457
err_return                      004363 constant        label                    dcl 533 ref 324 352 567
get_token                       004723 constant        entry                    internal dcl 570 ref 361 367 371 382 418 421 432 443
output_seg_err                  002172 constant        label                    dcl 322 ref 315 522
peek_rest_of_line               005033 constant        entry                    internal dcl 610 ref 424 431
rest_of_line                    005027 constant        entry                    internal dcl 605 ref 391 439
set_eof                         005142 constant        label                    dcl 634 ref 586 589 601 618 622
unwind_and_abort                004370 constant        label                    dcl 537 ref 337

NAMES DECLARED BY CONTEXT OR IMPLICATION.
before                                                 builtin function         ref 301
divide                                                 builtin function         ref 355

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6640        6754    6171        6650
Length      7304    6171       114         313     446           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
cref                                803 external procedure  is an external procedure.  
on unit on line 337                  64 on unit               
on unit on line 338                  64 on unit               
clean_up                            112 internal procedure  is called by several nonquick procedures.  
crump                                84 internal procedure  is called during a stack extension.  
get_token                               internal procedure  shares stack frame of external procedure cref.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
cref                     000100 auto_area_info              cref
                         000124 eof                         cref
                         000125 char_idx                    cref
                         000126 temp_dir                    cref
                         000201 temp_string                 cref
                         000253 search_dir                  cref
                         000325 token                       cref
                         000410 save_token                  cref
                         000474 master_node                 cref
                         000476 al                          cref
                         000477 bitcount                    cref
                         000500 seg_count                   cref
                         000501 char_count                  cref
                         000502 code                        cref
                         000503 i                           cref
                         000504 j                           cref
                         000505 n_pathnames                 cref
                         000506 given_ll                    cref
                         000507 nargs                       cref
                         000510 input_seg_ptr               cref
                         000512 test_outseg_ptr             cref
                         000514 output_seg_ptr              cref
                         000516 err_seg_ptr                 cref
                         000520 msf_fcb_ptr                 cref
                         000522 ap                          cref
                         000524 cur_dir_description         cref
                         000577 first_pass                  cref
                         000600 cur_all_option              cref
                         000601 first_switch                cref
                         000602 do_include_files            cref
                         000603 short_switch                cref
                         000604 brief_switch                cref
                         000605 input_filename              cref
                         000657 output_filename             cref
                         000731 input_filedir               cref
                         001003 output_filedir              cref
                         001056 star_struc_ptr              cref
                         001060 star_names_ptr              cref
                         001062 system_free_ptr             cref
                         001064 search_dir_ptr              cref
                         001066 pathname_ptr                cref
                         001124 token                       get_token
                         001207 i                           get_token
                         001210 peek_switch                 get_token

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return              tra_ext             signal              enable              shorten_stack
ext_entry           int_entry           int_entry_desc      set_cs_eis          alloc_based         free_based
index_before_cs

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_$add_suffix check_star_name_$entry        com_err_                      cref_analyze_
cref_analyze_$init            cref_filegen_                 cref_filegen_$init
cref_listman_$create_syn_block                              cref_listman_$init
cref_listman_$predefine_primary_block_char                  cref_sort_                    cu_$arg_count
cu_$arg_ptr                   cv_dec_check_                 define_area_                  expand_pathname_
get_system_free_area_         get_temp_segment_             hcs_$delentry_seg             hcs_$star_
hcs_$truncate_seg             initiate_file_                msf_manager_$adjust           msf_manager_$close
msf_manager_$get_ptr          msf_manager_$open             pathname_                     release_area_
release_temp_segment_         terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$inconsistent     error_table_$noarg            sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000430       173 000445       175 000450       177 000463       178 000471       179 000472       181 000474
    182 000502       183 000503       184 000505       186 000506       187 000515       188 000517       190 000547
    193 000550       194 000552       195 000556       196 000561       198 000564       199 000576       201 000617
    203 000626       204 000627       206 000630       208 000641       209 000642       211 000643       213 000651
    215 000666       217 000673       218 000704       220 000730       223 000753       224 000754       225 000771
    226 001023       227 001044       229 001045       230 001055       232 001101       235 001124       236 001125
    237 001142       238 001172       239 001213       241 001214       243 001223       245 001236       247 001245
    248 001255       249 001256       250 001257       251 001274       252 001305       254 001306       256 001321
    258 001334       259 001344       262 001367       263 001370       264 001405       265 001432       266 001467
    268 001471       269 001511       272 001512       273 001513       274 001523       275 001533       277 001537
    281 001541       284 001570       286 001620       293 001645       298 001661       299 001705       301 001723
    304 001771       307 001772       308 002017       310 002045       311 002050       312 002073       314 002111
    315 002135       317 002141       321 002166       322 002172       324 002244       327 002245       331 002251
    332 002260       333 002273       337 002312       338 002331       340 002353       342 002357       343 002362
    344 002405       346 002423       348 002457       349 002461       351 002514       352 002566       355 002567
    357 002572       358 002576       359 002600       361 002601       363 002603       365 002606       367 002620
    369 002622       370 002627       371 002631       372 002633       374 002634       376 002635       379 002704
    380 002706       382 002710       384 002716       386 002722       389 002744       390 002754       391 002763
    392 002775       393 003027       396 003070       399 003071       401 003124       403 003126       404 003131
    405 003170       408 003173       410 003213       412 003225       414 003234       418 003236       419 003244
    421 003245       424 003247       427 003261       429 003266       431 003334       432 003343       433 003345
    434 003401       436 003402       437 003407       439 003410       441 003417       443 003444       444 003447
    445 003450       446 003455       450 003456       451 003465       452 003522       454 003545       455 003567
    456 003577       457 003607       458 003630       460 003632       462 003636       464 003645       465 003646
    467 003650       468 003653       469 003712       472 003715       474 003717       476 003743       478 004003
    480 004014       482 004016       484 004022       486 004070       490 004164       493 004165       495 004175
    498 004202       501 004224       503 004226       506 004232       508 004235       511 004236       513 004255
    514 004257       518 004264       520 004271       521 004273       522 004307       524 004311       526 004322
    527 004331       529 004333       530 004361       533 004363       535 004367       537 004370       539 004421
    540 004425       542 004426       545 004434       546 004441       547 004463       548 004501       550 004511
    551 004525       552 004557       553 004613       554 004622       555 004631       556 004643       558 004656
    561 004657       566 004673       567 004720       570 004723       586 004725       588 004730       589 004747
    591 004751       593 004752       594 004771       595 005000       597 005004       599 005013       601 005015
    603 005020       605 005027       607 005031       608 005032       610 005033       616 005035       618 005037
    621 005042       622 005061       624 005063       626 005064       627 005104       628 005117       630 005126
    632 005132       634 005142       636 005145       637 005147


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
