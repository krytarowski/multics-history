	COMPILATION LISTING OF SEGMENT db_fnp_edit_inst_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1616.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* Procedure to interpret fnp machine instructions */
       12 
       13 /* Written February 1977 by Larry Johnson */
       14 /* Modified January 1978 by Larry Johnson for assemble entry */
       15 
       16 db_fnp_edit_inst_: proc (arg_corep, arg_fnp, arg_fnp_addr, arg_instr, arg_str);
       17 
       18 /* Parameters */
       19 
       20 dcl  arg_corep ptr;					/* Pointer to core image, if dump */
       21 dcl  arg_fnp fixed bin;				/* Fnp number, for running fnp */
       22 dcl  arg_instr bit (18);				/* Instruction to edit */
       23 dcl  arg_str char (*) var;				/* The output string */
       24 dcl  arg_asm_str char (*);				/* The string to assemble */
       25 dcl  arg_expr_infop ptr;
       26 dcl  arg_code fixed bin (35);
       27 dcl  arg_fnp_addr fixed bin;
       28 
       29 /* Automatic */
       30 
       31 dcl  fnp fixed bin;
       32 dcl  corep ptr;
       33 dcl  str char (64) var;
       34 dcl  instruction bit (18) aligned;
       35 dcl  opc bit (12) aligned;
       36 dcl (i, j) fixed bin;
       37 dcl  offset fixed bin;
       38 dcl  width fixed bin init (7);			/* Width to edit opcode field */
       39 dcl  code fixed bin (35);
       40 dcl  val fixed bin (35);
       41 dcl  temp_str char (4);
       42 dcl  char_addr_val bit (3);
       43 dcl  edited_addr char (32) var;
       44 dcl  fnp_addr_known bit (1);
       45 
       46 dcl 1 mi aligned based (addr (instruction)),
       47     2 i bit (1) unal,				/* Indirect bit */
       48     2 x bit (2) unal,				/* Index register */
       49     2 c bit (6) unal,				/* The opcode (normally) */
       50     2 d bit (9) unal;				/* The displacement */
       51 
       52 /* Constants */
       53 
       54 dcl  reg_name (3) char (1) int static options (constant) init ("1", "2", "3");
       55 dcl  char_addr (0:7) char (3) int static options (constant) init (
       56      "w.1", "w.2", "b.0", "b.1", "c.0", "c.1", "c.2", "idl");
       57 dcl  reg_code (10) char (2) int static options (constant) init (
       58      "*", "1*", "2*", "3*", "*1", "*2", "*3", "1", "2", "3");
       59 dcl  reg_val (10) bit (3) unal int static options (constant) init (
       60      "100"b, "101"b, "110"b, "111"b, "101"b, "110"b, "111"b, "001"b, "010"b, "011"b);
       61 dcl  white_space char (2) int static options (constant) init (" 	"); /* Space and tab */
       62 
       63 /* External stuff */
       64 
       65 dcl  ioa_$rsnnl entry options (variable);
       66 dcl  db_fnp_eval_ entry (ptr, fixed bin, char (*), ptr, char (*), fixed bin, fixed bin (35));
       67 dcl  db_fnp_util_$edit_module_addr_paren entry (ptr, fixed bin, fixed bin, char (*) var, fixed bin (35));
       68 
       69 dcl  error_table_$bad_arg ext fixed bin (35);
       70 
       71 dcl (addr, bin, bit, copy, index, length, ltrim, reverse, rtrim, search, substr, unspec) builtin;
       72 
       73 /* Edit an instruction */
       74 
       75 	fnp_addr_known = "1"b;
       76 start:	instruction = arg_instr;
       77 	str = "";
       78 
       79 	opc = substr (instruction, 1, 12);
       80 
       81 	optablep = addr (db_fnp_opcodes_$);
       82 
       83 	do i = 1 to optable.cnt;			/* Find instruction in table */
       84 	     opp = addr (optable.entry (i));
       85 	     if (opc & op.mask) = op.code then go to op_edit (op.type);
       86 	end;
       87 
       88 	arg_str = "";
       89 	return;
       90 
       91 
       92 /* Type 0 - storage reference instruction */
       93 
       94 op_edit (0):
       95 	if mi.x = "0"b then offset = fb (mi.d);		/* 9 bit displacement for ic modified instructions */
       96 	else do;					/* Offset depends in type of character addressing */
       97 	     i = bin (substr (mi.d, 1, 3));		/* Get char addr code */
       98 	     if i < 2 | i > 6 then offset = fb (mi.d);	/* If invalid, use 9 bits */
       99 	     else offset = fb (substr (mi.d, 4, 6));	/* Else use 6 bits */
      100 	end;
      101 	call ioa_$rsnnl ("^va ^o", str, (0), width, op.name, offset);
      102 	if mi.x = "0"b then do;			/* IC modifier */
      103 	     if mi.i then str = str || ",*";
      104 	     if fnp_addr_known then do;		/* Evaluate address */
      105 		call db_fnp_util_$edit_module_addr_paren (arg_corep, arg_fnp, arg_fnp_addr + offset, edited_addr,
      106 		     code);
      107 		if code = 0 then do;
      108 		     str = str || copy (" ", 15 - length (str)); /* Increase to 15 characters */
      109 		     str = str || edited_addr;
      110 		end;
      111 	     end;
      112 	end;
      113 	else do;					/* Index register modifier */
      114 	     str = str || ",";
      115 	     str = str || reg_name (bin (mi.x));
      116 	     if mi.i then str = str || "*";
      117 	     i = bin (substr (mi.d, 1, 3));		/* Get byte address */
      118 	     if i >= 2 & i <= 6 then do;		/* Valid one */
      119 		str = str || ",";
      120 		str = str || char_addr (i);
      121 	     end;
      122 	end;
      123 	go to op_done;
      124 
      125 /* Type 1 - immediate instructions */
      126 
      127 op_edit (1):
      128 	call ioa_$rsnnl ("^va ^o", str, (0), width, op.name, fb (mi.d));
      129 	go to op_done;
      130 
      131 /* Type 2 - iacxn instruction */
      132 
      133 op_edit (2):
      134 	call ioa_$rsnnl ("^va ^o", str, (0), width, op.name, fb (substr (mi.d, 4, 6)));
      135 	if substr (mi.d, 1, 3) ^= "0"b then do;
      136 	     str = str || ",";
      137 	     str = str || char_addr (bin (substr (mi.d, 1, 3)));
      138 	end;
      139 	go to op_done;
      140 
      141 /* Type 3 - shifts */
      142 
      143 op_edit (3):
      144 	call ioa_$rsnnl ("^va ^o", str, (0), width, op.name, bin (substr (mi.d, 4, 6)));
      145 	go to op_done;
      146 
      147 /* Type 4 - no operands */
      148 
      149 op_edit (4):
      150 	str = rtrim (op.name);
      151 	go to op_done;
      152 
      153 /* All done */
      154 
      155 op_done:
      156 	arg_str = str;
      157 	return;
      158 
      159 /* Entry which returns a compressed version */
      160 
      161 compressed: entry (arg_corep, arg_fnp, arg_instr, arg_str);
      162 
      163 	width = 1;
      164 	fnp_addr_known = "0"b;
      165 	go to start;
      166 
      167 /* Entry to "assemble" a character string into a machine instruction word */
      168 
      169 assemble:	entry (arg_corep, arg_fnp, arg_asm_str, arg_expr_infop, arg_instr, arg_code);
      170 
      171 	corep = arg_corep;
      172 	fnp = arg_fnp;
      173 	expr_infop = arg_expr_infop;
      174 	arg_code = 0;
      175 	arg_instr = "0"b;
      176 
      177 	instruction = "0"b;
      178 	str = rtrim (ltrim (arg_asm_str, white_space), white_space); /* Trim down input */
      179 	i = search (str, white_space);		/* Look for space after opcode */
      180 	if i = 0 then i = length (str);
      181 	else i = i-1;
      182 	optablep = addr (db_fnp_opcodes_$);
      183 	do j = 1 to optable.cnt;
      184 	     opp = addr (optable.entry (j));
      185 	     if op.name = substr (str, 1, i) then go to op_found; /* Found opcode match */
      186 	end;
      187 asm_bad:	arg_code = error_table_$bad_arg;
      188 	return;
      189 
      190 op_found:	instruction = op.code;			/* Start instruction with opcode */
      191 	if i >= length (str) then go to asm_complete;	/* No operands */
      192 	str = ltrim (substr (str, i+1), white_space);
      193 	if str = "" then go to asm_complete;
      194 	go to asm (op.type);			/* Complete instruction based on type */
      195 
      196 asm (0):						/* Storage reference */
      197 	call get_char_addr;				/* Remove char addressing */
      198 	if length (str) >= 2 then do;			/* May have index register */
      199 	     i = index (reverse (str), ",");		/* Look for comma before index */
      200 	     if (i = 2) | (i = 3) then do;		/* May really be there */
      201 		temp_str = substr (str, length (str) - i + 2); /* Copy end of string */
      202 		do j = 1 to 10;			/* Check possible codes */
      203 		     if temp_str = reg_code (j) then do; /* Found match */
      204 			mi.i = substr (reg_val (j), 1, 1);
      205 			mi.x = substr (reg_val (j), 2, 2);
      206 			str = substr (str, 1, length (str) - i); /* Trim off index */
      207 			go to eval_disp;
      208 		     end;
      209 		end;
      210 		go to asm_bad;
      211 	     end;
      212 	end;
      213 eval_disp:
      214 	call eval_str;				/* Evaluate rest of string as expression */
      215 	if char_addr_val = "0"b then mi.d = substr (unspec (val), 28); /* 9 bit displacement */
      216 	else do;
      217 	     substr (mi.d, 1, 3) = char_addr_val;
      218 	     substr (mi.d, 4, 6) = substr (unspec (val), 31); /* 6 bit displacement */
      219 	end;
      220 	go to asm_complete;
      221 
      222 asm (1):						/* Immediate instructions */
      223 	call eval_str;				/* Whole expr is amount */
      224 	mi.d = substr (unspec (val), 28);
      225 	go to asm_complete;
      226 
      227 asm (2):						/* Iacxn */
      228 	call get_char_addr;
      229 	go to eval_disp;				/* Rest is like storage reference */
      230 
      231 asm (3):						/* Shifts */
      232 	call eval_str;
      233 	substr (mi.d, 4, 6) = substr (unspec (val), 31);	/* 6 bit disp */
      234 	go to asm_complete;
      235 
      236 asm (4):						/* No operand instruction */
      237 	go to asm_bad;				/* Operand is error */
      238 
      239 asm_complete:
      240 	arg_instr = instruction;
      241 	arg_code = 0;
      242 	return;
      243 
      244 /* Fixed of bit function which respects the leading sign bit */
      245 
      246 fb:	proc (bits) returns (fixed bin);
      247 
      248 dcl  bits bit (*);
      249 dcl  i fixed bin (35);
      250 
      251 	     if substr (bits, 1, 1) = "0"b then i = 0;
      252 	     else i = -1;
      253 	     substr (unspec (i), 37 - length (bits)) = bits;
      254 	     return (i);
      255 
      256 	end fb;
      257 
      258 /* Remove character addressing from instruction specification */
      259 
      260 get_char_addr: proc;
      261 
      262 dcl  i fixed bin;
      263 
      264 	     char_addr_val = "0"b;
      265 	     if length (str) < 4 then return;		/* Too short */
      266 	     if substr (str, length (str) - 3, 1) ^= "," then return; /* Should be of form ,xxx */
      267 	     temp_str = substr (str, length (str)-2);	/* Copy the xxx part */
      268 	     do i = 2 to 6;				/* Check legal forms */
      269 		if temp_str = char_addr (i) then do;
      270 		     char_addr_val = bit (bin (i, 3), 3);
      271 		     str = substr (str, 1, length (str)-4);
      272 		     return;
      273 		end;
      274 	     end;
      275 	     return;
      276 
      277 	end get_char_addr;
      278 
      279 /* Evaluate operand of instruction */
      280 
      281 eval_str:	proc;
      282 
      283 dcl  i fixed bin;
      284 
      285 	     val = 0;
      286 	     if str = "" then return;
      287 	     call db_fnp_eval_ (corep, fnp, (str), expr_infop, "", i, code);
      288 	     if code ^= 0 then go to asm_bad;
      289 	     val = i;
      290 	     return;
      291 
      292 	end eval_str;
      293 
  1     1 /* Begin include file ..... debug_fnp_data.incl.pl1 */
  1     2 
  1     3 /* Describes various structures used by the debug_fnp command */
  1     4 
  1     5 /* Written February 1977 by Larry Johnson */
  1     6 
  1     7 /* Structures describing a symbol table used by the debug_fnp command,
  1     8*   to find values for common FNP symbols. */
  1     9 
  1    10 dcl  db_fnp_symbols_$db_fnp_symbols_ ext;
  1    11 
  1    12 dcl  symbol_tablep ptr;
  1    13 
  1    14 dcl 1 symbol_table aligned based (symbol_tablep),
  1    15     2 cnt fixed bin,				/* Number of entries */
  1    16     2 maxcnt fixed bin,				/* Max count */
  1    17     2 entry (symbol_table.cnt) unal,
  1    18       3 one_symbol like sym unal;
  1    19 
  1    20 dcl  symp ptr;					/* Pointer to one symbol */
  1    21 
  1    22 dcl 1 sym unal based (symp),
  1    23     2 name char (6),
  1    24     2 value fixed bin (17),
  1    25     2 len fixed bin (17),				/* Number of words */
  1    26     2 reloc fixed bin (17),
  1    27     2 type fixed bin (17),
  1    28     2 flag_mem char (6),				/* If non blank, name of word in which this is a flag */
  1    29     2 explain bit (18),				/* Offset to explanation for symbol */
  1    30     2 pad bit (18);
  1    31 
  1    32 dcl  exptextp ptr;
  1    33 
  1    34 dcl 1 exptext aligned based (exptextp),			/* Symbol explanation entry */
  1    35     2 len fixed bin (8) unal,
  1    36     2 data char (exptext.len) unal;
  1    37 
  1    38 /* Values for sym.reloc, which is relocation required to find the symbol */
  1    39 
  1    40 dcl (reloc_abs init (0),				/* Value is absolute */
  1    41      reloc_tib init (1),				/* Value is relative to current tib addr */
  1    42      reloc_hwcm init (2),				/* Value is relative to current hwcm */
  1    43      reloc_sfcm init (3),				/* Value is relative to software comm region */
  1    44      reloc_meters init (4))				/* Value is relative to tib meters */
  1    45      int static options (constant);
  1    46 
  1    47 /* Values for sym.type, which is the mode to be used in displaying symbol */
  1    48 
  1    49 dcl (type_oct init (0),				/* Octal, default for most symbols */
  1    50      type_char init (1),				/* Ascii characters */
  1    51      type_addr init (2),				/* Address to be converted to mod|offset */
  1    52      type_clock init (3),				/* Multics clock value */
  1    53      type_inst init (4),				/* Machine instruction */
  1    54      type_op init (5),				/* Interpreter opblock format */
  1    55      type_dec init (6),				/* Decimal */
  1    56      type_bit init (7),				/* In bits */
  1    57      type_ebcdic init (8))				/* 8-bit ebcdic characters */
  1    58      int static options (constant);
  1    59 
  1    60 dcl  long_type_names (0:8) char (12) int static options (constant) init (
  1    61      "octal", "character", "address", "clock", "instruction", "opblock", "decimal", "bit", "ebcdic");
  1    62 dcl  short_type_names (0:8) char (4) int static options (constant) init (
  1    63      "oct", "ch", "addr", "ck", "inst", "op", "dec", "bit", "ebc");
  1    64 
  1    65 
  1    66 /* Structure of suplmental data used in evaluating expressions */
  1    67 
  1    68 dcl  expr_infop ptr;
  1    69 
  1    70 dcl 1 expr_info aligned based (expr_infop),
  1    71     2 flags,
  1    72       3 star_known bit (1) unal,			/* Value of "*" is known */
  1    73       3 tib_known bit (1) unal,			/* TIB addresses may be used */
  1    74       3 hwcm_known bit (1) unal,			/* HWCM address may be used */
  1    75       3 sfcm_known bit (1) unal,			/* SFCM address may be used */
  1    76       3 pad bit (32) unal,
  1    77     2 star_addr fixed bin,				/* Value of "*" */
  1    78     2 tib_addr fixed bin,				/* Address of TIB */
  1    79     2 hwcm_addr fixed bin,				/* Address of HWCM */
  1    80     2 sfcm_addr fixed bin,				/* Address of SFCM */
  1    81     2 type fixed bin,				/* Expression type (mode for printing) */
  1    82     2 len fixed bin,				/* Implied length of expression */
  1    83     2 user_tablep ptr;				/* Pointer to a user symbol table */
  1    84 
  1    85 
  1    86 /* Structure of opcode table of machine instructions */
  1    87 
  1    88 dcl  db_fnp_opcodes_$ ext;
  1    89 
  1    90 dcl  optablep ptr;
  1    91 
  1    92 dcl 1 optable aligned based (optablep),
  1    93     2 cnt fixed bin,
  1    94     2 entry (optable.cnt) unal,
  1    95       3 one_op like op;
  1    96 
  1    97 dcl  opp ptr;
  1    98 
  1    99 dcl 1 op unal based (opp),
  1   100     2 name char (6),				/* The mneumonic */
  1   101     2 code bit (12),				/* The  opcode */
  1   102     2 mask bit (12),				/* Mask that says where the opcode is */
  1   103     2 type fixed bin (11),				/* Type of display required */
  1   104     2 pad bit (18);
  1   105 
  1   106 /* Values for op.type are:
  1   107*   0 - storage reference
  1   108*   1 - non-storage reference (immediate),
  1   109*   2 - non-storage reference (iacxn only),
  1   110*   3 - non-storage reference (shifts),
  1   111*   4 - non-storage reference (no operands) */
  1   112 
  1   113 
  1   114 /* Stuctures used while parsing commands into operands */
  1   115 
  1   116 dcl  cmd_infop ptr;
  1   117 
  1   118 dcl 1 cmd_info aligned based (cmd_infop),
  1   119     2 inbuf char (256),				/* For reading lines */
  1   120     2 opbuf char (256),				/* Used for operand in undoubling quotes */
  1   121     2 commandp ptr,					/* Address of unparsed part of command */
  1   122     2 commandl fixed bin,				/* Length of unparsed part */
  1   123     2 operandp ptr,					/* Address of current operand */
  1   124     2 operandl fixed bin,				/* And its length */
  1   125     2 error bit (1),				/* Set if error parsing operand */
  1   126     2 endline bit (1),				/* Set if no more operands on line */
  1   127     2 opstring bit (1),				/* Set if operand was unquoted string */
  1   128     2 flush bit (1),				/* If set, rest of input line will be ignored */
  1   129     2 envp ptr;					/* Pointer to the debug_fnp environment structure */
  1   130 
  1   131 dcl  command char (cmd_info.commandl) based (cmd_info.commandp);
  1   132 dcl  operand char (cmd_info.operandl) based (cmd_info.operandp);
  1   133 
  1   134 /* The following structure describes the current debug_fnp environment. */
  1   135 /* It specifies whether we are working on a dump, fnp, core image, etc. */
  1   136 
  1   137 dcl  envp ptr;
  1   138 
  1   139 dcl 1 env aligned based (envp),
  1   140     2 corep ptr,					/* Ptr to current dump or core-image. Null means live FNP */
  1   141     2 fnp fixed bin,				/* Current fnp number */
  1   142     2 dump_dir char (168) unal,			/* Directory where dumps are found */
  1   143     2 dir char (168) unal,				/* Directory for current dump or core image */
  1   144     2 ename char (32) unal,				/* Ename for current dump or core image */
  1   145     2 tty_name char (32),				/* Name of current channel */
  1   146     2 segp ptr,					/* Pointer to base of current segment */
  1   147     2 flags unal,
  1   148       3 fnps_configured bit (8),			/* Says which FNP's appear in config deck */
  1   149       3 fnp_sw bit (1),				/* 1 if currently working on fnp */
  1   150       3 image_sw bit (1),				/* 1 if currently working on a core-image */
  1   151       3 dump_sw bit (1),				/* 1 if current working on a dump */
  1   152       3 fdump_sw bit (1),				/* 1 if current dump is a fdump */
  1   153       3 pad bit (24),
  1   154     2 dump_time fixed bin (71);			/* Clock time dump occured */
  1   155 
  1   156 /* Structure of data defining table of interpreter opblock names */
  1   157 
  1   158 dcl  db_fnp_opblocks_$ ext;
  1   159 
  1   160 dcl  opblock_tablep ptr;
  1   161 
  1   162 dcl 1 opblock_table aligned based (opblock_tablep),
  1   163     2 cnt fixed bin,
  1   164     2 name (0:opblock_table.cnt) char (6) unal;
  1   165 
  1   166 /* End include file ..... debug_fnp_data.incl.pl1 */
      294 
      295 
      296      end db_fnp_edit_inst_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1501.9  db_fnp_edit_inst_.pl1             >dumps>old>recomp>db_fnp_edit_inst_.pl1
294          1    06/19/81  2115.0  debug_fnp_data.incl.pl1           >ldd>include>debug_fnp_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
addr                                                   builtin function         dcl 71 ref 81 84 94 94 97 98 99 99 102 103 115 116
                                                                                  117 127 127 133 133 133 133 135 137 143 143 182
                                                                                  184 204 205 215 217 218 224 233
arg_asm_str                            parameter       char                     unaligned dcl 24 ref 169 178
arg_code                               parameter       fixed bin(35,0)          dcl 26 set ref 169 174* 187* 241*
arg_corep                              parameter       pointer                  dcl 20 set ref 16 105* 161 169 171
arg_expr_infop                         parameter       pointer                  dcl 25 ref 169 173
arg_fnp                                parameter       fixed bin(17,0)          dcl 21 set ref 16 105* 161 169 172
arg_fnp_addr                           parameter       fixed bin(17,0)          dcl 27 ref 16 105
arg_instr                              parameter       bit(18)                  unaligned dcl 22 set ref 16 76 161 169 175* 239*
arg_str                                parameter       varying char             dcl 23 set ref 16 88* 155* 161
bin                                                    builtin function         dcl 71 ref 97 115 117 137 143 143 270
bit                                                    builtin function         dcl 71 ref 270
bits                                   parameter       bit                      unaligned dcl 248 ref 246 251 253 253
char_addr                       000020 constant        char(3)                  initial array unaligned dcl 55 ref 120 137 269
char_addr_val                   000136 automatic       bit(3)                   unaligned dcl 42 set ref 215 217 264* 270*
cnt                                    based           fixed bin(17,0)          level 2 dcl 1-92 ref 83 183
code                      1(18)        based           bit(12)                  level 2 in structure "op" packed unaligned dcl 1-99
                                                                                  in procedure "db_fnp_edit_inst_" ref 85 190
code                            000133 automatic       fixed bin(35,0)          dcl 39 in procedure "db_fnp_edit_inst_" set ref 105*
                                                                                  107 287* 288
copy                                                   builtin function         dcl 71 ref 108
corep                           000102 automatic       pointer                  dcl 32 set ref 171* 287*
d                         0(09)        based           bit(9)                   level 2 packed unaligned dcl 46 set ref 94* 97 98*
                                                                                  99 99 117 127* 127* 133 133 133 133 135 137 143
                                                                                  143 215* 217* 218* 224* 233*
db_fnp_eval_                    000012 constant        entry                    external dcl 66 ref 287
db_fnp_opcodes_$                000020 external static fixed bin(17,0)          dcl 1-88 set ref 81 182
db_fnp_util_$edit_module_addr_paren
                                000014 constant        entry                    external dcl 67 ref 105
edited_addr                     000137 automatic       varying char(32)         dcl 43 set ref 105* 109
entry                     1            based           structure                array level 2 packed unaligned dcl 1-92 set ref 84
                                                                                  184
error_table_$bad_arg            000016 external static fixed bin(35,0)          dcl 69 ref 187
expr_infop                      000152 automatic       pointer                  dcl 1-68 set ref 173* 287*
fnp                             000100 automatic       fixed bin(17,0)          dcl 31 set ref 172* 287*
fnp_addr_known                  000150 automatic       bit(1)                   unaligned dcl 44 set ref 75* 104 164*
i                               000127 automatic       fixed bin(17,0)          dcl 36 in procedure "db_fnp_edit_inst_" set ref 83*
                                                                                  84* 97* 98 98 117* 118 118 120 179* 180 180* 181*
                                                                                  181 185 191 192 199* 200 200 201 206
i                               000216 automatic       fixed bin(17,0)          dcl 283 in procedure "eval_str" set ref 287* 289
i                                      based           bit(1)                   level 2 in structure "mi" packed unaligned dcl 46
                                                                                  in procedure "db_fnp_edit_inst_" set ref 103 116
                                                                                  204*
i                               000176 automatic       fixed bin(35,0)          dcl 249 in procedure "fb" set ref 251* 252* 253 254
i                               000206 automatic       fixed bin(17,0)          dcl 262 in procedure "get_char_addr" set ref 268*
                                                                                  269 270*
index                                                  builtin function         dcl 71 ref 199
instruction                     000125 automatic       bit(18)                  dcl 34 set ref 76* 79 94 94 97 98 99 99 102 103 115
                                                                                  116 117 127 127 133 133 133 133 135 137 143 143
                                                                                  177* 190* 204 205 215 217 218 224 233 239
ioa_$rsnnl                      000010 constant        entry                    external dcl 65 ref 101 127 133 143
j                               000130 automatic       fixed bin(17,0)          dcl 36 set ref 183* 184* 202* 203 204 205*
length                                                 builtin function         dcl 71 ref 108 180 191 198 201 206 253 265 266 267
                                                                                  271
ltrim                                                  builtin function         dcl 71 ref 178 192
mask                      1(30)        based           bit(12)                  level 2 packed unaligned dcl 1-99 ref 85
mi                                     based           structure                level 1 dcl 46
name                                   based           char(6)                  level 2 packed unaligned dcl 1-99 set ref 101* 127*
                                                                                  133* 143* 149 185
offset                          000131 automatic       fixed bin(17,0)          dcl 37 set ref 94* 98* 99* 101* 105
op                                     based           structure                level 1 packed unaligned dcl 1-99
opc                             000126 automatic       bit(12)                  dcl 35 set ref 79* 85
opp                             000156 automatic       pointer                  dcl 1-97 set ref 84* 85 85 85 101 127 133 143 149
                                                                                  184* 185 190 194
optable                                based           structure                level 1 dcl 1-92
optablep                        000154 automatic       pointer                  dcl 1-90 set ref 81* 83 84 182* 183 184
reg_code                        000013 constant        char(2)                  initial array unaligned dcl 57 ref 203
reg_name                        000026 constant        char(1)                  initial array unaligned dcl 54 ref 115
reg_val                         000012 constant        bit(3)                   initial array unaligned dcl 59 ref 204 205
reverse                                                builtin function         dcl 71 ref 199
rtrim                                                  builtin function         dcl 71 ref 149 178
search                                                 builtin function         dcl 71 ref 179
str                             000104 automatic       varying char(64)         dcl 33 set ref 77* 101* 103* 103 108* 108 108 109*
                                                                                  109 114* 114 115* 115 116* 116 119* 119 120* 120
                                                                                  127* 133* 136* 136 137* 137 143* 149* 155 178* 179
                                                                                  180 185 191 192* 192 193 198 199 201 201 206* 206
                                                                                  206 265 266 266 267 267 271* 271 271 286 287
substr                                                 builtin function         dcl 71 set ref 79 97 99 99 117 133 133 133 133 135
                                                                                  137 143 143 185 192 201 204 205 206 215 217* 218*
                                                                                  218 224 233* 233 251 253* 266 267 271
sym                                    based           structure                level 1 packed unaligned dcl 1-22
temp_str                        000135 automatic       char(4)                  unaligned dcl 41 set ref 201* 203 267* 269
type                      2(06)        based           fixed bin(11,0)          level 2 packed unaligned dcl 1-99 ref 85 194
unspec                                                 builtin function         dcl 71 ref 215 218 224 233 253
val                             000134 automatic       fixed bin(35,0)          dcl 40 set ref 215 218 224 233 285* 289*
white_space                            constant        char(2)                  initial unaligned dcl 61 ref 178 178 179 192
width                           000132 automatic       fixed bin(17,0)          initial dcl 38 set ref 38* 101* 127* 133* 143* 163*
x                         0(01)        based           bit(2)                   level 2 packed unaligned dcl 46 set ref 94 102 115
                                                                                  205*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
cmd_info                               based           structure                level 1 dcl 1-118
cmd_infop                              automatic       pointer                  dcl 1-116
command                                based           char                     unaligned dcl 1-131
db_fnp_opblocks_$                      external static fixed bin(17,0)          dcl 1-158
db_fnp_symbols_$db_fnp_symbols_        external static fixed bin(17,0)          dcl 1-10
env                                    based           structure                level 1 dcl 1-139
envp                                   automatic       pointer                  dcl 1-137
expr_info                              based           structure                level 1 dcl 1-70
exptext                                based           structure                level 1 dcl 1-34
exptextp                               automatic       pointer                  dcl 1-32
long_type_names                        internal static char(12)                 initial array unaligned dcl 1-60
opblock_table                          based           structure                level 1 dcl 1-162
opblock_tablep                         automatic       pointer                  dcl 1-160
operand                                based           char                     unaligned dcl 1-132
reloc_abs                              internal static fixed bin(17,0)          initial dcl 1-40
reloc_hwcm                             internal static fixed bin(17,0)          initial dcl 1-40
reloc_meters                           internal static fixed bin(17,0)          initial dcl 1-40
reloc_sfcm                             internal static fixed bin(17,0)          initial dcl 1-40
reloc_tib                              internal static fixed bin(17,0)          initial dcl 1-40
short_type_names                       internal static char(4)                  initial array unaligned dcl 1-62
symbol_table                           based           structure                level 1 dcl 1-14
symbol_tablep                          automatic       pointer                  dcl 1-12
symp                                   automatic       pointer                  dcl 1-20
type_addr                              internal static fixed bin(17,0)          initial dcl 1-49
type_bit                               internal static fixed bin(17,0)          initial dcl 1-49
type_char                              internal static fixed bin(17,0)          initial dcl 1-49
type_clock                             internal static fixed bin(17,0)          initial dcl 1-49
type_dec                               internal static fixed bin(17,0)          initial dcl 1-49
type_ebcdic                            internal static fixed bin(17,0)          initial dcl 1-49
type_inst                              internal static fixed bin(17,0)          initial dcl 1-49
type_oct                               internal static fixed bin(17,0)          initial dcl 1-49
type_op                                internal static fixed bin(17,0)          initial dcl 1-49

NAMES DECLARED BY EXPLICIT CONTEXT.
asm                             000005 constant        label                    array(0:4) dcl 196 ref 194
asm_bad                         001202 constant        label                    dcl 187 ref 210 236 288
asm_complete                    001407 constant        label                    dcl 239 ref 191 193 220 225 234
assemble                        001041 constant        entry                    external dcl 169
compressed                      001011 constant        entry                    external dcl 161
db_fnp_edit_inst_               000064 constant        entry                    external dcl 16
eval_disp                       001353 constant        label                    dcl 213 ref 207 229
eval_str                        001537 constant        entry                    internal dcl 281 ref 213 222 231
fb                              001416 constant        entry                    internal dcl 246 ref 94 98 99 127 127 133 133
get_char_addr                   001463 constant        entry                    internal dcl 260 ref 196 227
op_done                         000765 constant        label                    dcl 155 ref 123 129 139 145 151
op_edit                         000000 constant        label                    array(0:4) dcl 94 ref 85
op_found                        001207 constant        label                    dcl 190 ref 185
start                           000104 constant        label                    dcl 76 set ref 165

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2370        2412    2253        2400
Length      2620    2253        22         171     115           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_fnp_edit_inst_                   228 external procedure  is an external procedure.  
fb                                      internal procedure  shares stack frame of external procedure db_fnp_edit_inst_.  
get_char_addr                           internal procedure  shares stack frame of external procedure db_fnp_edit_inst_.  
eval_str                                internal procedure  shares stack frame of external procedure db_fnp_edit_inst_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_fnp_edit_inst_        000100 fnp                         db_fnp_edit_inst_
                         000102 corep                       db_fnp_edit_inst_
                         000104 str                         db_fnp_edit_inst_
                         000125 instruction                 db_fnp_edit_inst_
                         000126 opc                         db_fnp_edit_inst_
                         000127 i                           db_fnp_edit_inst_
                         000130 j                           db_fnp_edit_inst_
                         000131 offset                      db_fnp_edit_inst_
                         000132 width                       db_fnp_edit_inst_
                         000133 code                        db_fnp_edit_inst_
                         000134 val                         db_fnp_edit_inst_
                         000135 temp_str                    db_fnp_edit_inst_
                         000136 char_addr_val               db_fnp_edit_inst_
                         000137 edited_addr                 db_fnp_edit_inst_
                         000150 fnp_addr_known              db_fnp_edit_inst_
                         000152 expr_infop                  db_fnp_edit_inst_
                         000154 optablep                    db_fnp_edit_inst_
                         000156 opp                         db_fnp_edit_inst_
                         000176 i                           fb
                         000206 i                           get_char_addr
                         000216 i                           eval_str

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_out_desc   return              mpfx2               shorten_stack       ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
db_fnp_eval_                  db_fnp_util_$edit_module_addr_paren                         ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
db_fnp_opcodes_$              error_table_$bad_arg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     38 000053        16 000057        75 000102        76 000104        77 000111        79 000112        81 000115
     83 000120        84 000127        85 000133        86 000153        88 000155        89 000163        94 000164
     97 000210        98 000214        99 000237       101 000246       102 000305       103 000314       104 000331
    105 000333       107 000367       108 000371       109 000412       112 000425       114 000426       115 000435
    116 000447       117 000461       118 000465       119 000471       120 000500       123 000515       127 000516
    129 000573       133 000574       135 000642       136 000646       137 000655       139 000676       143 000677
    145 000743       149 000744       151 000764       155 000765       157 001003       161 001004       163 001027
    164 001031       165 001032       169 001033       171 001060       172 001064       173 001066       174 001071
    175 001072       177 001076       178 001077       179 001134       180 001147       181 001153       182 001155
    183 001160       184 001167       185 001173       186 001200       187 001202       188 001206       190 001207
    191 001213       192 001216       193 001247       194 001254       196 001262       198 001263       199 001266
    200 001300       201 001304       202 001317       203 001324       204 001331       205 001336       206 001341
    207 001347       209 001350       210 001352       213 001353       215 001354       217 001362       218 001366
    220 001371       222 001372       224 001373       225 001376       227 001377       229 001400       231 001401
    233 001402       234 001405       236 001406       239 001407       241 001413       242 001415       246 001416
    251 001427       252 001437       253 001441       254 001460       260 001463       264 001464       265 001465
    266 001471       267 001476       268 001506       269 001513       270 001520       271 001525       272 001533
    274 001534       275 001536       281 001537       285 001540       286 001541       287 001547       288 001616
    289 001621       290 001623


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
