	COMPILATION LISTING OF SEGMENT lib_paged_output_
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 07/18/86  1352.3 mst Fri
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(76-11-23,GDixon), approve(), audit(), install():
       13*     Program created.
       14*  2) change(86-05-17,GDixon), approve(86-05-17,MCR7357),
       15*     audit(86-07-10,Farley), install(86-07-18,MR12.0-1098):
       16*     Change call to tct_$translate to reference
       17*     find_char_$translate_first_in_table instead.  This subroutine was renamed.
       18*                                                   END HISTORY COMMENTS */
       19 
       20 
       21 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       22 	/*									*/
       23 	/* NAME:  lib_paged_output_							*/
       24 	/*									*/
       25 	/*      This subroutine splits a segment up into printable pages, and outputs each page	*/
       26 	/* on a given I/O switch.  It provides for variable line length, page length, for	*/
       27 	/* top and bottom margin settings, for a caller-supplied end-of-page routine, and for	*/
       28 	/* processing of MSF component segments which are to be treated as part of a logical	*/
       29 	/* MSF.									*/
       30 	/*									*/
       31 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       32 
       33 lib_paged_output_:
       34 	procedure (APch, ALch, PPOD, Acode);
       35 
       36      dcl						/*	Parameters			*/
       37 	APch			ptr,		/* ptr to char string to be output with paging. 	*/
       38 						/*   (In)					*/
       39 	ALch			fixed bin(21),	/* length of char string. (In)		*/
       40 /*	PPOD			ptr,		/* ptr to input data structure. (In)		*/
       41 	Acode			fixed bin(35);	/* return code.	(Out)			*/
       42 
       43      dcl	Cbreak 			char(512) varying,	/* temporary string in which break table built.	*/
       44 	Cop			char(1),		/* character from break table corresponding to	*/
       45 						/*   break which was found.			*/
       46 	Iat_column		fixed bin,	/* current column of current line.		*/
       47 	Icolumns_used		fixed bin,	/* number of columns usedin current line.	*/
       48 	J			fixed bin(21),	/* index value.				*/
       49 	Lch			fixed bin(21),	/* length of unoutput part of input char str.	*/
       50 	Lline			fixed bin,	/* length of processed part of current line.	*/
       51 	Lprocessed		fixed bin(21),	/* length of processed part not output yet.	*/
       52 	Lunprocessed		fixed bin(21),	/* length of unprocessed part of input char str.	*/
       53 	Nheading_lines		fixed bin,	/* estimated number of lines required to print	*/
       54 						/*   the heading.				*/
       55 	Nlines			fixed bin,	/* number of print lines with the current line	*/
       56 						/*   will take up when printed.		*/
       57 	Nlines_page		fixed bin,	/* number of lines from input char str which will	*/
       58 						/*   fit on each page.			*/
       59 	Nvert_tabs		fixed bin,
       60 	Pch			ptr,		/* ptr to unoutput part of input char str.	*/
       61 	Punprocessed		ptr,		/* ptr to unprocessed part of input char str.	*/
       62 	Send_of_line		bit(1) aligned,	/* on if end of current line reached.		*/
       63 	Send_of_page		bit(1) aligned,	/* on if end of current page reached.		*/
       64 	Spartial			bit(1) aligned,	/* copy of POD.Spartial_last_page.		*/
       65 	Sprint			bit(1) aligned,	/* on if within page boundaries to be printed.	*/
       66 	Svertical_tab		bit(1) aligned,	/* on if vertical tab encountered.		*/
       67 	cleanup			condition,
       68 	code 			fixed bin(35),	/* status code.				*/
       69 	op			fixed bin(35),	/* binary value of Cop.			*/
       70 	vert_tab_lines (20)		fixed bin;	/* lines to skip for each vertical tab on this	*/
       71 						/*   page.  These ARE NOT TAB STOP SETTINGS.  	*/
       72 						/*   Tab stops assumed at 13,23,33... skipping	*/
       73 						/*   2 lines at top of each page for heading 	*/
       74 						/*   lines, just as the printer does.		*/
       75 	
       76 	
       77      dcl						/*	based variables.			*/
       78 	ch_array (Lch)		char(1) based (Pch),
       79 	unprocessed		char(Lunprocessed) based(Punprocessed),
       80 	unprocessed_array (Lunprocessed)
       81 				char(1) based(Punprocessed);
       82 
  1     1 /*	START OF:	paged_output_data_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3      dcl	1 POD			aligned based (PPOD),
  1     4 						/* data used by paged_output_ subroutine.	*/
  1     5 	  2 version		fixed bin,	/* version number of this structure. (= 1)	*/
  1     6 	  2 Lline			fixed bin,	/* max length of output lines.		*/
  1     7 	  2 Lpage			fixed bin,	/* lines per page.				*/
  1     8 	  2 Ltop_margin		fixed bin,	/* lines skipped for top margin.		*/
  1     9 	  2 Lbottom_margin		fixed bin,	/* lines skipped for bottom margin.		*/
  1    10 	  2 Nfrom			fixed bin,	/* number of first page printed.		*/
  1    11 	  2 Nto			fixed bin,	/* number of last page printed.		*/
  1    12 						/*     = 0  ==> no upper limit on last page.	*/
  1    13 	  2 switch		ptr,		/* ptr to IOCB for output switch.		*/
  1    14 	  2 end_page		entry (fixed bin),	/* endpage condition handler.			*/
  1    15 	  2 switches,
  1    16 	   (3 Send_page		bit(1),		/* on if endpage procedure to be called.	*/
  1    17 	    3 Spartial_last_page	bit(1),		/* on if last page need not be full.		*/
  1    18 						/*   (Turn on for all but last component segment	*/
  1    19 						/*    of an MSF.)				*/
  1    20 	    3 Sheader		bit(1),		/* on if heading to be printed before 1st page	*/
  1    21 						/*   of each file is output.			*/
  1    22 						/*   Heading contains pathname of file being 	*/
  1    23 						/*   printed.  It is not printed if output begins	*/
  1    24 						/*   with other than first page of the file.	*/
  1    25 	    3 pad			bit(33)) unal,
  1    26 	  2 Iat_column		fixed bin,	/* current column position of current line.	*/
  1    27 	  2 Icolumns_used		fixed bin,	/* number of columns used on current line.	*/
  1    28 	  2 Iline			fixed bin,	/* number of lines already on current page.	*/
  1    29 	  2 Ipage			fixed bin,	/* page number of the current page.		*/
  1    30 	  2 Imsf_comp		fixed bin,	/* number of MSF component being output.	*/
  1    31 						/*   = -1, a segment file is being output.	*/
  1    32 						/*   =  0, 1st component of MSF being output.	*/
  1    33 						/*   =  N, N+1st component of MSF being output.	*/
  1    34 	  2 heading		char(200) varying,	/* the heading line(s).			*/
  1    35 	PPOD			ptr,		/* ptr to this data structure.		*/
  1    36 	VPOD_1			fixed bin int static init (1) options(constant);
  1    37 
  1    38 /*	END OF:	paged_output_data_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       83 
       84 
       85      dcl (addr, binary, copy, divide, length, max, mod, substr, unspec)
       86 				builtin;
       87 
       88      dcl	find_char_$translate_first_in_table
       89 				entry (char(*), char(512) aligned, fixed bin(21)) returns (char(1)),
       90 	ioa_$ioa_switch_nnl		entry() options(variable),
       91 	iox_$put_chars		entry (ptr, ptr, fixed bin(21), fixed bin(35));
       92 
       93      dcl (ONE_POS			init (" "),	/* \000 - ignored by find_char_.		*/
       94 	IGNORE			init ("1"),	/* "1"  - returned by find_char_.		*/
       95 	ESCAPE			init ("2"),	/* "2"  - returned by find_char_.		*/
       96 	BS			init ("3"),	/* "3"  - returned by find_char_.		*/
       97 	HT			init ("4"),	/* "4"  - returned by find_char_.		*/
       98 	NL			init ("5"),	/* "5"  - returned by find_char_.		*/
       99 	NP			init ("6"),	/* "6"  - returned by find_char_.		*/
      100 	CR			init ("7"),	/* "7"  - returned by find_char_.		*/
      101 	VT			init ("8"))	/* "8"  - returned by find_char_.		*/
      102 				char(1) int static options(constant),
      103 	False			bit(1) aligned int static options(constant) init ("0"b),
      104 	NLs			char(200) aligned int static options(constant) init ((200)"
      105 "),
      106 	VTchar			char(1) aligned int static options(constant) init(""),
      107 	NPchar			char(1) aligned int static options(constant) init (""),
      108 	Sfirst			bit(1) aligned int static init ("1"b),
      109 						/* on if pgm invoked for first time in process.	*/
      110 	True			bit(1) aligned int static options(constant) init ("1"b),
      111 	break_table		char(512) aligned int static,
      112 	error_table_$unimplemented_version
      113 				fixed bin(35) ext static;
      114 						/* static copy of Cbreak, the break table used	*/
      115 						/*   by find_char_$translate_first_in_table.	*/
      116 
      117 
      118 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      119 
      120 
      121 	if Sfirst then do;				/* construct search table.			*/
      122 	     Cbreak = IGNORE;			/* 000    :  NUL is ignored wrt print positions.	*/
      123 	     Cbreak = Cbreak || copy(ESCAPE,6);		/* 001-006:  are escape sequences.		*/
      124 	     Cbreak = Cbreak || ESCAPE;		/* 007    :  BEL is escaped.			*/
      125 	     Cbreak = Cbreak || BS;			/* 010    :  BS is a -1 print positions.	*/
      126 	     Cbreak = Cbreak || HT;			/* 011    :  HT is variable number of print pos.	*/
      127 	     Cbreak = Cbreak || NL;			/* 012    :  NL is after last print position.	*/
      128 	     Cbreak = Cbreak || VT;			/* 013    :  VT ends line, skips to next VT stop. */
      129 	     Cbreak = Cbreak || NP;			/* 014    :  NP ends line and page.		*/
      130 	     Cbreak = Cbreak || CR;			/* 015    :  CR sets position to col 1.		*/
      131 	     Cbreak = Cbreak || copy(ESCAPE,2);		/* 016-017:  BRS-RRS are escaped.		*/
      132 	     Cbreak = Cbreak || copy(ESCAPE,16);	/* 020-037:  are escape sequences.		*/
      133 	     Cbreak = Cbreak || copy(ONE_POS,95);	/* 040-176:  are printable, taking 1 position.	*/
      134 	     Cbreak = Cbreak || IGNORE;		/* 177    :  PAD is ignored.			*/
      135 	     Cbreak = Cbreak || copy(ESCAPE,384);	/* 200-777:  are escape sequences.		*/
      136 	     break_table = Cbreak;			/* copy into internal static break table.	*/
      137 	     Sfirst = False;
      138 	     end;
      139 
      140 	if POD.version ^= VPOD_1 then   do;
      141 	     Acode = error_table_$unimplemented_version;
      142 	     return;
      143 	     end;
      144 	Acode = 0;
      145 	Pch = APch;				/* copy input args so we can change them.	*/
      146 	Lch = ALch;
      147 	Iat_column = POD.Iat_column;
      148 	Icolumns_used = POD.Icolumns_used;
      149 	Nlines_page = POD.Lpage - POD.Lbottom_margin;
      150 
      151 	if POD.Sheader & POD.Imsf_comp < 1 then do;
      152 	     Nheading_lines = 2 + divide(length(POD.heading) + (POD.Lline-1), POD.Lline, 17, 0);
      153 						/* estimate number of lines occupied by heading.	*/
      154 						/* exclude widowed heading lines by requiring at	*/
      155 						/*   least 2 text lines on page with heading.	*/
      156 	     if Nheading_lines > Nlines_page then;	/* heading can never fit on a page. Ignore it.	*/
      157 	     else do;
      158 		if Nheading_lines + POD.Iline > Nlines_page then do;
      159 		     if Sprint then do;		/* heading won't fit on current page. Force EOP.	*/
      160 			if (POD.Lpage-POD.Iline > 0) then do;
      161 			     call iox_$put_chars (POD.switch, addr(NLs), (POD.Lpage - POD.Iline), code);
      162 			     if code ^= 0 then go to FATAL_ERROR;
      163 			     end;
      164 			if POD.Send_page then call end_page (POD.Ipage);
      165 			end;
      166 		     POD.Ipage = POD.Ipage + 1;
      167 		     POD.Iline = 0;
      168 		     end;
      169 		Spartial = POD.Spartial_last_page;
      170 		on cleanup begin;
      171 		     POD.Sheader = True;
      172 		     POD.Spartial_last_page = Spartial;
      173 		     end;
      174 		POD.Sheader = False;
      175 		POD.Spartial_last_page = True;
      176 		Punprocessed = addr(substr(POD.heading,1));
      177 		Lunprocessed = length(POD.heading);
      178 		call lib_paged_output_ (Punprocessed, Lunprocessed, PPOD, code);
      179 		if code ^= 0 then go to FATAL_ERROR;
      180 		POD.Sheader = True;
      181 		POD.Spartial_last_page = Spartial;
      182 		revert cleanup;
      183 		end;
      184 	     end;
      185 
      186 	do while (((POD.Ipage <= POD.Nto) | (POD.Nto = 0)) & (Lch > 0)); 
      187 						/* Process input looking for pages to print.	*/
      188 	     if (POD.Nfrom <= POD.Ipage) & ((POD.Ipage <= POD.Nto) | (POD.Nto = 0)) then
      189 		Sprint = True;
      190 	     else Sprint = False;			/* Determine printability.			*/
      191 	     if (POD.Iline < POD.Ltop_margin) then do;
      192 		if Sprint then do;
      193 		     call iox_$put_chars (POD.switch, addr(NLs), (POD.Ltop_margin-POD.Iline), code);
      194 		     if code ^= 0 then go to FATAL_ERROR;
      195 		     end;
      196 		POD.Iline = POD.Ltop_margin;		/* output top margin.			*/
      197 		end;
      198 
      199 	     Send_of_page = False;			/* Prepare to process each page.		*/
      200 	     Punprocessed = Pch;
      201 	     Lunprocessed = Lch;
      202 	     Lprocessed = 0;
      203 	     Nlines = 0;
      204 	     Nvert_tabs = 0;
      205 	     do while ((POD.Iline + Nlines <= Nlines_page) & (Lunprocessed > 0) & ^Send_of_page);
      206 		Send_of_line = False;		/* Scan input until a page has been processed.	*/
      207 		Svertical_tab = False;
      208 		Lline = 0;			/* Note that lines are not output at this time.	*/
      209 		do while ((Lunprocessed > 0) & ^Send_of_line);
      210 						/* This loop processes each printed line.	*/
      211 		     Cop = find_char_$translate_first_in_table (unprocessed, break_table, J);
      212 		     if J = 0 then do;		/* end of input detected with no NL char.	*/
      213 			J = Lunprocessed;
      214 			Iat_column = Iat_column + J;
      215 			go to END_NOT_BREAK;
      216 			end;
      217 		     else op = binary (unspec(Cop), 9);
      218 		     go to DO(op);
      219 
      220 DO(49):		     Iat_column = Iat_column + (J - 1);	/* 49 = \061 = "1" = IGNORE.			*/
      221 		     go to END;
      222 
      223 DO(50):		     Iat_column = Iat_column + (J + 3);	/* 50 = \062 = "2" = ESCAPE.			*/
      224 		     go to END;
      225 
      226 DO(51):		     Iat_column = Iat_column + (J - 2);	/* 51 = \063 = "3" = BS (backspace).		*/
      227 		     Icolumns_used = max (Icolumns_used, Iat_column+1);
      228 		     go to END;
      229 
      230 DO(52):		     Iat_column = Iat_column + (J - 1);	/* 52 = \064 = "4" = HT (horizontal tab).	*/
      231 		     Iat_column = Iat_column + (10 - mod(Iat_column,10));
      232 		     go to END;
      233 
      234 DO(53):		     Iat_column = Iat_column + (J - 1);	/* 53 = \065 = "5" = NL (new line).		*/
      235 		     Send_of_line = True;
      236 		     go to END;
      237 
      238 DO(54):		     Iat_column = Iat_column + (J - 1);	/* 54 = \066 = "6" = NP (new page).		*/
      239 		     Send_of_line = True;
      240 		     Send_of_page = True;
      241 		     go to END;
      242 
      243 DO(55):		     Iat_column = Iat_column + (J - 1);	/* 55 = \067 = "7" = CR (carriage return).	*/
      244 		     Icolumns_used = max (Icolumns_used, Iat_column);
      245 		     Iat_column = 0;
      246 		     go to END;
      247 
      248 DO(56):		     Iat_column = Iat_column + (J - 1); /* 56 = \068 = "8" = VT (vertical tab)		*/
      249 		     Send_of_line = True;
      250 		     Svertical_tab = True;
      251 		     go to END;
      252 
      253 END:		     if ^Send_of_line then do;
      254 			Punprocessed = addr (unprocessed_array(J+1));
      255 			Lunprocessed = Lunprocessed - J;
      256 			Lline = Lline + J;
      257 			J = 0;			/* clear used value, in case do group ends.	*/
      258 			end;
      259 		     end;
      260 END_NOT_BREAK:	Icolumns_used = max (Icolumns_used, Iat_column);
      261 		Nlines = divide (Icolumns_used + (POD.Lline-1), POD.Lline, 17, 0);
      262 		if Send_of_line then Nlines = max(Nlines,1);
      263 		if POD.Iline + Nlines > Nlines_page then do;
      264 		     Iat_column = POD.Iat_column;	/* record where we were for subsequent invocation.*/
      265 		     Icolumns_used = POD.Icolumns_used;
      266 		     end;
      267 		else do;
      268 		     if ((Lunprocessed - J <= 0) & ^Send_of_line & POD.Spartial_last_page) then
      269 			POD.Iline = POD.Iline + Nlines-1;
      270 						/* Last line didn't end in NL or NP (final page)	*/
      271 						/*   and partial last pages are allowed.	*/
      272 		     else do;			/* Otherwise--				*/
      273 			POD.Iline = POD.Iline + Nlines;
      274 			Iat_column = 0;
      275 			Icolumns_used = 0;
      276 			end;
      277 		     POD.Iat_column = Iat_column;
      278 		     POD.Icolumns_used = Icolumns_used;
      279 		     if (Lunprocessed - J > 0) then
      280 			Punprocessed = addr (unprocessed_array(J+1));
      281 		     Lunprocessed = Lunprocessed - J;
      282 		     Lline = Lline + J;
      283 		     Lprocessed = Lprocessed + Lline;
      284 		     if Svertical_tab then do;	/* Process vertical table to count its extra lines*/
      285 			Nvert_tabs = Nvert_tabs + 1;
      286 			vert_tab_lines(Nvert_tabs) = 10 - mod(POD.Iline-POD.Ltop_margin-1, 10);
      287 			Nlines = vert_tab_lines(Nvert_tabs);
      288 			POD.Iline = POD.Iline - 1;	/* Omit line containing VT from line count.	*/
      289 			if  POD.Iline + Nlines < Nlines_page  then
      290 			     POD.Iline = POD.Iline + Nlines;
      291 						/*   The computed value of Nlines includes a NL	*/
      292 						/*   at end of line containing VT.		*/
      293 			else Send_of_page = True;	/*   Or else, the end-of-page routine will supply */
      294 			end;			/*   this NL.				*/
      295 		     Nlines = 0;			/* line just processed definitely on this page.	*/
      296 		     end;
      297 		end;
      298 
      299 	     if Sprint & (Lprocessed > 0) then		/* If we are to output anything, do it now.	*/
      300 		if ch_array(Lprocessed) = NPchar then do;
      301 		     call out (Lprocessed-1);
      302 		     call iox_$put_chars (POD.switch, addr(NLs), 1, code);
      303 		     if code ^= 0 then go to FATAL_ERROR;
      304 		     end;
      305 		else if ch_array(Lprocessed) = VTchar then do;
      306 		     call out (Lprocessed-1);
      307 		     end;
      308 		else do;
      309 		     call out (Lprocessed);
      310 		     end;
      311 	     if (Lch - Lprocessed > 0) then		/* Forget now about what's been processed.	*/
      312 		Pch = addr (ch_array (Lprocessed+1));
      313 	     Lch = Lch - Lprocessed;
      314 
      315 	     if (Lch > 0 | Send_of_page | ^POD.Spartial_last_page) then do;
      316 		if Sprint then do;
      317 		     if (POD.Lpage-POD.Iline > 0) then do;
      318 						/* Output footing for all but last page.  On last	*/
      319 						/*   page, output footing only if partial page	*/
      320 						/*   is not desired.			*/
      321 			call iox_$put_chars (POD.switch, addr(NLs), (POD.Lpage - POD.Iline), code);
      322 			if code ^= 0 then go to FATAL_ERROR;
      323 			end;
      324 		     if POD.Send_page then call end_page (POD.Ipage);
      325 		     end;
      326 		POD.Ipage = POD.Ipage + 1;
      327 		POD.Iline = 0;
      328 		end;
      329 	     end;
      330 
      331 	return;
      332 	
      333 FATAL_ERROR:
      334 	Acode = code;
      335 	return;
      336 
      337 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      338 
      339 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      340 
      341 
      342 out:	proc (L);
      343 	
      344      dcl	L			fixed bin(21),
      345 	Lstr			fixed bin(21),
      346 	Pstr			ptr,
      347 	str			char(Lstr) based(Pstr),
      348 	str_array (Lstr)		char(1) based(Pstr);
      349 
      350 	Nvert_tabs = 0;
      351 	Pstr = Pch;
      352 	Lstr = L;
      353 	do while(Lstr > 0);
      354 	     Cop = find_char_$translate_first_in_table (str, break_table, J);
      355 	     if J = 0 then do;
      356 		call iox_$put_chars (POD.switch, Pstr, Lstr, code);
      357 		if code ^= 0 then go to FATAL_ERROR;
      358 		Lstr = 0;
      359 		end;
      360 	     else do;
      361 		op = binary (unspec(Cop), 9);
      362 		go to OUT(op);
      363 		
      364 OUT(49):						/* IGNORE					*/
      365 OUT(51):						/* BS					*/
      366 OUT(52):						/* HT					*/
      367 OUT(53):						/* NL					*/
      368 OUT(54):						/* NP (should never process one of these.	*/
      369 OUT(55):						/* CR					*/
      370 		call iox_$put_chars (POD.switch, Pstr, J, code);
      371 		if code ^= 0 then go to FATAL_ERROR;
      372 		go to END_OUT;
      373 		
      374 OUT(50):		if J > 1 then do;			/* ESCAPE SEQUENCE.				*/
      375 		     call iox_$put_chars (POD.switch, Pstr, J-1, code);
      376 		     if code ^= 0 then go to FATAL_ERROR;
      377 		     end;
      378 		call ioa_$ioa_switch_nnl (POD.switch, "\^3.3b", unspec(str_array(J)));
      379 		go to END_OUT;
      380 		
      381 OUT(56):		if J > 1 then do;			/* VT					*/
      382 		     call iox_$put_chars (POD.switch, Pstr, J-1, code);
      383 		     if code ^= 0 then go to FATAL_ERROR;
      384 		     end;
      385 		Nvert_tabs = Nvert_tabs + 1;
      386 		call ioa_$ioa_switch_nnl (POD.switch, "^v/", vert_tab_lines(Nvert_tabs));
      387 		go to END_OUT;
      388 
      389 END_OUT:		if J < Lstr then
      390 		     Pstr = addr(str_array(J+1));
      391 		Lstr = Lstr - J;
      392 		end;
      393 	     end;
      394 	end out;
      395 
      396 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      397 
      398 
      399 	end lib_paged_output_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/18/86  1230.0  lib_paged_output_.pl1             >spec>install>1098>lib_paged_output_.pl1
83           1    02/28/77  1409.2  lib_paged_output_data_.incl.pl1   >ldd>include>lib_paged_output_data_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALch                                   parameter       fixed bin(21,0)          dcl 36 ref 33 146
APch                                   parameter       pointer                  dcl 36 ref 33 145
Acode                                  parameter       fixed bin(35,0)          dcl 36 set ref 33 141* 144* 333*
BS                              001720 constant        char(1)                  initial unaligned dcl 93 ref 125
CR                              001714 constant        char(1)                  initial unaligned dcl 93 ref 130
Cbreak                          000100 automatic       varying char(512)        dcl 43 set ref 122* 123* 123 124* 124 125* 125 126*
                                                                                  126 127* 127 128* 128 129* 129 130* 130 131* 131
                                                                                  132* 132 133* 133 134* 134 135* 135 136
Cop                             000301 automatic       char(1)                  unaligned dcl 43 set ref 211* 217 354* 361
ESCAPE                          001721 constant        char(1)                  initial unaligned dcl 93 ref 123 124 131 132 135
False                                  constant        bit(1)                   initial dcl 93 ref 137 174 190 199 206 207
HT                              001717 constant        char(1)                  initial unaligned dcl 93 ref 126
IGNORE                          001722 constant        char(1)                  initial unaligned dcl 93 ref 122 134
Iat_column                      000302 automatic       fixed bin(17,0)          dcl 43 in procedure "lib_paged_output_" set ref 147*
                                                                                  214* 214 220* 220 223* 223 226* 226 227 230* 230
                                                                                  231* 231 231 234* 234 238* 238 243* 243 244 245*
                                                                                  248* 248 260 264* 274* 277
Iat_column               17            based           fixed bin(17,0)          level 2 in structure "POD" dcl 1-3 in procedure
                                                                                  "lib_paged_output_" set ref 147 264 277*
Icolumns_used            20            based           fixed bin(17,0)          level 2 in structure "POD" dcl 1-3 in procedure
                                                                                  "lib_paged_output_" set ref 148 265 278*
Icolumns_used                   000303 automatic       fixed bin(17,0)          dcl 43 in procedure "lib_paged_output_" set ref 148*
                                                                                  227* 227 244* 244 260* 260 261 265* 275* 278
Iline                    21            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 158 160 161 167* 191 193
                                                                                  196* 205 263 268* 268 273* 273 286 288* 288 289
                                                                                  289* 289 317 321 327*
Imsf_comp                23            based           fixed bin(17,0)          level 2 dcl 1-3 ref 151
Ipage                    22            based           fixed bin(17,0)          level 2 dcl 1-3 set ref 164* 166* 166 186 188 188
                                                                                  324* 326* 326
J                               000304 automatic       fixed bin(21,0)          dcl 43 set ref 211* 212 213* 214 220 223 226 230 234
                                                                                  238 243 248 254 255 256 257* 268 279 279 281 282
                                                                                  354* 355 364* 374 375 378 378 381 382 389 389 391
L                                      parameter       fixed bin(21,0)          dcl 344 ref 342 352
Lbottom_margin            4            based           fixed bin(17,0)          level 2 dcl 1-3 ref 149
Lch                             000305 automatic       fixed bin(21,0)          dcl 43 set ref 146* 186 201 311 313* 313 315
Lline                     1            based           fixed bin(17,0)          level 2 in structure "POD" dcl 1-3 in procedure
                                                                                  "lib_paged_output_" ref 152 152 261 261
Lline                           000306 automatic       fixed bin(17,0)          dcl 43 in procedure "lib_paged_output_" set ref 208*
                                                                                  256* 256 282* 282 283
Lpage                     2            based           fixed bin(17,0)          level 2 dcl 1-3 ref 149 160 161 317 321
Lprocessed                      000307 automatic       fixed bin(21,0)          dcl 43 set ref 202* 283* 283 299 299 301 305 306
                                                                                  309* 311 311 313
Lstr                            000372 automatic       fixed bin(21,0)          dcl 344 set ref 352* 353 354 354 356* 358* 389 391*
                                                                                  391
Ltop_margin               3            based           fixed bin(17,0)          level 2 dcl 1-3 ref 191 193 196 286
Lunprocessed                    000310 automatic       fixed bin(21,0)          dcl 43 set ref 177* 178* 201* 205 209 211 211 213
                                                                                  255* 255 268 279 281* 281
NL                              001716 constant        char(1)                  initial unaligned dcl 93 ref 127
NLs                             001631 constant        char(200)                initial dcl 93 set ref 161 161 193 193 302 302 321
                                                                                  321
NP                              001715 constant        char(1)                  initial unaligned dcl 93 ref 129
NPchar                                 constant        char(1)                  initial dcl 93 ref 299
Nfrom                     5            based           fixed bin(17,0)          level 2 dcl 1-3 ref 188
Nheading_lines                  000311 automatic       fixed bin(17,0)          dcl 43 set ref 152* 156 158
Nlines                          000312 automatic       fixed bin(17,0)          dcl 43 set ref 203* 205 261* 262* 262 263 268 273
                                                                                  287* 289 289 295*
Nlines_page                     000313 automatic       fixed bin(17,0)          dcl 43 set ref 149* 156 158 205 263 289
Nto                       6            based           fixed bin(17,0)          level 2 dcl 1-3 ref 186 186 188 188
Nvert_tabs                      000314 automatic       fixed bin(17,0)          dcl 43 set ref 204* 285* 285 286 287 350* 385* 385
                                                                                  386
ONE_POS                                constant        char(1)                  initial unaligned dcl 93 ref 133
POD                                    based           structure                level 1 dcl 1-3
PPOD                                   parameter       pointer                  dcl 1-3 set ref 33 140 147 148 149 149 151 151 152
                                                                                  152 152 158 160 160 161 161 161 164 164 164 166
                                                                                  166 167 169 171 172 174 175 176 177 178* 180 181
                                                                                  186 186 186 188 188 188 188 188 191 191 193 193
                                                                                  193 196 196 205 261 261 263 264 265 268 268 268
                                                                                  273 273 277 278 286 286 288 288 289 289 289 302
                                                                                  315 317 317 321 321 321 324 324 324 326 326 327
                                                                                  356 364 375 378 382 386
Pch                             000316 automatic       pointer                  dcl 43 set ref 145* 200 299 305 311* 311 351
Pstr                            000374 automatic       pointer                  dcl 344 set ref 351* 354 356* 364* 375* 378 378 382*
                                                                                  389* 389
Punprocessed                    000320 automatic       pointer                  dcl 43 set ref 176* 178* 200* 211 254* 254 279* 279
Send_of_line                    000322 automatic       bit(1)                   dcl 43 set ref 206* 209 235* 239* 249* 253 262 268
Send_of_page                    000323 automatic       bit(1)                   dcl 43 set ref 199* 205 240* 293* 315
Send_page                16            based           bit(1)                   level 3 packed unaligned dcl 1-3 ref 164 324
Sfirst                          000010 internal static bit(1)                   initial dcl 93 set ref 121 137*
Sheader                  16(02)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 151 171*
                                                                                  174* 180*
Spartial                        000324 automatic       bit(1)                   dcl 43 set ref 169* 172 181
Spartial_last_page       16(01)        based           bit(1)                   level 3 packed unaligned dcl 1-3 set ref 169 172*
                                                                                  175* 181* 268 315
Sprint                          000325 automatic       bit(1)                   dcl 43 set ref 159 188* 190* 192 299 316
Svertical_tab                   000326 automatic       bit(1)                   dcl 43 set ref 207* 250* 284
True                                   constant        bit(1)                   initial dcl 93 ref 171 175 180 188 235 239 240 249
                                                                                  250 293
VPOD_1                                 constant        fixed bin(17,0)          initial dcl 1-3 ref 140
VT                              001713 constant        char(1)                  initial unaligned dcl 93 ref 128
VTchar                                 constant        char(1)                  initial dcl 93 ref 305
addr                                                   builtin function         dcl 85 ref 161 161 176 193 193 254 279 302 302 311
                                                                                  321 321 389
binary                                                 builtin function         dcl 85 ref 217 361
break_table                     000011 internal static char(512)                dcl 93 set ref 136* 211* 354*
ch_array                               based           char(1)                  array unaligned dcl 77 set ref 299 305 311
cleanup                         000330 stack reference condition                dcl 43 ref 170 182
code                            000336 automatic       fixed bin(35,0)          dcl 43 set ref 161* 162 178* 179 193* 194 302* 303
                                                                                  321* 322 333 356* 357 364* 371 375* 376 382* 383
copy                                                   builtin function         dcl 85 ref 123 131 132 133 135
divide                                                 builtin function         dcl 85 ref 152 261
end_page                 12            based           entry variable           level 2 dcl 1-3 ref 164 324
error_table_$unimplemented_version
                                000220 external static fixed bin(35,0)          dcl 93 ref 141
find_char_$translate_first_in_table
                                000212 constant        entry                    external dcl 88 ref 211 354
heading                  24            based           varying char(200)        level 2 dcl 1-3 set ref 152 176 177
ioa_$ioa_switch_nnl             000214 constant        entry                    external dcl 88 ref 378 386
iox_$put_chars                  000216 constant        entry                    external dcl 88 ref 161 193 302 321 356 364 375 382
length                                                 builtin function         dcl 85 ref 152 177
max                                                    builtin function         dcl 85 ref 227 244 260 262
mod                                                    builtin function         dcl 85 ref 231 286
op                              000337 automatic       fixed bin(35,0)          dcl 43 set ref 217* 218 361* 362
str                                    based           char                     unaligned dcl 344 set ref 354*
str_array                              based           char(1)                  array unaligned dcl 344 set ref 378 378 389
substr                                                 builtin function         dcl 85 ref 176
switch                   10            based           pointer                  level 2 dcl 1-3 set ref 161* 193* 302* 321* 356*
                                                                                  364* 375* 378* 382* 386*
switches                 16            based           structure                level 2 dcl 1-3
unprocessed                            based           char                     unaligned dcl 77 set ref 211*
unprocessed_array                      based           char(1)                  array unaligned dcl 77 set ref 254 279
unspec                                                 builtin function         dcl 85 ref 217 361 378 378
version                                based           fixed bin(17,0)          level 2 dcl 1-3 ref 140
vert_tab_lines                  000340 automatic       fixed bin(17,0)          array dcl 43 set ref 286* 287 386*

NAMES DECLARED BY EXPLICIT CONTEXT.
DO                              000000 constant        label                    array(49:56) dcl 220 ref 218
END                             000766 constant        label                    dcl 253 ref 221 224 228 232 236 241 246 251
END_NOT_BREAK                   001002 constant        label                    dcl 260 ref 215
END_OUT                         001601 constant        label                    dcl 389 ref 372 379 387
FATAL_ERROR                     001313 constant        label                    dcl 333 ref 162 179 194 303 322 357 371 376 383
OUT                             000010 constant        label                    array(49:56) dcl 364 ref 362
lib_paged_output_               000045 constant        entry                    external dcl 33 ref 178
out                             001317 constant        entry                    internal dcl 342 ref 301 306 309

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2034        2256    1724        2044
Length      2460    1724       222         166     107         202

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_paged_output_                   308 external procedure  is an external procedure.  
on unit on line 170                  64 on unit               
out                                     internal procedure  shares stack frame of external procedure lib_paged_output_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 Sfirst                      lib_paged_output_
000011 break_table                 lib_paged_output_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_paged_output_        000100 Cbreak                      lib_paged_output_
                         000301 Cop                         lib_paged_output_
                         000302 Iat_column                  lib_paged_output_
                         000303 Icolumns_used               lib_paged_output_
                         000304 J                           lib_paged_output_
                         000305 Lch                         lib_paged_output_
                         000306 Lline                       lib_paged_output_
                         000307 Lprocessed                  lib_paged_output_
                         000310 Lunprocessed                lib_paged_output_
                         000311 Nheading_lines              lib_paged_output_
                         000312 Nlines                      lib_paged_output_
                         000313 Nlines_page                 lib_paged_output_
                         000314 Nvert_tabs                  lib_paged_output_
                         000316 Pch                         lib_paged_output_
                         000320 Punprocessed                lib_paged_output_
                         000322 Send_of_line                lib_paged_output_
                         000323 Send_of_page                lib_paged_output_
                         000324 Spartial                    lib_paged_output_
                         000325 Sprint                      lib_paged_output_
                         000326 Svertical_tab               lib_paged_output_
                         000336 code                        lib_paged_output_
                         000337 op                          lib_paged_output_
                         000340 vert_tab_lines              lib_paged_output_
                         000372 Lstr                        out
                         000374 Pstr                        out

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ge_a              alloc_cs            call_var            call_ext_in         call_ext_out_desc
call_ext_out        return              mod_fx1             enable              shorten_stack       ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
find_char_$translate_first_in_table                         ioa_$ioa_switch_nnl           iox_$put_chars

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$unimplemented_version




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     33 000040       121 000052       122 000054       123 000060       124 000076       125 000105       126 000114
    127 000123       128 000132       129 000141       130 000150       131 000157       132 000175       133 000214
    134 000234       135 000244       136 000263       137 000270       140 000271       141 000276       142 000300
    144 000301       145 000302       146 000305       147 000307       148 000312       149 000314       151 000317
    152 000325       156 000333       158 000336       159 000341       160 000343       161 000346       162 000367
    164 000371       166 000405       167 000411       169 000412       170 000420       171 000434       172 000442
    173 000447       174 000450       175 000455       176 000457       177 000461       178 000463       179 000477
    180 000501       181 000506       182 000513       186 000514       188 000531       190 000541       191 000542
    192 000545       193 000547       194 000571       196 000573       199 000600       200 000601       201 000603
    202 000605       203 000606       204 000607       205 000610       206 000623       207 000624       208 000625
    209 000626       211 000632       212 000661       213 000663       214 000665       215 000666       217 000667
    218 000672       220 000673       221 000676       223 000677       224 000702       226 000703       227 000706
    228 000714       230 000715       231 000720       232 000727       234 000730       235 000733       236 000735
    238 000736       239 000741       240 000743       241 000744       243 000745       244 000750       245 000755
    246 000756       248 000757       249 000762       250 000764       251 000765       253 000766       254 000770
    255 000774       256 000776       257 001000       259 001001       260 001002       261 001007       262 001017
    263 001025       264 001031       265 001033       266 001035       268 001036       273 001053       274 001055
    275 001056       277 001057       278 001061       279 001063       281 001071       282 001073       283 001075
    284 001077       285 001101       286 001102       287 001114       288 001115       289 001117       293 001126
    295 001130       297 001131       299 001132       301 001145       302 001151       303 001175       304 001177
    305 001200       306 001202       307 001206       309 001207       311 001211       313 001220       315 001222
    316 001234       317 001236       321 001244       322 001266       324 001270       326 001304       327 001310
    329 001311       331 001312       333 001313       335 001316       342 001317       350 001321       351 001322
    352 001324       353 001326       354 001330       355 001357       356 001361       357 001401       358 001403
    359 001404       361 001405       362 001410       364 001411       371 001431       372 001433       374 001434
    375 001437       376 001461       378 001463       379 001520       381 001521       382 001524       383 001546
    385 001550       386 001551       387 001600       389 001601       391 001607       393 001611       394 001612


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
