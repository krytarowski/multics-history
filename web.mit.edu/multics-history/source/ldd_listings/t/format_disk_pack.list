	COMPILATION LISTING OF SEGMENT format_disk_pack
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1030.3 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 format_disk_pack:  fdp:	procedure;
       12 
       13 /*
       14*   Initially coded by J. A. Bush -- December, 1975
       15*   Modified by J. A. Bush -- May 1976 for NSS to write format label on System volumes
       16*   Modified by J. A. Bush -- July 1977 to fix bug making t.i. bits undefined if "-hbypass" and "-nodef" args were both used
       17*   Modified by P. B. Kelley -- August 1978 to fix several bugs and remove dependence upon rec. 7 of Multics label.
       18*			 Entire volume bad track list may now only be generated by "read_pack" & "format_pack" ops.
       19*			 Changed structure of arguments passed to avoid "positional argument bugs".
       20*			 Also provided consistency and constraints for formatting tracks.
       21**/
       22 
  1     1 /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  1     2 
  1     3 
  1     4 
  1     5 
  1     6 /****^  HISTORY COMMENTS:
  1     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  1     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  1     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  1    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  1    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  1    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  1    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  1    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  1    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18 
  1    19 /*
  1    20*   All disk packs have the standard layout described below:
  1    21*
  1    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  1    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  1    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  1    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  1    26*   Record  7		: formerly contained bad track list; no longer used.
  1    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  1    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  1    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  1    30*
  1    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  1    32*   of the particular partition.
  1    33*
  1    34*
  1    35*
  1    36*   A conceptual declaration for a disk pack could be:
  1    37*
  1    38*   dcl 1 disk_pack,
  1    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  1    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  1    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  1    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  1    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  1    44*   2 vtoc_array_records	(8 : n-1),
  1    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  1    46*   3 unused				bit(36 * 64),
  1    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  1    48*
  1    49*
  1    50*
  1    51*
  1    52**/
  1    53 
  1    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  1    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  1    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  1    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  1    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  1    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  1    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  1    61 		         fixed bin (17) int static options (constant);
  1    62 
  1    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  1    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  1    65 /* or the physical volume table entry (pvte) device type.		      */
  1    66 
  1    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  1    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  1    69 
  1    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  1    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  1    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  1    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  1    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  1    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  1    76 
  1    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
       23 
  2     1 /* BEGIN INCLUDE FILE ... fs_vol_label.incl.pl1 .. last modified January 1982 for new volume map format  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(86-04-10,Fawcett), approve(86-04-10,MCR7383),
  2     5*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  2     6*     Add the subvolume info.
  2     7*  2) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  2     8*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  2     9*     Added inconsistent_dbm bit used to determine consistency of volume
  2    10*     dumper bit maps.
  2    11*                                                   END HISTORY COMMENTS */
  2    12 
  2    13 /* This is the label at fixed location of each physical volume. Length 1 page */
  2    14 /* Note: fsout_vol clears pad fields before writing the label */
  2    15 
  2    16 dcl  labelp ptr;
  2    17 
  2    18 dcl 1 label based (labelp) aligned,
  2    19 
  2    20 /* First comes data not used by Multics.. for compatibility with GCOS */
  2    21 
  2    22     2 gcos (5*64) fixed bin,
  2    23 
  2    24 /* Now we have the Multics label */
  2    25 
  2    26     2 Multics char (32) init ("Multics Storage System Volume"), /* Identifier */
  2    27     2 version fixed bin,				/* Version 1 */
  2    28     2 mfg_serial char (32),				/* Manufacturer's serial number */
  2    29     2 pv_name char (32),				/* Physical volume name. */
  2    30     2 lv_name char (32),				/* Name of logical volume for pack */
  2    31     2 pvid bit (36),				/* Unique ID of this pack */
  2    32     2 lvid bit (36),				/* unique ID of its logical vol */
  2    33     2 root_pvid bit (36),				/* unique ID of the pack containing the root. everybody must agree. */
  2    34     2 time_registered fixed bin (71),			/* time imported to system */
  2    35     2 n_pv_in_lv fixed bin,				/* # phys volumes in logical */
  2    36     2 vol_size fixed bin,				/* total size of volume, in records */
  2    37     2 vtoc_size fixed bin,				/* number of recs in fixed area + vtoc */
  2    38     2 not_used bit (1) unal,				/* used to be multiple_class */
  2    39     2 private bit (1) unal,				/* TRUE if was registered as private */
  2    40     2 inconsistent_dbm bit (1) unal,			/* TRUE if ESD-less crash */
  2    41     2 flagpad bit (33) unal,
  2    42     2 max_access_class bit (72),			/* Maximum access class for stuff on volume */
  2    43     2 min_access_class bit (72),			/* Minimum access class for stuff on volume */
  2    44     2 password bit (72),				/* not yet used */
  2    45     2 number_of_sv fixed bin,				/* if = 0 not a subvolume else the number of svs */
  2    46     2 this_sv fixed bin,				/* what subvolume number it is */
  2    47     2 sub_vol_name char (1),				/* what subvolume name (a b c d) it is */
  2    48     2 pad1 (13) fixed bin,
  2    49     2 time_mounted fixed bin (71),			/* time mounted */
  2    50     2 time_map_updated fixed bin (71),			/* time vmap known good */
  2    51 
  2    52 /* The next two words overlay time_unmounted on pre-MR10 systems. This
  2    53*   forces a salvage if an MR10 pack is mounted on an earlier system.
  2    54* */
  2    55     2 volmap_version fixed bin,			/* version of volume map (currently 1) */
  2    56     2 pad6 fixed bin,				
  2    57 
  2    58     2 time_salvaged fixed bin (71),			/* time salvaged */
  2    59     2 time_of_boot fixed bin (71),			/* time of last bootload */
  2    60     2 time_unmounted fixed bin (71),			/* time unmounted cleanly */
  2    61     2 last_pvtx fixed bin,				/* pvtx in that PDMAP */
  2    62     2 pad1a (2) fixed bin,
  2    63     2 err_hist_size fixed bin,			/* size of pack error history */
  2    64     2 time_last_dmp (3) fixed bin (71),			/* time last completed dump pass started */
  2    65     2 time_last_reloaded fixed bin (71),		/* what it says */
  2    66     2 pad2 (40) fixed bin,
  2    67     2 root,
  2    68       3 here bit (1),				/* TRUE if the root is on this pack */
  2    69       3 root_vtocx fixed bin (35),			/* VTOC index of root, if it is here */
  2    70       3 shutdown_state fixed bin,			/* Status of hierarchy */
  2    71       3 pad7 bit (1) aligned,				
  2    72       3 disk_table_vtocx fixed bin,			/* VTOC index of disk table on RPV */
  2    73       3 disk_table_uid bit (36) aligned,		/* UID of disk table */
  2    74       3 esd_state fixed bin,				/* State of esd */
  2    75     2 volmap_record fixed bin,			/* Begin record of volume map */
  2    76     2 size_of_volmap fixed bin,			/* Number of records in volume map */
  2    77     2 vtoc_map_record fixed bin,			/* Begin record of VTOC map */
  2    78     2 size_of_vtoc_map fixed bin,			/* Number of records in VTOC map */
  2    79     2 volmap_unit_size fixed bin,			/* Number of words per volume map section */
  2    80     2 vtoc_origin_record fixed bin,			/* Begin record of VTOC */
  2    81     2 dumper_bit_map_record fixed bin,			/* Begin record of dumper bit-map */
  2    82     2 vol_trouble_count fixed bin,			/* Count of inconsistencies found since salvage */
  2    83     2 pad3 (52) fixed bin,
  2    84     2 nparts fixed bin,				/* Number of special partitions on pack */
  2    85     2 parts (47),
  2    86       3 part char (4),				/* Name of partition */
  2    87       3 frec fixed bin,				/* First record */
  2    88       3 nrec fixed bin,				/* Number of records */
  2    89       3 pad5 fixed bin,
  2    90     2 pad4 (5*64) fixed bin;
  2    91 
  2    92 dcl  Multics_ID_String char (32) init ("Multics Storage System Volume") static;
  2    93 
  2    94 /* END INCLUDE FILE fs_vol_label.incl.pl1 */
       24 
       25 
  3     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  3     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  3     3 /*	version number changed to 4, 08/10/78 WOS */
  3     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  3     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  3     6 
  3     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  3     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  3     9     2 switches aligned,                                     /* various bit switch values */
  3    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  3    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  3    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  3    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  3    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  3    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  3    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  3    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  3    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  3    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  3    20 
  3    21 /*  Limit of data defined for version 2 */
  3    22 
  3    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  3    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  3    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  3    26 						/* minimum of 30 seconds required for repeat */
  3    27 						/* otherwise, no repeat will occur */
  3    28 /* Limit of data defined for version 4 */
  3    29 
  3    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  3    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  3    32 
  3    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  3    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  3    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  3    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  3    37 
  3    38 /*	END INCLUDE FILE query_info.incl.pl1 */
       26 
       27 
       28 dcl  iox_$attach_name	entry (char (*), ptr, char (*), ptr, fixed bin (35)),
       29      iox_$close		entry (ptr, fixed bin (35)),
       30      iox_$control		entry (ptr, char (*), ptr, fixed bin (35)),
       31      iox_$detach_iocb	entry (ptr, fixed bin (35)),
       32      iox_$modes		entry (ptr, char (*), char (*), fixed bin (35)),
       33      iox_$open		entry (ptr, fixed bin, bit (1) aligned, fixed bin (35)),
       34      iox_$seek_key		entry (ptr, char (256) varying, fixed bin (21), fixed bin (35)),
       35      iox_$read_record	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
       36      iox_$rewrite_record	entry (ptr, ptr, fixed bin (21), fixed bin (21), fixed bin (35)),
       37     (ioa_, com_err_, ioa_$rsnnl, command_query_)	entry options (variable),
       38      cv_dec_check_		entry (char (*), fixed bin (35)) returns (fixed bin (35)),
       39      get_system_free_area_	entry returns (ptr),
       40      hcs_$initiate		entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35)),
       41      hcs_$fs_get_mode	entry (ptr, fixed bin (5), fixed bin (35)),
       42      cu_$arg_count		entry (fixed bin),
       43      cu_$arg_ptr		entry (fixed bin, ptr, fixed bin, fixed bin (35)),
       44      user_info_$process_type	entry ( fixed bin ),
       45      date_time_		entry (fixed bin (71), char (*));
       46 
       47 dcl 1 trk_header_info aligned,			/* structure returned from rd_trk_header order */
       48     2 ha_cyl bit (16) unaligned,			/* home address cylinder number */
       49     2 ha_hd bit (16) unaligned,			/* home address head number */
       50     2 pad1 bit (2) unaligned,
       51     2 ti bit (2) unaligned,				/* track indicator bits */
       52     2 pad2 bit (10) unaligned,
       53     2 r0cti bit (2) unaligned,			/* record zero ti bits */
       54     2 r0ccyl bit (16) unaligned,			/* record zero count cylinder number */
       55     2 r0chd bit (16) unaligned,			/* record zero count head number */
       56     2 r0crn bit (8) unaligned,			/* record zero count  record number */
       57     2 pad3 bit (24) unaligned,
       58     2 r0df (8) bit (8) unaligned,			/* record zero data field */
       59     2 pad4 bit (4) unaligned;
       60 
       61 dcl 1 fmt_info aligned,				/* user supplied structure for format_trk order */
       62     2 hz bit (2) unaligned,				/* header bypass information */
       63     2 ti bit (2) unaligned,				/* track indicator bits */
       64     2 alt_def_cyl fixed bin (16) unaligned,		/*  user supplied cyl and head address for alt or   */
       65     2 alt_def_hd fixed bin (16) unaligned;		/* defective track address */
       66 
       67 dcl 1 dev_char_table aligned,				/* return structure from device_info order */
       68     2 subsystem_name char (4),			/* Disk subsystem name */
       69     2 device_name char (8),				/* Disk drive name */
       70     2 sect_per_dev fixed bin (35),			/* total no. of non-T&D sectors on pack */
       71     2 cyl_per_dev fixed bin,				/* no. of non-T&D cylinders on pack */
       72     2 sect_per_cyl fixed bin,				/* no of sectors per cylinder */
       73     2 sect_per_track fixed bin,			/* no. of sectors per track */
       74     2 num_label_sect fixed bin,			/* no. of sectors to reserve for label */
       75     2 num_alt_sect fixed bin,				/* no. of sectors to reserve for alt. track area */
       76     2 sect_size fixed bin (12);			/* no. of words in sector */
       77 
       78 dcl 1 bounds,					/* return structure from getbounds order */
       79     2 low fixed bin (35),				/* low boundary */
       80     2 high fixed bin (35);				/* high disk boundary */
       81 
       82 dcl (error_table_$noarg,
       83      error_table_$action_not_performed,
       84      error_table_$not_detached,
       85      error_table_$request_not_recognized) ext fixed bin (35);
       86 
       87 dcl (code, seek_key, alt_add) fixed bin (35);
       88 dcl  process_type fixed bin;
       89 dcl ( ap, iocb_ptr, lsp, query_ptr ) ptr;
       90 dcl  areap ptr;
       91 dcl  formatp ptr;					/* pointer to format_label structure */
       92 dcl (mode, i, j, cyl, head, line_pos, outlen, altb, rlen, legal_cyl, legal_hd) fixed bin;
       93 dcl (al, n_args, sect_per_rec, use_sect_per_cyl, unuse_sect_per_cyl) fixed bin;
       94 dcl  arg char (al) based (ap);
       95 dcl  rec_len fixed bin (21);
       96 
       97 dcl  rs_mode fixed bin (5);				/* rcp_sys_ acess mode */
       98 dcl  execute bit (5) init ("00100"b);			/* execute permission */
       99 dcl  Option	char (20) varying,
      100      answer	char (10) varying,
      101      erresponse	char (18) varying,
      102      response	char (18) varying,
      103      vol_id	char (32) varying;
      104 
      105 dcl  adescrip	char (168),			/* rdisk_ attach description */
      106      dev_type	char (4),
      107      proc_name	char (16) init ("format_disk_pack"),
      108      pstring	char (5),
      109      ltime	char (24),
      110      out		char (256);
      111 dcl  error label;
      112 dcl  cleanup		condition,
      113      program_interrupt	condition;
      114 dcl (already_printed, input, open, read, hold, defective, interactive, system, fmt_good, bypass, priv, rstsw, fstsw,
      115      write_attach, not_attached_by_me)
      116      bit (1) unaligned init ("0"b);
      117 dcl (addr, bit, ceil, divide, fixed, hbound, index, length, mod, null, rtrim, substr, verify) builtin;
      118 dcl  (alt_partition_present, multics_storage_system_volume, total_bad_track_list) bit(1) init ("0"b);
      119 dcl  RECURSE bit(1) static init ("0"b);
      120 
      121 dcl  multics_lab_rec fixed bin(23) unaligned;
      122 dcl  1  MULTICS_LABEL aligned like label;
      123 
      124 dcl  area area based (areap);
      125 
      126 dcl max_bad_trks fixed bin(35) init(141);		/* maximum number of bad tracks - initialize for now */
      127 
      128 dcl 1 FORMAT_INFO aligned based (formatp),		/* format data - allocated in system free */
      129     2 bad_trk_count fixed bin,			/* Number of defective tracks on this pack */
      130     2 bad_trks (max_bad_trks),			/* array of defective tracks */
      131       3 track_addr fixed bin (35),			/* First bad Multics record address on this bad track */
      132       3 alt_addr   fixed bin(35),			/* alternate addr ( = 0 if none) */
      133       3 bad_rcd_cnt fixed bin;			/* number of bad Multics records on this track */
      134 
      135 
      136 	if RECURSE then do;				/* don't allow recursive calling */
      137 	     call com_err_ (error_table_$action_not_performed, proc_name,
      138 		"^/^a cannot be invoked recursively. Please type ^/ release -all ^/and try again.", proc_name);
      139 	     return;
      140 	end;
      141 	query_ptr = addr (query_info);
      142 	call user_info_$process_type ( process_type );
      143 	if process_type ^= 1
      144 	     then interactive = "0"b;
      145 	     else interactive = "1"b;
      146 	multics_lab_rec = LABEL_ADDR;
      147 	call cu_$arg_count (n_args);
      148 	if n_args < 2 then do;			/* not enough or no args */
      149 	     call com_err_ (error_table_$noarg, proc_name);
      150 puse:
      151 	     call com_err_ (0, "", "Usage:^-format_disk_pack operation <-volume volume_name> {-control_args-}" );
      152 	     call com_err_ (0, "", "^-^2xoperation:^5xformat_pack, read_pack, format_track, read_track, or read_label" );
      153 	     call com_err_ (0, "", "^-^2xcontrol_args:^2x<-model model_name>, -system, -nodef, -hold, -hbypass"   );
      154 	     call com_err_ (0, "", "^-^5xmodel_name may be: m451, m400, d190, or d181 (m400 default)");
      155 
      156 	     return;
      157 	end;
      158 	vol_id = "";				/* initialize to check */
      159 	dev_type = "m400";				/* default  */
      160 
      161 	do i = 1 to n_args;				/* process arguments */
      162 	     call cu_$arg_ptr (i, ap, al, code);
      163 	     if code ^= 0 then do;
      164 		call com_err_ (code, proc_name);
      165 		return;
      166 		end;
      167 	     if i = 1 then do;			/* special case arg 1 = positional arg = order */
      168 		if ( (arg ^= "format_track") & (arg ^= "format_pack")
      169 		   & (arg ^= "read_track") & (arg ^= "read_pack")
      170 		     & (arg ^= "read_label") ) then do;
      171 		     call com_err_ (error_table_$request_not_recognized, proc_name, "^a", arg );
      172 		     return;
      173 		     end;
      174 		Option = arg;			/* got a valid Option */
      175 						/* make sure Option doesn't require "interactive" */
      176 		if (^interactive) then if ( (Option ^= "format_pack") & (Option ^= "read_pack") & (Option ^= "read_label") ) then do;
      177 		     call com_err_ (0, proc_name, "The ""^a"" operation is valid only from an interactive process.", Option );
      178 		     return;
      179 		     end;
      180 		end;
      181 
      182 	     else if ((arg = "-volume") | (arg = "-vol")) then do;	/* volume" name comes next */
      183 		i = i + 1;				/* increment i */
      184 		call cu_$arg_ptr ( i, ap, al, code );
      185 		if ( (code ^= 0) | (al = 0) ) then do;		/* need volume name */
      186 		     call com_err_ ( 0, proc_name, "Missing volume name after the ""-volume"" control argument." );
      187 		     return;
      188 		     end;
      189 		vol_id = arg;
      190 		end;
      191 
      192 	     else if arg = "-model" then do;			/* model comes next */
      193 		i = i + 1;
      194 		call cu_$arg_ptr( i, ap, al, code );
      195 		if ( (code ^= 0) | (al = 0) ) then do;		/* need model # after "-model" */
      196 		     call com_err_ ( 0, proc_name, "Missing model after the ""-model"" control argument." );
      197 		     return;
      198 		     end;
      199 		dev_type = arg;				/* got device type */
      200 		end;
      201 
      202 	     else if ( (arg = "-system") | (arg = "-sys") ) 	/* thinks they have system privileges */
      203 		then system = "1"b;				/* we'll check for sure later. */
      204 
      205 	     else if arg = "-hold" then do;			/* user doesn't want to release disk */
      206 		if ^interactive then do;			/* can't "hold" from absentee */
      207 		     call com_err_ (0, proc_name, "The ""-hold"" argument is only allowed from an interactive process.");
      208 		     return;
      209 		     end;
      210 		hold = "1"b;
      211 		end;
      212 
      213 	     else if arg = "-hbypass"				/* bypass track headers already there */
      214 		then bypass = "1"b;
      215 
      216 	     else if arg = "-nodef" then do;			/* no defective tracks */
      217 		if Option ^= "format_pack" then do;		/* only valid with this order */
      218 		     call com_err_ (0, proc_name,
      219 			"The ""-nodef"" argument is only valid with the ""format_pack"" order." );
      220 		     return;
      221 		     end;
      222 		fmt_good = "1"b;				/* passed the test */
      223 		end;
      224 
      225 	     else do;					/* must be illegal option */
      226 		call com_err_ (error_table_$request_not_recognized, proc_name, "^a", arg);
      227 		return;
      228 		end;
      229 	     end;
      230 
      231 	if vol_id = "" then do;				/* user must specify volume name */
      232 	     call com_err_ (0, proc_name, "No volume specified. Cannot perform operation." );
      233 	     return;
      234 	     end;
      235 						/* Do we have to attach the disk for writing?	*/
      236 	if (Option = "format_pack" | Option = "format_track" )
      237 	     then write_attach = "1"b;		/* definitely!	*/
      238 	if (fmt_good | hold | bypass)
      239 	     then write_attach = "1"b;		/* likewise..	*/
      240 
      241 	on cleanup call release;			/* set up "cleanup" handler to release pack.	*/
      242 	call mount;				/* and make call to mount the disk */
      243 	if (code ^= 0 | ^open) then do;		/* error?	*/
      244 	     call release;			/* make sure we release before exiting */
      245 	     return;				/* couldn't mount, reason already given */
      246 	     end;
      247 
      248 	go to find_op;
      249 
      250 option_lp:
      251 	if ^interactive | (interactive & ^hold) then do;	/* release disk pack */
      252 	     call release;
      253 	     return;
      254 	     end;
      255 	if ^already_printed then do;			/* only print out instructions once */
      256 	     already_printed = "1"b;
      257 	     call ioa_ ("After ""Options:"", is typed out, enter one of the following options:");
      258 	     call ioa_ ("""format_pack"", ""read_pack"", ""read_track"", ""format_track"", ""read_label"", or ""quit""");
      259 	     end;
      260 
      261 	yes_or_no_sw, suppress_name_sw = "0"b;
      262 	call command_query_ (query_ptr, Option, "", "Options:");
      263 find_op:
      264 	if Option = "format_pack"
      265 	     then call format_pack;
      266 
      267 	else if Option = "read_pack" then do;
      268 	     call read_pack;
      269 	     end;
      270 
      271 	else if Option = "read_label" then do;
      272 	     call read_pack_label;
      273 	     end;
      274 
      275 	else if Option = "read_track" then do;
      276 	     if ^interactive then do;			/* operation is not allowed in absentee mode */
      277 abs_err:		call com_err_ (0, proc_name, "The ^a operation is only allowed from an ""interactive"" process.", Option);
      278 		return;
      279 		end;
      280 	     call read_track;
      281 	     end;
      282 
      283 	else if Option = "format_track" then do;
      284 	     if ^interactive
      285 		then go to abs_err;			/* operation is not allowed in absentee mode */
      286 						/* if Multics & it has no alt part., then don't allow this */
      287 	     if (multics_storage_system_volume & ^alt_partition_present) then do;
      288 		call ioa_ ("Multics Storage System volume ""^a"" has no ""alt"" partition defined.",
      289 		     vol_id );
      290 		call ioa_ ( "The ""format_track"" operation is not valid on this volume." );
      291 		go to option_lp;
      292 		end;
      293 	     call format_track;			/* OK, we'll allow it */
      294 	     end;
      295 
      296 	else if Option = "quit" then do;
      297 	     if open
      298 		then call release;			/* dismount pack if mounted */
      299 	     return;
      300 	     end;
      301 
      302 	else if ^already_printed then do;			/* if  the initial entry */
      303 	     call com_err_ (0, proc_name, "Operation ^a not recognized", Option);
      304 	     go to puse;
      305 	     end;
      306 
      307 	else call com_err_ (0, proc_name, "Illegal option ^a, reenter", Option);
      308 	go to option_lp;
      309 
      310 read_pack: proc;					/* read_pack subsystem */
      311 
      312 				/* Forms seek addresses for the entire pack, then calls	*/
      313 				/* the rd_sing_trk proc to process. Summary only at end.	*/
      314 	     call ioa_ ("Begin ""read_pack"" operation");
      315 						/* since this operation takes a long time */
      316 						/* establish pi handler to say something  */
      317 	     on program_interrupt			/* useful if user gets bored.              */
      318 		call ioa_ ("Processing ^a", cseek (seek_key ) );
      319 
      320 	     do seek_key = bounds.low to bounds.high - sect_per_track by sect_per_track;
      321 		call rd_sing_trk (seek_key);		/* rd track header */
      322 		if code ^= 0
      323 		     then call com_err_ (0, proc_name, "Skipping to next track.");
      324 		end;
      325 
      326 	     revert program_interrupt;
      327 
      328 						/* if we got this far then we've got the */
      329 	     total_bad_track_list = "1"b;		/* total bad track list figured out.  */
      330 						/* if we had any bad tracks  print them out */
      331 	     call prt_bad_trks;
      332 
      333 	     return;
      334 
      335 	end read_pack;
      336 
      337 read_track:  proc;					/* read track subsystem */
      338 
      339 				/* Queries user for "ccc,hh" input, then calls the 	*/
      340 				/* rd_sing_trk proc to process and print.		*/
      341 
      342 	if ^rstsw then do;				/* print out instructions one time */
      343 	     call ioa_ ("Enter track address as ""ccc,hh"" for cylinder and head");
      344 	     call ioa_ ("Terminate query by typing ""quit"".");
      345 	     rstsw = "1"b;			     	/* set switch so we don't print this out  again */
      346 	     end;
      347 
      348 	input = "1"b;
      349 	do while (input);
      350 read_track_er:
      351 	     yes_or_no_sw = "0"b;
      352 	     suppress_name_sw = "1"b;
      353 	     call command_query_ (query_ptr, response, "", "Enter:");
      354 	     if ( (response = "quit") | (length(response) = 0) ) then do;
      355 		input = "0"b;
      356 		call prt_bad_trks;			/* print out what we know */
      357 		end;
      358 	     else do;				/* still in the loop */
      359 		erresponse = response;		/* save for error reporting */
      360 		error = read_track_er;		/* set up error label */
      361 		line_pos = 1;			/* start at beginning of input */
      362 		rlen = length(response);		/* initial string length */
      363 		seek_key = form_sk_add ();		/* convert address */
      364 		call rd_sing_trk (seek_key);		/* call reader */
      365 		end;
      366 	     end;
      367 
      368 	end read_track;
      369 
      370 rd_sing_trk: proc (seek_key);				/* procedure to read headers of single trks */
      371 
      372 				/* Makes call to rd_header to physically read track.	*/
      373 				/* If called from the "read_track" option, then full	*/
      374 				/* description of track's status is printed, otherwise,	*/
      375 				/* only errors in track assignment are printed.		*/
      376 				/* If the track is "defa" or "alt", then an attempt is	*/
      377 				/* made to read the track which it points to for		*/
      378 				/* verification. If this verification turns out false, then	*/
      379 				/* user is warned appropriately.			*/
      380 
      381 dcl
      382      seek_key	fixed bin(35),
      383      temp_seek_key	fixed bin(35),
      384      match_seek_key	fixed bin(35);
      385 
      386 
      387 	call rd_header (seek_key);			/* go read the header */
      388 	if code ^= 0
      389 	     then return;				/* if error skip to next trk */
      390 
      391 	if trk_header_info.ti = "00"b then do;		/* "good", form message for later */
      392 		call ioa_$rsnnl ("Track ^a is formatted ""good"".", out, outlen, cseek(seek_key) );
      393 		call remove (seek_key);		/* make sure it's out of def list */
      394 		end;
      395 
      396 	else if trk_header_info.ti = "11"b then do;	/* "def", form message for later  */
      397 		call ioa_$rsnnl ("Track ^a is formatted ""def"", no alternate assigned.", out, outlen, cseek(seek_key) );
      398 		call sort (seek_key, 0);		/* sort into defective list */
      399 		end;
      400 
      401 	else if trk_header_info.ti = "01"b then do;	/* alternate trk */
      402 	     call remove (seek_key);			/* make sure it's out of def. list */
      403 	     error = rd_sing_loop;
      404 	     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      405 						/* form message for later */
      406 	     call ioa_$rsnnl ("Track ^a is formatted alternate for defective track ^a",
      407 		out, outlen, cseek(seek_key), cseek(temp_seek_key) );
      408 	     call rd_header (temp_seek_key);
      409 	     if code ^= 0 then do;
      410 						/* add to previous message for later */
      411 		call ioa_$rsnnl ("^/Unable to verify original defective track.  ^a.",
      412 		     out, outlen, cseek ( temp_seek_key) );
      413 		go to rd_sing_loop;
      414 		end;
      415 						/* match defective and its assigned alt */
      416 	     match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      417 	     if match_seek_key ^= seek_key then do;	/* shouldn't be this way !! */
      418 		call ioa_ ( "^/ERROR: Assignment mismatch.^/^a",
      419 		     "Defective track and its alleged alternate do not agree." );
      420 		call ioa_ ("Track ^a has been assigned as alternate for ^a,",
      421 		     cseek (seek_key), cseek(temp_seek_key) );
      422 		call ioa_ ("while ^a doesn't think ^a is its alternate.",
      423 		     cseek(temp_seek_key), cseek(seek_key) );
      424 		return;				/* return from here */
      425 		end;
      426 	     call sort (temp_seek_key, seek_key);		/* sort in original trk */
      427 	     end;
      428 
      429 	else if trk_header_info.ti = "10"b then do;	/* "defa" */
      430 	     call sort (seek_key, 0);			/* sort into defective list */
      431 	     error = rd_sing_loop;
      432 	     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      433 						/* form message for later */
      434 	     call ioa_$rsnnl ("Track ^a is formatted defective, alternate track assigned - ^a",
      435 		out, outlen, cseek(seek_key), cseek(temp_seek_key) );
      436 	     call rd_header (temp_seek_key);		/* read alternate */
      437 	     if code ^= 0 then do;
      438 						/* add to previously formed message */
      439 		call ioa_$rsnnl ("^/Unable to verify assigned alternate.  ^a",
      440 		     out, outlen, cseek(seek_key) );
      441 		go to rd_sing_loop;
      442 		end;
      443 	     match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      444 	     if match_seek_key ^= seek_key then do;	/* this shouldn't happen */
      445 		call ioa_ ( "ERROR: Assignment mismatch. Defective track and its assigned alternate do not match." );
      446 		call ioa_ ("Track ^a has been formatted as defective with ^a as its assigned alternate.",
      447 		     cseek(seek_key), cseek(temp_seek_key) );
      448 		call ioa_ ("while ^a doesn't think its the alternate for ^a",
      449 		     cseek(temp_seek_key), cseek(seek_key) );
      450 		call ioa_ ("This is a serious discrepency and must be fixed before using disk.");
      451 		return;				/* return from here */
      452 		end;
      453 	     call remove (seek_key);			/* we've already put it in without its alt , so */
      454 	     call sort (seek_key, temp_seek_key);	/* sort in def and it's alt */
      455 	     end;
      456 rd_sing_loop:
      457 	if Option = "read_track"			/* if we're in verbose mode, then */
      458 	     then call ioa_ ("^a", out);		/* print out something */
      459 	return;
      460 
      461 	end rd_sing_trk;
      462 
      463 format_pack: proc;					/* read pack and format pack subsystems */
      464 
      465 				/* Forms seek address for entire pack then calls		*/
      466 				/* format_trk for actual formating. If the "-nodef"	*/
      467 				/* or "-hbypass" control argument was given, then previous	*/
      468 				/* track info is ignored. Otherwise, the track is		*/
      469 				/* first read and if "def", "defa", or "alt", then its	*/
      470 				/* previous info is retained.				*/
      471 
      472 	if (fmt_good | bypass) then do;		/* warn user */
      473 	     call ioa_ ("^/Warning:  The ""-nodef"" and/or ""-hbypass"" control argument being specified,");
      474 	     call ioa_ ("^-previous bad track information will be ignored.");
      475 	     end;
      476 
      477 	call ioa_ ("Begin ""format_pack"" operation");
      478 						/* since this operation takes a long time */
      479 						/* establish pi handler to say something  */
      480 	on program_interrupt			/* useful if user gets bored.        */
      481 	     call ioa_ ( "Processing ^a", cseek (seek_key) );
      482 
      483 	if bypass
      484 	     then fmt_info.hz = "00"b;		/* set up header bypass switch */
      485 	     else fmt_info.hz = "01"b;
      486 	FORMAT_INFO.bad_trk_count = 0;		/* initialize bad track counter */
      487 
      488 	do seek_key = bounds.low to bounds.high - sect_per_track by sect_per_track;
      489 	     fmt_info.ti = "00"b;			/* initially set ti bits for good trk */
      490 	     fmt_info.alt_def_cyl = 0;		/* zap alt information */
      491 	     fmt_info.alt_def_hd = 0;
      492 	     if ^( bypass | fmt_good ) then do;		/* if we're not ignoring previous info */
      493 		call rd_header (seek_key);		/* rd track header */
      494 		if code ^= 0
      495 		     then go to format_pack_er1;	 /* skip read on error, but try write */
      496 		if trk_header_info.ti ^= "00"b then do;
      497 		     fmt_info.ti = trk_header_info.ti;
      498 		     fmt_info.alt_def_cyl = fixed(trk_header_info.r0ccyl);
      499 		     fmt_info.alt_def_hd = fixed(trk_header_info.r0chd);
      500 		     if trk_header_info.ti ^= "01"b	/* don't sort in "alt"'s */
      501 			then call sort (seek_key, 0);		/* initially sort in as "def" */
      502 		     if trk_header_info.ti = "10"b then do;	/* if "defa", then get alt */
      503 			call remove (seek_key);
      504 			call rd_sing_trk (seek_key);		/* this verifies, plus sorts in addr */
      505 			end;
      506 		     end;
      507 		end;
      508 format_pack_er1:
      509 	     call format_trk (seek_key);		/* go format */
      510 	     if code ^= 0
      511 		then call com_err_ (0, proc_name, "Skipping to next track.");
      512 	     end;
      513 	revert program_interrupt;
      514 						/* if we got this far then we've got the */
      515 	total_bad_track_list = "1"b;			/* total bad track list figured out.     */
      516 						/* if we had any bad tracks  print them out */
      517 	call prt_bad_trks;
      518 	return;
      519 	end format_pack;
      520 
      521 format_track: proc;				/* format_track subsystem			*/
      522 					/* Queries user for cyl/head and status of track.	*/
      523 					/* Calls fmt_sing_trk to do the actual formatting.*/
      524 dcl  info bit(2) aligned;
      525 
      526 	if (fmt_good | bypass) then do;		/* warn user */
      527 	     call ioa_ ("^/Warning:  The ""-nodef"" and/or ""-hbypass"" control argument being specified,");
      528 	     call ioa_ ("^-previous bad track information will be ignored.");
      529 	     end;
      530 
      531 	if ^fstsw then do;				/* print out instructions one time */
      532 	     call ioa_ ("Enter tracks to be formatted as:^/  ""ccc,hh,good"" - for a good track");
      533 	     call ioa_ ("  ""ccc,hh,def""  - for a defective track with no alternate assigned");
      534 	     call ioa_ ("  ""ccc,hh,defa"" - for a defective track, alternate assigned");
      535 	     call ioa_ ("Terminate query by typing ""quit"".");
      536 	     fstsw = "1"b;				/* set switch so we don't print this out again */
      537 	     end;
      538 
      539 	input = "1"b;				/* make sure we go thru loop at least once */
      540 	if bypass
      541 	     then fmt_info.hz = "00"b;		/* set up header bypass switch */
      542 	     else fmt_info.hz = "01"b;
      543 
      544 	     do while (input);
      545 fmt_loop_er1:					/* error label */
      546 		yes_or_no_sw = "0"b;
      547 		suppress_name_sw = "1"b;
      548 		call command_query_ (query_ptr, response, "", "Enter:");
      549 		if ( (response = "quit" ) | ( length (response) = 0 ) ) then do;
      550 		     input = "0"b;			/* terminate query */
      551 		     call prt_bad_trks;		/* print out the bad trk list */
      552 		     end;
      553 		else do;
      554 		     erresponse = response;		/* save reponse for error reporting */
      555 		     line_pos = 1;			/* start at the beginning of input */
      556 		     rlen = length (response);	/* set up initial string length */
      557 		     error = fmt_loop_er1;		/* set up error return label */
      558 		     seek_key = form_sk_add ();	/* convert address */
      559 		     pstring = parse ();		/* get type of format */
      560 
      561 		     if pstring = "good"		/* check out action */
      562 			then info = "00"b;		/* and set appropriate bit */
      563 		     else if pstring = "defa"
      564 			then info = "10"b;
      565 		     else if pstring = "def"
      566 			then info = "11"b;
      567 		     else do;			/* none of the above ?? */
      568 			call ioa_ ("Error in input parameters - ""^a"", please reenter.", erresponse );
      569 			go to fmt_loop_er1;
      570 			end;
      571 		     call fmt_sing_trk(seek_key, info);	/* make call to fmt routine */
      572 		     end;
      573 fmt_sing_loop:
      574 		end;
      575 	end format_track;
      576 
      577 fmt_sing_trk: proc ( seek_key, info );			/* procedure to format single tracks */
      578 
      579 	/*  .................................................................................... 	*/
      580 	/*									*/
      581 	/*  The heart of the formatting routine.  Called by format_track subsystem.		*/
      582 	/*  Rules:								*/
      583 	/*     1) If the track is to be formatted as "good":				*/
      584 	/*	If currently "good" or "def", then re-format it.				*/
      585 	/*	If currently "defa", then re-format this track and its alternate as well.	*/
      586 	/*	If currently "alt",  then don't re-format. User must re-format original first.	*/
      587 	/*     2) If the track is to formatted as "def":					*/
      588 	/*	If currently "good", or "def", then re-format it.				*/
      589 	/*	If currently "defa", then user must re-format track as "good" first.		*/
      590 	/*	If currently "alt",  then user must re-format original track first.		*/
      591 	/*     3) If track is to formatted as "defa":					*/
      592 	/*	If currently "good" or "def", then re-format and assign alternate.		*/
      593 	/*	If currently "defa" or "alt", then report state and return.			*/
      594 	/*     4) Tracks within the ALT partition may not be formatted as "defa".		*/
      595 	/*     5) The T & D cylinder may be formatted with this command for test purposes, or	*/
      596 	/*	for curiosity. However, it's presence is not mentioned when the cylinder	*/
      597 	/*	range is listed, nor are these tracks used as possible alternate tracks.	*/
      598 	/*	Those more informed will know what it's for.				*/
      599 	/*  .................................................................................... 	*/
      600 
      601 dcl
      602      seek_key	fixed bin(35),			/* input seek address */
      603      info		bit(2) aligned,			/* bits corresponding to format request */
      604      temp_seek_key	fixed bin(35),			/* temporary seek address */
      605      match_seek_key	fixed bin(35);			/* used for matching */
      606 
      607 	code = 0;
      608 	fmt_info.alt_def_cyl = 0;			/* initialize for now	*/
      609 	fmt_info.alt_def_hd  = 0;
      610 /* +++++++++++ */
      611 /* good & def  */
      612 /* +++++++++++ */
      613 	if ( (info = "00"b) | (info = "11"b) ) then do;	/* same code for "good" & "def" */
      614 	     call rd_header(seek_key);		/* read what's already there */
      615 	     if code = 0 then do;			/* if we can read what's there then lets look at it */
      616 						/* if we couldn't read, then branch to format section */
      617 		if trk_header_info.ti = "00"b		/* if already "good", say nothing but proceed to */
      618 		     then;			/* re-format it anyway   */
      619 
      620 		else if trk_header_info.ti = "11"b	/* if previously "def" then do nothing proceed to */
      621 		     then;			/* to format it anyway */
      622 
      623 		else if trk_header_info.ti = "10"b then do;/* if previously "defa" then check it out */
      624 		     error = fmt_sing_er2;		/* set up return label */
      625 		     temp_seek_key = form_address( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      626 		     call rd_header(temp_seek_key);	/* read assigned alt to check */
      627 		     if code ^= 0			/* got error reading, so skip this */
      628 			then go to fmt_sing_er2;
      629 		     if trk_header_info.ti = "01"b then do;	/* yup, was assigned alt trk */
      630 			error = fmt_sing_er2;		/* if not valid address then ignore */
      631 			match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      632 							/* try for match against original address */
      633 			if seek_key = match_seek_key then do;	/* MATCH, therefore must decide */
      634 							/* if trying to format as "def", then force */
      635 							/* user to re-format track "good" first */
      636 			     if info = "11"b then do;
      637 				call remove ( seek_key );
      638 				call sort (seek_key, temp_seek_key);
      639 				call ioa_ ("This track is currently formatted ""defa"" with ^a assigned alternate.",
      640 				     cseek(temp_seek_key) );
      641 				call ioa_ ("Track ^a must be re-formatted as ""good"" before formatting as ""def"".",
      642 				     cseek(seek_key) );
      643 				call ioa_ ("Track has not been modified." );
      644 				return;
      645 				end;
      646 
      647 			     fmt_info.ti = "00"b;			/* set up for "good" */
      648 			     call format_trk (temp_seek_key);		/* format alt as good */
      649 			     if code ^= 0
      650 				then go to fmt_sing_er2;
      651 			     call remove (seek_key);
      652 			     call ioa_ ("Previously assigned alternate track ^a formatted as ""good"".",
      653 				cseek(temp_seek_key) );
      654 			     end;
      655 			end;
      656 		     end;
      657 		else if trk_header_info.ti = "01"b then do;	/* if previously "alt" then check it out */
      658 		     error = fmt_sing_er2;			/* set up return label */
      659 		     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      660 		     call rd_header(temp_seek_key);		/* read original track to check */
      661 		     if code ^= 0				/* got error reading, so skip this */
      662 			then go to fmt_sing_er2;		/* allow user to format track */
      663 		     if trk_header_info.ti = "10"b then do;	/* yup, it's really "defa" */
      664 			match_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      665 							/* try for match against original address */
      666 			if seek_key = match_seek_key then do;	/* MATCH */
      667 							/* the user  must format orig. trk not this alt */
      668 			     call sort (temp_seek_key, seek_key);	/* sort in original trk */
      669 			     call ioa_ ("This track is formatted as the alternate for ^a.", cseek(temp_seek_key));
      670 			     call ioa_ ("Original track ^a must be re-formatted first.", cseek(temp_seek_key) );
      671 			     call ioa_ ("Track has not been modified." );
      672 			     return;
      673 			     end;
      674 			end;
      675 		     end;
      676 		end;
      677 fmt_sing_er2:
      678 	     fmt_info.ti = info;			/* set ti bits to appropriate value */
      679 	     call remove (seek_key);			/* remove this trk from the bad trk list */
      680 	     call format_trk (seek_key);		/* format track */
      681 	     if code ^= 0 then do;
      682 		call ioa_ ("Unable to format requested track.");
      683 		call ioa_ ("Track ^a not modified.", cseek(seek_key) );
      684 		return;
      685 		end;
      686 	     if info = "00"b			/* spout appropriate message */
      687 		then call ioa_ ("Track ^a formatted ""good"".", cseek(seek_key) );
      688 		else do;
      689 		     call ioa_ ("Track ^a formatted ""def"".", cseek(seek_key) );
      690 		     call sort (seek_key, 0);
      691 		     end;
      692 	     end;
      693 
      694 /* ++++ */
      695 /* defa */
      696 /* ++++ */
      697 	else if info = "10"b then do;			/* "defa" */
      698 	     if seek_key ^< altb then do;		/* check to make sure we aren't assigning an alternate */
      699 						/* for an alternate. It just doesn't seem right */
      700 		call ioa_ ("This track is within the ""alt"" partition. These tracks may not be formatted as ""defa""." );
      701 		call ioa_ ("Track has not been modified."  );
      702 		return;
      703 		end;
      704 	     call rd_header (seek_key);		/* first, read what's already there */
      705 	     if code = 0 then do;			/* if no error, then check it out */
      706 		if trk_header_info.ti = "00"b		/* if "good", then do nothing here */
      707 		     then;			/* but re-format it later on */
      708 
      709 		else if trk_header_info.ti = "11"b	/* if "def", then do nothing */
      710 		     then;			/* but re-format it later */
      711 
      712 		else if trk_header_info.ti = "10"b then do;	/* it's already "defa" !! */
      713 							/* since it's already "defa", we don't want */
      714 							/* re-format it if it's a valid assignment. */
      715 		     temp_seek_key = form_address ( (fixed(trk_header_info.r0ccyl)), (fixed(trk_header_info.r0chd)) );
      716 		     call rd_header (temp_seek_key);
      717 		     if code ^= 0
      718 			then go to fmt_sing_er3;		/* ignore what it might have been */
      719 		     if trk_header_info.ti = "01"b then do;	/* it checks so far */
      720 							/* let's print out what we're up to */
      721 			call ioa_ ("This track is already formatted ""defa"" with ^a assigned alternate.",
      722 			     cseek (temp_seek_key) );
      723 			call ioa_ ("Track has not been modified.");
      724 			return;
      725 			end;
      726 		     end;
      727 		end;
      728 fmt_sing_er3:
      729 						/* find first free alternate trk */
      730 	     trk_header_info.ti = "01"b;		/* make sure we go thru loop once */
      731 	     do alt_add = altb to sect_per_dev by sect_per_track while (trk_header_info.ti = "01"b);
      732 		call rd_header (alt_add);
      733 		if code ^= 0
      734 		     then return;
      735 		end;
      736 
      737 	     alt_add = alt_add - sect_per_track;	/* subtract 1 track's worth (do loop tells 1 too many */
      738 
      739 						/* important, check for legal address. (note >= */
      740 	     if ( alt_add >= sect_per_dev ) then do;
      741 		call ioa_ ("All alternates have been assigned, cannot format track as ""defa""." );
      742 		call ioa_ ("Track ^a has not been modified.", cseek(seek_key) );
      743 		return;
      744 		end;
      745 
      746 						/* format alternate trk first */
      747 
      748 	     fmt_info.ti = "01"b;
      749 	     fmt_info.alt_def_cyl = rcyl(seek_key);
      750 	     fmt_info.alt_def_hd = rhead(seek_key);
      751 	     call format_trk (alt_add);		/* format the alternate trk */
      752 	     if code ^= 0 then do;			/* didn't work */
      753 		call ioa_ ("Unable to assign alternate. Requested track not formatted." );
      754 		return;				/* skip track on error */
      755 		end;
      756 	     call remove (alt_add);			/* remove alternate trk from defective list if present */
      757 
      758 	     fmt_info.ti = "10"b;			/* set ti bits for def alt assigned */
      759 	     fmt_info.alt_def_cyl = rcyl(alt_add);
      760 	     fmt_info.alt_def_hd  = rhead(alt_add);
      761 	     call format_trk (seek_key);		/* format requested track */
      762 	     if code ^= 0 then do;			/* oh oh... */
      763 		call ioa_ ("Unable to format requested track. Track has not been modified.");
      764 		fmt_info.ti = "00"b;		/* set ti bits to "good" */
      765 		fmt_info.alt_def_cyl = 0;
      766 		fmt_info.alt_def_hd  = 0;
      767 		call format_trk (alt_add);		 /* re-assign the alt as "good" */
      768 		if code ^= 0 then do;		/* whoops, blew the alternate... */
      769 		     call ioa_ ("Unable to re-assign the alternate track as ""good"".");
      770 		     return;
      771 		     end;
      772 		return;
      773 		end;
      774 	     call sort (seek_key, alt_add);		/* sort in the defective address */
      775 	     call ioa_ ("Track ^a formatted ""defa"" with alternate track ^a assigned.",
      776 		cseek(seek_key), cseek (alt_add) );
      777 	     end;
      778 
      779 
      780 	end fmt_sing_trk;
      781 
      782 rd_header: proc (sk_add);
      783 						/* procedure to execute the rd_trk_header control */
      784 						/* order and do appropriate error processing */
      785 dcl  sk_add fixed bin (35);				/* IN  = seek address */
      786 
      787 rd_header_er:
      788 	     call iox_$seek_key (iocb_ptr, asc (sk_add), rec_len, code);
      789 	     call iox_$control (iocb_ptr, "rd_trk_header", addr (trk_header_info), code);
      790 	     if code ^= 0 then do;
      791 		call com_err_ (code, proc_name);	/* report error */
      792 		call com_err_ (0, "", "^-While executing a rd_trk_header command on ^a",
      793 		     cseek (sk_add));
      794 		if interactive then do;
      795 		     yes_or_no_sw = "1"b;
      796 		     suppress_name_sw = "0"b;
      797 		     call command_query_ (query_ptr, answer, "", "Do you wish to try again?");
      798 		     if answer = "yes" then go to rd_header_er;
      799 		     else return;			/* let caller decide */
      800 		     end;
      801 		end;
      802 
      803 	end rd_header;
      804 
      805 format_trk: proc (sk_add);
      806 						/* procedure to execute the format_trk order */
      807 						/* and do appropriate error processing */
      808 dcl  sk_add fixed bin (35);				/* IN  = seek address */
      809 dcl  save_hz bit (2) unaligned;
      810 dcl  er_sw bit (1) unaligned;
      811 
      812 	     er_sw = "0"b;				/* reset error switch if set */
      813 format_trk_er:
      814 	     call iox_$seek_key (iocb_ptr, asc (sk_add), rec_len, code);
      815 	     call iox_$control (iocb_ptr, "format_trk", addr (fmt_info), code);
      816 	     if code ^= 0 then do;
      817 		call com_err_ (code, proc_name);	/* report error */
      818 		call com_err_ (0, proc_name, "while executing a format_trk cmd on ^a",
      819 		     cseek (sk_add));
      820 		if interactive then do;
      821 		     yes_or_no_sw = "1"b;
      822 		     suppress_name_sw = "0"b;
      823 		     call command_query_ (query_ptr, answer, "", "Do you wish to try again?");
      824 		     if answer = "yes" then do;
      825 			if ^er_sw then do;		/* do not wipe out orig hz bits */
      826 			     save_hz = fmt_info.hz;	/* save users header bypass switch */
      827 			     fmt_info.hz = "00"b;	/* set them for header bypass */
      828 			     er_sw = "1"b;		/* set er_sw */
      829 			     end;
      830 			go to format_trk_er;
      831 			end;
      832 		     else return;			/* let caller decide */
      833 		     end;
      834 		end;
      835 
      836 	     if er_sw
      837 		then fmt_info.hz = save_hz;		/* if we had an error restore org. bypass sw */
      838 
      839 	end format_trk;
      840 
      841 mount:	proc;					/* procedure to attach a disk pack */
      842 
      843 	if write_attach
      844 	     then mode = 13;			/* Mode = direct update */
      845 	     else mode = 11;			/* for reading only. *
      846*						/* dev_type previously determined */
      847 	     if system then do;			/* check users access to rcp_sys_ */
      848 		call hcs_$initiate (">system_library_1", "rcp_sys_", "", 0, 0, lsp, code);
      849 		if lsp ^= null then do;		/* if can be initiated */
      850 		     call hcs_$fs_get_mode (lsp, rs_mode, code); /* check caller's access */
      851 		     if code = 0
      852 			then if (bit (rs_mode) & execute )
      853 			     then priv = "1"b;
      854 		     end;
      855 		end;
      856 						/* build attach description */
      857 
      858 	     call ioa_$rsnnl ("rdisk_ ^a ^a", adescrip, i, dev_type, vol_id); /* set up constants */
      859 	     if write_attach				/* if we have to write on disk */
      860 		then call ioa_$rsnnl ("^a  -write", adescrip, i, adescrip );
      861 	     if priv
      862 		then call ioa_$rsnnl ("^a -sys", adescrip, i, adescrip); /* if user has system priv. */
      863 	     call ioa_$rsnnl ("^a -size 4096", adescrip, i, adescrip);
      864 
      865 						/* attach rdisk_ */
      866 	     if write_attach
      867 		then call ioa_ ("Mounting disk ^a for writing", vol_id);
      868 		else call ioa_ ("Mounting disk ^a for reading", vol_id);
      869 	     call iox_$attach_name ("fmt_io_switch", iocb_ptr, adescrip, null, code);
      870 	     if code ^= 0 then do;
      871 		if code ^= error_table_$not_detached then do;
      872 		     call com_err_ ( code, proc_name, "Attempting to attach disk." );
      873 		     return;
      874 		     end;
      875 		not_attached_by_me = "1"b;		/* remember that we didn't perform the attachment */
      876 		end;
      877 
      878 	     call iox_$open (iocb_ptr, mode, "0"b, code);	 /* open  the i/o switch */
      879 	     if code ^= 0 then do;
      880 		call com_err_ ( code, proc_name, "Attempting to open disk I/O switch." );
      881 		return;
      882 		end;
      883 	     open = "1"b;				/* indicate we are now attached to a device */
      884 	     call iox_$modes (iocb_ptr, "raw", "", code); /* put dim in the raw mode */
      885 	     call iox_$control (iocb_ptr, "getbounds", addr (bounds), code); /* get sector bounds of pack */
      886 	     call iox_$control (iocb_ptr, "device_info", addr (dev_char_table), code); /*  and device char */
      887 
      888 	     if not_attached_by_me
      889 		then call ioa_ ("Using pack ^a already mounted on ^a ^a.", vol_id, subsystem_name, device_name  );
      890 		else call ioa_ ("Disk pack ^a mounted on ^a ^a", vol_id, subsystem_name, device_name);
      891 
      892 	     legal_cyl = divide (bounds.high, sect_per_cyl, 17, 0) - 1; /* set up input limits for user */
      893 	     legal_hd = divide (sect_per_cyl, sect_per_track, 17, 0) - 1;
      894 	     sect_per_rec = 1024 / sect_size;
      895 	     use_sect_per_cyl = divide (sect_per_cyl, sect_per_rec, 17, 0) * sect_per_rec;
      896 	     unuse_sect_per_cyl = sect_per_cyl - use_sect_per_cyl;
      897 	     altb = sect_per_dev - num_alt_sect;	/* compute beginning of alternate track area */
      898 
      899 	areap = get_system_free_area_();
      900 	max_bad_trks = (legal_cyl+1)*(legal_hd+1);
      901 	allocate FORMAT_INFO in (area) set (formatp);
      902 	FORMAT_INFO.bad_trk_count = 0;
      903 
      904 	if Option ^= "read_label"			/* not if that's what we're doing anyway */
      905 	     then call read_pack_label;		/* let's see what it is */
      906 	code = 0;					/* if we got this far, it's mounted */
      907 
      908 	end mount;
      909 
      910 
      911 release:	proc;					/* procedure to close and detach the disk pack.  */
      912 
      913 	RECURSE = "0"b;				/* reset recursion-checking switch */
      914 	     if ^open
      915 		then return;
      916 	     call iox_$close        (iocb_ptr, code);	/* close the i/o switch */
      917 	     open = "0"b;				/* reset open switch */
      918 
      919 	     if formatp ^= null then do;
      920 		free FORMAT_INFO in (area);
      921 		formatp = null;
      922 		end;
      923 	     if not_attached_by_me			/* don't detach if previously attached */
      924 		then return;
      925 	     call iox_$detach_iocb  (iocb_ptr, code);	/* detach the drive */
      926 
      927 	end release;
      928 
      929 						/* prt_bad_trks - procedure to print out the defective */
      930 						/* trk, bad Multics record info contained in the       */
      931 						/* temporary bad_trk_segment.  It does not print       */
      932 						/* tracks previously formatted.                        */
      933 prt_bad_trks: proc;
      934 
      935 dcl (i, j, out_len) fixed bin;
      936 dcl  out_str char (100);
      937 
      938 	     if total_bad_track_list			/* if we know where the bad tracks are... */
      939 		then call ioa_ ("^/Summary of bad tracks for entire volume ""^a"".", vol_id);
      940 		else call ioa_ ("^/Summary of bad tracks formatted this session." );
      941 
      942 	     if bad_trk_count ^= 0 then do;		/* found some bad tracks */
      943 		call ioa_ ("^/Defective tracks    Bad Multics records^5x(alternate, if ""defa"")^/");
      944 		do i = 1 to bad_trk_count;		/* print out the bad trks */
      945 		     call ioa_$rsnnl ("^a", out_str, out_len, cseek ( bad_trks(i).track_addr));
      946 		     do j = 0 to bad_trks(i).bad_rcd_cnt - 1;
      947 			call ioa_$rsnnl ("^a  ^6d", out_str, out_len, out_str,
      948 			     phy_mul ( bad_trks(i).track_addr + (j*sect_per_rec)));
      949 			end;
      950 		     if bad_trks(i).alt_addr ^= 0
      951 			then if bad_trks(i).bad_rcd_cnt = 3	/* check for proper spacing...  */
      952 			     then call ioa_$rsnnl ("^a^4x^a", out_str, out_len, out_str, cseek(bad_trks(i).alt_addr) );
      953 			     else call ioa_$rsnnl ("^a^12x^a", out_str, out_len, out_str, cseek(bad_trks(i).alt_addr) );
      954 		     call ioa_ ("^a", out_str);
      955 		     end;
      956 		call ioa_ ("");
      957 		end;
      958 
      959 		else call ioa_ ("No defective tracks found.");
      960 
      961 	end prt_bad_trks;
      962 
      963 cseek: proc (key) returns (char(18));			/* procedure to convert binary seek address */
      964 						/* to ascii cyl and head number */
      965 dcl  key fixed bin (35);				/* IN  = seek address */
      966 dcl (cyl, head, len) fixed bin;
      967 dcl  chstr char (18);
      968 
      969 	     if key < sect_per_cyl
      970 		then cyl = 0;
      971 		else cyl = divide ( key, sect_per_cyl, 17, 0 );
      972 
      973 	     len = mod (key, sect_per_cyl);
      974 	     if len <= 0
      975 		then head = 0;
      976 		else head = divide ( len, sect_per_track, 17, 0 );
      977 
      978 	     call ioa_$rsnnl ("cyl ^4d, head ^2d", chstr, len, cyl, head);
      979 	     return ( chstr );
      980 
      981 	end cseek;
      982 
      983 phy_mul: proc (key) returns (fixed bin);		/* entry to return Multics record number */
      984 						/* for a given seek address */
      985 dcl  key fixed bin (35),				/* IN  = seek address */
      986      mrecord fixed bin;				/* OUT = Multics record number */
      987 
      988 	     mrecord = divide ( key, sect_per_cyl, 17, 0 );
      989 	     return ( divide ( key - mrecord, 16, 17, 0 ) );
      990 
      991 	end phy_mul;
      992 
      993 rhead: proc (key) returns (fixed bin);			/* entry to return head number in binary */
      994 
      995 dcl  key fixed bin (35),				/* IN  = seek address */
      996      head fixed bin,				/* OUT = head number */
      997      len fixed bin;
      998 
      999 	     len = mod (key, sect_per_cyl);
     1000 
     1001 	     if len <= 0
     1002 		then head = 0;
     1003 		else head = divide ( len, sect_per_track, 17, 0 );
     1004 	     return ( head );			/* user only wants head number */
     1005 
     1006 	     end rhead;
     1007 
     1008 rcyl: proc (key) returns (fixed bin);			/* entry to return cyl number */
     1009 
     1010 dcl  key		fixed bin (35);			/* IN  = seek address */
     1011 						/* RETURN = cyl number */
     1012 
     1013 	if key < sect_per_cyl
     1014 	     then return (0);
     1015 	     else return ( (divide (key, sect_per_cyl, 17, 0) )  );
     1016 
     1017 	end rcyl;
     1018 
     1019 asc:	proc (key) returns (char (12) varying);
     1020 						/* internal procedure to convert fixed binary */
     1021 						/* seek address into zero filled char. string for rdisk_ */
     1022 dcl  key fixed bin (35);				/* IN  = seek address */
     1023 dcl  seek_pic picture "99999999";
     1024 dcl  v_string char (12) varying;
     1025 
     1026 	     seek_pic = key;
     1027 	     v_string = seek_pic;
     1028 	     return (v_string);
     1029 
     1030 	end asc;
     1031 
     1032 mul_phy:	proc (r) returns (fixed bin (35));
     1033 						/* procedure to convert a Multics */
     1034 						/* record number to a binary seek address */
     1035 dcl  r fixed bin (23) unaligned;			/* IN  = Multics record number */
     1036 dcl  s fixed bin (35);				/* OUT = seek address */
     1037 
     1038 	     s = r * sect_per_rec;
     1039 	     s = divide (s, use_sect_per_cyl, 17, 0) * unuse_sect_per_cyl + s;
     1040 	     return (s);
     1041 
     1042 	end mul_phy;
     1043 
     1044 form_sk_add: proc returns (fixed bin (35));
     1045 						/* procedure to pick up input parameters for cyl and head */
     1046 						/* and convert them to binary seek address */
     1047 dcl (int_sa, int_sb) fixed bin (37);
     1048 	     pstring = parse ();			/* get cylinder # */
     1049 	     cyl = cv_dec_check_ (pstring, code);
     1050 	     if code ^= 0 then do;
     1051 form_sk_add_er1:
     1052 		call ioa_ ("Error in input parameters - ""^a"", please reenter", erresponse);
     1053 		go to error;			/* return to label varable */
     1054 	     end;
     1055 	     if ((cyl > legal_cyl) | (cyl < 0)) then do;	/* illegal cyl number */
     1056 						/* pretend T&D cyl doesn't exist */
     1057 		call ioa_ ("Cylinder ^d illegal, cylinder range for this device is 0 to ^d", cyl, legal_cyl);
     1058 		go to error;
     1059 	     end;
     1060 	     pstring = parse ();			/* get head # */
     1061 	     head = cv_dec_check_ (pstring, code);
     1062 	     if code ^= 0 then go to form_sk_add_er1;
     1063 	     if ((head > legal_hd) | (head < 0)) then do;	/* illegal head number */
     1064 		call ioa_ ("Head ^d illegal, head range for this device is 0 to ^d", head, legal_hd);
     1065 		go to error;
     1066 	     end;
     1067 	     int_sa = cyl * sect_per_cyl;		/* compute raw cylinder number */
     1068 	     if int_sa > bounds.high then
     1069 		code = 1;				/* cyl # > # cylinders per device */
     1070 	     int_sb = head * sect_per_track;		/* compute raw head address */
     1071 	     if int_sb > sect_per_cyl then
     1072 		code = 2;				/* head # > heads per device */
     1073 	     int_sa = int_sa + int_sb;		/* compute full address */
     1074 	     if int_sa > bounds.high then
     1075 		code = 3;				/* total address > device capicity */
     1076 	     if code ^= 0 then go to form_sk_add_er1;
     1077 	     return (int_sa);
     1078 	end form_sk_add;
     1079 
     1080 parse:	proc returns (char (*));
     1081 						/* procedure to parse input line and return individual args */
     1082 dcl  i fixed bin;
     1083 dcl  string char (10) varying;
     1084 	if rlen ^> 0 then do;			/* we're out of business */
     1085 	     string = "NOT";
     1086 	     return ( string );
     1087 	end;
     1088 	i = index (substr (response, line_pos, rlen), ",");
     1089 	if i = 0 then do;				/* either blank or last parameter */
     1090 	     if substr ( response, line_pos, rlen) ^= ""	/* last one...	*/
     1091 		then string = substr ( response, line_pos, rlen);
     1092 		else string = "NOT";
     1093 	     rlen = 0;
     1094 	     return ( string );
     1095 	end;
     1096 	string = substr (response, line_pos, i-1);
     1097 	line_pos = line_pos + i;
     1098 	rlen = rlen - i;
     1099 	return ( string );
     1100 	end parse;
     1101 
     1102 form_address: proc ( cyl, head) returns (fixed bin (35));
     1103 
     1104 dcl
     1105      head		fixed bin,
     1106      cyl		fixed bin;
     1107 dcl (int_sa, int_sb) fixed bin (37);
     1108 
     1109 	if cyl > legal_cyl then do;			/* cylinder number too big */
     1110 	     call ioa_ ("Cylinder ^d too large, cylinder range for this device is 0 to ^d", cyl, legal_cyl);
     1111 	     go to error;
     1112 	     end;
     1113 	if head > legal_hd then do;			/* head number to big */
     1114 	     call ioa_ ("Head ^d too large, head range for this device is 0 to ^d", head, legal_hd);
     1115 	     go to error;
     1116 	     end;
     1117 	int_sa = cyl * sect_per_cyl;			/* compute raw cylinder number */
     1118 	if int_sa > bounds.high then
     1119 	     code = 1;				/* cyl # > # cylinders per device */
     1120 	int_sb = head * sect_per_track;		/* compute raw head address */
     1121 	if int_sb > sect_per_cyl then
     1122 	     code = 2;		     		/* head # > heads per device */
     1123 	int_sa = int_sa + int_sb;			/* compute full address */
     1124 	if int_sa > bounds.high then
     1125 	     code = 3;				/* total address > device capicity */
     1126 	if code = 0
     1127 	     then return (int_sa);
     1128 	     else go to error;
     1129 
     1130 
     1131 	end form_address;
     1132 
     1133 
     1134 sort:	proc (key, alt_key);
     1135 						/* procedure to sort a new defective address into the bad_trk */
     1136 						/* list in ascending order */
     1137 dcl  key fixed bin (35);				/* IN  = seek address */
     1138 dcl  alt_key fixed bin(35);				/* alt addr if defa */
     1139 dcl (i, j) fixed bin;
     1140 
     1141 /* first lets see if we can save ourselves some time and put the bad trk at the end of the list */
     1142 
     1143 	     if bad_trk_count = 0 | key > bad_trks.track_addr (bad_trk_count) then do;
     1144 		bad_trk_count = bad_trk_count + 1;
     1145 		i, j = bad_trk_count;		/* set constants */
     1146 		go to set_new_add;			/* go store the new defective address */
     1147 	     end;
     1148 
     1149 	     j = 0;				/* we must sort the new def. address in */
     1150 	     do i = 1 to bad_trk_count while (j = 0);
     1151 		if i > max_bad_trks then do;
     1152 		     call com_err_ ( 0, proc_name, "There are currently ^d bad track entries.^/^a",
     1153 			max_bad_trks, "Cannot add more to list." );
     1154 		     j = 1;				/* get out of loop */
     1155 		     end;
     1156 		else if key = FORMAT_INFO.bad_trks(i).track_addr then do; 	/* already exists in list */
     1157 		     if rhead ( key ) = legal_hd	/* if last trk on cyl maybe only part of trk used */
     1158 			then FORMAT_INFO.bad_trks(i).bad_rcd_cnt = divide ( sect_per_track, sect_per_rec, 17, 0 );
     1159 			else FORMAT_INFO.bad_trks(i).bad_rcd_cnt = ceil ( sect_per_track / sect_per_rec );
     1160 		     j = 1;			/* let's get out of the loop */
     1161 		     end;
     1162 		else if key < bad_trks.track_addr (i) then do; /* we found the right slot */
     1163 		     bad_trk_count = bad_trk_count + 1; /* increment the counter */
     1164 		     do j = bad_trk_count to i + 1 by -1; /* move all the rest of the def trks down one slot */
     1165 			FORMAT_INFO.bad_trks(j).track_addr = FORMAT_INFO.bad_trks(j-1).track_addr;
     1166 			FORMAT_INFO.bad_trks(j).alt_addr = FORMAT_INFO.bad_trks(j-1).alt_addr;
     1167 			FORMAT_INFO.bad_trks(j).bad_rcd_cnt = FORMAT_INFO.bad_trks(j-1).bad_rcd_cnt;
     1168 			end;
     1169 set_new_add:
     1170 		     bad_trks(i).track_addr = key;
     1171 		     bad_trks(i).alt_addr = alt_key;
     1172 		     if rhead (key) = legal_hd	/* if last trk on cyl maybe only part of trk used */
     1173 			then FORMAT_INFO.bad_trks(i).bad_rcd_cnt = divide (sect_per_track, sect_per_rec, 17, 0);
     1174 			else FORMAT_INFO.bad_trks(i).bad_rcd_cnt = ceil (sect_per_track / sect_per_rec);
     1175 		     end;
     1176 		end;
     1177 	     return;
     1178 
     1179 	end sort;
     1180 
     1181 remove:	proc (key);
     1182 						/* procedure to remove a track from the bad_trk list */
     1183 dcl  key fixed bin (35);				/* IN  = seek address */
     1184 dcl (i, j) fixed bin;
     1185 
     1186 	     if bad_trk_count = 0
     1187 		then return;			/* can't remove someting that isn't there */
     1188 	     j = 0;
     1189 	     do i = 1 to bad_trk_count while (j = 0);
     1190 		if key = bad_trks.track_addr(i) then do;	/* found the trk now remove it from the list */
     1191 		     do j = i to bad_trk_count;	/* and take out the blank space */
     1192 			bad_trks(j).track_addr = bad_trks(j+1).track_addr;
     1193 			bad_trks(j).alt_addr = bad_trks(j+1).alt_addr;
     1194 			bad_trks(j).bad_rcd_cnt = bad_trks(j+1).bad_rcd_cnt;
     1195 			end;
     1196 		     bad_trk_count = bad_trk_count - 1; /* reduce the counter */
     1197 		     end;
     1198 		end;
     1199 
     1200 	end remove;
     1201 
     1202 
     1203 read_pack_label: proc;				/* procedure for reading the Multics label record */
     1204 
     1205 dcl  ALPHANUM char (71) init ("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123457189.?+_-()! ");
     1206 
     1207 	call read_multics_label;
     1208 	if code ^= 0 then do;			/* must produce our own error messages */
     1209 	     if Option = "read_label"
     1210 		then call com_err_ (code, proc_name,
     1211 		     "^/While executing a read command on ""Multics label record"".");
     1212 	     return;
     1213 	     end;
     1214 
     1215 	call ioa_ ("^/Multics label record information:");
     1216 
     1217 	if labelp -> label.Multics ^= Multics_ID_String then do;
     1218 	     if ( verify ( labelp->label.pv_name, ALPHANUM ) ) = 0
     1219 		then if labelp->label.pv_name ^= " "
     1220 		     then call ioa_ ( "^2xphysical volume:^-^a", labelp->label.pv_name );
     1221 		     else call ioa_ ( "^2xphysical volume:^-^a", "(blank)" );
     1222 		else call ioa_ ( "cannot decipher physical volume name." );
     1223 	     if ( verify ( labelp->label.lv_name, ALPHANUM ) ) = 0
     1224 		then if labelp->label.lv_name = " "
     1225 		     then call ioa_ ( "^2xlogical volume:^-^a", "(blank)" );
     1226 		     else call ioa_ ( "^2xlogical volume:^-^a", labelp->label.lv_name );
     1227 		else call ioa_ ( "cannot decipher logical volume name." );
     1228 	     call ioa_ ("volume is not a ""Multics Storage System Volume""" );
     1229 	     multics_storage_system_volume = "0"b;	/*  set this switch (by default it's OFF) */
     1230 	     end;
     1231 
     1232 	else do;
     1233 	     multics_storage_system_volume = "1"b;	/* make sure it's ON */
     1234 	     call ioa_ ( "^2xphysical volume:^-^a", labelp -> label.pv_name );
     1235 	     call ioa_ ( "^2xlogical volume:^-^a", labelp -> label.lv_name );
     1236 	     call date_time_ ( labelp -> label.time_registered, ltime );
     1237 	     call ioa_ ( "^2xregistered on:^-^a", ltime );
     1238 	     if labelp->label.nparts > 0 then do;	/* Aha, partitions present.  */
     1239 		call ioa_ ( "^2x# partitions:^-^d", labelp -> label.nparts );
     1240 		if labelp->label.nparts > 47		/* legal # of partitions MUST be < 48 */
     1241 		     then call ioa_ ("^5x(Number partitions too great!)");
     1242 		     else do j = 1 to labelp->label.nparts;
     1243 			call ioa_ ( "      ^4a^-from ^d for ^d", labelp -> label.parts(j).part,
     1244 			     labelp -> label.parts(j).frec, labelp -> label. parts(j).nrec );
     1245 			if labelp->label.parts(j).part = "alt"	/* look for "alt" partition */
     1246 			     then alt_partition_present = "1"b;
     1247 		     end;
     1248 		end;
     1249 	     else do;
     1250 		alt_partition_present = "0"b;
     1251 						/* shouldn't allow user to format_tracks on a valid */
     1252 						/* Multics pack which has NO alt partition */
     1253 		call ioa_ ("no partitions specified in label." );
     1254 		end;
     1255 	     end;
     1256 
     1257 	call ioa_ ("legal cylinders:^-0:^d", legal_cyl);
     1258 	call ioa_ ("legal heads:^-0:^d^/", legal_hd );
     1259 
     1260 	end read_pack_label;
     1261 
     1262 						/* procedure to actually read the Multics label record */
     1263 read_multics_label: proc;
     1264 
     1265 	labelp = addr (MULTICS_LABEL);
     1266 	seek_key = mul_phy (multics_lab_rec);
     1267 	call iox_$seek_key (iocb_ptr, asc (seek_key), rec_len, code);
     1268 	call iox_$read_record (iocb_ptr, labelp, 1024 * 4, rec_len, code);
     1269 	return;
     1270 
     1271 	end read_multics_label;
     1272      end format_disk_pack;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1535.0  format_disk_pack.pl1              >special_ldd>install>MR12.2-1061>format_disk_pack.pl1
23           1    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
24           2    07/19/88  1523.2  fs_vol_label.incl.pl1             >special_ldd>install>MR12.2-1061>fs_vol_label.incl.pl1
26           3    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ALPHANUM                        002570 automatic       char(71)                 initial packed unaligned dcl 1205 set ref 1205* 1218
                                                                                  1223
FORMAT_INFO                            based           structure                level 1 dcl 128 set ref 901 920
LABEL_ADDR                             constant        fixed bin(17,0)          initial dcl 1-54 ref 146
MULTICS_LABEL                   000472 automatic       structure                level 1 dcl 122 set ref 1265
Multics                 500     000472 automatic       char(32)                 initial level 2 in structure "MULTICS_LABEL" dcl 122
                                                                                  in procedure "fdp" set ref 122*
Multics                 500            based           char(32)                 initial level 2 in structure "label" dcl 2-18
                                                                                  in procedure "fdp" ref 1217
Multics_ID_String               000000 constant        char(32)                 initial packed unaligned dcl 2-92 ref 1217
Option                          000205 automatic       varying char(20)         dcl 99 set ref 174* 176 176 176 177* 217 236 236
                                                                                  262* 263 267 271 275 277* 283 296 303* 307* 456
                                                                                  904 1209
RECURSE                         000010 internal static bit(1)                   initial packed unaligned dcl 119 set ref 136 913*
addr                                                   builtin function         dcl 117 ref 141 789 789 815 815 885 885 886 886 1265
adescrip                        000244 automatic       char(168)                packed unaligned dcl 105 set ref 858* 859* 859* 861*
                                                                                  861* 863* 863* 869*
al                              000175 automatic       fixed bin(17,0)          dcl 93 set ref 162* 168 168 168 168 168 171 171 174
                                                                                  182 182 184* 185 189 192 194* 195 199 202 202 205
                                                                                  213 216 226 226
already_printed                 000446 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 255
                                                                                  256* 302
alt_add                         000144 automatic       fixed bin(35,0)          dcl 87 set ref 731* 732* 737* 737 740 751* 756* 759*
                                                                                  760* 767* 774* 775* 775*
alt_addr                  2            based           fixed bin(35,0)          array level 3 dcl 128 set ref 950 950* 950* 953*
                                                                                  953* 1166* 1166 1171* 1193* 1193
alt_def_cyl               0(04) 000124 automatic       fixed bin(16,0)          level 2 packed packed unaligned dcl 61 set ref 490*
                                                                                  498* 608* 749* 759* 765*
alt_def_hd                0(21) 000124 automatic       fixed bin(16,0)          level 2 packed packed unaligned dcl 61 set ref 491*
                                                                                  499* 609* 750* 760* 766*
alt_key                                parameter       fixed bin(35,0)          dcl 1138 ref 1134 1171
alt_partition_present           000465 automatic       bit(1)                   initial packed unaligned dcl 118 set ref 118* 287
                                                                                  1245* 1250*
altb                            000171 automatic       fixed bin(17,0)          dcl 92 set ref 698 731 897*
answer                          000213 automatic       varying char(10)         dcl 99 set ref 797* 798 823* 824
answer_iocbp              6     000102 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
ap                              000146 automatic       pointer                  dcl 89 set ref 162* 168 168 168 168 168 171 174 182
                                                                                  182 184* 189 192 194* 199 202 202 205 213 216 226
area                                   based           area(1024)               dcl 124 ref 901 920
areap                           000156 automatic       pointer                  dcl 90 set ref 899* 901 920
arg                                    based           char                     packed unaligned dcl 94 set ref 168 168 168 168 168
                                                                                  171* 174 182 182 189 192 199 202 202 205 213 216
                                                                                  226*
bad_rcd_cnt               3            based           fixed bin(17,0)          array level 3 dcl 128 set ref 946 950 1157* 1159*
                                                                                  1167* 1167 1172* 1174* 1194* 1194
bad_trk_count                          based           fixed bin(17,0)          level 2 dcl 128 set ref 486* 902* 942 944 1143 1143
                                                                                  1144* 1144 1145 1150 1163* 1163 1164 1186 1189
                                                                                  1191 1196* 1196
bad_trks                  1            based           structure                array level 2 dcl 128
bit                                                    builtin function         dcl 117 ref 851
bounds                          000140 automatic       structure                level 1 unaligned dcl 78 set ref 885 885
bypass                          000457 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 213*
                                                                                  238 472 483 492 526 540
ceil                                                   builtin function         dcl 117 ref 1159 1174
chstr                           000103 automatic       char(18)                 packed unaligned dcl 967 set ref 978* 979
cleanup                         000440 stack reference condition                dcl 112 ref 241
code                            000142 automatic       fixed bin(35,0)          dcl 87 set ref 162* 163 164* 184* 185 194* 195 243
                                                                                  322 388 409 437 494 510 607* 615 627 649 661 681
                                                                                  705 717 733 752 762 768 787* 789* 790 791* 813*
                                                                                  815* 816 817* 848* 850* 851 869* 870 871 872* 878*
                                                                                  879 880* 884* 885* 886* 906* 916* 925* 1049* 1050
                                                                                  1061* 1062 1068* 1071* 1074* 1076 1118* 1121*
                                                                                  1124* 1126 1208 1209* 1267* 1268*
com_err_                        000034 constant        entry                    external dcl 28 ref 137 149 150 152 153 154 164 171
                                                                                  177 186 196 207 218 226 232 277 303 307 322 510
                                                                                  791 792 817 818 872 880 1152 1209
command_query_                  000040 constant        entry                    external dcl 28 ref 262 353 548 797 823
cp_escape_control         1(02) 000102 automatic       bit(2)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
cu_$arg_count                   000052 constant        entry                    external dcl 28 ref 147
cu_$arg_ptr                     000054 constant        entry                    external dcl 28 ref 162 184 194
cv_dec_check_                   000042 constant        entry                    external dcl 28 ref 1049 1061
cyl                                    parameter       fixed bin(17,0)          dcl 1104 in procedure "form_address" set ref 1102
                                                                                  1109 1110* 1117
cyl                             000100 automatic       fixed bin(17,0)          dcl 966 in procedure "cseek" set ref 969* 971* 978*
cyl                             000165 automatic       fixed bin(17,0)          dcl 92 in procedure "fdp" set ref 1049* 1055 1055
                                                                                  1057* 1067
date_time_                      000060 constant        entry                    external dcl 28 ref 1236
defective                       000453 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114*
dev_char_table                  000126 automatic       structure                level 1 dcl 67 set ref 886 886
dev_type                        000316 automatic       char(4)                  packed unaligned dcl 105 set ref 159* 199* 858*
device_name               1     000126 automatic       char(8)                  level 2 dcl 67 set ref 888* 890*
divide                                                 builtin function         dcl 117 ref 892 893 895 971 976 988 989 1003 1015
                                                                                  1039 1157 1172
er_sw                           000101 automatic       bit(1)                   packed unaligned dcl 810 set ref 812* 825 828* 836
erresponse                      000217 automatic       varying char(18)         dcl 99 set ref 359* 554* 568* 1051*
error                           000434 automatic       label variable           dcl 111 set ref 360* 403* 431* 557* 624* 630* 658*
                                                                                  1053 1058 1065 1111 1115 1126
error_table_$action_not_performed
                                000064 external static fixed bin(35,0)          dcl 82 set ref 137*
error_table_$noarg              000062 external static fixed bin(35,0)          dcl 82 set ref 149*
error_table_$not_detached       000066 external static fixed bin(35,0)          dcl 82 ref 871
error_table_$request_not_recognized
                                000070 external static fixed bin(35,0)          dcl 82 set ref 171* 226*
execute                         000204 automatic       bit(5)                   initial packed unaligned dcl 98 set ref 98* 851
explanation_len          14     000102 automatic       fixed bin(21,0)          initial level 2 dcl 3-7 set ref 3-7*
explanation_ptr          12     000102 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
fixed                                                  builtin function         dcl 117 ref 404 404 416 416 432 432 443 443 498 499
                                                                                  625 625 631 631 659 659 664 664 715 715
fmt_good                        000456 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 222*
                                                                                  238 472 492 526
fmt_info                        000124 automatic       structure                level 1 dcl 61 set ref 815 815
formatp                         000160 automatic       pointer                  dcl 91 set ref 486 901* 902 919 920 921* 942 944 945
                                                                                  945 946 947 947 950 950 950 950 953 953 1143 1143
                                                                                  1143 1144 1144 1145 1150 1156 1157 1159 1162 1163
                                                                                  1163 1164 1165 1165 1166 1166 1167 1167 1169 1171
                                                                                  1172 1174 1186 1189 1190 1191 1192 1192 1193 1193
                                                                                  1194 1194 1196 1196
frec                   1005            based           fixed bin(17,0)          array level 3 dcl 2-18 set ref 1243*
fstsw                           000462 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 531
                                                                                  536*
get_system_free_area_           000044 constant        entry                    external dcl 28 ref 899
hcs_$fs_get_mode                000050 constant        entry                    external dcl 28 ref 850
hcs_$initiate                   000046 constant        entry                    external dcl 28 ref 848
head                            000101 automatic       fixed bin(17,0)          dcl 966 in procedure "cseek" set ref 974* 976* 978*
head                            000166 automatic       fixed bin(17,0)          dcl 92 in procedure "fdp" set ref 1061* 1063 1063
                                                                                  1064* 1070
head                                   parameter       fixed bin(17,0)          dcl 1104 in procedure "form_address" set ref 1102
                                                                                  1113 1114* 1120
head                            000100 automatic       fixed bin(17,0)          dcl 995 in procedure "rhead" set ref 1001* 1003*
                                                                                  1004
high                      1     000140 automatic       fixed bin(35,0)          level 2 dcl 78 set ref 320 488 892 1068 1074 1118
                                                                                  1124
hold                            000452 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 210*
                                                                                  238 250
hz                              000124 automatic       bit(2)                   level 2 packed packed unaligned dcl 61 set ref 483*
                                                                                  485* 540* 542* 826 827* 836*
i                               000100 automatic       fixed bin(17,0)          dcl 1082 in procedure "parse" set ref 1088* 1089
                                                                                  1096 1097 1098
i                               000100 automatic       fixed bin(17,0)          dcl 935 in procedure "prt_bad_trks" set ref 944* 945
                                                                                  945 946 947 947 950 950 950 950 953 953*
i                               000100 automatic       fixed bin(17,0)          dcl 1184 in procedure "remove" set ref 1189* 1190
                                                                                  1191*
i                               000163 automatic       fixed bin(17,0)          dcl 92 in procedure "fdp" set ref 161* 162* 167 183*
                                                                                  183 184* 193* 193 194* 858* 859* 861* 863*
i                               000100 automatic       fixed bin(17,0)          dcl 1139 in procedure "sort" set ref 1145* 1150*
                                                                                  1151 1156 1157 1159 1162 1164 1169 1171 1172 1174*
index                                                  builtin function         dcl 117 ref 1088
info                            002510 automatic       bit(2)                   dcl 524 in procedure "format_track" set ref 561*
                                                                                  563* 565* 571*
info                                   parameter       bit(2)                   dcl 601 in procedure "fmt_sing_trk" ref 577 613 613
                                                                                  636 677 686 697
input                           000447 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 348*
                                                                                  349 355* 539* 544 550*
int_sa                          002556 automatic       fixed bin(37,0)          dcl 1047 in procedure "form_sk_add" set ref 1067*
                                                                                  1068 1073* 1073 1074 1077
int_sa                          000100 automatic       fixed bin(37,0)          dcl 1107 in procedure "form_address" set ref 1117*
                                                                                  1118 1123* 1123 1124 1126
int_sb                          002560 automatic       fixed bin(37,0)          dcl 1047 in procedure "form_sk_add" set ref 1070*
                                                                                  1071 1073
int_sb                          000102 automatic       fixed bin(37,0)          dcl 1107 in procedure "form_address" set ref 1120*
                                                                                  1121 1123
interactive                     000454 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 143*
                                                                                  145* 176 206 250 250 276 284 794 820
ioa_                            000032 constant        entry                    external dcl 28 ref 257 258 288 290 314 317 343 344
                                                                                  418 420 422 445 446 448 450 456 473 474 477 480
                                                                                  527 528 532 533 534 535 568 639 641 643 652 669
                                                                                  670 671 682 683 686 689 700 701 721 723 741 742
                                                                                  753 763 769 775 866 868 888 890 938 940 943 954
                                                                                  956 959 1051 1057 1064 1110 1114 1215 1218 1221
                                                                                  1222 1223 1226 1227 1228 1234 1235 1237 1239 1240
                                                                                  1243 1253 1257 1258
ioa_$rsnnl                      000036 constant        entry                    external dcl 28 ref 392 397 406 411 434 439 858 859
                                                                                  861 863 945 947 950 953 978
iocb_ptr                        000150 automatic       pointer                  dcl 89 set ref 787* 789* 813* 815* 869* 878* 884*
                                                                                  885* 886* 916* 925* 1267* 1268*
iox_$attach_name                000012 constant        entry                    external dcl 28 ref 869
iox_$close                      000014 constant        entry                    external dcl 28 ref 916
iox_$control                    000016 constant        entry                    external dcl 28 ref 789 815 885 886
iox_$detach_iocb                000020 constant        entry                    external dcl 28 ref 925
iox_$modes                      000022 constant        entry                    external dcl 28 ref 884
iox_$open                       000024 constant        entry                    external dcl 28 ref 878
iox_$read_record                000030 constant        entry                    external dcl 28 ref 1268
iox_$seek_key                   000026 constant        entry                    external dcl 28 ref 787 813 1267
j                               000164 automatic       fixed bin(17,0)          dcl 92 in procedure "fdp" set ref 1242* 1243 1243
                                                                                  1243 1245*
j                               000101 automatic       fixed bin(17,0)          dcl 1184 in procedure "remove" set ref 1188* 1189
                                                                                  1191* 1192 1192 1193 1193 1194 1194*
j                               000101 automatic       fixed bin(17,0)          dcl 1139 in procedure "sort" set ref 1145* 1149*
                                                                                  1150 1154* 1160* 1164* 1165 1165 1166 1166 1167
                                                                                  1167*
j                               000101 automatic       fixed bin(17,0)          dcl 935 in procedure "prt_bad_trks" set ref 946* 947
                                                                                  947*
key                                    parameter       fixed bin(35,0)          dcl 1010 in procedure "rcyl" ref 1008 1013 1015
key                                    parameter       fixed bin(35,0)          dcl 1022 in procedure "asc" ref 1019 1026
key                                    parameter       fixed bin(35,0)          dcl 1183 in procedure "remove" ref 1181 1190
key                                    parameter       fixed bin(35,0)          dcl 995 in procedure "rhead" ref 993 999
key                                    parameter       fixed bin(35,0)          dcl 985 in procedure "phy_mul" ref 983 988 989
key                                    parameter       fixed bin(35,0)          dcl 1137 in procedure "sort" set ref 1134 1143 1156
                                                                                  1157* 1162 1169 1172*
key                                    parameter       fixed bin(35,0)          dcl 965 in procedure "cseek" ref 963 969 971 973
label                                  based           structure                level 1 dcl 2-18
labelp                          000100 automatic       pointer                  dcl 2-16 set ref 1217 1218 1218 1218 1223 1223 1226
                                                                                  1234 1235 1236 1238 1239 1240 1242 1243 1243 1243
                                                                                  1245 1265* 1268*
legal_cyl                       000173 automatic       fixed bin(17,0)          dcl 92 set ref 892* 900 1055 1057* 1109 1110* 1257*
legal_hd                        000174 automatic       fixed bin(17,0)          dcl 92 set ref 893* 900 1063 1064* 1113 1114* 1157
                                                                                  1172 1258*
len                             000101 automatic       fixed bin(17,0)          dcl 995 in procedure "rhead" set ref 999* 1001 1003
len                             000102 automatic       fixed bin(17,0)          dcl 966 in procedure "cseek" set ref 973* 974 976
                                                                                  978*
length                                                 builtin function         dcl 117 ref 354 362 549 556
line_pos                        000167 automatic       fixed bin(17,0)          dcl 92 set ref 361* 555* 1088 1090 1090 1096 1097*
                                                                                  1097
literal_sw                1(05) 000102 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
low                             000140 automatic       fixed bin(35,0)          level 2 dcl 78 set ref 320 488
lsp                             000152 automatic       pointer                  dcl 89 set ref 848* 849 850*
ltime                           000326 automatic       char(24)                 packed unaligned dcl 105 set ref 1236* 1237*
lv_name                 531            based           char(32)                 level 2 dcl 2-18 set ref 1223 1223 1226* 1235*
match_seek_key                  002521 automatic       fixed bin(35,0)          dcl 601 in procedure "fmt_sing_trk" set ref 631* 633
                                                                                  664* 666
match_seek_key                  000101 automatic       fixed bin(35,0)          dcl 381 in procedure "rd_sing_trk" set ref 416* 417
                                                                                  443* 444
max_bad_trks                    002472 automatic       fixed bin(35,0)          initial dcl 126 set ref 126* 900* 901 920 1151 1152*
mod                                                    builtin function         dcl 117 ref 973 999
mode                            000162 automatic       fixed bin(17,0)          dcl 92 set ref 843* 845* 878*
mrecord                         000144 automatic       fixed bin(17,0)          dcl 985 set ref 988* 989
multics_lab_rec                 000470 automatic       fixed bin(23,0)          packed unaligned dcl 121 set ref 146* 1266*
multics_storage_system_volume   000466 automatic       bit(1)                   initial packed unaligned dcl 118 set ref 118* 287
                                                                                  1229* 1233*
n_args                          000176 automatic       fixed bin(17,0)          dcl 93 set ref 147* 148 161
not_attached_by_me              000464 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 875*
                                                                                  888 923
nparts                 1003            based           fixed bin(17,0)          level 2 dcl 2-18 set ref 1238 1239* 1240 1242
nrec                   1006            based           fixed bin(17,0)          array level 3 dcl 2-18 set ref 1243*
null                                                   builtin function         dcl 117 ref 3-7 3-7 3-7 849 869 869 919 921
num_alt_sect             10     000126 automatic       fixed bin(17,0)          level 2 dcl 67 set ref 897
open                            000450 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 243
                                                                                  297 883* 914 917*
out                             000334 automatic       char(256)                packed unaligned dcl 105 set ref 392* 397* 406* 411*
                                                                                  434* 439* 456*
out_len                         000102 automatic       fixed bin(17,0)          dcl 935 set ref 945* 947* 950* 953*
out_str                         000103 automatic       char(100)                packed unaligned dcl 936 set ref 945* 947* 947* 950*
                                                                                  950* 953* 953* 954*
outlen                          000170 automatic       fixed bin(17,0)          dcl 92 set ref 392* 397* 406* 411* 434* 439*
padding                   1(07) 000102 automatic       bit(29)                  initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
part                   1004            based           char(4)                  array level 3 dcl 2-18 set ref 1243* 1245
parts                  1004            based           structure                array level 2 dcl 2-18
priv                            000460 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 851*
                                                                                  861
proc_name                       000317 automatic       char(16)                 initial packed unaligned dcl 105 set ref 105* 137*
                                                                                  137* 149* 164* 171* 177* 186* 196* 207* 218* 226*
                                                                                  232* 277* 303* 307* 322* 510* 791* 817* 818* 872*
                                                                                  880* 1152* 1209*
process_type                    000145 automatic       fixed bin(17,0)          dcl 88 set ref 142* 143
program_interrupt               000000 stack reference condition                dcl 112 ref 317 326 480 513
prompt_after_explanation
                          1(06) 000102 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
pstring                         000324 automatic       char(5)                  packed unaligned dcl 105 set ref 559* 561 563 565
                                                                                  1048* 1049* 1060* 1061*
pv_name                 521            based           char(32)                 level 2 dcl 2-18 set ref 1218 1218 1218* 1234*
query_code                3     000102 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
query_info                      000102 automatic       structure                level 1 dcl 3-7 set ref 141
query_ptr                       000154 automatic       pointer                  dcl 89 set ref 141* 262* 353* 548* 797* 823*
question_iocbp            4     000102 automatic       pointer                  initial level 2 dcl 3-7 set ref 3-7*
r                                      parameter       fixed bin(23,0)          packed unaligned dcl 1035 ref 1032 1038
r0ccyl                    1(12) 000117 automatic       bit(16)                  level 2 packed packed unaligned dcl 47 set ref 404
                                                                                  416 432 443 498 625 631 659 664 715
r0chd                     1(28) 000117 automatic       bit(16)                  level 2 packed packed unaligned dcl 47 set ref 404
                                                                                  416 432 443 499 625 631 659 664 715
read                            000451 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114*
rec_len                         000202 automatic       fixed bin(21,0)          dcl 95 set ref 787* 813* 1267* 1268*
repeat_time              10     000102 automatic       fixed bin(71,0)          initial level 2 dcl 3-7 set ref 3-7*
response                        000225 automatic       varying char(18)         dcl 99 set ref 353* 354 354 359 362 548* 549 549 554
                                                                                  556 1088 1090 1090 1096
rlen                            000172 automatic       fixed bin(17,0)          dcl 92 set ref 362* 556* 1084 1088 1090 1090 1093*
                                                                                  1098* 1098
rs_mode                         000203 automatic       fixed bin(5,0)           dcl 97 set ref 850* 851
rstsw                           000461 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 342
                                                                                  345*
s                               002546 automatic       fixed bin(35,0)          dcl 1036 set ref 1038* 1039* 1039 1039 1040
save_hz                         000100 automatic       bit(2)                   packed unaligned dcl 809 set ref 826* 836
sect_per_cyl              5     000126 automatic       fixed bin(17,0)          level 2 dcl 67 set ref 892 893 895 896 969 971 973
                                                                                  988 999 1013 1015 1067 1071 1117 1121
sect_per_dev              3     000126 automatic       fixed bin(35,0)          level 2 dcl 67 set ref 731 740 897
sect_per_rec                    000177 automatic       fixed bin(17,0)          dcl 93 set ref 894* 895 895 947 947 1038 1157 1159
                                                                                  1172 1174
sect_per_track            6     000126 automatic       fixed bin(17,0)          level 2 dcl 67 set ref 320 320 488 488 731 737 893
                                                                                  976 1003 1070 1120 1157 1159 1172 1174
sect_size                11     000126 automatic       fixed bin(12,0)          level 2 dcl 67 set ref 894
seek_key                               parameter       fixed bin(35,0)          dcl 381 in procedure "rd_sing_trk" set ref 370 387*
                                                                                  392* 392* 393* 397* 397* 398* 402* 406* 406* 417
                                                                                  420* 420* 422* 422* 426* 430* 434* 434* 439* 439*
                                                                                  444 446* 446* 448* 448* 453* 454*
seek_key                        000143 automatic       fixed bin(35,0)          dcl 87 in procedure "fdp" set ref 317* 317* 320*
                                                                                  321* 363* 364* 480* 480* 488* 493* 500* 503* 504*
                                                                                  508* 558* 571* 1266* 1267*
seek_key                               parameter       fixed bin(35,0)          dcl 601 in procedure "fmt_sing_trk" set ref 577 614*
                                                                                  633 637* 638* 641* 641* 651* 666 668* 679* 680*
                                                                                  683* 683* 686* 686* 689* 689* 690* 698 704* 742*
                                                                                  742* 749* 750* 761* 774* 775* 775*
seek_pic                        000100 automatic       picture(8)               packed unaligned dcl 1023 set ref 1026* 1027
sk_add                                 parameter       fixed bin(35,0)          dcl 808 in procedure "format_trk" set ref 805 813*
                                                                                  818* 818*
sk_add                                 parameter       fixed bin(35,0)          dcl 785 in procedure "rd_header" set ref 782 787*
                                                                                  792* 792*
status_code               2     000102 automatic       fixed bin(35,0)          initial level 2 dcl 3-7 set ref 3-7*
string                          000101 automatic       varying char(10)         dcl 1083 set ref 1085* 1086 1090* 1092* 1094 1096*
                                                                                  1099
substr                                                 builtin function         dcl 117 ref 1088 1090 1090 1096
subsystem_name                  000126 automatic       char(4)                  level 2 dcl 67 set ref 888* 890*
suppress_name_sw          1(01) 000102 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 261* 3-7* 352* 547* 796* 822*
suppress_spacing          1(04) 000102 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 3-7*
switches                  1     000102 automatic       structure                level 2 dcl 3-7
system                          000455 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 202*
                                                                                  847
temp_seek_key                   002520 automatic       fixed bin(35,0)          dcl 601 in procedure "fmt_sing_trk" set ref 625*
                                                                                  626* 638* 639* 639* 648* 652* 652* 659* 660* 668*
                                                                                  669* 669* 670* 670* 715* 716* 721* 721*
temp_seek_key                   000100 automatic       fixed bin(35,0)          dcl 381 in procedure "rd_sing_trk" set ref 404* 406*
                                                                                  406* 408* 411* 411* 420* 420* 422* 422* 426* 432*
                                                                                  434* 434* 436* 446* 446* 448* 448* 454*
ti                        0(34) 000117 automatic       bit(2)                   level 2 in structure "trk_header_info" packed packed
                                                                                  unaligned dcl 47 in procedure "fdp" set ref 391
                                                                                  396 401 429 496 497 500 502 617 620 623 629 657
                                                                                  663 706 709 712 719 728* 731
ti                        0(02) 000124 automatic       bit(2)                   level 2 in structure "fmt_info" packed packed
                                                                                  unaligned dcl 61 in procedure "fdp" set ref 489*
                                                                                  497* 647* 677* 748* 758* 764*
time_registered         544            based           fixed bin(71,0)          level 2 dcl 2-18 set ref 1236*
total_bad_track_list            000467 automatic       bit(1)                   initial packed unaligned dcl 118 set ref 118* 329*
                                                                                  515* 938
track_addr                1            based           fixed bin(35,0)          array level 3 dcl 128 set ref 945* 945* 947 947 1143
                                                                                  1156 1162 1165* 1165 1169* 1190 1192* 1192
trk_header_info                 000117 automatic       structure                level 1 dcl 47 set ref 789 789
unuse_sect_per_cyl              000201 automatic       fixed bin(17,0)          dcl 93 set ref 896* 1039
use_sect_per_cyl                000200 automatic       fixed bin(17,0)          dcl 93 set ref 895* 896 1039
user_info_$process_type         000056 constant        entry                    external dcl 28 ref 142
v_string                        000102 automatic       varying char(12)         dcl 1024 set ref 1027* 1028
verify                                                 builtin function         dcl 117 ref 1218 1223
vol_id                          000233 automatic       varying char(32)         dcl 99 set ref 158* 189* 231 288* 858* 866* 868*
                                                                                  888* 890* 938*
write_attach                    000463 automatic       bit(1)                   initial packed unaligned dcl 114 set ref 114* 236*
                                                                                  238* 843 859 866
yes_or_no_sw              1     000102 automatic       bit(1)                   initial level 3 packed packed unaligned dcl 3-7 set
                                                                                  ref 261* 3-7* 350* 545* 795* 821*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 1-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 1-54
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 1-54
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 1-67
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 1-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 1-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 1-54
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 1-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 1-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 1-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 1-54
hbound                                                 builtin function         dcl 117
iox_$rewrite_record             000000 constant        entry                    external dcl 28
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 3-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 3-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 3-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 3-36
rtrim                                                  builtin function         dcl 117

NAMES DECLARED BY EXPLICIT CONTEXT.
abs_err                         004153 constant        label                    dcl 277 ref 284
asc                             013153 constant        entry                    internal dcl 1019 ref 787 813 1267
cseek                           013002 constant        entry                    internal dcl 963 ref 317 317 392 392 397 397 406 406
                                                                                  406 406 411 411 420 420 420 420 422 422 422 422
                                                                                  434 434 434 434 439 439 446 446 446 446 448 448
                                                                                  448 448 480 480 639 639 641 641 652 652 669 669
                                                                                  670 670 683 683 686 686 689 689 721 721 742 742
                                                                                  775 775 775 775 792 792 818 818 945 945 950 950
                                                                                  953 953
fdp                             002654 constant        entry                    external dcl 11
find_op                         004111 constant        label                    dcl 263 ref 248
fmt_loop_er1                    006702 constant        label                    dcl 545 ref 557 569
fmt_sing_er2                    007631 constant        label                    dcl 677 ref 624 627 630 649 658 661
fmt_sing_er3                    010207 constant        label                    dcl 728 ref 717
fmt_sing_loop                   007100 constant        label                    dcl 573
fmt_sing_trk                    007102 constant        entry                    internal dcl 577 ref 571
form_address                    013636 constant        entry                    internal dcl 1102 ref 404 416 432 443 625 631 659
                                                                                  664 715
form_sk_add                     013227 constant        entry                    internal dcl 1044 ref 363 558
form_sk_add_er1                 013276 constant        label                    dcl 1051 ref 1062 1076
format_disk_pack                002664 constant        entry                    external dcl 11
format_pack                     006151 constant        entry                    internal dcl 463 ref 263
format_pack_er1                 006464 constant        label                    dcl 508 ref 494
format_track                    006543 constant        entry                    internal dcl 521 ref 293
format_trk                      011057 constant        entry                    internal dcl 805 ref 508 648 680 751 761 767
format_trk_er                   011065 constant        label                    dcl 813 ref 830
mount                           011331 constant        entry                    internal dcl 841 ref 242
mul_phy                         013205 constant        entry                    internal dcl 1032 ref 1266
option_lp                       004010 constant        label                    dcl 250 ref 291 308
parse                           013517 constant        entry                    internal dcl 1080 ref 559 1048 1060
phy_mul                         013073 constant        entry                    internal dcl 983 ref 947 947
prt_bad_trks                    012366 constant        entry                    internal dcl 933 ref 331 356 517 551
puse                            002774 constant        label                    dcl 150 set ref 304
rcyl                            013140 constant        entry                    internal dcl 1008 ref 749 759
rd_header                       010626 constant        entry                    internal dcl 782 ref 387 408 436 493 614 626 660 704
                                                                                  716 732
rd_header_er                    010633 constant        label                    dcl 787 ref 798
rd_sing_loop                    006122 constant        label                    dcl 456 ref 403 413 431 441
rd_sing_trk                     004725 constant        entry                    internal dcl 370 ref 321 364 504
read_multics_label              015137 constant        entry                    internal dcl 1263 ref 1207
read_pack                       004364 constant        entry                    internal dcl 310 ref 268
read_pack_label                 014347 constant        entry                    internal dcl 1203 ref 272 904
read_track                      004565 constant        entry                    internal dcl 337 ref 280
read_track_er                   004626 constant        label                    dcl 350 ref 360
release                         012312 constant        entry                    internal dcl 911 ref 241 244 252 297
remove                          014263 constant        entry                    internal dcl 1181 ref 393 402 453 503 637 651 679
                                                                                  756
rhead                           013115 constant        entry                    internal dcl 993 ref 750 760 1157 1172
set_new_add                     014206 constant        label                    dcl 1169 ref 1146
sort                            013776 constant        entry                    internal dcl 1134 ref 398 426 430 454 500 638 668
                                                                                  690 774

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15732       16024   15272       15742
Length     16456   15272        72         415     437           2

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
fdp                                1872 external procedure  is an external procedure.  
on unit on line 241                  64 on unit               
read_pack                           102 internal procedure  enables or reverts conditions.  
on unit on line 317                  92 on unit               
read_track                              internal procedure  shares stack frame of external procedure fdp.  
rd_sing_trk                         150 internal procedure  is called by several nonquick procedures.  
format_pack                         100 internal procedure  enables or reverts conditions.  
on unit on line 480                  92 on unit               
format_track                            internal procedure  shares stack frame of external procedure fdp.  
fmt_sing_trk                            internal procedure  shares stack frame of external procedure fdp.  
rd_header                           174 internal procedure  is called by several nonquick procedures.  
format_trk                          156 internal procedure  is called by several nonquick procedures.  
mount                                   internal procedure  shares stack frame of external procedure fdp.  
release                              70 internal procedure  is called by several nonquick procedures.  
prt_bad_trks                        184 internal procedure  is called by several nonquick procedures.  
cseek                               100 internal procedure  is called by several nonquick procedures.  
phy_mul                                 internal procedure  shares stack frame of internal procedure prt_bad_trks.  
rhead                                66 internal procedure  is called by several nonquick procedures.  
rcyl                                    internal procedure  shares stack frame of external procedure fdp.  
asc                                  73 internal procedure  is called by several nonquick procedures.  
mul_phy                                 internal procedure  shares stack frame of external procedure fdp.  
form_sk_add                             internal procedure  shares stack frame of external procedure fdp.  
parse                                69 internal procedure  uses returns(char(*)) or returns(bit(*)).  
form_address                         98 internal procedure  is called by several nonquick procedures.  
sort                                110 internal procedure  is called by several nonquick procedures.  
remove                               69 internal procedure  is called by several nonquick procedures.  
read_pack_label                         internal procedure  shares stack frame of external procedure fdp.  
read_multics_label                      internal procedure  shares stack frame of external procedure fdp.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 RECURSE                     fdp

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
asc                      000100 seek_pic                    asc
                         000102 v_string                    asc
cseek                    000100 cyl                         cseek
                         000101 head                        cseek
                         000102 len                         cseek
                         000103 chstr                       cseek
fdp                      000100 labelp                      fdp
                         000102 query_info                  fdp
                         000117 trk_header_info             fdp
                         000124 fmt_info                    fdp
                         000126 dev_char_table              fdp
                         000140 bounds                      fdp
                         000142 code                        fdp
                         000143 seek_key                    fdp
                         000144 alt_add                     fdp
                         000145 process_type                fdp
                         000146 ap                          fdp
                         000150 iocb_ptr                    fdp
                         000152 lsp                         fdp
                         000154 query_ptr                   fdp
                         000156 areap                       fdp
                         000160 formatp                     fdp
                         000162 mode                        fdp
                         000163 i                           fdp
                         000164 j                           fdp
                         000165 cyl                         fdp
                         000166 head                        fdp
                         000167 line_pos                    fdp
                         000170 outlen                      fdp
                         000171 altb                        fdp
                         000172 rlen                        fdp
                         000173 legal_cyl                   fdp
                         000174 legal_hd                    fdp
                         000175 al                          fdp
                         000176 n_args                      fdp
                         000177 sect_per_rec                fdp
                         000200 use_sect_per_cyl            fdp
                         000201 unuse_sect_per_cyl          fdp
                         000202 rec_len                     fdp
                         000203 rs_mode                     fdp
                         000204 execute                     fdp
                         000205 Option                      fdp
                         000213 answer                      fdp
                         000217 erresponse                  fdp
                         000225 response                    fdp
                         000233 vol_id                      fdp
                         000244 adescrip                    fdp
                         000316 dev_type                    fdp
                         000317 proc_name                   fdp
                         000324 pstring                     fdp
                         000326 ltime                       fdp
                         000334 out                         fdp
                         000434 error                       fdp
                         000446 already_printed             fdp
                         000447 input                       fdp
                         000450 open                        fdp
                         000451 read                        fdp
                         000452 hold                        fdp
                         000453 defective                   fdp
                         000454 interactive                 fdp
                         000455 system                      fdp
                         000456 fmt_good                    fdp
                         000457 bypass                      fdp
                         000460 priv                        fdp
                         000461 rstsw                       fdp
                         000462 fstsw                       fdp
                         000463 write_attach                fdp
                         000464 not_attached_by_me          fdp
                         000465 alt_partition_present       fdp
                         000466 multics_storage_system_volume
                                                            fdp
                         000467 total_bad_track_list        fdp
                         000470 multics_lab_rec             fdp
                         000472 MULTICS_LABEL               fdp
                         002472 max_bad_trks                fdp
                         002510 info                        format_track
                         002520 temp_seek_key               fmt_sing_trk
                         002521 match_seek_key              fmt_sing_trk
                         002546 s                           mul_phy
                         002556 int_sa                      form_sk_add
                         002560 int_sb                      form_sk_add
                         002570 ALPHANUM                    read_pack_label
form_address             000100 int_sa                      form_address
                         000102 int_sb                      form_address
format_trk               000100 save_hz                     format_trk
                         000101 er_sw                       format_trk
parse                    000100 i                           parse
                         000101 string                      parse
prt_bad_trks             000100 i                           prt_bad_trks
                         000101 j                           prt_bad_trks
                         000102 out_len                     prt_bad_trks
                         000103 out_str                     prt_bad_trks
                         000144 mrecord                     phy_mul
rd_sing_trk              000100 temp_seek_key               rd_sing_trk
                         000101 match_seek_key              rd_sing_trk
remove                   000100 i                           remove
                         000101 j                           remove
rhead                    000100 head                        rhead
                         000101 len                         rhead
sort                     000100 i                           sort
                         000101 j                           sort

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this       call_int_other      return_mac
tra_ext_2           mdfx1               enable_op           shorten_stack       ext_entry           int_entry
int_entry_desc      trunc_fx2           ceil_fx2            return_chars_eis    verify_eis          divide_fx1
divide_fx3          op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                cu_$arg_count                 cu_$arg_ptr
cv_dec_check_                 date_time_                    get_system_free_area_         hcs_$fs_get_mode
hcs_$initiate                 ioa_                          ioa_$rsnnl                    iox_$attach_name
iox_$close                    iox_$control                  iox_$detach_iocb              iox_$modes
iox_$open                     iox_$read_record              iox_$seek_key                 user_info_$process_type

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$action_not_performed                           error_table_$noarg            error_table_$not_detached
error_table_$request_not_recognized




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 3    7 002562        98 002612       105 002614       114 002622       118 002641       122 002644       126 002647
     11 002653       136 002672       137 002675       139 002723       141 002724       142 002726       143 002734
    145 002741       146 002743       147 002745       148 002754       149 002757       150 002774       152 003021
    153 003046       154 003073       156 003120       158 003121       159 003122       161 003124       162 003133
    163 003150       164 003152       165 003167       167 003170       168 003173       171 003221       172 003253
    174 003254       176 003264       177 003305       178 003336       180 003337       182 003340       183 003352
    184 003353       185 003370       186 003374       187 003421       189 003422       190 003432       192 003433
    193 003437       194 003440       195 003455       196 003461       197 003506       199 003507       200 003513
    202 003514       205 003527       206 003533       207 003535       208 003562       210 003563       211 003565
    213 003566       216 003575       217 003601       218 003606       220 003633       222 003634       223 003636
    226 003637       227 003671       229 003672       231 003674       232 003701       233 003726       236 003727
    238 003743       241 003753       242 003775       243 003776       244 004002       245 004006       248 004007
    250 004010       252 004015       253 004021       255 004022       256 004024       257 004026       258 004042
    261 004056       262 004062       263 004111       267 004123       268 004130       269 004134       271 004135
    272 004142       273 004143       275 004144       276 004151       277 004153       278 004204       280 004205
    281 004206       283 004207       284 004214       287 004216       288 004222       290 004242       291 004256
    293 004257       294 004260       296 004261       297 004266       299 004274       302 004275       303 004277
    304 004330       307 004331       308 004362       310 004363       314 004371       317 004404       320 004455
    321 004506       322 004516       324 004546       326 004554       329 004555       331 004557       333 004564
    337 004565       342 004566       343 004570       344 004604       345 004620       348 004622       349 004624
    350 004626       352 004630       353 004632       354 004661       355 004670       356 004671       357 004675
    359 004676       360 004703       361 004706       362 004710       363 004712       364 004714       366 004722
    368 004723       370 004724       387 004732       388 004742       391 004745       392 004751       393 005014
    394 005024       396 005025       397 005027       398 005072       399 005105       401 005106       402 005110
    403 005120       404 005124       406 005147       408 005226       409 005235       411 005240       413 005302
    416 005303       417 005326       418 005332       420 005355       422 005423       424 005471       426 005472
    427 005503       429 005504       430 005506       431 005521       432 005525       434 005550       436 005627
    437 005636       439 005641       441 005704       443 005705       444 005730       445 005734       446 005750
    448 006016       450 006064       451 006100       453 006101       454 006110       456 006122       459 006147
    463 006150       472 006156       473 006163       474 006176       477 006212       480 006226       483 006277
    485 006305       486 006311       488 006312       489 006342       490 006345       491 006351       492 006356
    493 006362       494 006371       496 006374       497 006377       498 006403       499 006412       500 006422
    502 006440       503 006445       504 006454       508 006464       510 006474       512 006524       513 006532
    515 006533       517 006535       518 006542       521 006543       526 006544       527 006550       528 006564
    531 006600       532 006602       533 006616       534 006632       535 006646       536 006662       539 006664
    540 006666       542 006673       544 006677       545 006702       547 006704       548 006706       549 006735
    550 006744       551 006745       552 006751       554 006752       555 006757       556 006761       557 006763
    558 006766       559 006770       561 007011       563 007025       565 007041       568 007055       569 007075
    571 007076       573 007100       575 007101       577 007102       607 007104       608 007105       609 007111
    613 007116       614 007124       615 007132       617 007134       620 007141       623 007144       624 007146
    625 007151       626 007173       627 007201       629 007203       630 007207       631 007212       633 007234
    636 007240       637 007244       638 007252       639 007263       641 007313       643 007344       644 007360
    647 007361       648 007363       649 007371       651 007373       652 007402       656 007432       657 007433
    658 007435       659 007440       660 007462       661 007470       663 007472       664 007476       666 007520
    668 007524       669 007534       670 007564       671 007614       672 007630       677 007631       679 007637
    680 007645       681 007654       682 007656       683 007672       684 007723       686 007724       689 007761
    690 010011       692 010023       697 010024       698 010026       700 010031       701 010045       702 010061
    704 010062       705 010070       706 010072       709 010077       712 010102       715 010104       716 010126
    717 010134       719 010136       721 010142       723 010172       724 010206       728 010207       731 010213
    732 010240       733 010246       735 010251       737 010256       740 010264       741 010266       742 010302
    743 010333       748 010334       749 010340       750 010356       751 010375       752 010403       753 010405
    754 010421       756 010422       758 010430       759 010434       760 010443       761 010461       762 010470
    763 010472       764 010506       765 010510       766 010514       767 010521       768 010527       769 010531
    770 010545       772 010546       774 010547       775 010560       780 010624       782 010625       787 010633
    789 010670       790 010724       791 010727       792 010744       794 011007       795 011012       796 011014
    797 011016       798 011046       799 011054       803 011055       805 011056       812 011064       813 011065
    815 011122       816 011156       817 011161       818 011176       820 011242       821 011245       822 011247
    823 011251       824 011301       825 011307       826 011311       827 011314       828 011316       830 011320
    832 011321       836 011322       839 011330       841 011331       843 011332       845 011337       847 011341
    848 011343       849 011413       850 011417       851 011432       858 011444       859 011502       861 011534
    863 011564       866 011614       868 011637       869 011657       870 011715       871 011717       872 011722
    873 011745       875 011746       878 011750       879 011767       880 011771       881 012015       883 012016
    884 012020       885 012047       886 012102       888 012134       890 012167       892 012217       893 012223
    894 012227       895 012236       896 012242       897 012245       899 012253       900 012262       901 012271
    902 012300       904 012301       906 012307       908 012310       911 012311       913 012317       914 012320
    916 012323       917 012333       919 012335       920 012341       921 012346       923 012351       925 012353
    927 012364       933 012365       938 012373       940 012416       942 012431       943 012434       944 012450
    945 012461       946 012524       947 012537       949 012605       950 012607       953 012666       954 012731
    955 012750       956 012752       957 012763       959 012764       961 013000       963 013001       969 013007
    971 013016       973 013020       974 013024       976 013027       978 013031       979 013065       983 013073
    988 013075       989 013101       993 013114       999 013122      1001 013130      1003 013133      1004 013135
   1008 013140      1013 013142      1015 013147      1019 013152      1026 013160      1027 013171      1028 013176
   1032 013205      1038 013207      1039 013217      1040 013225      1044 013227      1048 013231      1049 013251
   1050 013274      1051 013276      1053 013316      1055 013320      1057 013325      1058 013350      1060 013352
   1061 013372      1062 013415      1063 013417      1064 013424      1065 013447      1067 013451      1068 013456
   1070 013464      1071 013471      1073 013477      1074 013502      1076 013510      1077 013512      1080 013516
   1084 013524      1085 013527      1086 013533      1088 013543      1089 013555      1090 013556      1092 013574
   1093 013600      1094 013601      1096 013611      1097 013621      1098 013623      1099 013625      1102 013635
   1109 013643      1110 013650      1111 013672      1113 013675      1114 013700      1115 013722      1117 013725
   1118 013732      1120 013740      1121 013745      1123 013753      1124 013756      1126 013764      1134 013775
   1143 014003      1144 014015      1145 014016      1146 014021      1149 014022      1150 014023      1151 014035
   1152 014041      1154 014101      1155 014103      1156 014104      1157 014114      1159 014140      1160 014153
   1161 014155      1162 014156      1163 014157      1164 014160      1165 014171      1166 014177      1167 014201
   1168 014203      1169 014206      1171 014216      1172 014220      1174 014244      1176 014257      1177 014261
   1181 014262      1186 014270      1188 014273      1189 014274      1190 014305      1191 014316      1192 014325
   1193 014333      1194 014335      1195 014337      1196 014341      1198 014344      1200 014346      1203 014347
   1205 014350      1207 014353      1208 014354      1209 014356      1212 014407      1215 014410      1217 014424
   1218 014431      1221 014464      1222 014507      1223 014523      1226 014561      1227 014602      1228 014616
   1229 014632      1230 014633      1233 014634      1234 014636      1235 014656      1236 014677      1237 014715
   1238 014735      1239 014740      1240 014760      1242 015001      1243 015007      1245 015040      1247 015053
   1248 015055      1250 015056      1253 015057      1257 015073      1258 015113      1260 015136      1263 015137
   1265 015140      1266 015142      1267 015144      1268 015176      1269 015217


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
