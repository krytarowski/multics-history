	COMPILATION LISTING OF SEGMENT library_print
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0850.0 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       12 
       13 /* Modified October 24, 1983 by Jim Lippard to add page_length option */
       14 
       15 library_print: lpr:	procedure
       16 		options	(rename ((alloc_, smart_alloc_)));
       17 
       18      dcl						/*	automatic variables			*/
       19 	Parea			ptr,		/* ptr to an MSA.				*/
       20 	Ptree			ptr,		/* ptr to a tree of status nodes.		*/
       21 	1 arg_struc_temp		like arg_struc,	/* storage for argument structure.		*/
       22 	clock			fixed bin(71),	/* a clock value.				*/
       23 	code			fixed bin(35),	/* a status code.				*/
       24 	date			char(16) aligned,	/* a date/time string.			*/
       25 	1 fcb_temp		like fcb,		/* storage for file control block.		*/
       26 	i			fixed bin,	/* a do-group index.			*/
       27 	j			fixed bin,	/* a do-group index.			*/
       28 	progress			fixed bin init (0),	/* integer indicating progress of our search.	*/
       29 						/*   0 = search beginning.			*/
       30 						/*   1 = finding library descriptor.		*/
       31 						/*   2 = seeing if library_print command supported	*/
       32 						/*       by this descriptor.			*/
       33 						/*   3 = getting default library names if user	*/
       34 						/*       specified none.			*/
       35 						/*   4 = getting default search names if user	*/
       36 						/*       specified none.			*/
       37 						/*   5 = allocating the root nodes of the tree.	*/
       38 						/*   6 = searching each library root for entries	*/
       39 						/*       identified by the search names.	*/
       40 						/*   7 = no entries matching search names found.	*/
       41 	state			char(16);		/* an error temporary char string.		*/
       42 
       43      dcl						/* 	based variables			*/
       44 	area			area based (Parea);	/* an MSA (multi-segment area).		*/
       45 
       46      dcl (addr, divide, length, min, null, reverse, substr, verify)
       47 				builtin;
       48      dcl	cleanup			condition;
       49 
       50      dcl						/*	Entries Called			*/
       51 	clock_			entry returns (fixed bin(71)),
       52 	com_err_			entry options(variable),
       53 	condition_		entry (char(*) aligned, entry),
       54 	cu_$arg_count		entry returns (fixed bin),
       55 	cu_$arg_list_ptr		entry returns(ptr),
       56 	date_time_		entry (fixed bin(71), char(*) aligned),
       57 	get_group_id_		entry returns (char(32) aligned),
       58 	get_system_msa_		entry (ptr, fixed bin, ptr),
       59 	ioa_$ioa_switch		entry options (variable),
       60 	ioa_$ioa_switch_nnl		entry options (variable),
       61 	iox_$attach_ioname		entry (char(*), ptr, char(*), fixed bin(35)),
       62 	iox_$close		entry (ptr, fixed bin(35)),
       63 	iox_$detach_iocb		entry (ptr, fixed bin(35)),
       64 	iox_$open			entry (ptr, fixed bin, bit(1) aligned, fixed bin(35)),
       65 	lib_args_			entry (1 aligned like LIBRARY, 1 aligned like STARNAME, 1 aligned like STARNAME, bit(72) aligned,
       66 				       bit(36) aligned, ptr, fixed bin(35)),
       67 	lib_descriptor_$print	entry (char(168) varying, ptr, ptr, ptr, bit(72) aligned,  bit(36) aligned,
       68 				       ptr, ptr, fixed bin, fixed bin(35)),
       69 	lib_error_list_		entry (char(32) varying, ptr, char(32) varying),
       70 	lib_output_node_list_$print	entry (ptr, ptr, ptr, ptr, char(45) varying, bit(72) aligned, ptr, ptr),
       71 	lib_sort_tree_$make_name_list
       72 				entry (ptr, ptr, ptr, ptr, fixed bin(35)),
       73 	lib_sort_tree_$name_list	entry (ptr, ptr),
       74 	msa_manager_$area_handler	entry,
       75 	release_system_msa_		entry (ptr, fixed bin(35)),
       76 	system_info_$titles		entry (char(*) aligned, char(*) aligned, char(*) aligned,
       77 				       char(*) aligned);
       78 
       79      dcl						/*	static variables			*/
       80 	Lcompany			fixed bin int static,
       81 	Ldepartment		fixed bin int static,
       82 	Ocompany			fixed bin int static,
       83 	Odepartment		fixed bin int static,
       84 	Sno_titles		bit(1) aligned int static init ("1"b),
       85 	True			bit(1) aligned int static options(constant) init ("1"b),
       86 	company			char(120) aligned int static,
       87 	department		char(120) aligned int static,
       88          (error_table_$entlong,
       89 	error_table_$noarg,
       90 	error_table_$not_detached,
       91 	error_table_$not_open)	fixed bin(35) ext static,
       92 	finish			bit(1) aligned int static options(constant) init ("1"b),
       93 	on_unit			bit(1) aligned int static options(constant) init ("0"b),
       94 	stream_output		fixed bin int static init (2);
       95 						/* iox_ opening mode for stream-output I/O.	*/
       96 
       97 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       98 
       99 
      100 	Parg_struc = addr(arg_struc_temp);		/* Initialize argument processing structure.	*/
      101 	arg_struc.version = Varg_struc_1;
      102 	arg_struc.program = "library_print";
      103 	arg_struc.Parg_list = cu_$arg_list_ptr();
      104 	arg_struc.Iarg_list = 1;
      105 	arg_struc.Larg_list = cu_$arg_count();
      106 	arg_struc.put_error = com_err_;
      107 	arg_struc.Srequirements_allowed = ""b;
      108 	arg_struc.Srequirements_initial = ""b;
      109 	arg_struc.Scontrol_allowed = ""b;
      110 	arg_struc.Scontrol_initial = ""b;
      111 
      112 	Sreq_allowed.access_class        = True;	/* Mark Sreq bits-  show which output args allowed*/
      113 	Sreq_allowed.acl                 = True;
      114 	Sreq_allowed.aim                 = True;
      115 	Sreq_allowed.author              = True;
      116 	Sreq_allowed.bit_count           = True;
      117 	Sreq_allowed.bit_count_author    = True;
      118 	Sreq_allowed.compiler_name       = True;
      119 	Sreq_allowed.compiler_options    = True;
      120 	Sreq_allowed.compiler_version    = True;
      121 	Sreq_allowed.copy                = True;
      122 	Sreq_allowed.current_length      = True;
      123 	Sreq_allowed.dtc                 = True;
      124 	Sreq_allowed.dtd                 = True;
      125 	Sreq_allowed.dtem                = True;
      126 	Sreq_allowed.dtm                 = True;
      127 	Sreq_allowed.dtu                 = True;
      128 	Sreq_allowed.entry_bound         = True;
      129 	Sreq_allowed.iacl                = True;
      130 	Sreq_allowed.kids                = True;
      131 	Sreq_allowed.kids_error          = True;
      132 	Sreq_allowed.level               = True;
      133 	Sreq_allowed.link_target         = True;
      134 	Sreq_allowed.lvid                = True;
      135 	Sreq_allowed.matching_names      = True;
      136 	Sreq_allowed.max_length          = True;
      137 	Sreq_allowed.mode                = True;
      138 	Sreq_allowed.msf_indicator       = True;
      139 	Sreq_allowed.names               = True;
      140 	Sreq_allowed.new_line            = True;
      141 	Sreq_allowed.not_ascii           = True;
      142 	Sreq_allowed.object_info         = True;
      143 	Sreq_allowed.offset              = True;
      144 	Sreq_allowed.pathname            = True;
      145 	Sreq_allowed.primary_name        = True;
      146 	Sreq_allowed.pvid                = True;
      147 	Sreq_allowed.quota               = True;
      148 	Sreq_allowed.rb                  = True;
      149 	Sreq_allowed.records_used        = True;
      150 	Sreq_allowed.root_search_proc    = True;
      151 	Sreq_allowed.safety              = True;
      152 	Sreq_allowed.type                = True;
      153 	Sreq_allowed.unique_id           = True;
      154 	Sreq_allowed.user                = True;
      155 
      156 
      157 
      158 	Sreq_init.root_search_proc	   = True;	/* Mark bits on by default.			*/
      159 	Sreq_init.user                   = True;
      160 
      161 	Sc_allowed.acl            = True;		/* Mark Sc bits- show which ctl args allowed.	*/
      162 	Sc_allowed.all_status     = True;
      163 	Sc_allowed.chase          = True;
      164 	Sc_allowed.check_archive  = True;
      165 	Sc_allowed.check_ascii    = True;
      166 	Sc_allowed.components     = True;
      167 	Sc_allowed.container      = True;
      168 	Sc_allowed.default        = True;
      169 	Sc_allowed.iacl           = True;
      170 	Sc_allowed.object_info    = True;
      171 	Sc_allowed.quota          = True;
      172 	Sc_allowed.retain         = True;
      173 	Sc_allowed.descriptor     = True;
      174 	Sc_allowed.footing        = True;
      175 	Sc_allowed.heading        = True;
      176 	Sc_allowed.library        = True;
      177 	Sc_allowed.output_file    = True;
      178 	Sc_allowed.page_length    = True;
      179 	Sc_allowed.search_names   = True;
      180 
      181 	Sc_init.output_file	      = True;		/* Mark bits for ctl args supplied by default.	*/
      182 	Sc_init.page_length       = True;
      183 	arg_struc.output_file = "library.print";
      184 	arg_struc.page_length = 60;
      185 
      186 	call lib_args_ (LIBRARY, STARNAME, EXCLUDE, Srequirements, Scontrol, addr(arg_struc), code);
      187 	if code ^= 0 then return;			/* call subr to process all arguments.		*/
      188 
      189 	if Srequirements & ^arg_struc.Srequirements_initial then;
      190 	else Sc.default = True;			/* give user default output if he didn't care.	*/
      191 
      192 	if ^Sc.default & ^S.names & ^S.matching_names & ^S.primary_name then
      193 	     go to NO_NAME;				/* complain if output devoid of names.		*/
      194 
      195 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      196 	/*									*/
      197 	/* 1) initialize library pgm's file control block.				*/
      198 	/* 2) establish cleanup on unit.						*/
      199 	/* 3) attach/open output file.						*/
      200 	/* 4) get ptr to system multi-segment area, and establish area on unit.		*/
      201 	/* 5) search and build status tree for library entries being sought.			*/
      202 	/* 6) make a list of found entries, and sort the list.				*/
      203 	/*									*/
      204 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      205 
      206 	Pfcb = addr(fcb_temp);
      207 	fcb.version = Vfcb_1;
      208 	fcb.ioname = "lib_print_";			/* do all of our output on the lib_print_ ioname.	*/
      209 	fcb.Piocb = null;				/* indicate no attachment so far.		*/
      210 	fcb.Eend_page = no_end_page;
      211 	fcb.page_length, fcb.page_text_length = arg_struc.page_length;
      212 	fcb.page_no = 1;
      213 	fcb.line_length = 132;
      214 	fcb.line_no = 1;
      215 
      216 	Parea = null;				/* initialize values used by cleanup on unit.	*/
      217 	on cleanup call janitor(on_unit);
      218 
      219 	if substr(arg_struc.output_file, length(arg_struc.output_file)-5) ^= ".print" then
      220 	     if length(arg_struc.output_file) > 162 then do;
      221 		code = error_table_$entlong;
      222 		go to  BAD_ATTACH;
      223 		end;
      224 	     else arg_struc.output_file = arg_struc.output_file || ".print";
      225 	call iox_$attach_ioname (fcb.ioname, fcb.Piocb, "vfile_ " || arg_struc.output_file, code);
      226 	if code ^= 0 then go to BAD_ATTACH;
      227 	call iox_$open (fcb.Piocb, stream_output, "0"b, code);
      228 	if code ^= 0 then go to BAD_OPEN;
      229 
      230 	call condition_ ("area", msa_manager_$area_handler);
      231 						/* let msa_manager_ handle area conditions.	*/
      232 	call get_system_msa_ (addr(Parea), 0, (null));	/* get MSA ptr.				*/
      233 
      234 	Plibrary = addr(LIBRARY);
      235 	Pstarname = addr(STARNAME);
      236 	Pexclude = addr(EXCLUDE);
      237 	call lib_descriptor_$print (arg_struc.descriptor, Plibrary, Pstarname, Pexclude,
      238 	     Srequirements, Scontrol, Parea, Ptree, progress, code);
      239 						/* get a tree of status nodes reflecting the	*/
      240 	if code ^= 0 then go to BAD_SEARCH;		/* library entries which match the star name.	*/
      241 
      242 	allocate 	index_list in (area),		/* allocate space for sorting the status nodes.	*/
      243 		name_list in (area),
      244 		node_list in (area),
      245 		page_list in (area);
      246 	index_list.I = 0;				/* initialize count of entries in each list.	*/
      247 	name_list.I = 0;
      248 	node_list.I = 0;
      249 	page_list.I = 0;
      250 	call lib_sort_tree_$make_name_list (Ptree, Pname_list, Pindex_list, Pnode_list, code);
      251 	if code ^= 0 then go to NO_MATCH;		/* put the outputable nodes into a name list.	*/
      252 	call lib_sort_tree_$name_list (Pname_list, Pindex_list);
      253 						/* sort the name list.			*/
      254 
      255 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      256 	/*									*/
      257 	/* Output a header page for the print out which includes:				*/
      258 	/*   1) company and department titles.						*/
      259 	/*   2) count of library entries printed at level 1.				*/
      260 	/*   3) a heading line indicating which library was searched.			*/
      261 	/*   4) a line stating what search names were used to identify the sought entries.	*/
      262 	/*   5) date of generation; process group id of generator; and name of library descriptor.*/
      263 	/* Construct the footing phrase to appear in the last line of each page of output.	*/
      264 	/* Generate the print out from the sorted list of status entries.			*/
      265 	/*									*/
      266 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      267 
      268 	if Sno_titles then do;			/* get titles for output file.		*/
      269 	     call system_info_$titles ("", "", company, department);
      270 	     Lcompany = min (120, 121 - verify (reverse (company), " "));
      271 	     Ocompany = divide (132-Lcompany, 2, 0, 0);
      272 	     Ldepartment = min (120, 121 - verify (reverse (department), " "));
      273 	     Odepartment = divide (132-Ldepartment, 2, 0, 0);
      274 	     Sno_titles = "0"b;
      275 	     end;
      276 	call ioa_$ioa_switch (fcb.Piocb, "^4/^vx^va", Ocompany, Lcompany, company);
      277 	fcb.line_no = fcb.line_no + 5;
      278 	call ioa_$ioa_switch (fcb.Piocb, "^/^vx^va", Odepartment, Ldepartment, department);
      279 	fcb.line_no = fcb.line_no + 2;
      280 	if name_list.I = 1 then
      281 	     call ioa_$ioa_switch (fcb.Piocb, "^6/^54xPrintout of the 1 Entry");
      282 	else
      283 	     call ioa_$ioa_switch (fcb.Piocb, "^6/^53xPrintout of the ^3d Entries", name_list.I);
      284 	fcb.line_no = fcb.line_no + 7;
      285 	if Sc.heading then do;			/* use user-specified heading line.		*/
      286 	     i = length (arg_struc.heading);
      287 	     call ioa_$ioa_switch (fcb.Piocb, "^/^63xof the^2/^vx^va", divide (132-i, 2, 0, 0), i,
      288 		arg_struc.heading);
      289 	     fcb.line_no = fcb.line_no + 4;
      290 	     end;
      291 	else do;					/* form default heading line from library names.	*/
      292 	     if library.N = 1 then do;
      293 		j = min (32, 33 - verify (reverse (library.V(1)), " "));
      294 		arg_struc.heading = substr (library.V(1), 1, j) || " Library";
      295 		i = length (arg_struc.heading);
      296 		call ioa_$ioa_switch (fcb.Piocb, "^/^63xof the^2/^vx^va", divide (132-i, 2, 0, 0), i, 
      297 		     arg_struc.heading);
      298 		fcb.line_no = fcb.line_no + 4;
      299 		end;
      300 	     else do;
      301 		call ioa_$ioa_switch (fcb.Piocb, "^/^62xof  the^2/^61xLibraries");
      302 		fcb.line_no = fcb.line_no + 4;
      303 		arg_struc.heading = "";
      304 		do i = 1 to library.N;
      305 		     j = min (32, 33 - verify (reverse (library.V(i)), " "));
      306 		     if length (arg_struc.heading) + j + 2 > 120 then do;
      307 			call ioa_$ioa_switch (fcb.Piocb, "^/^vx^va", divide (132-(length(arg_struc.heading)-1),
      308 			     2, 0, 0), length(arg_struc.heading)-1, arg_struc.heading);
      309 			fcb.line_no = fcb.line_no + 2;
      310 			arg_struc.heading = "";
      311 			end;
      312 		     arg_struc.heading = arg_struc.heading || substr (library.V(i), 1, j) || ", ";
      313 		     end;
      314 		arg_struc.heading = substr (arg_struc.heading, 1, length(arg_struc.heading) - 2);
      315 						/* remove last ", " from final heading line.	*/
      316 
      317 		call ioa_$ioa_switch (fcb.Piocb, "^/^vx^va", divide (132-(length(arg_struc.heading)), 2, 0, 0),
      318 		     length(arg_struc.heading), arg_struc.heading);
      319 		fcb.line_no = fcb.line_no + 2;
      320 		end;
      321 	     end;
      322 	if starname.C(1) = 2 then;			/* Don't list search names if name of '**' given.	*/
      323 	else if starname.N = 1 then do;
      324 	     i = min (32, 33 - verify (reverse (starname.V(1)), " "));
      325 	     call ioa_$ioa_switch (fcb.Piocb, "^2/^53xWhich Match the Search Name^2/^51x^vx^va",
      326 		divide (32 - i, 2, 0, 0), i, starname.V(1));
      327 	     fcb.line_no = fcb.line_no + 3;
      328 	     end;
      329 	else do;
      330 	     call ioa_$ioa_switch (fcb.Piocb, "^2/^51xWhich Match the Search Names");
      331 	     fcb.line_no = fcb.line_no + 3;
      332 	     arg_struc.heading = "";
      333 	     do i = 1 to starname.N;
      334 		j = min (32, 33 - verify (reverse (starname.V(i)), " "));
      335 		if length (arg_struc.heading) + j + 2 > 120 then do;
      336 		     call ioa_$ioa_switch (fcb.Piocb, "^/^vx^va", divide (132-(length(arg_struc.heading)-1),
      337 			2, 0, 0), length(arg_struc.heading)-1, arg_struc.heading);
      338 		     fcb.line_no = fcb.line_no + 2;
      339 		     arg_struc.heading = "";
      340 		     end;
      341 		arg_struc.heading = arg_struc.heading || substr (starname.V(i), 1, j) || ", ";
      342 		end;
      343 	     arg_struc.heading = substr (arg_struc.heading, 1, length(arg_struc.heading)  - 2);
      344 	     call ioa_$ioa_switch (fcb.Piocb, "^/^vx^va", divide (132-length(arg_struc.heading), 2, 0, 0),
      345 		length(arg_struc.heading), arg_struc.heading);
      346 	     fcb.line_no = fcb.line_no + 2;
      347 	     end;
      348 	j = 46 - fcb.line_no;			/* space down near bottom of page.		*/
      349 	if j > 0 then
      350 	     call ioa_$ioa_switch_nnl (fcb.Piocb, "^v/", j);
      351 	clock = clock_();
      352 	call date_time_ (clock, date);
      353 	call ioa_$ioa_switch (fcb.Piocb, "^/^30xPrinted on:^-^a", date);
      354 	call ioa_$ioa_switch (fcb.Piocb, "^/^30xPrinted by:^-^a", get_group_id_());
      355 	call ioa_$ioa_switch (fcb.Piocb, "^/^30xDescriptor:^-^a", arg_struc.descriptor);
      356 	if name_list.I = max_entries then
      357 	     call ioa_$ioa_switch_nnl (fcb.Piocb,
      358 		"^/^3-Maximum number of entries (^d) exceeded.
      359 			Entries may have been excluded from the print out.^/^|",
      360 		max_entries);
      361 	else
      362 	     call ioa_$ioa_switch_nnl (fcb.Piocb, "^|");
      363 	fcb.line_no = 1;
      364 
      365 	if Sc.footing then;				/* use default value for footer if user didn't	*/
      366 	else do;
      367 	     arg_struc.heading = "";
      368 	     do i = 1 to library.N - 1;
      369 		j = min (32, 33 - verify (reverse (library.V(i)), " "));
      370 		if length (arg_struc.heading) + j + 5 > 45 then do;
      371 		     arg_struc.heading = arg_struc.heading || "...";
      372 		     go to SET_FOOTING;
      373 		     end;
      374 		arg_struc.heading = arg_struc.heading || substr(library.V(i), 1, j) || ", ";
      375 		end;
      376 	     j = min (32, 33 - verify (reverse (library.V(i)), " "));
      377 	     if length (arg_struc.heading) + j > 45 then arg_struc.heading = arg_struc.heading || "...";
      378 	     else arg_struc.heading = arg_struc.heading || library.V(i);
      379 SET_FOOTING:   arg_struc.footing = arg_struc.heading;
      380 	     end;
      381 
      382 	call lib_output_node_list_$print (Pfcb, Pnode_list, Pname_list, Pindex_list, arg_struc.footing,
      383 	     (72)"1"b, addr(starname), Ppage_list);
      384 						/* print the nodes, including names which	*/
      385 						/*    match the user's search names.		*/
      386 DETACH:	call janitor(finish);			/* clean up.				*/
      387 	return;
      388 
      389 
      390 janitor:	procedure (invocation_mode);			/* cleanup procedure.			*/
      391 
      392      dcl	invocation_mode		bit(1) aligned;	/* off if invoked by cleanup on unit.		*/
      393 
      394 	if Parea ^= null then			/* cleanup by releasing any system MSA.		*/
      395 	     call release_system_msa_ (addr(Parea), code);
      396 	if fcb.Piocb ^= null then do;			/* close/detach our output file, if open.	*/
      397 	     call iox_$close (fcb.Piocb, code);
      398 	     if invocation_mode = finish then if code ^= 0 then if code ^= error_table_$not_open
      399 		then go to BAD_CLOSE;
      400 	     call iox_$detach_iocb (fcb.Piocb, code);
      401 	     fcb.Piocb = null;			/* we've done all we can.  Stop trying.		*/
      402 	     if invocation_mode = finish then if code ^= 0 then go to BAD_DETACH;
      403 	     end;
      404 
      405 	end janitor;
      406 
      407 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      408 
      409 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      410 
      411 
      412 BAD_ATTACH:
      413 	if code = error_table_$not_detached then go to MULTIPLE_ATTACH;
      414 	state = "attaching";
      415 	fcb.Piocb = null;
      416 	go to BAD_IO;
      417 BAD_CLOSE:
      418 	state = "closing";
      419 	go to BAD_IO;
      420 BAD_DETACH:
      421 	state = "detaching";
      422 	go to BAD_IO;
      423 BAD_OPEN:
      424 	state = "opening";
      425 BAD_IO:	call com_err_ (code,arg_struc.program, "^/  While ^a the print file  ^R^a^B^/  using the I/O switch  ^R^a^B.",
      426 	     state, arg_struc.output_file, fcb.ioname);
      427 	go to DETACH;
      428 
      429 MULTIPLE_ATTACH:
      430 	call com_err_ (code, arg_struc.program,
      431 	     "^/  While attaching the print file  ^R^a^B^/  to the I/O switch  ^R^a^B.
      432   Release any other activations of ^a and try again.", arg_struc.output_file, fcb.ioname, arg_struc.program);
      433 	return;
      434 
      435 BAD_SEARCH:
      436 	progress = min (progress, 7);
      437 	go to BAD_S (progress);
      438 BAD_S(0): call com_err_ (code, arg_struc.program, "^/  While calling lib_descriptor_$print.");
      439 	go to DETACH;
      440 BAD_S(1): call com_err_ (code, arg_struc.program, "^/  While finding the  '^R^a^B'  library descriptor.",
      441 	     arg_struc.descriptor);
      442 	go to DETACH;
      443 BAD_S(2): call com_err_ (code, arg_struc.program,
      444 	     "^/  Library descriptor  '^R^a^B'  does not implement^/  the ^a command.",
      445 	     arg_struc.descriptor, arg_struc.program);
      446 	go to DETACH;
      447 BAD_S(3): state = "library";
      448 	go to NO_DEFAULT_NAMES;
      449 BAD_S(4): state = "search";
      450 NO_DEFAULT_NAMES:
      451 	call com_err_ (code, arg_struc.program,
      452 	     "^/  No ^a names were specified, and the  '^R^a^B'
      453   library descriptor does not define any default ^a names.", state, arg_struc.descriptor, state);
      454 	go to DETACH;
      455 BAD_S(5): call com_err_ (code, arg_struc.program, "^/  While allocating the root nodes of the library tree.");
      456 	go to DETACH;
      457 
      458 BAD_S(6):
      459 NO_MATCH:	call com_err_ (code, arg_struc.program,
      460 	     "^/  While searching for entries in the library.^/  Descriptor:^-^5x^a",
      461 	     arg_struc.descriptor);
      462 	call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      463 	call lib_error_list_ ("search name", Pstarname, arg_struc.program);
      464 	go to DETACH;
      465 BAD_S(7):	call com_err_ (code, arg_struc.program, "^/  No libraries matching the library name(s) could be found.
      466   Descriptor:^-^5x^a", arg_struc.descriptor);
      467 	call lib_error_list_ ("library name", Plibrary, arg_struc.program);
      468 	go to DETACH;
      469 
      470 NO_NAME:	call com_err_ (error_table_$noarg, arg_struc.program,
      471 	     "^/  At least one of the following control arguments must be given
      472   so that the name of each library entry will be output:
      473      -name, -match, -primary, or -default.");
      474 	return;
      475 
      476 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      477 
      478 
      479 no_end_page:	procedure;			/* This is a null end-of-page handling proc.	*/
      480 
      481 	fcb.page_no = fcb.page_no + 1;
      482 	fcb.line_no = 1;
      483 
      484 	end no_end_page;
      485 
      486 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      487 
  1     1 /* START OF	lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* NAME:  lib_arg_struc_.incl.pl1						*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines structures used by the library maintenance tools	*/
  1     8 	/* to process their input arguments.  These structures are the arguments to the		*/
  1     9 	/* lib_args_ subroutine.							*/
  1    10 	/*									*/
  1    11 	/* STATUS									*/
  1    12 	/*									*/
  1    13 	/* 0) Created on:   May 25, 1976 by   Gary C. Dixon				*/
  1    14 	/* 1) Modified:     October 24, 1983 by Jim Lippard to add page_length		*/
  1    15 	/*									*/
  1    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    17 
  1    18 
  2     1 /* START OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_args_.incl.pl1							*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines structures for the arrays of library names and search*/
  2     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  2     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  2    10 	/* to the lib_descriptor_ subroutine.						*/
  2    11 	/*									*/
  2    12 	/* S__t_a_t_u_s									*/
  2    13 	/*									*/
  2    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  2    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  2    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  2    17 	/* 3) Modified on:  January 17, 1984 by Jim Lippard to make structures aligned.		*/
  2    18 	/*									*/
  2    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    20 
  2    21 
  2    22      dcl	1 LIBRARY			aligned,		/* a structure containing names of libraries to	*/
  2    23 						/*   be searched.				*/
  2    24 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  2    25 	  2 group (100),				/*   attribute: array of library names		*/
  2    26 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  2    27 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    28 						/*     this library name.			*/
  2    29 
  2    30      dcl	1 STARNAME		aligned,		/* a structure containing names of library entries*/
  2    31 						/*   being searched for.			*/
  2    32 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  2    33 	  2 group (1000),				/*   attribute: array of starnames		*/
  2    34 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  2    35 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  2    36 						/*     this starname.			*/
  2    37 
  2    38      dcl 	1 EXCLUDE			aligned like STARNAME;
  2    39 						/* structure containing names of library entries	*/
  2    40 						/*   to be excluded from a search.		*/
  2    41 
  2    42 /* END OF:	lib_args_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1    19 
  1    20 
  1    21      dcl	Parg_struc		ptr;		/* ptr to the structure described below.	*/
  1    22 
  1    23      dcl	1 arg_struc		structure based (Parg_struc),
  1    24 	  2 version		fixed bin,	/* version number (currently 1).		*/
  1    25 	  2 program		char(32) varying,	/* name of calling program. 			*/
  1    26 	  2 Parg_list		ptr,		/* ptr to calling program's argument list. 	*/
  1    27 	  2 Iarg_list		fixed bin,	/* first arg of calling program's argument list	*/
  1    28 						/*   to be processed.			*/
  1    29 	  2 Larg_list		fixed bin,	/* total number of arguments in calling pgm's list*/
  1    30 	  2 put_error		entry options(variable),
  1    31 						/* program to call to output an error.		*/
  1    32 	  2 Srequirements_allowed	bit(72) aligned,	/* bits on if control argument associated with	*/
  1    33 						/*   that bit is acceptable to the program. 	*/
  1    34 	  2 Scontrol_allowed	bit(36) aligned,	/* bits on if control operation associated with	*/
  1    35 						/*   that bit is acceptable to the program. 	*/
  1    36 	  2 Srequirements_initial	bit(72) aligned,	/* bits on indicating initial settings for 	*/
  1    37 						/*   Srequirements. 			*/
  1    38 	  2 Scontrol_initial	bit(36) aligned,	/* bits on indicating initial settings for	*/
  1    39 						/*   Scontrol.  				*/
  1    40 	  2 descriptor		char(168) varying,	/* name of library descriptor to be used. 	*/
  1    41 	  2 footing		char(45) varying,	/* footing to be used on output pages. 		*/
  1    42 	  2 heading		char(120) varying,	/* heading to be used on 1st output page.	*/
  1    43 	  2 into_path		char(168) varying,	/* path into which library entries to be fetched.	*/
  1    44 	  2 output_file		char(168) varying,	/* path of output file to be written.		*/
  1    45 	  2 page_length		fixed bin,	/* length of output page			*/
  1    46 	  2 time			fixed bin;	/* grace period (in days) for library_cleanup.	*/
  1    47      dcl	1 Sreq_allowed		aligned like Svalid_req based (addr(arg_struc.Srequirements_allowed));
  1    48 						/* allowed requirements switches.		*/
  1    49      dcl	1 Sreq_init		aligned like Svalid_req based (addr(arg_struc.Srequirements_initial));
  1    50 						/* initial values for requirements switches.	*/
  1    51      dcl	1 Sc_allowed		aligned like Sc based (addr(arg_struc.Scontrol_allowed));
  1    52 						/* allowed control switches.			*/
  1    53      dcl	1 Sc_init			aligned like Sc based (addr(arg_struc.Scontrol_initial));
  1    54 						/* initial values for control switches.		*/
  1    55      dcl	Varg_struc_1		fixed bin int static init (1);
  1    56 
  1    57 /* END OF		lib_arg_struc_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      488 
      489 
  3     1 /* START OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_based_args_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines structures for the arrays of library names and search*/
  3     8 	/* names used by library descriptor commands.  This segment, lib_Svalid_req_.incl.pl1,	*/
  3     9 	/* and lib_Scontrol_.incl.pl1 define the complete set of structures required as input	*/
  3    10 	/* to the lib_descriptor_ subroutine.						*/
  3    11 	/*									*/
  3    12 	/* S__t_a_t_u_s									*/
  3    13 	/*									*/
  3    14 	/* 0) Created on:   March 1, 1975 by  A. J. Scherer				*/
  3    15 	/* 1) Modified on:  April 8, 1975 by  G. C. Dixon					*/
  3    16 	/* 2) Modified on:  May 13, 1976 by  G. C. Dixon					*/
  3    17 	/* 3) Modified on:  November 2, 1983 by Jim Lippard to align structures		*/
  3    18 	/*									*/
  3    19 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    20 
  3    21 
  3    22      dcl	1 library			aligned based (Plibrary),
  3    23 						/* a structure containing names of libraries to	*/
  3    24 						/*   be searched.				*/
  3    25 	  2 N			fixed bin,	/*   attribute: number of library names in array.	*/
  3    26 	  2 group (0 refer (library.N)),		/*   attribute: array of library names		*/
  3    27 	    3 V			char(32) unal,	/*   attribute: a library name (value).		*/
  3    28 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    29      dcl	Plibrary			ptr;		/* ptr to:  library structure.		*/
  3    30 						/*     this library name.			*/
  3    31 
  3    32      dcl	1 starname		aligned based (Pstarname),
  3    33 						/* a structure containing names of library entries*/
  3    34 						/*   being searched for.			*/
  3    35 	  2 N			fixed bin,	/*   attribute: number of starnames in array.	*/
  3    36 	  2 group (0 refer (starname.N)),		/*   attribute: array of starnames		*/
  3    37 	    3 V			char(32) unal,	/*   attribute: a starname (value).		*/
  3    38 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    39 						/*     this starname.			*/
  3    40      dcl	Pstarname			ptr;		/* ptr to:  starname structure.		*/
  3    41 
  3    42      dcl	1 exclude			aligned based (Pexclude),
  3    43 						/* a structure containing names of library entries*/
  3    44 						/*   being excluded from the search.		*/
  3    45 	  2 N			fixed bin,	/*   attribute: number of excludes in array.	*/
  3    46 	  2 group (0 refer (exclude.N)),		/*   attribute: array of excludes		*/
  3    47 	    3 V			char(32) unal,	/*   attribute: an exclude (value).		*/
  3    48 	    3 C			fixed bin(35);	/*   attribute: code from check_star_name_ for	*/
  3    49 						/*     this exclude.			*/
  3    50      dcl	Pexclude			ptr;		/* ptr to:  exclude structure.		*/
  3    51 
  3    52 /* END OF:	lib_based_args_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      490 
      491 
  4     1 /* START OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  4     2 
  4     3      dcl	1 fcb			based (Pfcb),	/* file control block for our output file.	*/
  4     4 	  2 version		fixed bin,	/*    version number = 1;			*/
  4     5 	  2 ioname		char(32),		/*    ioname of our I/O control block.		*/
  4     6 	  2 Piocb			ptr,		/*    ptr to our I/O control block.		*/
  4     7 	  2 Eend_page		entry variable,	/*    entry which handles endpage condition.	*/
  4     8 	  2 page_length		fixed bin,	/*    number of lines per page.		*/
  4     9 	  2 page_text_length	fixed bin,	/*    number of usable lines per page, excluding	*/
  4    10 						/*       footer lines generated by end-of-page	*/
  4    11 						/*       handler.				*/
  4    12 	  2 page_no		fixed bin,	/*    current page number.			*/
  4    13 	  2 line_length		fixed bin,	/*    number of characters per line.		*/
  4    14 	  2 line_no		fixed bin;	/*    number of lines on current page.		*/
  4    15      dcl	Pfcb			ptr;		/* ptr to file control block.			*/
  4    16      dcl	Vfcb_1			fixed bin int static options(constant) init (1);
  4    17 
  4    18 /* END OF:	lib_fcb_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      492 
      493 
  5     1 /* START OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  5     2 
  5     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 	/*									*/
  5     5 	/* Name:  lib_list_.incl.pl1							*/
  5     6 	/*									*/
  5     7 	/*      This segment declares the list structures which are used by the library 	*/
  5     8 	/* maintenance tools.  The structures are filled in by lib_sort_tree_, and referenced by	*/
  5     9 	/* lib_output_node_list_, having been allocated originally by one of the maintenance	*/
  5    10 	/* commands (library_map, library_info, library_print, etc).			*/
  5    11 	/*									*/
  5    12 	/* Status									*/
  5    13 	/*									*/
  5    14 	/* 0) Created on:  May 30, 1976  by  G. C. Dixon					*/
  5    15 	/*									*/
  5    16 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    17 
  5    18 
  5    19      dcl	1 index_list		aligned based (Pindex_list),
  5    20 						/* an index list.				*/
  5    21 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    22 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    23 	  2 e (max_entries refer (index_list.N))
  5    24 				fixed bin(24),	/* the list.				*/
  5    25 	1 name_list		aligned based (Pname_list),
  5    26 						/* a name list.				*/
  5    27 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    28 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    29 	  2 e (max_entries refer (name_list.N))	ptr unal,	/* list of ptrs to node names.		*/
  5    30 	1 node_list		aligned based (Pnode_list),
  5    31 						/* a list of ptrs to nodes to be output.	*/
  5    32 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    33 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    34 	  2 e (max_entries refer (node_list.N))	ptr unal,	/* list of ptrs to nodes.			*/
  5    35 	1 page_list		aligned based (Ppage_list),
  5    36 						/* list of page numbers on which each node was	*/
  5    37 						/* output.				*/
  5    38 	  2 N			fixed bin(24),	/* max length of list.			*/
  5    39 	  2 I			fixed bin(24),	/* current length of list.			*/
  5    40 	  2 e (max_entries refer (page_list.N))	
  5    41 				fixed bin(24),	/* list of page numbers.			*/
  5    42 	max_entries		fixed bin int static init (32000),
  5    43 	Pindex_list		ptr,		/* ptr to index_list structure.		*/
  5    44 	Pname_list		ptr,		/* ptr to name_list structure.		*/
  5    45 	Pnode_list		ptr,		/* ptr to node_list structure.		*/
  5    46 	Ppage_list		ptr;		/* ptr to page_list structure.		*/
  5    47 
  5    48 /* END OF:	lib_list_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      494 
      495 
  6     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6     2 
  6     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6     4 	/*									*/
  6     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  6     6 	/*									*/
  6     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  6     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  6     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  6    10 	/* called the node target.							*/
  6    11 	/*									*/
  6    12 	/* S__t_a_t_u_s									*/
  6    13 	/*									*/
  6    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  6    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  6    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  6    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  6    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  6    19 	/*									*/
  6    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    21 
  6    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    23 	/*									*/
  6    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  6    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  6    26 	/* both types of nodes are the same length.					*/
  6    27 	/*									*/
  6    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    29 
  6    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  6    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  6    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  6    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  6    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  6    35 						/*             (= node.Svalid & Srequirements)	*/
  6    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  6    37 	  2 switches		unaligned,
  6    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  6    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  6    40 						/* 	     entry before lib_access_mode_$set.	*/
  6    41 	    3 pad			bit(22),
  6    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  6    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  6    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  6    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  6    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  6    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  6    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  6    49 						/*	     in this directory;  if off, records*/
  6    50 						/*	     charged against 1st superior	*/
  6    51 						/*	     directory with switch on.	*/
  6    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  6    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  6    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  6    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  6    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  6    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  6    58 
  6    59 						/* From here on, link_nodes differ from nodes	*/
  6    60 						/*  for other types of node targets.		*/
  6    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  6    62 
  6    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    64 	/*									*/
  6    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  6    66 	/*									*/
  6    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6    68 
  6    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  6    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  6    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  6    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  6    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  6    74 						/*             (= node.Svalid & Srequirements)	*/
  6    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  6    76 	  2 switches		unaligned,
  6    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  6    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  6    79 						/* 	     entry before lib_access_mode_$set.	*/
  6    80 	    3 pad			bit(22),
  6    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  6    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  6    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  6    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  6    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  6    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  6    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  6    88 						/*	     in this directory;  if off, records*/
  6    89 						/*	     charged against 1st superior	*/
  6    90 						/*	     directory with switch on.	*/
  6    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  6    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  6    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  6    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  6    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  6    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  6    97 
  6    98 						/* From here on, other nodes differ from	*/
  6    99 						/*  link_nodes.				*/
  6   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  6   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  6   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  6   103 	  2 pad1 (1)		fixed bin,
  6   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  6   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  6   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  6   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  6   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  6   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  6   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  6   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  6   112 						/*             component from the base of archive.*/
  6   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  6   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  6   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  6   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  6   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  6   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  6   119 						/*	     updated.			*/
  6   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  6   121 						/*	     directories with Sterminal_account	*/
  6   122 						/*	     on.				*/
  6   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  6   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  6   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  6   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  6   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  6   128 						/*	     updated.			*/
  6   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  6   130 						/*	     directories with Sterminal_account	*/
  6   131 						/*	     on.				*/
  6   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  6   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  6   134 	  2 pad2 (5)		fixed bin,
  6   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  6   136 
  6   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   138 	/*									*/
  6   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  6   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  6   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  6   142 	/* descriptors are the only ones that have been defined.				*/
  6   143 	/*									*/
  6   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   145 
  6   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  6   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  6   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  6   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  6   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  6   152 
  6   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  6   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  6   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  6   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   163 	    3 zero_pad		bit(36),
  6   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  6   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  6   167 	Vacl_1			fixed bin int static options(constant) init (1),
  6   168 						/* version:   version of ACL descriptor.	*/
  6   169 	Tacl			fixed bin int static options(constant) init (7);
  6   170 						/* attribute: type of a segment ACL descriptor.	*/
  6   171 
  6   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  6   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  6   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  6   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  6   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  6   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  6   186 						/* version:   version of directory ACL descriptor.*/
  6   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  6   188 						/* attribute: type of a directory ACL descriptor.	*/
  6   189 
  6   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  6   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  6   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  6   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  6   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  6   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  6   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  6   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  6   206 						/* version:   version of dir IACL descriptor.	*/
  6   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  6   208 
  6   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  6   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  6   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  6   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  6   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  6   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  6   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  6   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  6   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  6   221 	    3 zero_pad		bit(36),
  6   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  6   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  6   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  6   225 	Viacl_1			fixed bin int static options(constant) init (1),
  6   226 						/* version:   version of segment IACL descriptor.	*/
  6   227 	Tiacl			fixed bin int static options(constant) init (10);
  6   228 						/* attribute: type of a segment IACL descriptor.	*/
  6   229 
  6   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  6   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  6   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  6   236 	  2 names (Nnames refer (Dnames.N))
  6   237 				char(32),		/* attribute: names.			*/
  6   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  6   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  6   240 	Vnames_1			fixed bin int static options(constant) init (1),
  6   241 						/* version:   version of names descriptor.	*/
  6   242 	Tnames			fixed bin int static options(constant) init (1);
  6   243 						/* attribute: type of a name descriptor.	*/
  6   244 
  6   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  6   246 						/* nodes.					*/
  6   247 	  2 header,
  6   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  6   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  6   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  6   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  6   255 				like node,
  6   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  6   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  6   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  6   259 						/* version:   version of nodes descriptor.	*/
  6   260 	Tnodes			fixed bin int static options(constant) init (2);
  6   261 						/* attribute: type of a node descriptor.	*/
  6   262 
  6   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  6   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  6   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   268 	  2 info,
  6   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  6   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  6   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  6   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  6   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  6   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  6   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  6   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  6   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  6   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  6   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  6   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  6   281 	    3 format		aligned,
  6   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  6   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  6   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  6   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  6   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  6   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  6   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  6   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  6   290 	      4 pad		bit(28) unal,
  6   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  6   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  6   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  6   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  6   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  6   296 	    3 cversion,				/* attribite: compiler version string.		*/
  6   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  6   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  6   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  6   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  6   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  6   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  6   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  6   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  6   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  6   306 	Vobj_1			fixed bin int static options(constant) init (1),
  6   307 						/* version:   version of object_info_ descriptor.	*/
  6   308 	Tobj			fixed bin int static options(constant) init (3);
  6   309 						/* attribute: type of a node descriptor.	*/
  6   310 
  6   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  6   312 						/* library root search_proc attribute descriptor.	*/
  6   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  6   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  6   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  6   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  6   320 						/* version:   version of search_proc info descrip.*/
  6   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  6   322 						/* attribute: type of a search_proc descriptor.	*/
  6   323 
  6   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  6   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  6   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  6   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  6   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  6   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  6   330 						/*            output.			*/
  6   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  6   332 	  2 info			char(Luser refer (Duser.L)),
  6   333 						/* attribute: user info string.		*/
  6   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  6   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  6   336 	Vuser_1			fixed bin int static options(constant) init (1),
  6   337 						/* version:   version of user info descriptor.	*/
  6   338 	Tuser			fixed bin int static options(constant) init (6);
  6   339 						/* attribute: type of a user descriptor.	*/
  6   340 
  7     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  7     2 
  7     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7     4 	/*									*/
  7     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  7     6 	/*									*/
  7     7 	/*      This include segment defines the switches which request/validate the fields	*/
  7     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  7     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  7    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  7    11 	/* descriptor commands to obtain information about entries in a library.		*/
  7    12 	/*									*/
  7    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  7    14 	/* is requested for output.							*/
  7    15 	/*									*/
  7    16 	/* S__t_a_t_u_s									*/
  7    17 	/*									*/
  7    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  7    19 	/*									*/
  7    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    21 
  7    22 
  7    23      dcl	1 Svalid_req		aligned based,
  7    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  7    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  7    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  7    27 
  7    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  7    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  7    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  7    31 
  7    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  7    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  7    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  7    35 
  7    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  7    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  7    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  7    39 
  7    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  7    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  7    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  7    43 
  7    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  7    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  7    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  7    47 
  7    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  7    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  7    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  7    51 
  7    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  7    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  7    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  7    55 
  7    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  7    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  7    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  7    59 
  7    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  7    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  7    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  7    63 
  7    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  7    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  7    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  7    67 
  7    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  7    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  7    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  7    71 
  7    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  7    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  7    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  7    75 
  7    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  7    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  7    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  7    79 	  2 pad			bit(26) unal,
  7    80 
  7    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  7    82 
  7    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  7    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  7    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  7    86 
  7    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    88 	/*									*/
  7    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  7    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  7    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  7    92 	/*									*/
  7    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  7    94 
  7    95 
  7    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  7    97 	Srequirements		bit(72) aligned;
  7    98 
  7    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6   341 
  6   342 
  6   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  6   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  6   345 
  8     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  8     2 
  8     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8     4 	/*									*/
  8     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  8     6 	/*									*/
  8     7 	/*      This include segment defines the control switches used by library descriptor	*/
  8     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  8     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  8    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  8    11 	/* to the lib_descriptor_ subroutine.						*/
  8    12 	/*									*/
  8    13 	/* S__t_a_t_u_s									*/
  8    14 	/*									*/
  8    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  8    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  8    17 	/*									*/
  8    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  8    19 
  8    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  8    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  8    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  8    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  8    24 
  8    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  8    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  8    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  8    28 						/*         nodes of the tree, and about all the	*/
  8    29 						/*	 nodes below the parent.		*/
  8    30 
  8    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  8    32 						/*         nodes of the tree.			*/
  8    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  8    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  8    35 
  8    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  8    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  8    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  8    39 						/*         deletion.			*/
  8    40 
  8    41 	  2 pad			bit(10) unal,
  8    42 
  8    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  8    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  8    45 
  8    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  8    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  8    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  8    49 
  8    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  8    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  8    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  8    53 
  8    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  8    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  8    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  8    57 
  8    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  8    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  8    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  8    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  8    62 
  8    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  6   346 
  6   347 
  6   348 
  6   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   350 	/*									*/
  6   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  6   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  6   353 	/* that:		mod (type, 2) = 1;						*/
  6   354 	/*									*/
  6   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   356 
  6   357 
  6   358      dcl (Tlink			init (0),
  6   359 	Tsegment			init (1),
  6   360 	Tdirectory		init (2),
  6   361 	Tmsf			init (3),
  6   362 	Tmsf_comp			init (4),
  6   363 	Tarchive			init (5),
  6   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  6   365 
  6   366 
  6   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   368 	/*									*/
  6   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  6   370 	/* Both brief and long string arrays are provided.				*/
  6   371 	/*									*/
  6   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  6   373 
  6   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  6   375 				"link",
  6   376 				"segment",
  6   377 				"directory",
  6   378 				"multisegment file",
  6   379 				"multi-segment file component",
  6   380 				"archive",
  6   381 				"archive component"),
  6   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  6   383 				"link",
  6   384 				"segment",
  6   385 				"directory",
  6   386 				"msf",
  6   387 				"msf comp",
  6   388 				"archive",
  6   389 				"arch comp");
  6   390 
  6   391 
  6   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      496 
      497 
      498 
      499 	end library_print;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0749.8  library_print.pl1                 >special_ldd>on>6588>library_print.pl1
488          1    02/15/84  0754.7  lib_arg_struc_.incl.pl1           >special_ldd>on>6588>lib_arg_struc_.incl.pl1
1-19         2    02/15/84  0754.6  lib_args_.incl.pl1                >special_ldd>on>6588>lib_args_.incl.pl1
490          3    02/15/84  0754.6  lib_based_args_.incl.pl1          >special_ldd>on>6588>lib_based_args_.incl.pl1
492          4    01/05/79  1321.1  lib_fcb_.incl.pl1                 >ldd>include>lib_fcb_.incl.pl1
494          5    02/28/77  1409.2  lib_list_.incl.pl1                >ldd>include>lib_list_.incl.pl1
496          6    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
6-341        7    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
6-346        8    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
C                        11            based           fixed bin(35,0)          array level 3 dcl 3-32 set ref 322
EXCLUDE                         023744 automatic       structure                level 1 dcl 2-38 set ref 186* 236
Eend_page                14            based           entry variable           level 2 dcl 4-3 set ref 210*
I                         1            based           fixed bin(24,0)          level 2 in structure "name_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 247* 280 282* 356
I                         1            based           fixed bin(24,0)          level 2 in structure "node_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 248*
I                         1            based           fixed bin(24,0)          level 2 in structure "index_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 246*
I                         1            based           fixed bin(24,0)          level 2 in structure "page_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 249*
Iarg_list                14            based           fixed bin(17,0)          level 2 dcl 1-23 set ref 104*
LIBRARY                         000466 automatic       structure                level 1 dcl 2-22 set ref 186* 234
Larg_list                15            based           fixed bin(17,0)          level 2 dcl 1-23 set ref 105*
Lcompany                        000010 internal static fixed bin(17,0)          dcl 79 set ref 270* 271 276*
Ldepartment                     000011 internal static fixed bin(17,0)          dcl 79 set ref 272* 273 278*
N                                      based           fixed bin(17,0)          level 2 in structure "starname" dcl 3-32
                                                                                  in procedure "lpr" set ref 323 333
N                                      based           fixed bin(17,0)          level 2 in structure "library" dcl 3-22 in procedure
                                                                                  "lpr" ref 292 304 368
N                                      based           fixed bin(24,0)          level 2 in structure "index_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 242*
N                                      based           fixed bin(24,0)          level 2 in structure "name_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 242*
N                                      based           fixed bin(24,0)          level 2 in structure "node_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 242*
N                                      based           fixed bin(24,0)          level 2 in structure "page_list" dcl 5-19
                                                                                  in procedure "lpr" set ref 242*
Ocompany                        000012 internal static fixed bin(17,0)          dcl 79 set ref 271* 276*
Odepartment                     000013 internal static fixed bin(17,0)          dcl 79 set ref 273* 278*
Parea                           000100 automatic       pointer                  dcl 18 set ref 216* 232 232 237* 242 242 242 242 394
                                                                                  394 394
Parg_list                12            based           pointer                  level 2 dcl 1-23 set ref 103*
Parg_struc                      045416 automatic       pointer                  dcl 1-21 set ref 100* 101 102 103 104 105 106 107
                                                                                  108 109 110 112 113 114 115 116 117 118 119 120
                                                                                  121 122 123 124 125 126 127 128 129 130 131 132
                                                                                  133 134 135 136 137 138 139 140 141 142 143 144
                                                                                  145 146 147 148 149 150 151 152 153 154 158 159
                                                                                  161 162 163 164 165 166 167 168 169 170 171 172
                                                                                  173 174 175 176 177 178 179 181 182 183 184 186
                                                                                  186 189 211 219 219 219 224 224 225 237 286 287
                                                                                  294 295 296 303 306 307 307 307 307 310 312 312
                                                                                  314 314 314 317 317 317 317 317 332 335 336 336
                                                                                  336 336 339 341 341 343 343 343 344 344 344 344
                                                                                  344 355 367 370 371 371 374 374 377 377 377 378
                                                                                  378 379 379 382 425 425 429 429 429 438 440 440
                                                                                  443 443 443 450 450 455 458 458 462 463 465 465
                                                                                  467 470
Pexclude                        045424 automatic       pointer                  dcl 3-50 set ref 236* 237*
Pfcb                            045426 automatic       pointer                  dcl 4-15 set ref 206* 207 208 209 210 211 211 212
                                                                                  213 214 225 225 227 276 277 277 278 279 279 280
                                                                                  282 284 284 287 289 289 296 298 298 301 302 302
                                                                                  307 309 309 317 319 319 325 327 327 330 331 331
                                                                                  336 338 338 344 346 346 348 349 353 354 355 356
                                                                                  361 363 382* 396 397 400 401 415 425 429 481 481
                                                                                  482
Pindex_list                     045430 automatic       pointer                  dcl 5-19 set ref 242* 246 250* 252* 382*
Piocb                    12            based           pointer                  level 2 dcl 4-3 set ref 209* 225* 227* 276* 278*
                                                                                  280* 282* 287* 296* 301* 307* 317* 325* 330* 336*
                                                                                  344* 349* 353* 354* 355* 356* 361* 396 397* 400*
                                                                                  401* 415*
Plibrary                        045420 automatic       pointer                  dcl 3-29 set ref 234* 237* 292 293 294 304 305 312
                                                                                  368 369 374 376 378 462* 467*
Pname_list                      045432 automatic       pointer                  dcl 5-19 set ref 242* 247 250* 252* 280 282 356 382*
Pnode_list                      045434 automatic       pointer                  dcl 5-19 set ref 242* 248 250* 382*
Ppage_list                      045436 automatic       pointer                  dcl 5-19 set ref 242* 249 382*
Pstarname                       045422 automatic       pointer                  dcl 3-40 set ref 235* 237* 322 323 324 325 333 334
                                                                                  341 382 382 463*
Ptree                           000102 automatic       pointer                  dcl 18 set ref 237* 250*
S                                      based           structure                level 1 dcl 7-96
STARNAME                        002273 automatic       structure                level 1 dcl 2-30 set ref 186* 235
Sc                                     based           structure                level 1 dcl 8-20
Sc_allowed                             based           structure                level 1 dcl 1-51
Sc_init                                based           structure                level 1 dcl 1-53
Scontrol                        045442 automatic       bit(36)                  dcl 8-20 set ref 186* 190 192 237* 285 365
Scontrol_allowed         24            based           bit(36)                  level 2 dcl 1-23 set ref 109* 161 162 163 164 165
                                                                                  166 167 168 169 170 171 172 173 174 175 176 177
                                                                                  178 179
Scontrol_initial         27            based           bit(36)                  level 2 dcl 1-23 set ref 110* 181 182
Sno_titles                      000014 internal static bit(1)                   initial dcl 79 set ref 268 274*
Sreq_allowed                           based           structure                level 1 dcl 1-47
Sreq_init                              based           structure                level 1 dcl 1-49
Srequirements                   045440 automatic       bit(72)                  dcl 7-96 set ref 186* 189 192 192 192 237*
Srequirements_allowed
                         22            based           bit(72)                  level 2 dcl 1-23 set ref 107* 112 113 114 115 116
                                                                                  117 118 119 120 121 122 123 124 125 126 127 128
                                                                                  129 130 131 132 133 134 135 136 137 138 139 140
                                                                                  141 142 143 144 145 146 147 148 149 150 151 152
                                                                                  153 154
Srequirements_initial
                         25            based           bit(72)                  level 2 dcl 1-23 set ref 108* 158 159 189
Svalid_req                             based           structure                level 1 dcl 7-23
True                            000010 constant        bit(1)                   initial dcl 79 ref 112 113 114 115 116 117 118 119
                                                                                  120 121 122 123 124 125 126 127 128 129 130 131
                                                                                  132 133 134 135 136 137 138 139 140 141 142 143
                                                                                  144 145 146 147 148 149 150 151 152 153 154 158
                                                                                  159 161 162 163 164 165 166 167 168 169 170 171
                                                                                  172 173 174 175 176 177 178 179 181 182 190
V                         1            based           char(32)                 array level 3 in structure "starname" packed
                                                                                  unaligned dcl 3-32 in procedure "lpr" set ref 324
                                                                                  325* 334 341
V                         1            based           char(32)                 array level 3 in structure "library" packed
                                                                                  unaligned dcl 3-22 in procedure "lpr" ref 293 294
                                                                                  305 312 369 374 376 378
Varg_struc_1                           constant        fixed bin(17,0)          initial dcl 1-55 ref 101
Vfcb_1                                 constant        fixed bin(17,0)          initial dcl 4-16 ref 207
access_class              0(19)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 112*
acl                                    based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 161*
acl                       0(31)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 113*
addr                                                   builtin function         dcl 46 ref 100 112 113 114 115 116 117 118 119 120
                                                                                  121 122 123 124 125 126 127 128 129 130 131 132
                                                                                  133 134 135 136 137 138 139 140 141 142 143 144
                                                                                  145 146 147 148 149 150 151 152 153 154 158 159
                                                                                  161 162 163 164 165 166 167 168 169 170 171 172
                                                                                  173 174 175 176 177 178 179 181 182 186 186 190
                                                                                  192 192 192 192 206 232 232 234 235 236 285 365
                                                                                  382 382 394 394
aim                       0(09)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 114*
all_status                0(01)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 162*
area                                   based           area(1024)               dcl 43 ref 242 242 242 242
arg_struc                              based           structure                level 1 unaligned dcl 1-23 set ref 186 186
arg_struc_temp                  000104 automatic       structure                level 1 unaligned dcl 18 set ref 100
author                    0(12)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 115*
bit_count                 0(24)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 116*
bit_count_author          0(25)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 117*
chase                     0(02)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 163*
check_archive             0(03)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 164*
check_ascii               0(04)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 165*
cleanup                         000460 stack reference condition                dcl 48 ref 217
clock                           000414 automatic       fixed bin(71,0)          dcl 18 set ref 351* 352*
clock_                          000116 constant        entry                    external dcl 50 ref 351
code                            000416 automatic       fixed bin(35,0)          dcl 18 set ref 186* 187 221* 225* 226 227* 228 237*
                                                                                  240 250* 251 394* 397* 398 398 400* 402 412 425*
                                                                                  429* 438* 440* 443* 450* 455* 458* 465*
com_err_                        000120 constant        entry                    external dcl 50 ref 106 425 429 438 440 443 450 455
                                                                                  458 465 470
company                         000015 internal static char(120)                dcl 79 set ref 269* 270 276*
compiler_name             0(34)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 118*
compiler_options          1            based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 119*
compiler_version          0(35)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 120*
components                0(05)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 166*
condition_                      000122 constant        entry                    external dcl 50 ref 230
container                 0(06)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 167*
copy                      0(10)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 121*
cu_$arg_count                   000124 constant        entry                    external dcl 50 ref 105
cu_$arg_list_ptr                000126 constant        entry                    external dcl 50 ref 103
current_length            0(21)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 122*
date                            000417 automatic       char(16)                 dcl 18 set ref 352* 353*
date_time_                      000130 constant        entry                    external dcl 50 ref 352
default                   0(07)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 168*
default                   0(07)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lpr" set ref 190* 192
department                      000053 internal static char(120)                dcl 79 set ref 269* 272 278*
descriptor               30            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lpr" set ref 237* 355* 440* 443*
                                                                                  450* 458* 465*
descriptor                0(25)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 173*
divide                                                 builtin function         dcl 46 ref 271 273 287 287 296 296 307 307 317 317
                                                                                  325 325 336 336 344 344
dtc                       0(33)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 123*
dtd                       0(14)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 124*
dtem                      0(13)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 125*
dtm                       0(16)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 126*
dtu                       0(17)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 127*
entry_bound               0(27)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 128*
error_table_$entlong            000174 external static fixed bin(35,0)          dcl 79 ref 221
error_table_$noarg              000176 external static fixed bin(35,0)          dcl 79 set ref 470*
error_table_$not_detached       000200 external static fixed bin(35,0)          dcl 79 ref 412
error_table_$not_open           000202 external static fixed bin(35,0)          dcl 79 ref 398
fcb                                    based           structure                level 1 unaligned dcl 4-3
fcb_temp                        000424 automatic       structure                level 1 unaligned dcl 18 set ref 206
finish                          000010 constant        bit(1)                   initial dcl 79 set ref 386* 398 402
footing                   0(27)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 174*
footing                   0(27)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lpr" ref 365
footing                 103            based           varying char(45)         level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lpr" set ref 379* 382*
get_group_id_                   000132 constant        entry                    external dcl 50 ref 354 354
get_system_msa_                 000134 constant        entry                    external dcl 50 ref 232
group                     1            based           structure                array level 2 in structure "library" dcl 3-22
                                                                                  in procedure "lpr"
group                     1            based           structure                array level 2 in structure "starname" dcl 3-32
                                                                                  in procedure "lpr"
heading                   0(28)        based           bit(1)                   level 2 in structure "Sc" packed unaligned dcl 8-20
                                                                                  in procedure "lpr" ref 285
heading                   0(28)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 175*
heading                 120            based           varying char(120)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lpr" set ref 286 287* 294* 295 296*
                                                                                  303* 306 307 307 307 307* 310* 312* 312 314* 314
                                                                                  314 317 317 317 317 317* 332* 335 336 336 336 336*
                                                                                  339* 341* 341 343* 343 343 344 344 344 344 344*
                                                                                  367* 370 371* 371 374* 374 377 377* 377 378* 378
                                                                                  379
i                               000451 automatic       fixed bin(17,0)          dcl 18 set ref 286* 287 287 287* 295* 296 296 296*
                                                                                  304* 305 312* 324* 325 325 325* 333* 334 341* 368*
                                                                                  369 374* 376 378
iacl                      0(08)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 169*
iacl                      0(32)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 129*
index_list                             based           structure                level 1 dcl 5-19 set ref 242
invocation_mode                        parameter       bit(1)                   dcl 392 ref 390 398 402
ioa_$ioa_switch                 000136 constant        entry                    external dcl 50 ref 276 278 280 282 287 296 301 307
                                                                                  317 325 330 336 344 353 354 355
ioa_$ioa_switch_nnl             000140 constant        entry                    external dcl 50 ref 349 356 361
ioname                    1            based           char(32)                 level 2 packed unaligned dcl 4-3 set ref 208* 225*
                                                                                  425* 429*
iox_$attach_ioname              000142 constant        entry                    external dcl 50 ref 225
iox_$close                      000144 constant        entry                    external dcl 50 ref 397
iox_$detach_iocb                000146 constant        entry                    external dcl 50 ref 400
iox_$open                       000150 constant        entry                    external dcl 50 ref 227
j                               000452 automatic       fixed bin(17,0)          dcl 18 set ref 293* 294 305* 306 312 334* 335 341
                                                                                  348* 349 349* 369* 370 374 376* 377
kids                      0(04)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 130*
kids_error                0(05)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 131*
length                                                 builtin function         dcl 46 ref 219 219 286 295 306 307 307 307 314 317
                                                                                  317 317 317 335 336 336 336 343 344 344 344 344
                                                                                  370 377
level                     1(34)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 132*
lib_args_                       000152 constant        entry                    external dcl 50 ref 186
lib_descriptor_$print           000154 constant        entry                    external dcl 50 ref 237
lib_error_list_                 000156 constant        entry                    external dcl 50 ref 462 463 467
lib_output_node_list_$print     000160 constant        entry                    external dcl 50 ref 382
lib_sort_tree_$make_name_list   000162 constant        entry                    external dcl 50 ref 250
lib_sort_tree_$name_list        000164 constant        entry                    external dcl 50 ref 252
library                   0(30)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 176*
library                                based           structure                level 1 dcl 3-22 in procedure "lpr"
line_length              23            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 213*
line_no                  24            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 214* 277* 277 279* 279 284*
                                                                                  284 289* 289 298* 298 302* 302 309* 309 319* 319
                                                                                  327* 327 331* 331 338* 338 346* 346 348 363* 482*
link_target               0(15)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 133*
lvid                      0(28)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 134*
matching_names            0(01)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 7-96
                                                                                  in procedure "lpr" ref 192
matching_names            0(01)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 135*
max_entries                     000112 internal static fixed bin(17,0)          initial dcl 5-19 set ref 242 242 242 242 242 242 242
                                                                                  242 356 356*
max_length                0(22)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 136*
min                                                    builtin function         dcl 46 ref 270 272 293 305 324 334 369 376 435
mode                      0(07)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 137*
msa_manager_$area_handler       000166 constant        entry                    external dcl 50 ref 230 230
msf_indicator             0(23)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 138*
name_list                              based           structure                level 1 dcl 5-19 set ref 242
names                     0(02)        based           bit(1)                   level 2 in structure "S" packed unaligned dcl 7-96
                                                                                  in procedure "lpr" ref 192
names                     0(02)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 139*
new_line                  1(35)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 140*
node                                   based           structure                level 1 unaligned dcl 6-69
node_list                              based           structure                level 1 dcl 5-19 set ref 242
not_ascii                 1(02)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 141*
null                                                   builtin function         dcl 46 ref 209 216 232 394 396 401 415
object_info               0(09)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 170*
object_info               1(01)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 142*
offset                    0(26)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 143*
on_unit                         000110 constant        bit(1)                   initial dcl 79 set ref 217*
output_file               0(33)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 177*
output_file               0(33)        based           bit(1)                   level 2 in structure "Sc_init" packed unaligned
                                                                                  dcl 1-53 in procedure "lpr" set ref 181*
output_file             232            based           varying char(168)        level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lpr" set ref 183* 219 219 219 224*
                                                                                  224 225 425* 429*
page_length               0(23)        based           bit(1)                   level 2 in structure "Sc_init" packed unaligned
                                                                                  dcl 1-53 in procedure "lpr" set ref 182*
page_length             305            based           fixed bin(17,0)          level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lpr" set ref 184* 211
page_length               0(23)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 178*
page_length              20            based           fixed bin(17,0)          level 2 in structure "fcb" dcl 4-3 in procedure
                                                                                  "lpr" set ref 211*
page_list                              based           structure                level 1 dcl 5-19 set ref 242
page_no                  22            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 212* 481* 481
page_text_length         21            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 211*
pathname                  0(03)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 144*
primary_name                           based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 145*
primary_name                           based           bit(1)                   level 2 in structure "S" packed unaligned dcl 7-96
                                                                                  in procedure "lpr" ref 192
program                   1            based           varying char(32)         level 2 dcl 1-23 set ref 102* 425* 429* 429* 438*
                                                                                  440* 443* 443* 450* 455* 458* 462* 463* 465* 467*
                                                                                  470*
progress                        000453 automatic       fixed bin(17,0)          initial dcl 18 set ref 18* 237* 435* 435 437
put_error                16            based           entry variable           level 2 dcl 1-23 set ref 106*
pvid                      0(29)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 146*
quota                     0(30)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 147*
quota                     0(10)        based           bit(1)                   level 2 in structure "Sc_allowed" packed unaligned
                                                                                  dcl 1-51 in procedure "lpr" set ref 171*
rb                        0(18)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 148*
records_used              0(20)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 149*
release_system_msa_             000170 constant        entry                    external dcl 50 ref 394
retain                    0(11)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 172*
reverse                                                builtin function         dcl 46 ref 270 272 293 305 324 334 369 376
root_search_proc          1(04)        based           bit(1)                   level 2 in structure "Sreq_init" packed unaligned
                                                                                  dcl 1-49 in procedure "lpr" set ref 158*
root_search_proc          1(04)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 150*
safety                    0(08)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 151*
search_names              0(34)        based           bit(1)                   level 2 packed unaligned dcl 1-51 set ref 179*
starname                               based           structure                level 1 dcl 3-32 set ref 382 382
state                           000454 automatic       char(16)                 unaligned dcl 18 set ref 414* 417* 420* 423* 425*
                                                                                  447* 449* 450* 450*
stream_output                   000111 internal static fixed bin(17,0)          initial dcl 79 set ref 227*
substr                                                 builtin function         dcl 46 ref 219 294 312 314 341 343 374
system_info_$titles             000172 constant        entry                    external dcl 50 ref 269
type                      0(06)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 152*
unique_id                 0(11)        based           bit(1)                   level 2 packed unaligned dcl 1-47 set ref 153*
user                      1(03)        based           bit(1)                   level 2 in structure "Sreq_allowed" packed unaligned
                                                                                  dcl 1-47 in procedure "lpr" set ref 154*
user                      1(03)        based           bit(1)                   level 2 in structure "Sreq_init" packed unaligned
                                                                                  dcl 1-49 in procedure "lpr" set ref 159*
verify                                                 builtin function         dcl 46 ref 270 272 293 305 324 334 369 376
version                                based           fixed bin(17,0)          level 2 in structure "fcb" dcl 4-3 in procedure
                                                                                  "lpr" set ref 207*
version                                based           fixed bin(17,0)          level 2 in structure "arg_struc" dcl 1-23
                                                                                  in procedure "lpr" set ref 101*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 6-146
Dacl                                   based           structure                level 1 unaligned dcl 6-153
Ddir_acl                               based           structure                level 1 unaligned dcl 6-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 6-190
Diacl                                  based           structure                level 1 unaligned dcl 6-209
Dnames                                 based           structure                level 1 unaligned dcl 6-230
Dnodes                                 based           structure                level 1 unaligned dcl 6-245
Dobj                                   based           structure                level 1 unaligned dcl 6-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 6-311
Duser                                  based           structure                level 1 unaligned dcl 6-324
Luser                                  automatic       fixed bin(17,0)          dcl 6-324
Nacls                                  automatic       fixed bin(17,0)          dcl 6-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 6-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 6-190
Niacls                                 automatic       fixed bin(17,0)          dcl 6-209
Nnames                                 automatic       fixed bin(17,0)          dcl 6-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 6-245
PD                                     automatic       pointer                  dcl 6-146
PDacl                                  automatic       pointer                  dcl 6-153
PDdir_acl                              automatic       pointer                  dcl 6-172
PDdir_iacl                             automatic       pointer                  dcl 6-190
PDiacl                                 automatic       pointer                  dcl 6-209
PDnames                                automatic       pointer                  dcl 6-230
PDnodes                                automatic       pointer                  dcl 6-245
PDobj                                  automatic       pointer                  dcl 6-263
PDsearch_proc                          automatic       pointer                  dcl 6-311
PDuser                                 automatic       pointer                  dcl 6-324
Pnode                                  automatic       pointer                  dcl 6-69
Sreq                                   based           structure                level 1 dcl 6-343
Svalid                                 based           structure                level 1 dcl 6-343
Tacl                                   internal static fixed bin(17,0)          initial dcl 6-153
Tarchive                               internal static fixed bin(17,0)          initial dcl 6-358
Tarchive_comp                          internal static fixed bin(17,0)          initial dcl 6-358
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 6-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 6-190
Tdirectory                             internal static fixed bin(17,0)          initial dcl 6-358
Tiacl                                  internal static fixed bin(17,0)          initial dcl 6-209
Tlink                                  internal static fixed bin(17,0)          initial dcl 6-358
Tmsf                                   internal static fixed bin(17,0)          initial dcl 6-358
Tmsf_comp                              internal static fixed bin(17,0)          initial dcl 6-358
Tnames                                 internal static fixed bin(17,0)          initial dcl 6-230
Tnodes                                 internal static fixed bin(17,0)          initial dcl 6-245
Tobj                                   internal static fixed bin(17,0)          initial dcl 6-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 6-311
Tsegment                               internal static fixed bin(17,0)          initial dcl 6-358
Tuser                                  internal static fixed bin(17,0)          initial dcl 6-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 6-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 6-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 6-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 6-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 6-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 6-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 6-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 6-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 6-324
brief_node_type                        internal static varying char(12)         initial array dcl 6-374
exclude                                based           structure                level 1 dcl 3-42
link_node                              based           structure                level 1 unaligned dcl 6-30
node_type                              internal static varying char(32)         initial array dcl 6-374

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_ATTACH                      004016 constant        label                    dcl 412 ref 222 226
BAD_CLOSE                       004031 constant        label                    dcl 417 ref 398
BAD_DETACH                      004035 constant        label                    dcl 420 ref 402
BAD_IO                          004044 constant        label                    dcl 425 set ref 416 419 422
BAD_OPEN                        004041 constant        label                    dcl 423 set ref 228
BAD_S                           000000 constant        label                    array(0:7) dcl 438 ref 437
BAD_SEARCH                      004154 constant        label                    dcl 435 set ref 240
DETACH                          004006 constant        label                    dcl 386 ref 427 439 442 446 454 456 464 468
MULTIPLE_ATTACH                 004111 constant        label                    dcl 429 ref 412
NO_DEFAULT_NAMES                004314 constant        label                    dcl 450 set ref 448
NO_MATCH                        004407 constant        label                    dcl 458 ref 251
NO_NAME                         004570 constant        label                    dcl 470 ref 192
SET_FOOTING                     003742 constant        label                    dcl 379 ref 372
janitor                         004617 constant        entry                    internal dcl 390 ref 217 386
library_print                   000650 constant        entry                    external dcl 15
lpr                             000640 constant        entry                    external dcl 15
no_end_page                     004736 constant        entry                    internal dcl 479 ref 210

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5340        5544    4755        5350
Length      6200    4755       204         420     363         104

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lpr                               19414 external procedure  is an external procedure.  
on unit on line 217                  70 on unit               
janitor                              72 internal procedure  is called by several nonquick procedures.  
no_end_page                          64 internal procedure  is assigned to an entry variable.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 Lcompany                    lpr
000011 Ldepartment                 lpr
000012 Ocompany                    lpr
000013 Odepartment                 lpr
000014 Sno_titles                  lpr
000015 company                     lpr
000053 department                  lpr
000111 stream_output               lpr
000112 max_entries                 lpr

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lpr                      000100 Parea                       lpr
                         000102 Ptree                       lpr
                         000104 arg_struc_temp              lpr
                         000414 clock                       lpr
                         000416 code                        lpr
                         000417 date                        lpr
                         000424 fcb_temp                    lpr
                         000451 i                           lpr
                         000452 j                           lpr
                         000453 progress                    lpr
                         000454 state                       lpr
                         000466 LIBRARY                     lpr
                         002273 STARNAME                    lpr
                         023744 EXCLUDE                     lpr
                         045416 Parg_struc                  lpr
                         045420 Plibrary                    lpr
                         045422 Pstarname                   lpr
                         045424 Pexclude                    lpr
                         045426 Pfcb                        lpr
                         045430 Pindex_list                 lpr
                         045432 Pname_list                  lpr
                         045434 Pnode_list                  lpr
                         045436 Ppage_list                  lpr
                         045440 Srequirements               lpr
                         045442 Scontrol                    lpr

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return              tra_ext             enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
clock_                        com_err_                      condition_                    cu_$arg_count
cu_$arg_list_ptr              date_time_                    get_group_id_                 get_system_msa_
ioa_$ioa_switch               ioa_$ioa_switch_nnl           iox_$attach_ioname            iox_$close
iox_$detach_iocb              iox_$open                     lib_args_                     lib_descriptor_$print
lib_error_list_               lib_output_node_list_$print   lib_sort_tree_$make_name_list lib_sort_tree_$name_list
msa_manager_$area_handler     release_system_msa_           smart_alloc_                  system_info_$titles

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$entlong          error_table_$noarg            error_table_$not_detached     error_table_$not_open




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000634        15 000637       100 000656       101 000661       102 000663       103 000670       104 000700
    105 000704       106 000714       107 000723       108 000726       109 000730       110 000731       112 000732
    113 000734       114 000736       115 000740       116 000742       117 000744       118 000746       119 000750
    120 000752       121 000754       122 000756       123 000760       124 000762       125 000764       126 000766
    127 000770       128 000772       129 000774       130 000776       131 001000       132 001002       133 001004
    134 001006       135 001010       136 001012       137 001014       138 001016       139 001020       140 001022
    141 001024       142 001026       143 001030       144 001032       145 001034       146 001036       147 001040
    148 001042       149 001044       150 001046       151 001050       152 001052       153 001054       154 001056
    158 001060       159 001062       161 001064       162 001066       163 001070       164 001072       165 001074
    166 001076       167 001100       168 001102       169 001104       170 001106       171 001110       172 001112
    173 001114       174 001116       175 001120       176 001122       177 001124       178 001126       179 001130
    181 001132       182 001134       183 001136       184 001143       186 001145       187 001172       189 001174
    190 001206       192 001210       206 001220       207 001222       208 001224       209 001227       210 001231
    211 001234       212 001237       213 001241       214 001243       216 001245       217 001247       219 001273
    221 001312       222 001315       224 001316       225 001330       226 001376       227 001401       228 001423
    230 001425       232 001452       234 001474       235 001477       236 001501       237 001503       240 001536
    242 001540       246 001657       247 001661       248 001663       249 001665       250 001667       251 001706
    252 001710       268 001723       269 001726       270 001752       271 001774       272 002000       273 002020
    274 002024       276 002025       277 002064       278 002070       279 002124       280 002130       282 002156
    284 002203       285 002207       286 002212       287 002215       289 002256       290 002262       292 002263
    293 002266       294 002307       295 002330       296 002333       298 002374       299 002400       301 002401
    302 002422       303 002426       304 002430       305 002440       306 002463       307 002470       309 002540
    310 002544       312 002546       313 002610       314 002613       317 002622       319 002664       322 002670
    323 002675       324 002700       325 002720       327 002763       328 002767       330 002770       331 003011
    332 003015       333 003017       334 003030       335 003053       336 003060       338 003130       339 003134
    341 003136       342 003200       343 003203       344 003212       346 003254       348 003260       349 003263
    351 003310       352 003320       353 003336       354 003365       355 003426       356 003456       361 003512
    363 003532       365 003536       367 003542       368 003544       369 003556       370 003601       371 003607
    372 003621       374 003622       375 003662       376 003665       377 003711       378 003730       379 003742
    382 003752       386 004006       387 004015       412 004016       414 004021       415 004024       416 004030
    417 004031       419 004034       420 004035       422 004040       423 004041       425 004044       427 004110
    429 004111       433 004153       435 004154       437 004161       438 004162       439 004211       440 004212
    442 004245       443 004246       446 004304       447 004305       448 004310       449 004311       450 004314
    454 004356       455 004357       456 004406       458 004407       462 004442       463 004465       464 004510
    465 004511       467 004544       468 004567       470 004570       474 004615       390 004616       394 004624
    396 004643       397 004652       398 004663       400 004701       401 004715       402 004722       405 004734
    479 004735       481 004743       482 004747       484 004751


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
