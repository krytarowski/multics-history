	COMPILATION LISTING OF SEGMENT amu_tc_data_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/13/85  0934.4 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        4*   *                                                         *
        5*   *********************************************************** */
        6 amu_tc_data_:
        7      proc (P_amu_info_ptr, argument);
        8 	return;
        9 
       10 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend,ifthendo,ifthen,^thendo */
       11 
       12 /* this proc will deal with the tc_data seg it has 2 entry points */
       13 
       14 /* dcl amu_$tc_data_get_apt_entry entry (ptr, char (3), fixed bin, ptr);
       15*   call amu_$tc_data_get_apt_entry (amu_info_ptr,arg, apte_array_ptr,apte_array_index);
       16*   where
       17*   amu_info_ptr is a pointer to the main info structer for the fdump
       18*   arg is the three character state
       19*   ("run", "rdy", "wat", "blk", "stp", "ptl")
       20*   apte_array_ptr is a pointer to an array (see apte_array)
       21*   apte_array_index is where the last entry is in the array.
       22*   (this is used as input and output)
       23*
       24*   This entry will return the selected apte entries in the array and
       25*   increment the index
       26**/
       27 
       28 /* dcl amu_$tc_data_find_apte entry (ptr,fixed bin (24),ptr,fixed bin (35));
       29*   call amu_$tc_data_find_apte (amu_info_ptr,dbr,aptep,code);
       30*   where
       31*   amu_info_ptr is a pointer to the main info for this fdump
       32*   dbr is the dbr address value that is to be searched for
       33*   aptep is the pointer that is returned for the found apte
       34*   code the the error code retunred
       35*
       36*   This entry will return the apte pointer given the dbr value if code = -1 then
       37*   the dbr did not match any apte's
       38**/
       39 dcl  APT_BASE fixed bin;
       40 dcl  WCTE_WORDS fixed bin;
       41 dcl  code fixed bin (35);
       42 dcl  offset fixed bin (18);
       43 dcl  P_amu_info_ptr ptr;
       44 dcl  P_offset fixed bin (18);
       45 dcl  P_aptep ptr;
       46 dcl  P_code fixed bin (35);
       47 dcl  P_dbr fixed bin (24);
       48 dcl  P_all_sw bit (1);
       49 dcl  P_return_ptr ptr;
       50 dcl  P_rdy_sw bit(1);
       51 dcl  P_return_index fixed bin;
       52 dcl  dbr_search fixed bin (24);
       53 dcl  i fixed bin;
       54 dcl  rdy_sw bit(1);
       55 dcl  return_index fixed bin;
       56 dcl  return_ptr ptr;
       57 dcl  1 apte_array (return_index) based (return_ptr),
       58        2 ptr ptr,
       59        2 off fixed bin (18),
       60        2 index fixed bin;
       61 
       62 dcl  ioa_ entry () options (variable);
       63 dcl  amu_$print_apte entry (ptr, ptr, fixed bin (18), fixed bin);
       64 dcl  amu_$print_apte_bf entry (ptr, ptr, fixed bin (18));
       65 dcl  amu_$check_info_hard entry (ptr);
       66 
       67 dcl  (
       68      amu_et_$proc_not_dumped,
       69      amu_et_$entry_not_found
       70      ) fixed bin (35) ext;
       71 
       72 dcl  RUNNING fixed bin init (1) static options (constant);
       73 dcl  argument char (3);
       74 
       75 dcl  all_sw bit (1) init ("0"b);
       76 dcl  tc_datap ptr;
       77 
       78 dcl (addr, addrel, binary, divide, 
       79      fixed, null, pointer, rel, substr, unspec)  builtin;
       80 
       81 amu_tc_data_$get_apt_entry:
       82      entry (P_amu_info_ptr, arg_idx, process_id, apte_offset, P_return_ptr, P_return_index);
       83 
       84 dcl arg_idx fixed bin;
       85 dcl process_id bit(36);
       86 dcl apte_offset fixed bin(18);
       87 dcl ( arg_sw, apte_sw, pid_sw, want_it) bit(1);
       88 
       89     call amu_$check_info_hard (P_amu_info_ptr);
       90     amu_info_ptr = P_amu_info_ptr;
       91     call set_tcp_aptp;
       92     arg_sw, apte_sw, pid_sw, want_it = "0"b;
       93     return_ptr = P_return_ptr;
       94     return_index = P_return_index;
       95 
       96     if arg_idx > 0 then arg_sw = "1"b;			/* have to match on apte state		*/
       97     else if apte_offset >0 then apte_sw = "1"b;
       98     else if process_id > "0"b then pid_sw = "1"b;
       99 
      100     offset = fixed (rel (aptep), 18) - fixed (rel (tc_datap), 18);
      101 
      102     do i = 1 to hardcore_info.apt.count;
      103        if arg_sw then do;
      104           if arg_idx = fixed (apte.state, 17) then want_it = "1"b;
      105           end;
      106        else if apte_sw then do;
      107 	if apte_offset = offset then want_it = "1"b;
      108 	end;
      109        else if pid_sw then do;
      110           if process_id = apte.processid then want_it = "1"b;
      111 	end;
      112        if want_it then do;
      113 	return_index = return_index + 1;
      114 	apte_array (return_index).ptr = aptep;
      115 	apte_array (return_index).off = offset;
      116 	apte_array (return_index).index = i;
      117 	want_it = "0"b;
      118 	end;
      119        aptep = addrel (aptep, hardcore_info.apt.size);
      120        offset = fixed (rel (aptep), 18) - fixed (rel (tc_datap), 18);
      121        end;
      122 
      123 
      124     P_return_index = return_index;
      125     return;
      126 
      127 
      128 amu_tc_data_$tcq:
      129      entry (P_amu_info_ptr, P_all_sw, P_rdy_sw);
      130 
      131 dcl apte_number fixed bin;
      132 dcl wc_number fixed bin;
      133 dcl first_aptep ptr;
      134 dcl print_this_wc bit(1);
      135 	amu_info_ptr = P_amu_info_ptr;
      136 	call set_tcp_aptp;
      137 	tcmp = tc_datap;
      138           rdy_sw = P_rdy_sw;				/* Print the eligible queue. */
      139 	all_sw = P_all_sw;				/* Print unthreaded entruies also.		*/
      140 
      141 	APT_BASE = fixed (tcm.apt_offset, 18);
      142 	if APT_BASE = 0 then APT_BASE = 256;		/* old style tc_data */
      143 	WCTE_WORDS = divide (APT_BASE - fixed (tcm.min_wct_index), 17, 17, 0);
      144 
      145 	  call ioa_ ("ELIGIBLE QUEUE:^/Proc^8tDBR^17tState^27tProcess ID^39tCPU");
      146 	aptep = addrel (tcmp, tcm.eligible_q_head.fp);
      147 elig_apt_loop:
      148 	if aptep ^= addr (tcm.ready_q_tail) then do;
      149 	     offset = fixed (rel (aptep), 18) - fixed (rel (tcmp), 18);
      150 	     call amu_$print_apte_bf (amu_info_ptr, aptep, offset);
      151 	     aptep = addrel (tcmp, apte.thread.fp);
      152 	     go to elig_apt_loop;
      153 	     end;
      154 
      155 	if ^(all_sw | rdy_sw) then return;			
      156 
      157 /* Print the realtime queue. */
      158 
      159 	if tcm.realtime_q.sentinel ^= "0"b then do;	/* look in realtime queue */
      160 	     call ioa_ ("REALTIME QUEUE:");
      161 	     aptep = addrel (tcmp, tcm.realtime_q.fp);
      162 dead_apt_loop:
      163 	     if aptep ^= addr (tcm.realtime_q) then do;
      164 		offset = fixed (rel (aptep), 18) - fixed (rel (tcmp), 18);
      165 		call amu_$print_apte_bf (amu_info_ptr, aptep, offset);
      166 		aptep = addrel (tcmp, apte.thread.fp);
      167 		go to dead_apt_loop;
      168 		end;
      169 	     end;
      170 
      171 /* Print the interactive queue. */
      172 
      173 	if tcm.apt_offset ^= "0"b then do;		/* look in interactvve queue */
      174 	     if tcm.deadline_mode ^= 0 then
      175 		call ioa_ ("DEADLINE QUEUE:");	/* processes with soft deadlines */
      176 	     else call ioa_ ("INTERACTIVE QUEUE:");
      177 	     aptep = addrel (tcmp, tcm.interactive_q.fp);
      178 int_apt_loop:
      179 	     if aptep ^= addr (tcm.interactive_q) then do;
      180 		offset = fixed (rel (aptep), 18) - fixed (rel (tcmp), 18);
      181 		call amu_$print_apte_bf (amu_info_ptr, aptep, offset);
      182 		aptep = addrel (tcmp, apte.thread.fp);
      183 		go to int_apt_loop;
      184 		end;
      185 	     end;
      186 
      187 /* Print per-workclass queues. */
      188 
      189 	if tcm.apt_offset ^= ""b then do;
      190 	     wctep = addr (tcm.wcte (0));
      191 	     do wc_number = 0 to 16;
      192 
      193 		first_aptep = addrel (tcmp, wct_entry.thread.fp);
      194 		print_this_wc = "0"b;
      195 
      196 		/* print all queues, first check some things */
      197 		if (tcm.deadline_mode = 0)		/* only if not in deadline mode */
      198 		     & wct_entry.flags.defined	/* skip undefined ones */
      199 		     & (wct_entry.realtime = 0)	/* skip realtime as not threaded here unless bug */
      200 		     & wctep ^= first_aptep then	/* and skip the empties, too */
      201 		     print_this_wc = "1"b;
      202 
      203 		if print_this_wc then do;
      204 		     call ioa_ ("WORKCLASS ^d QUEUE: credits = ^d ms.",
      205 			wc_number, divide (wct_entry.credits, 1000, 17, 0), (first_aptep = wctep));
      206 		     call print_queue (first_aptep, wctep);
      207 		     end;
      208 
      209 		wctep = addrel (wctep, WCTE_WORDS);
      210 		end;				/* of loop through workclasses */
      211 	     end;
      212           
      213           if ^all_sw then return;
      214 
      215 /* Print unthreaded entries. */
      216 
      217           call ioa_ ("^/UNTHREADED:");
      218 	do apte_number = 0 to tcm.apt_size - 1; 	/* loop through all the APTEs */
      219 	     aptep = pointer (tcmp, (apte_number * tcm.apt_entry_size + binary (rel (addrel (tcmp, APT_BASE)), 17)));
      220 	     offset = fixed (rel (aptep), 18) - fixed (rel (tcmp), 18);
      221 
      222 	     if unspec (apte.thread) = ""b & apte.state ^= ""b then
      223 	        call amu_$print_apte_bf (amu_info_ptr, aptep, offset);
      224 	     else if apte.idle then call amu_$print_apte_bf (amu_info_ptr, aptep, offset);
      225 	     end;
      226 
      227 	return;					/* end tcq entry */
      228 
      229 amu_tc_data_$find_apte:
      230      entry (P_amu_info_ptr, P_dbr, P_aptep, P_code);
      231 	call amu_$check_info_hard (P_amu_info_ptr);
      232 	amu_info_ptr = P_amu_info_ptr;
      233 	call set_tcp_aptp;
      234 	dbr_search = P_dbr;
      235 	offset = fixed (rel (aptep), 18) - fixed (rel (tc_datap), 18);
      236 	do i = 1 to hardcore_info.apt.count;
      237 	     if dbr_search = binary (substr (unspec (apte.dbr), 1, 24)) then do;
      238 		P_aptep = aptep;
      239 		P_code = 0;
      240 		return;
      241 		end;
      242 	     aptep = addrel (aptep, hardcore_info.apt.size);
      243 	end;
      244 	P_aptep = null ();
      245 	P_code = -1;
      246 	return;
      247 
      248 
      249 amu_tc_data_$print_this_apte:
      250      entry (P_amu_info_ptr, P_offset, P_code);
      251 	amu_info_ptr = P_amu_info_ptr;
      252 	call set_tcp_aptp;
      253 
      254 	offset = fixed (rel (aptep), 18) - fixed (rel (tc_datap), 18);
      255 	do i = 1 to hardcore_info.apt.count;
      256 	     if P_offset = offset then do;
      257 		call amu_$print_apte (amu_info_ptr, aptep, offset, i);
      258 		return;
      259 		end;
      260 	     aptep = addrel (aptep, hardcore_info.apt.size);
      261 	     offset = fixed (rel (aptep), 18) - fixed (rel (tc_datap), 18);
      262 	end;
      263 	P_code = amu_et_$entry_not_found;
      264 	return;
      265 amu_tc_data_$get_dbr:
      266      entry (P_amu_info_ptr, P_offset, P_dbr);
      267 	amu_info_ptr = P_amu_info_ptr;
      268 	offset = P_offset;
      269 	call set_tcp_aptp;
      270 	aptep = addrel (tc_datap, offset);
      271 	if apte.state = "0"b then P_dbr = -1;
      272 	else P_dbr = binary (substr (unspec (apte.dbr), 1, 24));
      273 	return;
      274 
      275 
      276 amu_tc_data_$find_first_running:
      277      entry (P_amu_info_ptr, P_dbr, P_code);
      278 	amu_info_ptr = P_amu_info_ptr;
      279 	call set_tcp_aptp;
      280 	do i = 1 to hardcore_info.apt.count;
      281 	     if binary (apte.state) = RUNNING then do;
      282 		P_dbr = binary (substr (unspec (apte.dbr), 1, 24));
      283 		P_code = 0;
      284 		return;
      285 		end;
      286 	     aptep = addrel (aptep, hardcore_info.apt.size);
      287 	end;
      288 	P_dbr = -1;
      289 	P_code = amu_et_$proc_not_dumped;
      290 	return;
      291 
      292 print_queue:
      293           proc(Pfirst, Plast);
      294 
      295 /* Prints a single workclass queue */
      296 
      297 dcl (Pfirst, Plast) ptr parameter;
      298 
      299      do aptep = Pfirst
      300 	      repeat (addrel (tcmp, apte.thread.fp))
      301                 while (aptep ^= Plast);
      302                  
      303         offset = fixed (rel (aptep), 18) - fixed (rel (tcmp), 18);
      304         call amu_$print_apte_bf (amu_info_ptr, aptep, offset);
      305         end;
      306 
      307 end print_queue;
      308 
      309 set_tcp_aptp:
      310      proc;
      311 
      312 	if hardcore_info.pointers.tc_data.fptr ^= null () then do;
      313 	     tc_datap = hardcore_info.pointers.tc_data.fptr;
      314 						/* tc_data is in dump */
      315 	     aptep = hardcore_info.apt.foreign_ptr;
      316 	     return;
      317 	     end;
      318 
      319 
      320 	else if hardcore_info.pointers.tc_data.lptr ^= null () then do;
      321 	     tc_datap = hardcore_info.pointers.tc_data.lptr;
      322 						/* tc_data is in local copy */
      323 	     aptep = hardcore_info.apt.local_ptr;
      324 	     return;
      325 	     end;
      326 
      327 	else do;
      328 	     tc_datap = null ();
      329 	     aptep = null ();
      330 	     return;				/* we can not look at it */
      331 	     end;
      332      end set_tcp_aptp;
      333 
  1     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  1     2 
  1     3 dcl 1 amu_info aligned based (amu_info_ptr),
  1     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  1     5     2 flags aligned,
  1     6       3 early_dump bit(1) unal,
  1     7       3 pad  bit(35) unal,
  1     8     2 type fixed bin unal,				/* One of the types below */
  1     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  1    10     2 chain,					/* a chain of all the amu_info's which exist */
  1    11       3 prev pointer unaligned,
  1    12       3 next pointer unaligned,
  1    13 
  1    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  1    15 
  1    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  1    17 						/*   SEE: amu_translation.incl.pl1 */
  1    18     2 fdump_info_ptr pointer, 			
  1    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  1    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  1    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  1    22 						/* See: amu_old_uid_table			*/
  1    23 	
  1    24 
  1    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  1    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  1    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  1    28 						/*   SEE: amu_copy_info.incl.pl1 */
  1    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  1    30 						/*   SEE: amu_process_info.incl.pl1 */
  1    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  1    32 
  1    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  1    34 
  1    35     2 error_info,					/* various info about how amu_error_ is to behave */
  1    36       3 error_flags aligned,
  1    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  1    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  1    39         4 pad bit (34) unaligned,
  1    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  1    41     2 definitions_info_ptr ptr;
  1    42 
  1    43 dcl  amu_area area based (amu_info.area_ptr);
  1    44 
  1    45 dcl  amu_info_ptr pointer;
  1    46 
  1    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  1    48      FDUMP_PROCESS_TYPE	init (1038),
  1    49      ONLINE_TYPE		init (1039),
  1    50      ONLINE_PROCESS_TYPE	init (1040),
  1    51      NETWORK_FDUMP_TYPE	init (1041),
  1    52      NETWORK_ONLINE_TYPE	init (1042),
  1    53      SAVED_PROC_TYPE	init (1043),
  1    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  1    55 
  1    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  1    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  1    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  1    59 
  1    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  1    61 
  1    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      334 
  2     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  2     2 
  2     3 /* This structure contains information about the hardcore supervisor address
  2     4*   space for an address translation. */
  2     5 
  2     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  2     7 
  2     8     2 pointers,					/* assorted pointers to various useful items */
  2     9       3 slt aligned,				/* SLT */
  2    10         4 fptr pointer unaligned,			/* address in foreign address space */
  2    11         4 lptr pointer unaligned,			/* location in local address space */
  2    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  2    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  2    14 
  2    15       3 sst aligned like hardcore_info.slt,		/* SST */
  2    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  2    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  2    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  2    19 
  2    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  2    21       3 prds fixed bin (15),				/* segno of PRDS */
  2    22       3 dseg fixed bin (15),				/* DSEG */
  2    23       3 pds fixed bin (15),				/* PDS */
  2    24       3 kst fixed bin (15),				/* KST */
  2    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  2    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  2    27 
  2    28     2 apt,					/* information about the APT */
  2    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  2    30       3 local_ptr pointer unaligned,
  2    31       3 count fixed bin,				/* number of APTEs */
  2    32       3 size fixed bin,				/* size of a single APTE */
  2    33 
  2    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  2    35 
  2    36     2 pad1 fixed bin;
  2    37 
  2    38 dcl hardcore_cur_ptr ptr;
  2    39 
  2    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  2    41     2 sltp ptr,
  2    42     2 sltntp ptr,
  2    43     2 defp ptr,
  2    44     2 sstp ptr,
  2    45     2 tc_datap ptr,
  2    46     2 sstntp ptr,
  2    47     2 uptp ptr;
  2    48 	
  2    49     
  2    50 
  2    51 
  2    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      335 
  3     1 /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
  3     2 
  3     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
  3     4 
  3     5 dcl  aptep pointer;
  3     6 
  3     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
  3     8     2 thread unaligned,				/* List thread */
  3     9       3 fp bit (18),				/* Forward pointer */
  3    10       3 bp bit (18),				/* Backward pointer */
  3    11     2 flags unaligned,				/* Flags and miscellaneous */
  3    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
  3    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
  3    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
  3    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
  3    16       3 hproc bit (1),				/* ON if process is hardcore process */
  3    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
  3    18       3 eligible bit (1),				/* ON if process is eligible */
  3    19       3 idle bit (1),				/* ON if  this is an idle process */
  3    20       3 interaction bit (1),				/* ON if process has interacted recently */
  3    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
  3    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
  3    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
  3    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
  3    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
  3    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
  3    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
  3    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
  3    29       3 firstsw bit (1),				/* OFF until process is intialized */
  3    30       3 state bit (18),				/* execution state */
  3    31     2 page_faults fixed bin (35),			/* total page faults for the process */
  3    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
  3    33 						/* bit 18-35: sequential number */
  3    34     2 te fixed bin (35),				/* virtual time since eligibility award */
  3    35     2 ts fixed bin (35),				/* virtual time since scheduling */
  3    36     2 ti fixed bin (35),				/* virtual time since interaction */
  3    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
  3    38 
  3    39 /* * * * * * * * */
  3    40 
  3    41     2 ipc_pointers unaligned,
  3    42       3 event_thread bit (18),			/* relative pointer to ITT list */
  3    43       3 pad3 bit (18),
  3    44     2 ips_message bit (36),				/* IPS signals pending */
  3    45     2 asteps unaligned,				/* relative ASTE pointers */
  3    46       3 pds bit (18),				/* PDS (per-process) */
  3    47       3 dseg bit (18),				/* DSEG (per-process) */
  3    48       3 prds bit (18),				/* PRDS (per-processor) */
  3    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
  3    50     2 term_processid bit (36),			/* process to send wakeup at temination */
  3    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
  3    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
  3    53 
  3    54 /* * * * * * * * */
  3    55 
  3    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
  3    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
  3    58     2 flags2 unaligned,
  3    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
  3    60       3 special_wakeups bit (6),			/* Special wakeup channels */
  3    61       3 pad7 bit (7),
  3    62       3 batch bit (1),				/* ON if absentee */
  3    63       3 pr_tag bit (3),				/* CPU tag running or last run */
  3    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
  3    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
  3    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
  3    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
  3    68 
  3    69 /* * * * * * */
  3    70 
  3    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
  3    72     2 ws_size fixed bin,				/* working set estimate for the process */
  3    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
  3    74     2 deadline fixed bin (71),			/* time of next run */
  3    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
  3    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
  3    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
  3    78*						/* reaches this (units = 1/1024 sec) */
  3    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
  3    80     2 access_authorization bit (72),			/* authorization of this process */
  3    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
  3    82 
  3    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
  3    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
  3    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
  3    86 
  3    87 /*  Cells used to drive and instrument finite-state model for response time
  3    88*    measurement. Maintained by meter_response_time */
  3    89 
  3    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
  3    91     2 pad18 bit (18) unaligned,
  3    92     2 number_processing fixed bin (35),			/* Number interactions */
  3    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
  3    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
  3    95 
  3    96 /* * * * * * */
  3    97 
  3    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
  3    99 
  3   100 /*  End of cells for finite-state model */
  3   101 
  3   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
  3   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
  3   104     2 pad4 bit (28) unaligned,
  3   105     2 ipc_r_offset fixed bin (18) unsigned,
  3   106     2 ipc_r_factor fixed bin (35) unsigned,
  3   107     2 apad (10) fixed bin (35);
  3   108 
  3   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      336 
  4     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  4     2 
  4     3 dcl  sdwp ptr;
  4     4 
  4     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  4     6 
  4     7    (2 add bit (24),					/* main memory address of page table */
  4     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  4     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  4    10     2 df_no bit (2),				/* directed fault number */
  4    11 
  4    12     2 pad1 bit (1),
  4    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  4    14     2 access,					/* access bits */
  4    15       3 read bit (1),				/* read permission bit */
  4    16       3 execute bit (1),				/* execute permission bit */
  4    17       3 write bit (1),				/* write permission bit */
  4    18       3 privileged bit (1),				/* privileged bit */
  4    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  4    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  4    21     2 cache bit (1),				/* cache enable bit */
  4    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  4    23 
  4    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  4    25 
  4    26 /* END INCLUDE FILE  sdw.incl.pl1 */
      337 
  5     1 /* BEGIN INCLUDE FILE ... tcm.incl.pl1 ... used to generate tc_data cds */
  5     2 /* NOTE -- This include file has TWO counterparts in ALM: tc_meters.incl.alm and */
  5     3 /* wcte.incl.alm. They cannot be produced with cif, and must be kept up to date manually. */
  5     4 /* Modified 830914 to replace tty_polling_time with opc_polling_time... -E. A. Ranzenbach */
  5     5 /* Modified 1984.05.21 by M. Pandolf to add tc_suspend_lock */
  5     6 /* Modified 1984.11.26 by Keith Loepere for uid_array. */
  5     7 /* Modified 1984.12.06 by Keith Loepere for page create delaying. */
  5     8 
  5     9 dcl  tcmp ptr;
  5    10 
  5    11 dcl 1 tcm aligned based (tcmp),
  5    12     2 tc_suspend_lock like lock,			/* when locked, tc is suspended */
  5    13     2 cid2 fixed bin (18),
  5    14     2 cid3 fixed bin (18),
  5    15     2 cid4 fixed bin (18),
  5    16     2 depth_count fixed bin (18),			/* depth last process run */
  5    17     2 loadings fixed bin (18),			/* number of process loadings */
  5    18 
  5    19     2 blocks fixed bin (18),				/* number of calls to block */
  5    20     2 wakeups fixed bin (18),				/* number of calls to wakeup */
  5    21     2 waits fixed bin (18),				/* number of calls to wait */
  5    22     2 notifies fixed bin (18),			/* number of calls to notify */
  5    23     2 schedulings fixed bin (18),
  5    24     2 interactions fixed bin (18),			/* number of interactive schedulings */
  5    25     2 avequeue fixed bin (35, 18),			/* recent time average of number in queue */
  5    26     2 te_wait fixed bin (18),				/* times te called from wait */
  5    27 
  5    28     2 te_block fixed bin (18),			/* times te updated from block */
  5    29     2 te_i_stop fixed bin (18),			/* times te updated from i_stop */
  5    30     2 te_pre_empt fixed bin (18),			/* times te updated from pre_empt */
  5    31     2 p_interactions fixed bin,			/* times interaction bit turned off because of high priority */
  5    32     2 idle fixed bin (71),				/* total idle time */
  5    33     2 mp_idle fixed bin (71),				/* multi-programming idle */
  5    34 
  5    35     2 nmp_idle fixed bin (71),			/* non-multi-programming idle time */
  5    36     2 zero_idle fixed bin (71),			/* zero idle time */
  5    37     2 last_time fixed bin (71),			/* last time a process was run */
  5    38     2 loop_locks fixed bin (18),			/* times looped on the APT lock */
  5    39     2 loop_lock_time fixed bin (18),			/* time looping on the APT lock */
  5    40     2 ave_eligible fixed bin (35, 18),			/* average length of eligible queue */
  5    41     2 sort_to_elhead fixed bin (18),			/* 0=> no one,1 => int've only, 2 => everybody */
  5    42     2 processor_time fixed bin (71),			/* total processor time on system */
  5    43     2 response_time fixed bin (71),			/* estimate of response time */
  5    44     2 eligible_time fixed bin (71),			/* estimate of eligible time */
  5    45     2 response_count fixed bin,			/* count of response meters */
  5    46     2 eligible_count fixed bin,			/* count of eligible meters */
  5    47     2 quit_counts (0:5) fixed bin,			/* array of buckets indexed by state */
  5    48     2 loading_idle fixed bin (71),			/* loading_idle time */
  5    49     2 delta_vcpu fixed bin (71),			/* delta virtual CPU time for the system */
  5    50     2 post_purge_switch fixed bin,			/* ON if post purging is to be done */
  5    51     2 time_out_severity fixed bin,			/* syserr first arg for notify time outs */
  5    52     2 notify_check fixed bin,				/* obsolete */
  5    53     2 quit_priority fixed bin,			/* factor for scheduler quit response */
  5    54     2 iobm_polling_time fixed bin (71),			/* time to poll iobm */
  5    55     2 end_of_time fixed bin (71),			/* very large time */
  5    56     2 gp_at_notify fixed bin (18),			/* 0 => just do get_idle_processor */
  5    57     2 gp_at_ptlnotify fixed bin (18),			/* 0 => just do get_idle_processor */
  5    58     2 int_q_enabled fixed bin (18),			/* 0 => no intv q in percent mode */
  5    59     2 fnp_buffer_threshold fixed bin (18),		/* if fewer free buffs then stingy alloc strategy */
  5    60 						/* set this to >= half n_ttylines/fnp for safety */
  5    61 
  5    62 /* 100 octal */
  5    63 
  5    64     2 depths (8) fixed bin (18),			/* histogram of run depths */
  5    65     2 tdepths (8) fixed bin (71),			/* histogram of times run per depth */
  5    66     2 pfdepth (8) fixed bin (18),			/* histogram of page faults per depth */
  5    67 
  5    68     2 ptl_not_waits fixed bin (18),			/* times ptl_wait noticed ptl was unlocked */
  5    69     2 gw_gp_window_count fixed bin (18),		/* times window noticed */
  5    70     2 metering_lock fixed bin (18),			/* 0=locked, else unlocked */
  5    71     2 ptl_waits fixed bin (18),			/* num calls to ptl_wait */
  5    72     2 gp_start_count fixed bin (18),			/*  to detect gw_gp window lossage */
  5    73     2 gp_done_count fixed bin (18),
  5    74     2 nto_check_time fixed bin (71),			/* next time at which nto code will be called */
  5    75     2 nto_delta fixed bin (35),			/* microsec between nto checks */
  5    76     2 nto_count fixed bin (18),			/* number of times nto detected */
  5    77     2 tcpu_scheduling fixed bin (18),			/* obsolete				*/
  5    78     2 nto_event bit (36),				/* last event which NTO'd */
  5    79     2 page_notifies fixed bin (18),
  5    80     2 notify_nobody_count fixed bin (18),
  5    81     2 notify_nobody_event bit (36),
  5    82     2 system_type fixed bin,				/* used to be tcm.inter */
  5    83 
  5    84     2 stat (0:15) fixed bin (18),			/* num apte's in each state */
  5    85 
  5    86 /* 200 octal */
  5    87 
  5    88     2 wait (8),
  5    89       3 time fixed bin (18),				/* histogram of page fault waiting times versus did */
  5    90       3 count fixed bin (18),
  5    91 
  5    92     2 ready (8),
  5    93       3 time fixed bin (18),				/* histogram of times in ready queue */
  5    94       3 count fixed bin (18),
  5    95 
  5    96     2 total_pf_time fixed bin (71),			/* total time spent from start to end of
  5    97*						   all page faults */
  5    98     2 total_pf_count fixed bin (18),			/* total number of page faults metered */
  5    99     2 auto_tune_ws fixed bin (18),			/* 0=> dont, atherwise compensate for quantum len */
  5   100     2 ocore_delta fixed bin (18),			/* number of pages reserved for int users */
  5   101     2 ws_sum fixed bin (18),				/* total of eligible's ws_sizes */
  5   102     2 nonidle_force_count fixed bin (18),		/* count of eligibilities forced */
  5   103     2 itt_list_lock bit (36) aligned,			/* Lock on ITT free list */
  5   104     2 cpu_pf_time fixed bin (71),			/* total cpu time spent handling page faults */
  5   105     2 cpu_pf_count fixed bin (18),			/* total count of cpu time meterings */
  5   106     2 special_offsets unaligned,
  5   107       3 apt_offset bit (18),
  5   108       3 pad bit (18),
  5   109     2 getwork_time fixed bin (71),			/* total time spent in getwork */
  5   110     2 getwork_count fixed bin (18),			/* total times through getwork */
  5   111     2 short_pf_count fixed bin (18),			/* number of short page faults */
  5   112     2 interrupt_time fixed bin (71),			/* total time spent in interrupt */
  5   113     2 interrupt_count fixed bin (71),			/* total number of metered interrupts */
  5   114     2 ocore fixed bin (35, 18),			/* fraction of core for int've users */
  5   115     2 pre_empt_flag bit (36) aligned,			/* controls whether preempting at done time */
  5   116     2 cumulative_memory_usage fixed binary (71),		/* total number of memory usage units */
  5   117     2 processor_time_at_define_wc fixed bin (71),		/* value of processor_time when WC's last defined */
  5   118     2 boost_priority fixed bin,			/* number of times priority process given high priority */
  5   119     2 lost_priority fixed bin,			/* number of times priority process lost eligibility */
  5   120     2 total_clock_lag fixed bin (71),			/* sum of all simulated clock delays */
  5   121     2 clock_simulations fixed bin,			/* number of times alarm clock interrupt was simulated */
  5   122     2 max_clock_lag fixed bin,			/* largest simulated alarm clock delay */
  5   123 
  5   124 /* 300 octal */
  5   125 
  5   126     2 pdscopyl fixed bin (18),			/* amount of pds to copy for new process */
  5   127     2 max_hproc_segno fixed bin,			/* largest allowed hardcore segment number */
  5   128     2 prds_length fixed bin (18),			/* length of PRDS */
  5   129     2 pds_length fixed bin (18),			/* length of PDS */
  5   130     2 lock fixed bin (18),				/* process id generator lock */
  5   131     2 id bit (36) aligned,				/* next uid to be added to uid_array */
  5   132     2 system_shutdown fixed bin (18),
  5   133     2 working_set_factor fixed bin (35, 18),		/* working set factor */
  5   134 
  5   135     2 ncpu fixed bin (18),				/* number of processors currently being used */
  5   136     2 last_eligible bit (18),				/* last process to gain eligibility */
  5   137     2 apt_lock fixed bin (35),			/* + write; 0 hidden; -1 unlocked; -(N+1) Nreaders */
  5   138     2 apt_size fixed bin (18),			/* number of APT entries */
  5   139     2 realtime_q aligned like based_sentinel,		/* processes with realtime deadlines */
  5   140     2 aht_size fixed bin (18),			/* APT hash table size */
  5   141     2 itt_size fixed bin (18),			/* number of ITT entries */
  5   142 
  5   143     2 dst_size fixed bin (18),			/* number of allowed DST entries */
  5   144     2 itt_free_list bit (18),				/* pointer to ITT free list */
  5   145     2 used_itt fixed bin (18),			/* number of used ITT entries */
  5   146     2 initializer_id bit (36) aligned,			/* process id of initializer */
  5   147     2 n_eligible fixed bin (18),			/* number of processes eligible */
  5   148     2 max_eligible fixed bin (30),			/* maximum allowed number of eligible processes */
  5   149     2 wait_enable fixed bin (18),			/* turned on when waiting mechanism works */
  5   150     2 apt_entry_size fixed bin (18),			/* size of an APT entry */
  5   151 
  5   152     2 interactive_q aligned like based_sentinel,		/* head of interactive queue */
  5   153     2 dst_ptr ptr,					/* pointer to device signal table */
  5   154     2 old_user ptr,					/* last process to run (apt ptr ) */
  5   155     2 initialize_time fixed bin (71),			/* time of initialization */
  5   156 
  5   157     2 init_event fixed bin (18),			/* wait event during initialization */
  5   158     2 oldt fixed bin (18),				/* timer reading from previous process */
  5   159     2 newt fixed bin (18),				/* timer setting for new process */
  5   160     2 tefirst fixed bin (30),				/* first eligible time */
  5   161     2 telast fixed bin (30),				/* last eligible time */
  5   162     2 timax fixed bin (35),				/* time in queue for lowest level */
  5   163     2 empty_q bit (18),				/* thread of empty APT entries */
  5   164     2 working_set_addend fixed bin (18),		/* additive working set parameter */
  5   165     2 ready_q_head bit (0) aligned,			/* for added segdef */
  5   166     2 eligible_q_head aligned like based_sentinel,	/* head of eligible queue */
  5   167     2 ready_q_tail bit (0) aligned,			/* for added segdef */
  5   168     2 eligible_q_tail aligned like based_sentinel,	/* tail of eligible queue */
  5   169     2 idle_tail aligned like based_sentinel,		/* tail of idle list */
  5   170     2 min_eligible fixed bin (30),
  5   171     2 alarm_timer_list bit (18) aligned,		/* rel pointer to apt entry for next alarm timer */
  5   172     2 guaranteed_elig_inc fixed bin (35),		/* amount of guaranteed eligibility time in microsecs. */
  5   173     2 priority_sched_inc fixed bin (35),		/* amount of block time before process is given priority */
  5   174     2 next_alarm_time fixed bin (71),			/* clock time for next alarm timer */
  5   175     2 priority_sched_time fixed bin (71),		/* time for priority process to be given priority */
  5   176     2 opc_polling_time fixed bin (71),			/* time to poll console DIM */
  5   177     2 disk_polling_time fixed bin (71),			/* time to poll disk DIM */
  5   178     2 tape_polling_time fixed bin (71),			/* time to poll tape DIM */
  5   179     2 imp_polling_time fixed bin (71),			/* time to poll imp */
  5   180     2 imp_polling_lock fixed bin (18),			/* do not poll if lock set */
  5   181     2 max_channels fixed bin (18),			/* num special channels per process */
  5   182 
  5   183 /* 400 octal */
  5   184 
  5   185     2 system_virtual_time fixed bin (71),		/* non-idle virtual time */
  5   186     2 credit_bank fixed bin (71),			/* credits not yet passed out */
  5   187     2 min_wct_index bit (18) aligned,			/* offset of initializer work class table entry */
  5   188     2 max_wct_index bit (18) aligned,			/* offset of highest wcte currently defined */
  5   189     2 delta_vt fixed bin (71),			/* temp used by pxss.compute_virtual_clocks */
  5   190     2 gross_idle_time fixed bin (71),			/* idle time_used_clock */
  5   191     2 credits_per_scatter fixed bin (35),		/* total number of credits awarded at once */
  5   192     2 best_credit_value fixed bin (18),			/* temp for pxss.find_next_eligible */
  5   193     2 define_wc_time fixed bin (71),			/* clock time when workclasses last degined */
  5   194     2 max_batch_elig fixed bin (35),
  5   195     2 num_batch_elig fixed bin (35),
  5   196     2 deadline_mode fixed bin (35),			/* 0=> ti sorts, else deadline sorts */
  5   197     2 credits_scattered fixed bin (35),
  5   198     2 max_max_eligible fixed bin (30),			/* Maximum of maxe */
  5   199     2 max_stopped_stack_0 fixed bin (35),		/* Maximum stack_0's suspended by stopped procs	*/
  5   200     2 stopped_stack_0 fixed bin (35),			/* Number stack_0's suspended by stopped procs	*/
  5   201     2 mos_polling_interval fixed bin (35),		/* for heals */
  5   202     2 mos_polling_time fixed bin (71),			/* for heals */
  5   203     2 vcpu_response_bounds (VCPU_RESPONSE_BOUNDS) fixed bin (35),
  5   204     2 vcpu_response_bounds_size fixed bin (35),
  5   205     2 meter_response_time_calls fixed bin (35),
  5   206     2 meter_response_time_invalid fixed bin (35),
  5   207     2 meter_response_time_overhead fixed bin (71),
  5   208     2 init_wait_time fixed bin (71),			/* used by wait/notify during initialization	*/
  5   209     2 init_wait_timeout fixed bin (71),			/* notify-timeout interval during initialization	*/
  5   210     2 init_timeout_severity fixed bin,			/* notify-timeout severity during initialization	*/
  5   211     2 init_timeout_recurse fixed bin,			/* count of NTO recursion during initialization	*/
  5   212     2 max_timer_register fixed bin (71),		/* max cpu burst = # cpus x pre_empt_sample_time	*/
  5   213     2 pre_empt_sample_time fixed bin (35),		/* tuning parameter - max time between samples	*/
  5   214     2 governing_credit_bank fixed bin (35),		/* used for limiting eligibility on governed work classes*/
  5   215     2 process_initial_quantum fixed bin (35),		/* eligibility quantum first eligibility	*/
  5   216     2 default_procs_required bit (8) aligned,		/* default mask of CPUs required */
  5   217     2 work_class_idle fixed bin (71),			/* idle time due to work class restrictions */
  5   218 
  5   219 /* Tuning Parameters for Stack Truncation */
  5   220 
  5   221     2 stk_truncate bit (1) aligned,
  5   222     2 stk_truncate_always bit (1) aligned,
  5   223     2 stk_trunc_avg_f1 fixed bin (35, 18),
  5   224     2 stk_trunc_avg_f2 fixed bin (35, 18),
  5   225     2 lock_error_severity fixed bin,                        /* syserr severity */
  5   226 
  5   227     2 gv_integration fixed bin (35),			/* Integration interval for governing */
  5   228     2 gv_integration_set bit (1) aligned,		/* ON => gv_integration set by ctp */
  5   229     2 pauses fixed bin (35),				/* Calls to pause (reschedule) */
  5   230     2 volmap_polling_time fixed bin (71),
  5   231     2 next_ring0_timer fixed bin (71),			/* next time that ring 0 timer goes off */
  5   232     2 realtime_io_priority_switch fixed bin,		/* 0 => give I/O interrupt wakeups realtime priotiry */
  5   233     2 realtime_io_deadline fixed bin (35),		/* Delta to clock for I/O realtime deadline */
  5   234     2 realtime_io_quantum fixed bin (35),		/* Quantum for I/O realtime burst */
  5   235     2 realtime_priorities fixed bin (35),		/* Count for metering */
  5   236     2 relinquishes fixed bin (35),			/* Calls to relinquish_priority */
  5   237     2 abort_ips_mask bit (36) aligned,			/* IPS mask for tc_util$check_abort */
  5   238 
  5   239 /* 500 octal */
  5   240 
  5   241     2 uid_array (0:15) bit (36) aligned,		/* array from which a uid is chosen (randomly) */
  5   242     2 pad5 (176) fixed bin (35),			/* room for expansion compatibly		*/
  5   243 
  5   244 /* 1000 octal */
  5   245 
  5   246     2 pad7 (64) fixed bin (35),
  5   247 
  5   248 /* 1100 octal */
  5   249 
  5   250     2 pad6 (8) fixed bin (35),
  5   251     2 work_class_table aligned,			/* array of per workclass information */
  5   252       3 wcte (0:16) aligned like wct_entry,
  5   253 
  5   254 /* 3000 octal */
  5   255 
  5   256     2 apt fixed bin;
  5   257 
  5   258 dcl  wctep ptr;
  5   259 
  5   260 dcl 1 wct_entry aligned based (wctep),			/* Work class entry */
  5   261     2 thread unaligned,				/* Ready list */
  5   262       3 fp bit (18),				/* Head of ready list */
  5   263       3 bp bit (18),				/* Tail of ready list */
  5   264     2 flags unaligned,
  5   265       3 mnbz bit (1),				/* Sentinel bit must not be zero. */
  5   266       3 defined bit (1),
  5   267       3 io_priority bit (1),
  5   268       3 governed bit (1),
  5   269       3 interactive_q bit (1),
  5   270       3 pad bit (31),
  5   271     2 credits fixed bin (35),				/* Current worthiness of group */
  5   272     2 minf fixed bin (35),				/* min fraction of cpu */
  5   273     2 pin_weight fixed bin (35),			/* number of cycles to pin pages */
  5   274     2 eligibilities fixed bin (35),			/* Count of eligibilities awarded */
  5   275     2 cpu_sum fixed bin (71),				/* CPU used by members */
  5   276     2 resp1 fixed bin (71),
  5   277     2 resp2 fixed bin (71),
  5   278     2 quantum1 fixed bin (35),
  5   279     2 quantum2 fixed bin (35),
  5   280     2 rmeter1 fixed bin (71),
  5   281     2 rmeter2 fixed bin (71),
  5   282     2 rcount1 fixed bin (35),
  5   283     2 rcount2 fixed bin (35),
  5   284     2 realtime fixed bin (35),
  5   285     2 purging fixed bin (35),
  5   286     2 maxel fixed bin (35),
  5   287     2 nel fixed bin (35),
  5   288     2 number_thinks fixed bin (35),			/* number times process entered "think" state	*/
  5   289     2 number_queues fixed bin (35),			/* number times process entered "queued" state	*/
  5   290     2 total_think_time fixed bin (71),
  5   291     2 total_queue_time fixed bin (71),
  5   292 
  5   293 /*  The next three arrays  correspond to the array vcpu_response_bounds				*/
  5   294 
  5   295     2 number_processing (VCPU_RESPONSE_BOUNDS+1) fixed bin (35), /* number times entered "processing" state	*/
  5   296     2 total_processing_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  5   297     2 total_vcpu_time (VCPU_RESPONSE_BOUNDS+1) fixed bin (71),
  5   298     2 maxf fixed bin (35),				/* maximum fraction of cpu time		*/
  5   299     2 governing_credits fixed bin (35),			/* for limiting cpu resources			*/
  5   300     2 pad1 (4) fixed bin (35);
  5   301 	
  5   302 
  5   303 dcl 1 based_sentinel aligned based,			/* format of pxss-style sentinel */
  5   304     2 fp bit (18) unal,
  5   305     2 bp bit (18) unal,
  5   306     2 sentinel bit (36) aligned;
  5   307 
  5   308 dcl VCPU_RESPONSE_BOUNDS fixed bin init (3) int static options (constant);
  5   309 
  5   310 /* END INCLUDE FILE tcm.incl.pl1 */
      338 
  6     1 /* Begin include file hc_lock.incl.pl1 BIM 2/82 */
  6     2 /* Replaced by hc_fast_lock.incl.pl1 RSC 11/84 because name of structure
  6     3*   encourages name conflicts.
  6     4*   USE HC_FAST_LOCK INSTEAD!
  6     5**/
  6     6 
  6     7 /* Lock format suitable for use with lock$lock_fast, unlock_fast */
  6     8 
  6     9 /* format: style3 */
  6    10 
  6    11 declare	lock_ptr		pointer;
  6    12 declare	1 lock		aligned based (lock_ptr),
  6    13 	  2 pid		bit (36) aligned,		/* holder of lock */
  6    14 	  2 event		bit (36) aligned,		/* event associated with lock */
  6    15 	  2 flags		aligned,
  6    16 	    3 notify_sw	bit (1) unaligned,
  6    17 	    3 pad		bit (35) unaligned;		/* certain locks use this pad, like dirs */
  6    18 
  6    19 /* End include file hc_lock.incl.pl1 */
      339 
      340 
      341      end amu_tc_data_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/13/85  0907.5  amu_tc_data_.pl1                  >special_ldd>online>6897>amu_tc_data_.pl1
334          1    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
335          2    11/20/84  0854.8  amu_hardcore_info.incl.pl1        >ldd>include>amu_hardcore_info.incl.pl1
336          3    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
337          4    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
338          5    01/30/85  1523.9  tcm.incl.pl1                      >ldd>include>tcm.incl.pl1
339          6    01/06/85  1422.1  hc_lock.incl.pl1                  >ldd>include>hc_lock.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
APT_BASE                        000100 automatic       fixed bin(17,0)          dcl 39 set ref 141* 142 142* 143 219
P_all_sw                               parameter       bit(1)                   unaligned dcl 48 ref 128 139
P_amu_info_ptr                         parameter       pointer                  dcl 43 set ref 6 81 89* 90 128 135 229 231* 232 249
                                                                                  251 265 267 276 278
P_aptep                                parameter       pointer                  dcl 45 set ref 229 238* 244*
P_code                                 parameter       fixed bin(35,0)          dcl 46 set ref 229 239* 245* 249 263* 276 283* 289*
P_dbr                                  parameter       fixed bin(24,0)          dcl 47 set ref 229 234 265 271* 272* 276 282* 288*
P_offset                               parameter       fixed bin(18,0)          dcl 44 ref 249 256 265 268
P_rdy_sw                               parameter       bit(1)                   unaligned dcl 50 ref 128 138
P_return_index                         parameter       fixed bin(17,0)          dcl 51 set ref 81 94 124*
P_return_ptr                           parameter       pointer                  dcl 49 ref 81 93
Pfirst                                 parameter       pointer                  dcl 297 ref 292 299
Plast                                  parameter       pointer                  dcl 297 ref 292 299
RUNNING                                constant        fixed bin(17,0)          initial dcl 72 ref 281
VCPU_RESPONSE_BOUNDS                   constant        fixed bin(17,0)          initial dcl 5-308 ref 190
WCTE_WORDS                      000101 automatic       fixed bin(17,0)          dcl 40 set ref 143* 209
addr                                                   builtin function         dcl 78 ref 147 162 178 190
addrel                                                 builtin function         dcl 78 ref 119 146 151 161 166 177 182 193 209 219
                                                                                  242 260 270 286 305
all_sw                          000112 automatic       bit(1)                   initial unaligned dcl 75 set ref 75* 139* 155 213
amu_$check_info_hard            000016 constant        entry                    external dcl 65 ref 89 231
amu_$print_apte                 000012 constant        entry                    external dcl 63 ref 257
amu_$print_apte_bf              000014 constant        entry                    external dcl 64 ref 150 165 181 222 224 304
amu_et_$entry_not_found         000022 external static fixed bin(35,0)          dcl 67 ref 263
amu_et_$proc_not_dumped         000020 external static fixed bin(35,0)          dcl 67 ref 289
amu_info                               based           structure                level 1 dcl 1-3
amu_info_ptr                    000130 automatic       pointer                  dcl 1-45 set ref 90* 102 119 135* 150* 165* 181*
                                                                                  222* 224* 232* 236 242 251* 255 257* 260 267* 278*
                                                                                  280 286 304* 312 313 315 320 321 323
apt                      24            based           structure                level 2 dcl 2-6
apt_entry_size          327            based           fixed bin(18,0)          level 2 dcl 5-11 ref 219
apt_offset              253            based           bit(18)                  level 3 packed unaligned dcl 5-11 ref 141 173 189
apt_size                313            based           fixed bin(18,0)          level 2 dcl 5-11 ref 218
apte                                   based           structure                level 1 dcl 3-7
apte_array                             based           structure                array level 1 unaligned dcl 57
apte_number                     000122 automatic       fixed bin(17,0)          dcl 131 set ref 218* 219*
apte_offset                            parameter       fixed bin(18,0)          dcl 86 ref 81 97 107
apte_sw                         000117 automatic       bit(1)                   unaligned dcl 87 set ref 92* 97* 106
aptep                           000132 automatic       pointer                  dcl 3-5 set ref 100 104 110 114 119* 119 120 146*
                                                                                  147 149 150* 151* 151 161* 162 164 165* 166* 166
                                                                                  177* 178 180 181* 182* 182 219* 220 222 222 222*
                                                                                  224 224* 235 237 238 242* 242 254 257* 260* 260
                                                                                  261 270* 271 272 281 282 286* 286 299* 299* 303
                                                                                  304* 305 315* 323* 329*
arg_idx                                parameter       fixed bin(17,0)          dcl 84 ref 81 96 104
arg_sw                          000116 automatic       bit(1)                   unaligned dcl 87 set ref 92* 96* 103
argument                               parameter       char(3)                  unaligned dcl 73 ref 6
based_sentinel                         based           structure                level 1 dcl 5-303
binary                                                 builtin function         dcl 78 ref 219 237 272 281 282
count                    26            based           fixed bin(17,0)          level 3 dcl 2-6 ref 102 236 255 280
credits                   2            based           fixed bin(35,0)          level 2 dcl 5-260 ref 204 204
dbr                      44            based           fixed bin(71,0)          level 2 dcl 3-7 ref 237 272 282
dbr_search                      000103 automatic       fixed bin(24,0)          dcl 52 set ref 234* 237
deadline_mode           420            based           fixed bin(35,0)          level 2 dcl 5-11 ref 174 197
defined                   1(01)        based           bit(1)                   level 3 packed unaligned dcl 5-260 ref 197
divide                                                 builtin function         dcl 78 ref 143 204 204
eligible_q_head         350            based           structure                level 2 dcl 5-11
first_aptep                     000124 automatic       pointer                  dcl 133 set ref 193* 197 204 206*
fixed                                                  builtin function         dcl 78 ref 100 100 104 120 120 141 143 149 149 164
                                                                                  164 180 180 220 220 235 235 254 254 261 261 303
                                                                                  303
flags                     1            based           structure                level 2 in structure "wct_entry" packed unaligned
                                                                                  dcl 5-260 in procedure "amu_tc_data_"
flags                     1            based           structure                level 2 in structure "apte" packed unaligned dcl 3-7
                                                                                  in procedure "amu_tc_data_"
foreign_ptr              24            based           pointer                  level 3 packed unaligned dcl 2-6 ref 315
fp                                     based           bit(18)                  level 3 in structure "apte" packed unaligned dcl 3-7
                                                                                  in procedure "amu_tc_data_" ref 151 166 182 305
fp                                     based           bit(18)                  level 3 in structure "wct_entry" packed unaligned
                                                                                  dcl 5-260 in procedure "amu_tc_data_" ref 193
fp                      314            based           bit(18)                  level 3 in structure "tcm" packed unaligned dcl 5-11
                                                                                  in procedure "amu_tc_data_" set ref 161
fp                      350            based           bit(18)                  level 3 in structure "tcm" packed unaligned dcl 5-11
                                                                                  in procedure "amu_tc_data_" ref 146
fp                      330            based           bit(18)                  level 3 in structure "tcm" packed unaligned dcl 5-11
                                                                                  in procedure "amu_tc_data_" set ref 177
fptr                     10            based           pointer                  level 4 packed unaligned dcl 2-6 ref 312 313
hardcore_info                          based           structure                level 1 dcl 2-6
hardcore_info_ptr        16            based           pointer                  level 2 dcl 1-3 ref 102 119 236 242 255 260 280 286
                                                                                  312 313 315 320 321 323
i                               000104 automatic       fixed bin(17,0)          dcl 53 set ref 102* 116* 236* 255* 257* 280*
idle                      1(07)        based           bit(1)                   level 3 packed unaligned dcl 3-7 ref 224
index                     3            based           fixed bin(17,0)          array level 2 dcl 57 set ref 116*
interactive_q           330            based           structure                level 2 dcl 5-11 set ref 178
ioa_                            000010 constant        entry                    external dcl 62 ref 145 160 174 176 204 217
local_ptr                25            based           pointer                  level 3 packed unaligned dcl 2-6 ref 323
lock                                   based           structure                level 1 dcl 6-12
lptr                     11            based           pointer                  level 4 packed unaligned dcl 2-6 ref 320 321
min_wct_index           404            based           bit(18)                  level 2 dcl 5-11 ref 143
null                                                   builtin function         dcl 78 ref 244 312 320 328 329
off                       2            based           fixed bin(18,0)          array level 2 dcl 57 set ref 115*
offset                          000102 automatic       fixed bin(18,0)          dcl 42 set ref 100* 107 115 120* 149* 150* 164* 165*
                                                                                  180* 181* 220* 222* 224* 235* 254* 256 257* 261*
                                                                                  268* 270 303* 304*
pid_sw                          000120 automatic       bit(1)                   unaligned dcl 87 set ref 92* 98* 109
pointer                                                builtin function         dcl 78 ref 219
pointers                               based           structure                level 2 dcl 2-6
print_this_wc                   000126 automatic       bit(1)                   unaligned dcl 134 set ref 194* 197* 203
process_id                             parameter       bit(36)                  unaligned dcl 85 ref 81 98 110
processid                 3            based           bit(36)                  level 2 dcl 3-7 ref 110
ptr                                    based           pointer                  array level 2 dcl 57 set ref 114*
rdy_sw                          000105 automatic       bit(1)                   unaligned dcl 54 set ref 138* 155
ready_q_tail            352            based           bit                      level 2 dcl 5-11 set ref 147
realtime                 24            based           fixed bin(35,0)          level 2 dcl 5-260 ref 197
realtime_q              314            based           structure                level 2 dcl 5-11 set ref 162
rel                                                    builtin function         dcl 78 ref 100 100 120 120 149 149 164 164 180 180
                                                                                  219 220 220 235 235 254 254 261 261 303 303
return_index                    000106 automatic       fixed bin(17,0)          dcl 55 set ref 94* 113* 113 114 115 116 124
return_ptr                      000110 automatic       pointer                  dcl 56 set ref 93* 114 115 116
sdw                                    based           structure                level 1 dcl 4-5
sentinel                315            based           bit(36)                  level 3 dcl 5-11 set ref 159
size                     27            based           fixed bin(17,0)          level 3 dcl 2-6 ref 119 242 260 286
slt                                    based           structure                level 3 dcl 2-6
special_offsets         253            based           structure                level 2 packed unaligned dcl 5-11
state                     1(18)        based           bit(18)                  level 3 packed unaligned dcl 3-7 ref 104 222 271 281
substr                                                 builtin function         dcl 78 ref 237 272 282
tc_data                  10            based           structure                level 3 dcl 2-6
tc_datap                        000114 automatic       pointer                  dcl 76 set ref 100 120 137 235 254 261 270 313* 321*
                                                                                  328*
tcm                                    based           structure                level 1 dcl 5-11
tcmp                            000134 automatic       pointer                  dcl 5-9 set ref 137* 141 143 146 146 147 149 151 159
                                                                                  161 161 162 164 166 173 174 177 177 178 180 182
                                                                                  189 190 193 197 218 219 219 219 220 303 305
thread                                 based           structure                level 2 in structure "apte" packed unaligned dcl 3-7
                                                                                  in procedure "amu_tc_data_" ref 222
thread                                 based           structure                level 2 in structure "wct_entry" packed unaligned
                                                                                  dcl 5-260 in procedure "amu_tc_data_"
unspec                                                 builtin function         dcl 78 ref 222 237 272 282
want_it                         000121 automatic       bit(1)                   unaligned dcl 87 set ref 92* 104* 107* 110* 112 117*
wc_number                       000123 automatic       fixed bin(17,0)          dcl 132 set ref 191* 204*
wct_entry                              based           structure                level 1 dcl 5-260
wcte                                   based           structure                array level 3 dcl 5-11 set ref 190
wctep                           000136 automatic       pointer                  dcl 5-258 set ref 190* 193 197 197 197 204 204 204
                                                                                  206* 209* 209
work_class_table                       based           structure                level 2 dcl 5-11

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_INFO_VERSION                       internal static char(8)                  initial unaligned dcl 1-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial unaligned dcl 1-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial unaligned dcl 1-58
FDUMP_PROCESS_TYPE                     internal static fixed bin(17,0)          initial dcl 1-47
FDUMP_TYPE                             internal static fixed bin(17,0)          initial dcl 1-47
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 1-47
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 1-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 1-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 1-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 1-47
PDIR_SUFFIX                            internal static char(4)                  initial unaligned dcl 1-60
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 1-47
amu_area                               based           area(1024)               dcl 1-43
code                                   automatic       fixed bin(35,0)          dcl 41
hardcore_cur                           based           structure                level 1 unaligned dcl 2-40
hardcore_cur_ptr                       automatic       pointer                  dcl 2-38
lock_ptr                               automatic       pointer                  dcl 6-11
sdwa                                   based           structure                array level 1 dcl 4-24
sdwp                                   automatic       pointer                  dcl 4-3

NAMES DECLARED BY EXPLICIT CONTEXT.
amu_tc_data_                    000101 constant        entry                    external dcl 6
amu_tc_data_$find_apte          001131 constant        entry                    external dcl 229
amu_tc_data_$find_first_running 001412 constant        entry                    external dcl 276
amu_tc_data_$get_apt_entry      000116 constant        entry                    external dcl 81
amu_tc_data_$get_dbr            001350 constant        entry                    external dcl 265
amu_tc_data_$print_this_apte    001240 constant        entry                    external dcl 249
amu_tc_data_$tcq                000321 constant        entry                    external dcl 128
dead_apt_loop                   000504 constant        label                    dcl 162 ref 167
elig_apt_loop                   000413 constant        label                    dcl 147 ref 152
int_apt_loop                    000614 constant        label                    dcl 178 ref 183
print_queue                     001475 constant        entry                    internal dcl 292 ref 206
set_tcp_aptp                    001540 constant        entry                    internal dcl 309 ref 91 136 233 252 269 279

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2040        2064    1600        2050
Length      2400    1600        24         277     237           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amu_tc_data_                        184 external procedure  is an external procedure.  
print_queue                             internal procedure  shares stack frame of external procedure amu_tc_data_.  
set_tcp_aptp                            internal procedure  shares stack frame of external procedure amu_tc_data_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
amu_tc_data_             000100 APT_BASE                    amu_tc_data_
                         000101 WCTE_WORDS                  amu_tc_data_
                         000102 offset                      amu_tc_data_
                         000103 dbr_search                  amu_tc_data_
                         000104 i                           amu_tc_data_
                         000105 rdy_sw                      amu_tc_data_
                         000106 return_index                amu_tc_data_
                         000110 return_ptr                  amu_tc_data_
                         000112 all_sw                      amu_tc_data_
                         000114 tc_datap                    amu_tc_data_
                         000116 arg_sw                      amu_tc_data_
                         000117 apte_sw                     amu_tc_data_
                         000120 pid_sw                      amu_tc_data_
                         000121 want_it                     amu_tc_data_
                         000122 apte_number                 amu_tc_data_
                         000123 wc_number                   amu_tc_data_
                         000124 first_aptep                 amu_tc_data_
                         000126 print_this_wc               amu_tc_data_
                         000130 amu_info_ptr                amu_tc_data_
                         000132 aptep                       amu_tc_data_
                         000134 tcmp                        amu_tc_data_
                         000136 wctep                       amu_tc_data_

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_out_desc   call_ext_out        return              ext_entry           divide_fx3

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$check_info_hard          amu_$print_apte               amu_$print_apte_bf            ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$entry_not_found       amu_et_$proc_not_dumped




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     75 000072         6 000075         8 000107        81 000110        89 000124        90 000134        91 000140
     92 000141        93 000145        94 000151        96 000153        97 000160        98 000165       100 000175
    102 000204       103 000215       104 000217       105 000227       106 000230       107 000232       108 000240
    109 000241       110 000243       112 000254       113 000256       114 000257       115 000264       116 000267
    117 000271       119 000272       120 000300       121 000307       124 000311       125 000314       128 000315
    135 000327       136 000333       137 000334       138 000336       139 000344       141 000351       142 000355
    143 000361       145 000371       146 000405       147 000413       149 000422       150 000431       151 000444
    152 000451       155 000452       159 000456       160 000461       161 000476       162 000504       164 000513
    165 000522       166 000535       167 000542       173 000543       174 000547       176 000567       177 000606
    178 000614       180 000623       181 000632       182 000645       183 000652       189 000653       190 000657
    191 000703       193 000707       194 000714       197 000715       203 000734       204 000736       206 000776
    209 001000       210 001004       213 001006       217 001010       218 001025       219 001035       220 001052
    222 001061       224 001103       225 001121       227 001123       229 001124       231 001144       232 001154
    233 001160       234 001161       235 001163       236 001172       237 001203       238 001213       239 001215
    240 001216       242 001217       243 001224       244 001226       245 001231       246 001233       249 001234
    251 001251       252 001255       254 001256       255 001265       256 001277       257 001303       258 001320
    260 001321       261 001327       262 001336       263 001340       264 001343       265 001344       267 001361
    268 001365       269 001367       270 001370       271 001374       272 001402       273 001405       276 001406
    278 001425       279 001431       280 001432       281 001443       282 001453       283 001456       284 001457
    286 001460       287 001465       288 001467       289 001471       290 001474       292 001475       299 001477
    303 001507       304 001516       305 001531       307 001537       309 001540       312 001541       313 001546
    315 001550       316 001552       320 001553       321 001556       323 001560       324 001562       328 001563
    329 001565       330 001566


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
