	COMPILATION LISTING OF SEGMENT copy_disk_io_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/16/87  1329.7 mst Thu
	    Options: optimize map

        1 /****^  ********************************************
        2*        *                                          *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987 *
        4*        *                                          *
        5*        ******************************************** */
        6 
        7 
        8 /****^  HISTORY COMMENTS:
        9*  1) change(87-03-31,Blair), approve(87-03-31,MCR7666),
       10*     audit(87-06-25,Fawcett), install(87-07-15,MR12.1-1040):
       11*     Install as part of bound_copy_disk_.  Error processing rewritten to
       12*     do retries a page at a time and exit on write errors.  Changed P_io_error
       13*     to be a flag to indicate whether or not we're supposed to retry failed
       14*     reads.  We won't when we're trying to read the label or vol_map or if the
       15*     user specifies error_threshold of 0.
       16*     
       17*     Basically, the way this works is as follows:
       18*               If something goes wrong while we're processing a block, we'll get a
       19*     sub-err condition from rdisk_.  If we're writing, or retries are not
       20*     allowed, we call condition_info_ to get the error and report it before
       21*     returning.  Otherwise, we start processing the block, reading and writing
       22*     one record at a time.  If the error persists, we'll reach the condition
       23*     where first_record and last_record are the same and we call io_error to
       24*     report the bad record, returning to the loop where we're going through the
       25*     block one record at a time.  After all the records have been processed, we
       26*     set the block size to zero, so that when we return to our caller, we will
       27*     have nothing to write and we can resynchronize our double buffering.  If
       28*     we reach the error_threshold and the user wants to abort, we'll return a
       29*     non-zero error_code to our caller, forcing a return, but normally, after
       30*     a bad read, we zero the error code after reporting the error, allowing us
       31*     to continue.
       32*                                                   END HISTORY COMMENTS */
       33 copy_disk_io_:
       34      procedure ();
       35 
       36 /* This is the procedure which actually does I/O for the disks. It is
       37*   responsible for error handling and doing retries. When a disk error 
       38*   occurs on an I/O, it splits the I/O in two pieces (making the break
       39*   at a record boundary) and calls itself to retry the I/O recursively.
       40*   If an error occurs on an I/O that is entirely within the bounds of 
       41*   a single record, it gives up, damages the record, and returns. An
       42*   I/O error is indicated by the P_io_error bit being set, rather than
       43*   by the value of P_code.  Any non-zero error code means a fatal error
       44*   which should abort the copy; if a non-zero code is returned, a message
       45*   has already been printed.
       46*   */
       47 
       48 dcl  P_info_ptr pointer parameter;
       49 dcl  P_buffer_ptr pointer parameter;
       50 dcl  P_sector fixed bin (35) parameter;
       51 dcl  P_n_sectors fixed bin parameter;
       52 dcl  P_record fixed bin (18) parameter;
       53 dcl  P_brief_sw bit (1) aligned parameter;
       54 dcl  P_query_sw bit (1) aligned parameter;
       55 dcl  P_cv_record fixed bin (18);
       56 dcl  P_cv_sector fixed bin (35);
       57 dcl  P_retry_sw bit (1) aligned;
       58 dcl  P_code fixed bin (35) parameter;
       59 
       60 dcl 1 P_info aligned like copy_disk_info based (P_info_ptr);
       61 
       62 dcl  answer char (32) varying;
       63 dcl  operation fixed bin;
       64 dcl  source_info_ptr ptr;
       65 dcl  target_info_ptr ptr;
       66 dcl  error_table_$device_parity fixed bin (35) external static;
       67 dcl  error_table_$item_too_big fixed bin(35) ext static;
       68 
       69 dcl  command_query_ entry() options(variable);
       70 dcl  com_err_ entry options (variable);
       71 
       72 dcl  (cleanup, sub_error_) condition;
       73 
       74 dcl (addr, divide, mod, null, substr, unspec) builtin;
       75 
       76 /*  */
       77 
       78 copy_disk_io_$read:
       79      entry (P_info_ptr, P_brief_sw, P_query_sw,
       80             P_buffer_ptr, P_sector, P_n_sectors, P_retry_sw, P_code);
       81 
       82 	source_info_ptr = P_info_ptr;
       83 	operation = READ;
       84 	call sector_io (operation, (P_sector), (P_n_sectors));
       85 	return;
       86 
       87 
       88 
       89 copy_disk_io_$write:
       90      entry (P_info_ptr, P_brief_sw, P_query_sw,
       91             P_buffer_ptr, P_sector, P_n_sectors, P_retry_sw, P_code);
       92 
       93 	target_info_ptr = P_info_ptr;
       94 	operation = WRITE;
       95 	call sector_io (operation, (P_sector), (P_n_sectors));
       96 	return;
       97 
       98 
       99 
      100 copy_disk_io_$read_record:
      101      entry (P_info_ptr, P_brief_sw, P_query_sw,
      102             P_buffer_ptr, P_record, P_retry_sw, P_code);
      103 
      104 	call sector_io (READ, r_to_s (P_record), P_info.sectors_per_record);
      105 	return;
      106 
      107 
      108 
      109 copy_disk_io_$write_record:
      110      entry (P_info_ptr, P_brief_sw, P_query_sw,
      111             P_buffer_ptr, P_record, P_retry_sw, P_code);
      112 
      113 	call sector_io (WRITE, r_to_s (P_record), P_info.sectors_per_record);
      114 	return;
      115 
      116 
      117 
      118 copy_disk_io_$sector_to_record:
      119      entry (P_info_ptr, P_cv_sector) returns (fixed bin (18));
      120 
      121 	return (s_to_r (P_cv_sector));
      122 
      123 
      124 
      125 copy_disk_io_$record_to_sector:
      126      entry (P_info_ptr, P_cv_record) returns (fixed bin (35));
      127 
      128 	return (r_to_s (P_cv_record));
      129 
      130 /*  */
      131 
      132 sector_io:
      133      procedure (P_operation, P_first_sector, P_n_sectors);
      134 
      135 dcl  P_operation fixed bin;
      136 dcl  P_first_sector fixed bin (35);
      137 dcl  P_n_sectors fixed bin;
      138 
      139 dcl  buffer_ptr pointer;
      140 dcl  buffer (buffer_size) bit (36) aligned based (buffer_ptr);
      141 dcl  buffer_size fixed bin (18);
      142 dcl  io_length fixed bin (21);
      143 
      144 
      145 	buffer_ptr = P_buffer_ptr;
      146 	buffer_size = P_n_sectors * P_info.words_per_sector;
      147 	io_length = P_n_sectors * P_info.chars_per_sector;
      148 	P_code = 0;				/* assume success */
      149 
      150 	call iox_$position (P_info.iocb, POSITION_ABSOLUTE, (P_sector), P_code);
      151 	if (P_code ^= 0) then do;
      152 	     call com_err_ (P_code, WHOAMI, 
      153 		"Cannot position to sector ^d. on ^a",
      154 		P_sector, P_info.device);
      155 	     return;
      156 	     end;
      157 
      158 /* Establish handlers so we can get control when rdisk_ reports an error. */
      159 	on condition (cleanup) call cleanup_stack;  /* this will get rid of unwanted stack frames */
      160 
      161 	on condition (sub_error_) begin;
      162 	     call suberr_handler;
      163 	     goto HANDLE_IO_ERROR;  /* the non_local goto allows us to cleanup the stack */
      164 	     end;
      165 
      166 	if (P_operation = READ) then
      167 	     call iox_$read_record (P_info.iocb, buffer_ptr, io_length, (0), P_code);
      168 	else call iox_$rewrite_record (P_info.iocb, buffer_ptr, io_length, P_code);
      169 
      170 	revert condition (sub_error_);
      171 
      172 	if (P_code = error_table_$item_too_big) then return;
      173 	
      174 	if (P_code ^= 0) then do;			/* not an I/O error, probably a program bug */
      175 	     call com_err_ (P_code, WHOAMI, 
      176 		"Unrecoverable error ^[reading^;writing^] disk ^a.",
      177 		(P_operation = READ), P_info.device);
      178 	     return;
      179 	     end;
      180 
      181 	P_code = 0;				/* all went well */
      182 	return;
      183 
      184 
      185 
      186 HANDLE_IO_ERROR:
      187 	if (P_operation = READ & P_retry_sw) then call retry_io ();
      188 	return;
      189 
      190 /*  */
      191 
      192 retry_io:						/* internal to sector_io */
      193      procedure ();
      194 
      195 dcl  first_record fixed bin (18);
      196 dcl  last_record fixed bin (18);
      197 dcl  record_idx fixed bin (18);
      198      
      199 /* We'll only ever get here on a READ since we just return for a bad WRITE */
      200 	first_record = s_to_r (P_sector);
      201 	last_record = s_to_r (P_sector + P_n_sectors - 1);
      202 
      203 	if first_record = last_record then do; /* this is the case during single record I/O */
      204 	     call report_io_error;
      205 	     if (P_code ^= 0) then return; /* Error threshold reached and no continue */
      206 	     return;
      207 	     end;
      208 	else do record_idx = first_record to last_record by 1;
      209 	     unspec (buffer) = ""b;
      210 
      211 	     call copy_disk_io_$read (source_info_ptr, P_brief_sw, P_query_sw,
      212 	          P_buffer_ptr,  r_to_s (record_idx), sect_per_rec (P_info.device_type), P_retry_sw, P_code);
      213 /* switch info_ptr to the target disk */
      214 
      215 	     call copy_disk_io_$write (source_info_ptr -> P_info.target_info_ptr, P_brief_sw, P_query_sw,
      216 		P_buffer_ptr, r_to_s (record_idx), sect_per_rec (P_info.device_type), P_retry_sw, P_code);
      217 
      218 	     if (P_code ^= 0) then return; 
      219 	     end;			/*  no more records this I/O block */
      220 /* Here we've finished with a whole buffer, and we need to do another synchronous I/O
      221*   to get back on track.  The way to cause this is to force the write buffer to zero. */
      222 	P_n_sectors = 0;
      223 
      224 	return;
      225 	end retry_io;
      226 
      227 	end sector_io;
      228 
      229 /*  */
      230 
      231 report_io_error:
      232      procedure ();
      233 
      234 /* Report the bad sector and then check to see if we've reached the error_threshold. */
      235 
      236           call com_err_ (error_table_$device_parity, WHOAMI, 
      237 	     "Unrecoverable error reading ^a at sector ^d.", P_info.device, P_sector);
      238 	P_code = 0;      /* Once we report it, we'll set ourselves up to continue. */
      239 	P_info.errors = P_info.errors + 1;
      240 	if (P_info.errors = P_info.threshold) then
      241 	     if ^P_query_sw then do;
      242 		call com_err_ (0, WHOAMI,
      243 		     "More than ^d I/O errors on ^a. Copying aborted.",
      244 		     P_info.threshold, P_info.device);
      245 
      246 		P_code = error_table_$item_too_big;
      247 		return;
      248 		end;
      249 	     else do;
      250 		call command_query_ (addr(query_info), answer, WHOAMI, "Error_threshold of ^d errors reached. ^/Do you wish to continue?", P_info.threshold);
      251 		if (answer = "yes" |  answer = "y" | answer = "Y" | answer = "YES") then do;
      252 		     P_info.errors = 0;
      253 		     return;
      254 		     end;
      255 		else do;
      256 		     call com_err_  (0, WHOAMI,
      257 			"More than ^d I/O errors on ^a. Copying aborted.",
      258 			P_info.threshold, P_info.device);
      259 
      260 		     P_code = error_table_$item_too_big;
      261 		     return;
      262 		     end;
      263 		end;
      264 	else return;
      265 	end report_io_error;
      266 
      267 
      268 cleanup_stack:
      269      proc ();
      270      return;
      271      end cleanup_stack;
      272 
      273 suberr_handler:
      274      proc();
      275      
      276 dcl  1 local_condition_info like condition_info;
      277 dcl  continue_to_signal_ entry (fixed bin(35));
      278 dcl  find_condition_info_ entry (ptr, ptr, fixed bin(35));
      279 dcl  ioa_ entry() options(variable);
      280 
      281 
      282 	condition_info_ptr = addr (local_condition_info);
      283 	condition_info.version = condition_info_version_1;
      284 	call find_condition_info_ (null (), condition_info_ptr, P_code);
      285 	if P_code ^= 0
      286 	     then do;
      287 	     call com_err_ (P_code, WHOAMI, "Unrecoverable error writing disk ^a.", P_info.device);
      288 	     return;
      289 	     end;
      290 
      291 	sub_error_info_ptr = condition_info.info_ptr;
      292 	if substr (sub_error_info.name, 1, 5) ^= "rdisk_"
      293 	     then do;
      294 	     call continue_to_signal_ (P_code);
      295 	     return;
      296 	     end;
      297 	
      298 	if operation = WRITE
      299 	     then call ioa_ ("^a", sub_error_info.header.info_string);
      300 	P_code = sub_error_info.retval;
      301 	return;
      302 	end suberr_handler;
      303 
      304 r_to_s:
      305      procedure (P_rec) returns (fixed bin (35));
      306 
      307 dcl  P_rec fixed bin (18) parameter;
      308 dcl  P_sec fixed bin (35) parameter;
      309 
      310 dcl  cylinder fixed bin;
      311 dcl  record_in_cylinder fixed bin;
      312 dcl  record fixed bin (18);
      313 dcl  sector fixed bin (35);
      314 dcl  sector_in_cylinder fixed bin;
      315 
      316 
      317 	cylinder = divide (P_rec, P_info.records_per_cylinder, 17, 0);
      318 	record_in_cylinder = mod (P_rec, P_info.records_per_cylinder);
      319 	sector = cylinder * P_info.sectors_per_cylinder;
      320 	sector = sector + record_in_cylinder * P_info.sectors_per_record;
      321 
      322 	return (sector);
      323 
      324 
      325 s_to_r:
      326      entry (P_sec) returns (fixed bin (18));
      327 
      328 	cylinder = divide (P_sec, P_info.sectors_per_cylinder, 17, 0);
      329 	sector_in_cylinder = mod (P_sec, P_info.sectors_per_cylinder);
      330 	record_in_cylinder = divide (sector_in_cylinder, P_info.sectors_per_record, 17, 0);
      331 	if (record_in_cylinder >= P_info.records_per_cylinder) then
      332 	     record_in_cylinder = P_info.records_per_cylinder - 1;
      333 	record = cylinder * P_info.records_per_cylinder;
      334 	record = record + record_in_cylinder;
      335 
      336 	return (record);
      337 	end r_to_s;
      338 
      339  /* BEGIN INCLUDE FILE ... copy_disk_info.incl.pl1 ... 83-04-25 ... W. Olin Sibert */
  1     2 
  1     3 
  1     4 /****^  HISTORY COMMENTS:
  1     5*  1) change(87-03-31,Blair), approve(87-03-31,MCR7666),
  1     6*     audit(87-07-08,Fawcett), install(87-07-15,MR12.1-1040):
  1     7*     Install as part of the copy_disk command.  This is the info structure used
  1     8*     to pass around information about the source and target disks.
  1     9*  2) change(87-07-08,Blair), approve(87-07-08,MCR7731),
  1    10*     audit(87-07-08,Fawcett), install(87-07-15,MR12.1-1040):
  1    11*     Change the copy_disk command to copy_disk_volume.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 dcl 1 copy_disk_info aligned based,
  1    15     2 device char (32) unaligned,
  1    16     2 device_type fixed bin,
  1    17     2 mode fixed bin,
  1    18     2 attached bit (1) aligned,
  1    19     2 opened bit (1) aligned,
  1    20     2 iocb_name char (32) unaligned,
  1    21     2 iocb pointer,
  1    22     2 target_info_ptr pointer,
  1    23     2 bounds, 
  1    24       3 low_bound fixed bin (35),
  1    25       3 high_bound fixed bin (35),
  1    26     2 disk_parameters,
  1    27       3 words_per_sector fixed bin,
  1    28       3 chars_per_sector fixed bin,
  1    29       3 sectors_per_cylinder fixed bin,
  1    30       3 sectors_per_record fixed bin,
  1    31       3 records_per_cylinder fixed bin,
  1    32       3 sectors_per_io fixed bin,
  1    33       3 n_records fixed bin (18),
  1    34       3 n_vtoces fixed bin,
  1    35     2 errors fixed bin,
  1    36     2 threshold fixed bin,
  1    37     2 trace_parm fixed bin,
  1    38     2 trace_count fixed bin,
  1    39     2 desc char (200) varying;
  1    40     	
  1    41 dcl  WHOAMI char (32) internal static options (constant) init ("copy_disk_volume");
  1    42 
  1    43 dcl  READ fixed bin internal static options (constant) init (1);
  1    44 dcl  WRITE fixed bin internal static options (constant) init (2);
  1    45 
  1    46 dcl  POSITION_BEGINNING fixed bin internal static options (constant) init (-1);
  1    47 dcl  POSITION_RELATIVE fixed bin internal static options (constant) init (0);
  1    48 dcl  POSITION_ABSOLUTE fixed bin internal static options (constant) init (2);
  1    49 
  1    50 /* END INCLUDE FILE ... copy_disk_info.incl.pl1 */
      339 
      340  /* Begin fs_dev_types_sector.incl.pl1 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(86-04-21,Fawcett), approve(86-04-21,MCR7383),
  2     6*     audit(86-05-12,Coppola), install(86-07-18,MR12.0-1098):
  2     7*     Add the sector differance for devices that do 64 word IO and devices that
  2     8*     do 512 word IO.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 /* Created by R. A. Fawcett for 512 word IO. for procedures that do not
  2    12*	 need all the data in fs_dev_types. This is also included in
  2    13*	 fs_dev_types.incl.pl1  */
  2    14 
  2    15 dcl  sect_per_cyl (9) fixed bin static options (constant) init /* table of # of sectors per cylinder on each device */
  2    16     (0, 760, 760, 760, 589, 360, 1280, 255, 255);
  2    17 
  2    18 dcl  sect_per_sv (9) fixed bin (24) static options (constant) init /* table of # of sectors per cylinder on each subvolume */
  2    19      (0, 0, 0, 0, 0, 0, 0, 112710, 150450);
  2    20 
  2    21 dcl  sect_per_rec (9) fixed bin static options (constant) init
  2    22  /* table of # of sectors per record on each device */
  2    23  /* coresponding array in disk_pack.incl.pl1 called SECTORS_PER_RECORD */
  2    24     (0, 16, 16, 16, 16, 16, 16, 2, 2);
  2    25 
  2    26 dcl  sect_per_vtoc (9) fixed bin static options (constant) init
  2    27      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  2    28 	
  2    29 dcl  vtoc_per_rec (9) fixed bin  static options  (constant) init
  2    30 /* corespending array in disk_pack.incl.pl1 named VTOCES_PER_RECORD */
  2    31      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  2    32 
  2    33 dcl  sect_per_track (9) fixed bin static options (constant) init /* table of # of sectors per track on each device */
  2    34     (0, 40, 40, 40, 31, 18, 64, 17, 17);
  2    35 
  2    36 dcl  words_per_sect (9) fixed bin static options (constant) init /* table of # of words per sector on each device */
  2    37     (0, 64, 64, 64, 64, 64, 64, 512, 512);
  2    38 
  2    39 /* End fs_dev_types_sector.incl.pl1 */
  2    40 
      340 
      341  /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  3     2 
  3     3 /* Written 05/04/78 by C. D. Tavares */
  3     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  3     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  3     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  3     7 
  3     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  3     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  3    10      iox_$close entry (pointer, fixed bin (35)),
  3    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  3    12      iox_$delete_record entry (pointer, fixed bin (35)),
  3    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  3    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  3    15      iox_$err_not_attached entry options (variable),
  3    16      iox_$err_not_closed entry options (variable),
  3    17      iox_$err_no_operation entry options (variable),
  3    18      iox_$err_not_open entry options (variable),
  3    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  3    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  3    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  3    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  3    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  3    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  3    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  3    28      iox_$propagate entry (pointer),
  3    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  3    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  3    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  3    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  3    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  3    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  3    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  3    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  3    40 
  3    41 dcl (iox_$user_output,
  3    42      iox_$user_input,
  3    43      iox_$user_io,
  3    44      iox_$error_output) external static pointer;
  3    45 
  3    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
      341 
      342  /*	BEGIN INCLUDE FILE...disk_pack.incl.pl1          Last Modified January 1982 for new volume map   */
  4     2 
  4     3 
  4     4 
  4     5 
  4     6 /****^  HISTORY COMMENTS:
  4     7*  1) change(86-01-14,Fawcett), approve(86-05-13,MCR7383),
  4     8*     audit(86-05-14,LJAdams), install(86-07-18,MR12.0-1098):
  4     9*     Add vars PAGE_SIZE and VTOCE_SIZE, Also change the SECTORS_PER_VTOCE and
  4    10*     VTOCES_PER_RECORD form fixed bin constants to arrays of fixed bin
  4    11*     constants indexed by device type as defined in fs_dev_types.incl.pl1.
  4    12*     This was done for support of the 3380, and 3390 devices for 512_WORD_IO.
  4    13*  2) change(86-10-21,Fawcett), approve(86-10-21,MCR7533),
  4    14*     audit(86-10-21,Farley), install(86-10-22,MR12.0-1193):
  4    15*     Change PAGE_SIZE and VTOCE_SIZE from automatic to static constants.
  4    16*                                                   END HISTORY COMMENTS */
  4    17 
  4    18 
  4    19 /*
  4    20*   All disk packs have the standard layout described below:
  4    21*
  4    22*   Record  0		: contains the label, as declared in fs_vol_label.incl.pl1.
  4    23*   Record  1 to 3		: contains the volume map, as declared in vol_map.incl.pl1
  4    24*   Record  4 to 5		: contains the dumper bit map, as declared in dumper_bit_map.incl.pl1
  4    25*   Record  6		: contains the vtoc map, as declared in vtoc_map.incl.pl1 
  4    26*   Record  7		: formerly contained bad track list; no longer used.
  4    27*   Records 8 to n-1		: contain the array of vtoc entries; ( n is specified in the label)
  4    28*   each record contains 5 192-word vtoc entries. The last 64 words are unused.
  4    29*   Records n to N-1		: contain the pages of the Multics segments. ( N is specified in the label)
  4    30*
  4    31*   Sundry partitions may exist within the region n to N-1, withdrawn or not as befits the meaning
  4    32*   of the particular partition.
  4    33*
  4    34*
  4    35*
  4    36*   A conceptual declaration for a disk pack could be:
  4    37*
  4    38*   dcl 1 disk_pack,
  4    39*   2 label_record		(0 : 0)		bit(36 * 1024),
  4    40*   2 volume_map_record	(1 : 3)		bit(36 * 1024),
  4    41*   2 dumper_bit_map_record	(4 : 5)		bit(36 * 1024),
  4    42*   2 vtoc_map_record	(6 : 6)		bit(36 * 1024),
  4    43*   2 spare_record	          (7 : 7)		bit(36 * 1024),
  4    44*   2 vtoc_array_records	(8 : n-1),
  4    45*   3 vtoc_entry ( 5 )			bit(36 * 192),
  4    46*   3 unused				bit(36 * 64),
  4    47*   2 Multics_pages_records	(n : N-1)		bit(36 * 1024);
  4    48*
  4    49*
  4    50*
  4    51*
  4    52**/
  4    53 
  4    54 dcl (LABEL_ADDR              init (0),			/* Address of Volume Label */
  4    55      VOLMAP_ADDR	         init (1),			/* Address of first Volume Map record */
  4    56      DUMPER_BIT_MAP_ADDR     init (4),			/* For initial release compaitiblity */
  4    57      VTOC_MAP_ADDR	         init (6),			/* Address of first VTOC Map Record */
  4    58      VTOC_ORIGIN	         init (8),			/* Address of first record of VTOC */
  4    59      DEFAULT_HCPART_SIZE     init (1000),		/* Size of Hardcore Partition */
  4    60      MAX_VTOCE_PER_PACK      init (31774))		/* Limited by size of VTOC Map */
  4    61 		         fixed bin (17) int static options (constant);
  4    62 
  4    63 /* SECTORS_PER_VTOCE & VTOCES_PER_RECORD are indexed via device type as     */
  4    64 /* defined by fs_dev_types and extracted form the disk_table entry (dte)    */
  4    65 /* or the physical volume table entry (pvte) device type.		      */
  4    66 
  4    67 dcl PAGE_SIZE fixed bin (17) init (1024) static options (constant);
  4    68 dcl VTOCE_SIZE fixed bin (17) init (192) static options (constant);
  4    69 
  4    70 dcl SECTORS_PER_VTOCE       (9) fixed bin static options (constant) init
  4    71      (0, 3, 3, 3, 3, 3, 3, 1, 1);
  4    72 dcl VTOCES_PER_RECORD       (9) fixed bin  static options  (constant) init
  4    73      (0, 5, 5, 5, 5, 5, 5, 2, 2);
  4    74 dcl SECTORS_PER_RECORD      (9) fixed bin static options (constant) init
  4    75      (0, 16, 16, 16, 16, 16, 16, 2, 2);
  4    76 
  4    77 /*	END INCLUDE FILE...disk_pack.incl.pl1	*/
      342 
      343  /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  5     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  5     3 /*	version number changed to 4, 08/10/78 WOS */
  5     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  5     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  5     6 
  5     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  5     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  5     9     2 switches aligned,                                     /* various bit switch values */
  5    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  5    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  5    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  5    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  5    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  5    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  5    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  5    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  5    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  5    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  5    20 
  5    21 /*  Limit of data defined for version 2 */
  5    22 
  5    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  5    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  5    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  5    26 						/* minimum of 30 seconds required for repeat */
  5    27 						/* otherwise, no repeat will occur */
  5    28 /* Limit of data defined for version 4 */
  5    29 
  5    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  5    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  5    32 
  5    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  5    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  5    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  5    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  5    37 
  5    38 /*	END INCLUDE FILE query_info.incl.pl1 */
      343 
      344  /* BEGIN INCLUDE FILE sub_error_info.incl.pl1 */
  6     2 /* format: style2 */
  6     3 
  6     4 /* The include file condition_info_header must be used with this file */
  6     5 
  6     6      declare sub_error_info_ptr     pointer;
  6     7      declare 1 sub_error_info	      aligned based (sub_error_info_ptr),
  6     8 	     2 header	      aligned like condition_info_header,
  6     9 	     2 retval	      fixed bin (35),	/* return value */
  6    10 	     2 name	      char (32),		/* module name */
  6    11 	     2 info_ptr	      ptr;
  6    12 
  6    13      declare sub_error_info_version_1
  6    14 			      internal static options (constant) fixed bin init (1);
  6    15 
  6    16 /* END INCLUDE FILE sub_error_info.incl.pl1 */
      344 
      345  /* BEGIN INCLUDE FILE ... condition_info.incl.pl1 */
  7     2 
  7     3 /* Structure for find_condition_info_.
  7     4*
  7     5*   Written 1-Mar-79 by M. N. Davidoff.
  7     6**/
  7     7 
  7     8 /* automatic */
  7     9 
  7    10      declare condition_info_ptr     pointer;
  7    11 
  7    12 /* based */
  7    13 
  7    14      declare 1 condition_info	      aligned based (condition_info_ptr),
  7    15 	     2 mc_ptr	      pointer,		/* pointer to machine conditions at fault time */
  7    16 	     2 version	      fixed binary,		/* Must be 1 */
  7    17 	     2 condition_name     char (32) varying,	/* name of condition */
  7    18 	     2 info_ptr	      pointer,		/* pointer to the condition data structure */
  7    19 	     2 wc_ptr	      pointer,		/* pointer to wall crossing machine conditions */
  7    20 	     2 loc_ptr	      pointer,		/* pointer to location where condition occured */
  7    21 	     2 flags	      unaligned,
  7    22 	       3 crawlout	      bit (1),		/* on if condition occured in lower ring */
  7    23 	       3 pad1	      bit (35),
  7    24 	     2 pad2	      bit (36),
  7    25 	     2 user_loc_ptr	      pointer,		/* ptr to most recent nonsupport loc before condition occurred */
  7    26 	     2 pad3	      (4) bit (36);
  7    27 
  7    28 /* internal static */
  7    29 
  7    30      declare condition_info_version_1
  7    31 			      fixed binary internal static options (constant) initial (1);
  7    32 
  7    33 /* END INCLUDE FILE ... condition_info.incl.pl1 */
      345 
      346  /* BEGIN INCLUDE FILE condition_info_header.incl.pl1 BIM 1981 */
  8     2 /* format: style2 */
  8     3 
  8     4      declare condition_info_header_ptr
  8     5 			      pointer;
  8     6      declare 1 condition_info_header
  8     7 			      aligned based (condition_info_header_ptr),
  8     8 	     2 length	      fixed bin,		/* length in words of this structure */
  8     9 	     2 version	      fixed bin,		/* version number of this structure */
  8    10 	     2 action_flags	      aligned,		/* tell handler how to proceed */
  8    11 	       3 cant_restart     bit (1) unaligned,	/* caller doesn't ever want to be returned to */
  8    12 	       3 default_restart  bit (1) unaligned,	/* caller can be returned to with no further action */
  8    13 	       3 quiet_restart    bit (1) unaligned,	/* return, and print no message */
  8    14 	       3 support_signal   bit (1) unaligned,	/* treat this signal as if the signalling procedure had the support bit set */
  8    15 						/* if the signalling procedure had the support bit set, do the same for its caller */
  8    16 	       3 pad	      bit (32) unaligned,
  8    17 	     2 info_string	      char (256) varying,	/* may contain printable message */
  8    18 	     2 status_code	      fixed bin (35);	/* if^=0, code interpretable by com_err_ */
  8    19 
  8    20 /* END INCLUDE FILE condition_info_header.incl.pl1 */
      346 
      347        
      348 
      349 	end copy_disk_io_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/15/87  1548.6  copy_disk_io_.pl1                 >special_ldd>install>MR12.1-1040>copy_disk_io_.pl1
339          1    07/15/87  1546.6  copy_disk_info.incl.pl1           >special_ldd>install>MR12.1-1040>copy_disk_info.incl.pl1
340          2    07/24/86  2051.8  fs_dev_types_sector.incl.pl1      >ldd>include>fs_dev_types_sector.incl.pl1
341          3    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
342          4    10/22/86  1450.1  disk_pack.incl.pl1                >ldd>include>disk_pack.incl.pl1
343          5    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
344          6    07/18/81  1100.0  sub_error_info.incl.pl1           >ldd>include>sub_error_info.incl.pl1
345          7    06/28/79  1204.8  condition_info.incl.pl1           >ldd>include>condition_info.incl.pl1
346          8    03/24/82  1347.2  condition_info_header.incl.pl1    >ldd>include>condition_info_header.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
POSITION_ABSOLUTE               000036 constant        fixed bin(17,0)          initial dcl 1-48 set ref 150*
P_brief_sw                             parameter       bit(1)                   dcl 53 set ref 78 89 100 109 211* 215*
P_buffer_ptr                           parameter       pointer                  dcl 49 set ref 78 89 100 109 145 211* 215*
P_code                                 parameter       fixed bin(35,0)          dcl 58 set ref 78 89 100 109 148* 150* 151 152* 166*
                                                                                  168* 172 174 175* 181* 205 211* 215* 218 238* 246*
                                                                                  260* 284* 285 287* 294* 300*
P_cv_record                            parameter       fixed bin(18,0)          dcl 55 set ref 125 128*
P_cv_sector                            parameter       fixed bin(35,0)          dcl 56 set ref 118 121*
P_first_sector                         parameter       fixed bin(35,0)          dcl 136 ref 132
P_info                                 based           structure                level 1 dcl 60
P_info_ptr                             parameter       pointer                  dcl 48 ref 78 82 89 93 100 104 109 113 118 125 146
                                                                                  147 150 152 166 168 175 211 215 236 239 239 240
                                                                                  240 242 242 250 252 256 256 287 317 318 319 320
                                                                                  328 329 330 331 331 333
P_n_sectors                            parameter       fixed bin(17,0)          dcl 137 in procedure "sector_io" set ref 132 146 147
                                                                                  201 222*
P_n_sectors                            parameter       fixed bin(17,0)          dcl 51 in procedure "copy_disk_io_" ref 78 84 89 95
P_operation                            parameter       fixed bin(17,0)          dcl 135 ref 132 166 175 186
P_query_sw                             parameter       bit(1)                   dcl 54 set ref 78 89 100 109 211* 215* 240
P_rec                                  parameter       fixed bin(18,0)          dcl 307 ref 304 317 318
P_record                               parameter       fixed bin(18,0)          dcl 52 set ref 100 104* 104* 109 113* 113*
P_retry_sw                             parameter       bit(1)                   dcl 57 set ref 78 89 100 109 186 211* 215*
P_sec                                  parameter       fixed bin(35,0)          dcl 308 ref 325 328 329
P_sector                               parameter       fixed bin(35,0)          dcl 50 set ref 78 84 89 95 150 152* 200* 201 236*
READ                            000041 constant        fixed bin(17,0)          initial dcl 1-43 set ref 83 104* 166 175 186
WHOAMI                          000011 constant        char(32)                 initial unaligned dcl 1-41 set ref 152* 175* 236*
                                                                                  242* 250* 256* 287*
WRITE                           000036 constant        fixed bin(17,0)          initial dcl 1-44 set ref 94 113* 298
addr                                                   builtin function         dcl 74 ref 250 250 282
answer                          000100 automatic       varying char(32)         dcl 62 set ref 250* 251 251 251 251
answer_iocbp              6     000116 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
buffer                                 based           bit(36)                  array dcl 140 set ref 209*
buffer_ptr                      000100 automatic       pointer                  dcl 139 set ref 145* 166* 168* 209
buffer_size                     000102 automatic       fixed bin(18,0)          dcl 141 set ref 146* 209
chars_per_sector         33            based           fixed bin(17,0)          level 3 dcl 60 ref 147
cleanup                         000000 stack reference condition                dcl 72 ref 159
com_err_                        000016 constant        entry                    external dcl 70 ref 152 175 236 242 256 287
command_query_                  000014 constant        entry                    external dcl 69 ref 250
condition_info                         based           structure                level 1 dcl 7-14
condition_info_header                  based           structure                level 1 dcl 8-6
condition_info_ptr              000136 automatic       pointer                  dcl 7-10 set ref 282* 283 284* 291
condition_info_version_1               constant        fixed bin(17,0)          initial dcl 7-30 ref 283
continue_to_signal_             000026 constant        entry                    external dcl 277 ref 294
copy_disk_info                         based           structure                level 1 dcl 1-14
cp_escape_control         1(02) 000116 automatic       bit(2)                   initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*
cylinder                        000100 automatic       fixed bin(17,0)          dcl 310 set ref 317* 319 328* 333
device                                 based           char(32)                 level 2 packed unaligned dcl 60 set ref 152* 175*
                                                                                  236* 242* 256* 287*
device_type              10            based           fixed bin(17,0)          level 2 dcl 60 ref 211 215
disk_parameters          32            based           structure                level 2 dcl 60
divide                                                 builtin function         dcl 74 ref 317 328 330
error_table_$device_parity      000010 external static fixed bin(35,0)          dcl 66 set ref 236*
error_table_$item_too_big       000012 external static fixed bin(35,0)          dcl 67 ref 172 246 260
errors                   42            based           fixed bin(17,0)          level 2 dcl 60 set ref 239* 239 240 252*
explanation_len          14     000116 automatic       fixed bin(21,0)          initial level 2 dcl 5-7 set ref 5-7*
explanation_ptr          12     000116 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
find_condition_info_            000030 constant        entry                    external dcl 278 ref 284
first_record                    000126 automatic       fixed bin(18,0)          dcl 195 set ref 200* 203 208
header                                 based           structure                level 2 dcl 6-7
info_ptr                 14            based           pointer                  level 2 dcl 7-14 ref 291
info_string               3            based           varying char(256)        level 3 dcl 6-7 set ref 298*
io_length                       000103 automatic       fixed bin(21,0)          dcl 142 set ref 147* 166* 168*
ioa_                            000032 constant        entry                    external dcl 279 ref 298
iocb                     24            based           pointer                  level 2 dcl 60 set ref 150* 166* 168*
iox_$position                   000020 constant        entry                    external dcl 3-8 ref 150
iox_$read_record                000022 constant        entry                    external dcl 3-8 ref 166
iox_$rewrite_record             000024 constant        entry                    external dcl 3-8 ref 168
last_record                     000127 automatic       fixed bin(18,0)          dcl 196 set ref 201* 203 208
literal_sw                1(05) 000116 automatic       bit(1)                   initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*
local_condition_info            000106 automatic       structure                level 1 unaligned dcl 276 set ref 282
mod                                                    builtin function         dcl 74 ref 318 329
name                    106            based           char(32)                 level 2 dcl 6-7 ref 292
null                                                   builtin function         dcl 74 ref 5-7 5-7 5-7 284 284
operation                       000111 automatic       fixed bin(17,0)          dcl 63 set ref 83* 84* 94* 95* 298
padding                   1(07) 000116 automatic       bit(29)                  initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*
prompt_after_explanation
                          1(06) 000116 automatic       bit(1)                   initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*
query_code                3     000116 automatic       fixed bin(35,0)          initial level 2 dcl 5-7 set ref 5-7*
query_info                      000116 automatic       structure                level 1 dcl 5-7 set ref 250 250
question_iocbp            4     000116 automatic       pointer                  initial level 2 dcl 5-7 set ref 5-7*
record                          000102 automatic       fixed bin(18,0)          dcl 312 set ref 333* 334* 334 336
record_idx                      000130 automatic       fixed bin(18,0)          dcl 197 set ref 208* 211* 211* 215* 215*
record_in_cylinder              000101 automatic       fixed bin(17,0)          dcl 311 set ref 318* 320 330* 331 331* 334
records_per_cylinder     36            based           fixed bin(17,0)          level 3 dcl 60 ref 317 318 331 331 333
repeat_time              10     000116 automatic       fixed bin(71,0)          initial level 2 dcl 5-7 set ref 5-7*
retval                  105            based           fixed bin(35,0)          level 2 dcl 6-7 ref 300
sect_per_rec                    000000 constant        fixed bin(17,0)          initial array dcl 2-21 set ref 211* 215*
sector                          000103 automatic       fixed bin(35,0)          dcl 313 set ref 319* 320* 320 322
sector_in_cylinder              000104 automatic       fixed bin(17,0)          dcl 314 set ref 329* 330
sectors_per_cylinder     34            based           fixed bin(17,0)          level 3 dcl 60 ref 319 328 329
sectors_per_record       35            based           fixed bin(17,0)          level 3 dcl 60 set ref 104* 113* 320 330
source_info_ptr                 000112 automatic       pointer                  dcl 64 set ref 82* 211* 215
status_code               2     000116 automatic       fixed bin(35,0)          initial level 2 dcl 5-7 set ref 5-7*
sub_error_                      000000 stack reference condition                dcl 72 ref 161 170
sub_error_info                         based           structure                level 1 dcl 6-7
sub_error_info_ptr              000134 automatic       pointer                  dcl 6-6 set ref 291* 292 298 300
substr                                                 builtin function         dcl 74 ref 292
suppress_name_sw          1(01) 000116 automatic       bit(1)                   initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*
suppress_spacing          1(04) 000116 automatic       bit(1)                   initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*
switches                  1     000116 automatic       structure                level 2 dcl 5-7
target_info_ptr                 000114 automatic       pointer                  dcl 65 in procedure "copy_disk_io_" set ref 93*
target_info_ptr          26            based           pointer                  level 2 in structure "P_info" dcl 60 in procedure
                                                                                  "copy_disk_io_" set ref 215*
threshold                43            based           fixed bin(17,0)          level 2 dcl 60 set ref 240 242* 250* 256*
unspec                                                 builtin function         dcl 74 set ref 209*
version                   2            based           fixed bin(17,0)          level 2 dcl 7-14 set ref 283*
words_per_sector         32            based           fixed bin(17,0)          level 3 dcl 60 ref 146
yes_or_no_sw              1     000116 automatic       bit(1)                   initial level 3 packed unaligned dcl 5-7 set ref
                                                                                  5-7*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
DEFAULT_HCPART_SIZE                    internal static fixed bin(17,0)          initial dcl 4-54
DUMPER_BIT_MAP_ADDR                    internal static fixed bin(17,0)          initial dcl 4-54
LABEL_ADDR                             internal static fixed bin(17,0)          initial dcl 4-54
MAX_VTOCE_PER_PACK                     internal static fixed bin(17,0)          initial dcl 4-54
PAGE_SIZE                              internal static fixed bin(17,0)          initial dcl 4-67
POSITION_BEGINNING                     internal static fixed bin(17,0)          initial dcl 1-46
POSITION_RELATIVE                      internal static fixed bin(17,0)          initial dcl 1-47
SECTORS_PER_RECORD                     internal static fixed bin(17,0)          initial array dcl 4-74
SECTORS_PER_VTOCE                      internal static fixed bin(17,0)          initial array dcl 4-70
VOLMAP_ADDR                            internal static fixed bin(17,0)          initial dcl 4-54
VTOCES_PER_RECORD                      internal static fixed bin(17,0)          initial array dcl 4-72
VTOCE_SIZE                             internal static fixed bin(17,0)          initial dcl 4-68
VTOC_MAP_ADDR                          internal static fixed bin(17,0)          initial dcl 4-54
VTOC_ORIGIN                            internal static fixed bin(17,0)          initial dcl 4-54
condition_info_header_ptr              automatic       pointer                  dcl 8-4
iox_$attach_loud                000000 constant        entry                    external dcl 3-8
iox_$attach_name                000000 constant        entry                    external dcl 3-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 3-8
iox_$close                      000000 constant        entry                    external dcl 3-8
iox_$close_file                 000000 constant        entry                    external dcl 3-8
iox_$control                    000000 constant        entry                    external dcl 3-8
iox_$delete_record              000000 constant        entry                    external dcl 3-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 3-8
iox_$detach                     000000 constant        entry                    external dcl 3-8
iox_$detach_iocb                000000 constant        entry                    external dcl 3-8
iox_$err_no_operation           000000 constant        entry                    external dcl 3-8
iox_$err_not_attached           000000 constant        entry                    external dcl 3-8
iox_$err_not_closed             000000 constant        entry                    external dcl 3-8
iox_$err_not_open               000000 constant        entry                    external dcl 3-8
iox_$error_output                      external static pointer                  dcl 3-41
iox_$find_iocb                  000000 constant        entry                    external dcl 3-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 3-8
iox_$get_chars                  000000 constant        entry                    external dcl 3-8
iox_$get_line                   000000 constant        entry                    external dcl 3-8
iox_$look_iocb                  000000 constant        entry                    external dcl 3-8
iox_$modes                      000000 constant        entry                    external dcl 3-8
iox_$move_attach                000000 constant        entry                    external dcl 3-8
iox_$open                       000000 constant        entry                    external dcl 3-8
iox_$open_file                  000000 constant        entry                    external dcl 3-8
iox_$propagate                  000000 constant        entry                    external dcl 3-8
iox_$put_chars                  000000 constant        entry                    external dcl 3-8
iox_$read_key                   000000 constant        entry                    external dcl 3-8
iox_$read_length                000000 constant        entry                    external dcl 3-8
iox_$seek_key                   000000 constant        entry                    external dcl 3-8
iox_$user_input                        external static pointer                  dcl 3-41
iox_$user_io                           external static pointer                  dcl 3-41
iox_$user_output                       external static pointer                  dcl 3-41
iox_$write_record               000000 constant        entry                    external dcl 3-8
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 5-33
query_info_version_4                   internal static fixed bin(17,0)          initial dcl 5-34
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 5-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 5-36
sect_per_cyl                           internal static fixed bin(17,0)          initial array dcl 2-15
sect_per_sv                            internal static fixed bin(24,0)          initial array dcl 2-18
sect_per_track                         internal static fixed bin(17,0)          initial array dcl 2-33
sect_per_vtoc                          internal static fixed bin(17,0)          initial array dcl 2-26
sub_error_info_version_1               internal static fixed bin(17,0)          initial dcl 6-13
vtoc_per_rec                           internal static fixed bin(17,0)          initial array dcl 2-29
words_per_sect                         internal static fixed bin(17,0)          initial array dcl 2-36

NAMES DECLARED BY EXPLICIT CONTEXT.
HANDLE_IO_ERROR                 001143 constant        label                    dcl 186 ref 163
cleanup_stack                   001634 constant        entry                    internal dcl 268 ref 159
copy_disk_io_                   000231 constant        entry                    external dcl 33
copy_disk_io_$read              000251 constant        entry                    external dcl 78 ref 211
copy_disk_io_$read_record       000407 constant        entry                    external dcl 100
copy_disk_io_$record_to_sector  000614 constant        entry                    external dcl 125
copy_disk_io_$sector_to_record  000547 constant        entry                    external dcl 118
copy_disk_io_$write             000326 constant        entry                    external dcl 89 ref 215
copy_disk_io_$write_record      000466 constant        entry                    external dcl 109
r_to_s                          001773 constant        entry                    internal dcl 304 ref 104 104 113 113 128 211 211 215
                                                                                  215
report_io_error                 001363 constant        entry                    internal dcl 231 ref 204
retry_io                        001155 constant        entry                    internal dcl 192 ref 186
s_to_r                          002040 constant        entry                    internal dcl 325 ref 121 200 201
sector_io                       000655 constant        entry                    internal dcl 132 ref 84 95 104 113
suberr_handler                  001636 constant        entry                    internal dcl 273 ref 162

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      2450        2504    2116        2460
Length      3104    2116        34         364     332           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
copy_disk_io_                       116 external procedure  is an external procedure.  
sector_io                           238 internal procedure  enables or reverts conditions.  
on unit on line 159                  70 on unit               
on unit on line 161                 134 on unit               
retry_io                                internal procedure  shares stack frame of internal procedure sector_io.  
report_io_error                         internal procedure  shares stack frame of internal procedure sector_io.  
cleanup_stack                           internal procedure  shares stack frame of on unit on line 159.  
suberr_handler                          internal procedure  shares stack frame of on unit on line 161.  
r_to_s                               70 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
copy_disk_io_            000100 answer                      copy_disk_io_
                         000111 operation                   copy_disk_io_
                         000112 source_info_ptr             copy_disk_io_
                         000114 target_info_ptr             copy_disk_io_
                         000116 query_info                  copy_disk_io_
                         000134 sub_error_info_ptr          copy_disk_io_
                         000136 condition_info_ptr          copy_disk_io_
on unit on line 161      000106 local_condition_info        suberr_handler
r_to_s                   000100 cylinder                    r_to_s
                         000101 record_in_cylinder          r_to_s
                         000102 record                      r_to_s
                         000103 sector                      r_to_s
                         000104 sector_in_cylinder          r_to_s
sector_io                000100 buffer_ptr                  sector_io
                         000102 buffer_size                 sector_io
                         000103 io_length                   sector_io
                         000126 first_record                retry_io
                         000127 last_record                 retry_io
                         000130 record_idx                  retry_io

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              call_ext_in         call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           mdfx1               signal_op           enable_op           ext_entry
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      command_query_                continue_to_signal_           find_condition_info_
ioa_                          iox_$position                 iox_$read_record              iox_$rewrite_record

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$device_parity    error_table_$item_too_big




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 5    7 000176        33 000230        78 000241        82 000266        83 000272        84 000274        85 000312
     89 000324        93 000343        94 000347        95 000351        96 000367       100 000401       104 000424
    105 000452       109 000464       113 000503       114 000531       118 000543       121 000557       125 000610
    128 000623       132 000654       145 000662       146 000667       147 000675       148 000700       150 000701
    151 000717       152 000722       155 000756       159 000757       161 000775       162 001011       163 001012
    166 001015       168 001046       170 001067       172 001070       174 001075       175 001077       178 001140
    181 001141       182 001142       186 001143       188 001154       192 001155       200 001156       201 001171
    203 001214       204 001217       205 001220       206 001224       208 001225       209 001235       211 001245
    215 001307       218 001352       219 001356       222 001360       224 001362       231 001363       236 001364
    238 001421       239 001423       240 001427       242 001435       246 001471       247 001475       250 001476
    251 001534       252 001561       253 001565       256 001566       260 001625       261 001631       264 001632
    265 001633       268 001634       270 001635       273 001636       282 001637       283 001643       284 001645
    285 001662       287 001666       288 001717       291 001720       292 001723       294 001732       295 001741
    298 001742       300 001764       301 001771       304 001772       317 002002       318 002012       319 002016
    320 002021       322 002027       325 002037       328 002046       329 002056       330 002062       331 002064
    333 002071       334 002074       336 002076


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
