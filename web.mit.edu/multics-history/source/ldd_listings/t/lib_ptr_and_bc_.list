	COMPILATION LISTING OF SEGMENT lib_ptr_and_bc_
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 02/15/84  0859.5 mst Wed
	    Options: optimize map

        1 /* ***************************************************************
        2*   *                                                             *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982     *
        4*   *                                                             *
        5*   * Copyright (c) 1975 by Massachusetts Institute of Technology *
        6*   *                                                             *
        7*   * Copyright (c) 1972 by Massachusetts Institute of            *
        8*   * Technology and Honeywell Information Systems, Inc.          *
        9*   *                                                             *
       10*   *************************************************************** */
       11 
       12 
       13 
       14 
       15 lib_ptr_and_bc_:	procedure (Pnode, msf_comp_no, Ptarget_node, ptr, bc, Acode);
       16 
       17 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       18 	/*									*/
       19 	/* This procedure is part of the library maintenance subsystem of tools.  Documentation of*/
       20 	/* the complete subsystem is available in AN-80, Library Maintenance.			*/
       21 	/*									*/
       22 	/* This procedure, when given the pointer to a library node, initiates the segment	*/
       23 	/* containing the entry identified by the node and returns the ptr and bit count of	*/
       24 	/* the segment.  The procedure can handle archive components (and even archived-archive	*/
       25 	/* components, etc).  For MSFs, msf_comp_no should be set to 0 to obtain a ptr to and	*/
       26 	/* bit count of the first component (named 0).  msf_comp_no will be incremented for use	*/
       27 	/* in obtaining ptr/bc for the next component in a subsequent call.  If ptr is null, then	*/
       28 	/* the library entry identified by the node could not exist (or there is no MSF component	*/
       29 	/* which corresponds to the value of msf_comp_no).  Links are chased and their target	*/
       30 	/* is initiated.  A pointer to the target node for link targets and MSF components is	*/
       31 	/* returned as Ptarget_node.							*/
       32 	/*									*/
       33 	/* S__t_a_t_u_s									*/
       34 	/*									*/
       35 	/* 0) Created by:   G. C. Dixon, April 8, 1975					*/
       36 	/*									*/
       37 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       38 
       39      dcl						/*		Parameters		*/
       40 /*	Pnode			ptr,		/* ptr to node identifying lib entry to be	*/
       41 						/*   initiated. (In)			*/
       42 	msf_comp_no		fixed bin(24),	/* if node identifies an MSF, numeric name of MSF	*/
       43 						/*   component to be initiated. (In)		*/
       44 						/* if node identifies an MSF, the input value	*/
       45 						/*   is incremented by 1. (Out)		*/
       46 	Ptarget_node		ptr,		/* ptr to the node which identifies the library	*/
       47 						/*   entry actually initiated.  This node is the	*/
       48 						/*   final target node of a link, or the MSF comp	*/
       49 						/*   node for an MSF. (Out)			*/
       50 	ptr			ptr,		/* is the pointer to the initiated entry. (Out)	*/
       51 	bc			fixed bin(24),	/* is the bit count of the initiated entry. (Out)	*/
       52 	Acode			fixed bin(35);	/* a status Acode. (Out)			*/
       53 
       54      dcl						/*	Automatic Variables			*/
       55 	code			fixed bin(35),	/* an error code.				*/
       56 	dir			char(168) varying,	/* dir part of path name of lib node.		*/
       57 	ent			char(32) varying,	/* ent part of path name of lib node.		*/
       58          (i, j)			fixed bin,	/* do group index variables.			*/
       59 	name			char(32) aligned;	/* character string name of MSF comp we		*/
       60 						/*   are looking for.			*/
       61 
       62      dcl						/*	Builtin Functions			*/
       63          (addr, min, null, pointer, substr, verify)
       64 				builtin;
       65 
       66      dcl						/*		Entries			*/
       67 	hcs_$initiate		entry (char(*), char(*), char(*), fixed bin(1), fixed bin(2),
       68 				       ptr, fixed bin(35)),
       69 	lib_node_path_		entry (ptr, char(168) varying, char(32) varying);
       70 
       71      dcl						/*	Static Variables			*/
       72          (error_table_$dirseg,
       73 	error_table_$improper_data_format,
       74 	error_table_$noentry)	fixed bin(35) ext static;
       75 
       76 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
       77 
       78 	Acode = 0;				/* initialize the output status Acode.		*/
       79 	if node.T = Tsegment then do;			/* initiate the segment, as is.		*/
       80 like_segment:  call lib_node_path_ (Pnode, dir, ent);	/*   first, get path name of segment.		*/
       81 	     call hcs_$initiate ((dir), (ent), "", 0, 0, ptr, code);
       82 	     if ptr ^= null then do;
       83 		bc = node.bit_count;
       84 		Ptarget_node = Pnode;
       85 		end;
       86 	     else Acode = code;
       87 	     end;
       88 
       89  	else if node.T = Tarchive then
       90 	     if node.offset = 0 then go to like_segment;	/* unarchived-archives are like segments.	*/
       91 	     else go to like_archive_component;		/* archived-archives are really archive comps.	*/
       92 
       93 	else if node.T = Tarchive_comp then do;		/* get ptr/bc of parent node for the		*/
       94 like_archive_component:				/* archive component, then use offset/bc in node.	*/
       95 	     call lib_ptr_and_bc_ (node.Pparent, 0, null, ptr, 0, Acode);
       96 	     if ptr ^= null then do;
       97 		ptr = pointer (ptr, node.offset);
       98 		bc = node.bit_count;
       99 		Ptarget_node = Pnode;
      100 		end;
      101 	     end;
      102 
      103 	else if node.T = Tlink then do;		/* get ptr/bc for link target, if any.		*/
      104 	     if Svalid.kids then do;
      105 		do PDnodes = node.PD repeat Dnodes.Pnext while (Dnodes.header.T ^= Tnodes);
      106 		     end;				/*   find target of this link.		*/
      107 		if Dnodes.N = 1 then		/*   get ptr/bc for this target.		*/
      108 		     call lib_ptr_and_bc_ (addr(Dnodes.nodes(1)), msf_comp_no, Ptarget_node, ptr, bc, Acode);
      109 		else do;
      110 		     ptr = null;
      111 		     Acode = error_table_$improper_data_format;
      112 		     end;
      113 		end;
      114 	     else ptr = null;
      115 	     end;
      116 
      117 	else if node.T = Tdirectory then do;		/* can't initiate directories.		*/
      118 	     ptr = null;
      119 	     Acode = error_table_$dirseg;
      120 	     end;
      121 
      122 	else if node.T = Tmsf_comp then go to like_segment;
      123 						/* msf components are really segments at heart.	*/
      124 
      125 
      126 	else if node.T = Tmsf then			/* get the correspondingly-named msf component.	*/
      127 	     if msf_comp_no + 1 <= node.msf_indicator then/*   test for existence of desired comp.	*/
      128 		if Svalid.kids then do;
      129 		     do PDnodes = node.PD repeat Dnodes.Pnext while (Dnodes.header.T ^= Tnodes);
      130 			end;
      131 		     name = char_form (msf_comp_no);
      132 		     Ptarget_node = null;
      133 		     do i = msf_comp_no+1 to Dnodes.N,
      134 			  1 to min(msf_comp_no, Dnodes.N) while (Ptarget_node = null);
      135 			do PDnames = addr(Dnodes.nodes(i))->node.PD repeat Dnames.Pnext while (Dnames.T ^= Tnames);
      136 			     end;
      137 			do j = 1 to Dnames.N while (Dnames.names(j) ^= name);
      138 			     end;
      139 			if j <= Dnames.N then Ptarget_node = addr(Dnodes.nodes(i));
      140 			end;
      141 		     if Ptarget_node ^= null then
      142 			call lib_ptr_and_bc_ (Ptarget_node, msf_comp_no, Ptarget_node, ptr, bc, Acode);
      143 		     else ptr = null;
      144 		     msf_comp_no = msf_comp_no + 1;
      145 		     end;
      146 		else ptr = null;
      147 	     else ptr = null;
      148 
      149 	else ptr = null;				/* I don't know what it is!  Too bad.		*/
      150 
      151 	if ptr = null then if Acode = 0 then Acode = error_table_$noentry;
      152 	return;
      153 
      154 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      155 
      156 
      157 char_form: procedure (number) returns (char(32) aligned);	/* internal proc to convert an integer to a	*/
      158 						/* left-justified 32-char string.		*/
      159 
      160      dcl	number			fixed bin(24),
      161 	char_number		pic "zzzzz9",
      162 	i			fixed bin;
      163 
      164 	char_number = number;			/* convert number to right-justified numeric	*/
      165 						/* string.				*/
      166 	i = verify (char_number, " ");		/* find left-most significant digit.		*/
      167 	return (substr(char_number,i));		/* return significant digits.			*/
      168 
      169 	end char_form;
      170 
      171 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  **  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      172 
  1     1 /*  START OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1     2 
  1     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1     4 	/*									*/
  1     5 	/* N__a_m_e:  lib_node_.incl.pl1							*/
  1     6 	/*									*/
  1     7 	/*      This include segment defines the structures which form the tree of status nodes	*/
  1     8 	/* created by lib_get_tree_.  Each node of the tree is associated with a directory	*/
  1     9 	/* entry or an archive component.  The node lists the attributes of that entry, which is	*/
  1    10 	/* called the node target.							*/
  1    11 	/*									*/
  1    12 	/* S__t_a_t_u_s									*/
  1    13 	/*									*/
  1    14 	/* 0) Created:  May, 1973 by G. C. Dixon					*/
  1    15 	/* 1) Modified: Aug, 1973 by G. C. Dixon - standardize descriptor format.		*/
  1    16 	/* 2) Modified: Oct, 1973 by G. C. Dixon - add object_info_ descriptor.		*/
  1    17 	/* 3) Modified: Apr, 1975 by G. C. Dixon - add ACL and IACL descriptors.		*/
  1    18 	/* 4) Modified: Oct, 1975 by G. C. Dixon - additional status info added.		*/
  1    19 	/*									*/
  1    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    21 
  1    22 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    23 	/*									*/
  1    24 	/*	The structure of each node whose target is a link is shown below.	The	*/
  1    25 	/* structure of nodes for other types of targets is shown on the next page.  Note that	*/
  1    26 	/* both types of nodes are the same length.					*/
  1    27 	/*									*/
  1    28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    29 
  1    30      dcl  1 link_node		based (Pnode),	/* node of a status tree.			*/
  1    31 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    32 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    33 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    34 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    35 						/*             (= node.Svalid & Srequirements)	*/
  1    36 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    37 	  2 switches		unaligned,
  1    38 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    39 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    40 						/* 	     entry before lib_access_mode_$set.	*/
  1    41 	    3 pad			bit(22),
  1    42 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    43 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    44 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    45 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    46 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    47 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    48 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    49 						/*	     in this directory;  if off, records*/
  1    50 						/*	     charged against 1st superior	*/
  1    51 						/*	     directory with switch on.	*/
  1    52 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    53 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    54 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    55 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    56 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    57 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    58 
  1    59 						/* From here on, link_nodes differ from nodes	*/
  1    60 						/*  for other types of node targets.		*/
  1    61 	  2 link_target		char(168) varying;	/* attribute: target pathname of the link.	*/
  1    62 
  1    63 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    64 	/*									*/
  1    65 	/*	The structure of nodes for other types of node targets is shown below.	*/
  1    66 	/*									*/
  1    67 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1    68 
  1    69      dcl  1 node			based (Pnode),	/* node of a status tree.			*/
  1    70 	  2 Pparent		ptr,		/* ptr to:    parent node (previous tree level).	*/
  1    71 	  2 PD			ptr,		/* ptr to:    descriptor chain attached to node.	*/
  1    72 	  2 Svalid		bit(72) aligned,	/* switches:  node data which is valid.		*/
  1    73 	  2 Sreq			bit(72) aligned,	/* switches:  node data which is req'd for output.*/
  1    74 						/*             (= node.Svalid & Srequirements)	*/
  1    75 	  2 T			fixed bin(35),	/* attribute: type of node target.		*/
  1    76 	  2 switches		unaligned,
  1    77 	    3 Smode		bit(3),		/* attribute: user's access mode to entry.	*/
  1    78 	    3 Sprev_mode		bit(3),		/* attribute: user's previous access mode to the	*/
  1    79 						/* 	     entry before lib_access_mode_$set.	*/
  1    80 	    3 pad			bit(22),
  1    81 	    3 Smaster_dir		bit(1),		/* attribute: master directory		*/
  1    82 	    3 Stpd		bit(1),		/* attribute: transparent (never on) paging device*/
  1    83 	    3 Ssafety		bit(1),		/* attribute: safety switch.			*/
  1    84 	    3 Saim_security_oos	bit(1),		/* attribute: security out-of-service.		*/
  1    85 	    3 Saim_audit		bit(1),		/* attribute: AIM audit use of node target.	*/
  1    86 	    3 Saim_multiple_class	bit(1),		/* attribute: AIM multiple class segment.	*/
  1    87 	    3 Sterminal_account	bit(1),		/* attribute: if on, records charged against quota*/
  1    88 						/*	     in this directory;  if off, records*/
  1    89 						/*	     charged against 1st superior	*/
  1    90 						/*	     directory with switch on.	*/
  1    91 	    3 Sterminal_account_dir	bit(1),		/* attribute: like Sterminal_account for dir quota*/
  1    92 	    3 Scopy		bit(1),		/* attribute: copy-on-write switch.		*/
  1    93 	  2 unique_id		bit(36),		/* attribute: unique identifier.		*/
  1    94 	  2 author		char(32) varying,	/* attribute: author of node target.		*/
  1    95 	  2 dtem			bit(36),		/* attribute: date-time attributes modified.	*/
  1    96 	  2 dtd			bit(36),		/* attribute: date-time node target dumped.	*/
  1    97 
  1    98 						/* From here on, other nodes differ from	*/
  1    99 						/*  link_nodes.				*/
  1   100 	  2 dtm			bit(36),		/* attribute: date-time node target modified.	*/
  1   101 	  2 dtu			bit(36),		/* attribute: date-time node target last used.	*/
  1   102 	  2 rb (3)		fixed bin(3),	/* attribute: ring brackets.			*/
  1   103 	  2 pad1 (1)		fixed bin,
  1   104 	  2 access_class		bit(72) aligned,	/* attribute: access class assoc. with entry.	*/
  1   105 	  2 records_used		fixed bin(35),	/* attribute: storage used, in records.		*/
  1   106 	  2 current_length		fixed bin(35),	/* attribute: length, in records.		*/
  1   107 	  2 max_length		fixed bin(35),	/* attribute: maximum length.			*/
  1   108 	  2 msf_indicator		fixed bin(35),	/* attribute: msf indicator.			*/
  1   109 	  2 bit_count		fixed bin(35),	/* attribute: bit count.			*/
  1   110 	  2 bit_count_author	char(32) varying,	/* attribute: bit count/msf indicator author.	*/
  1   111 	  2 offset		fixed bin(35),	/* attribute: offset, in words, of an archive	*/
  1   112 						/*             component from the base of archive.*/
  1   113 	  2 entry_bound		fixed bin(35),	/* attribute: entry limit for calls to a gate.	*/
  1   114 	  2 segment,				/* group:  segment quota information for a dir.	*/
  1   115 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   116 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   117 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   118 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   119 						/*	     updated.			*/
  1   120 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   121 						/*	     directories with Sterminal_account	*/
  1   122 						/*	     on.				*/
  1   123 	  2 directory,				/* group:  directory quota information for a dir.	*/
  1   124 	    3 quota		fixed bin(35),	/* attribute: quota set.			*/
  1   125 	    3 quota_used		fixed bin(35),	/* attribute: quota used.			*/
  1   126 	    3 trp			fixed bin(71),	/* attribute: time-record product.		*/
  1   127 	    3 dttrp		bit(36),		/* attribute: date-time time-record product last	*/
  1   128 						/*	     updated.			*/
  1   129 	    3 Ninf_quota		fixed bin(35),	/* attribute: number of immediately-inferior 	*/
  1   130 						/*	     directories with Sterminal_account	*/
  1   131 						/*	     on.				*/
  1   132 	  2 pvid			bit(36),		/* attribute: physical volume id.		*/
  1   133 	  2 lvid			bit(36),		/* attribute: logical volume id.		*/
  1   134 	  2 pad2 (5)		fixed bin,
  1   135 	Pnode			ptr;		/* ptr to:    a tree node.			*/
  1   136 
  1   137 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   138 	/*									*/
  1   139 	/*      The descriptors attached to each node of the tree describe the variable-sized	*/
  1   140 	/* attributes of the directory entry or archive component associated with the node.	*/
  1   141 	/* Each descriptor must begin with a header shown in structure D below.  The following	*/
  1   142 	/* descriptors are the only ones that have been defined.				*/
  1   143 	/*									*/
  1   144 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   145 
  1   146      dcl	1 D			based (PD),	/* Header common to all descriptors.		*/
  1   147 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   148 	  2 version		fixed bin(17) unal,	/* descriptor: version number.		*/
  1   149 	  2 T			fixed bin,	/* descriptor: type of descriptor.		*/
  1   150 	  2 Pnext		ptr,			/* ptr to:    next descriptor attached to node.	*/
  1   151 	PD			ptr;		/* ptr to:    a descriptor.			*/
  1   152 
  1   153      dcl	1 Dacl			based (PDacl),	/* a segment ACL descriptor.			*/
  1   154 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   155 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   156 	  2 T			fixed bin,	/* descriptor: type = Tacl.			*/
  1   157 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   158 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   159 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   160 	  2 acls (Nacls refer (Dacl.N)),		/* attribute: ACL entries.			*/
  1   161 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   162 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   163 	    3 zero_pad		bit(36),
  1   164 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   165 	Nacls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   166 	PDacl			ptr,		/* ptr to:    a segment ACL descriptor.		*/
  1   167 	Vacl_1			fixed bin int static options(constant) init (1),
  1   168 						/* version:   version of ACL descriptor.	*/
  1   169 	Tacl			fixed bin int static options(constant) init (7);
  1   170 						/* attribute: type of a segment ACL descriptor.	*/
  1   171 
  1   172      dcl	1 Ddir_acl		based (PDdir_acl),	/* a directory ACL descriptor.		*/
  1   173 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   174 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   175 	  2 T			fixed bin,	/* descriptor: type = Tdir_acl.		*/
  1   176 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   177 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   178 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   179 	  2 acls (Ndir_acls refer (Ddir_acl.N)),	/* attribute: ACL entries.			*/
  1   180 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   181 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   182 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   183 	Ndir_acls			fixed bin,	/* temporary: number of entries in ACL descriptor.*/
  1   184 	PDdir_acl			ptr,		/* ptr to:    a directory ACL descriptor.	*/
  1   185 	Vdir_acl_1		fixed bin int static options(constant) init (1),
  1   186 						/* version:   version of directory ACL descriptor.*/
  1   187 	Tdir_acl			fixed bin int static options(constant) init (8);
  1   188 						/* attribute: type of a directory ACL descriptor.	*/
  1   189 
  1   190      dcl	1 Ddir_iacl		based (PDdir_iacl),	/* a directory IACL descriptor.		*/
  1   191 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   192 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   193 	  2 T			fixed bin,	/* descriptor: type = Tdir_iacl.		*/
  1   194 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   195 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   196 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   197 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   198 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   199 	  2 acls (Ndir_iacls refer (Ddir_iacl.N)),	/* attribute: ACL entries.			*/
  1   200 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   201 	    3 dir_modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   202 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   203 	Ndir_iacls		fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   204 	PDdir_iacl		ptr,		/* ptr to:    a directory IACL descriptor.	*/
  1   205 	Vdir_iacl_1		fixed bin int static options(constant) init (1),
  1   206 						/* version:   version of dir IACL descriptor.	*/
  1   207 	Tdir_iacl			fixed bin int static options(constant) init (9);
  1   208 
  1   209      dcl	1 Diacl			based (PDiacl),	/* a segment IACL descriptor.			*/
  1   210 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   211 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   212 	  2 T			fixed bin,	/* descriptor: type = Tiacl.			*/
  1   213 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   214 	  2 C			fixed bin(35),	/* attribute: error code from filling descriptor.	*/
  1   215 	  2 N			fixed bin,	/* attribute: number of ACL entries.		*/
  1   216 	  2 Iring (0:7)		fixed bin,	/* attribute: index of first ACLe in each ring.	*/
  1   217 	  2 Nring (0:7)		fixed bin,	/* attribute: number of ACL entries in each ring.	*/
  1   218 	  2 acls (Niacls refer (Diacl.N)),		/* attribute: ACL entries.			*/
  1   219 	    3 access_name		char(32),		/* attribute: access name associated with entry.	*/
  1   220 	    3 modes		bit(36),		/* attribute: access modes associated with entry.	*/
  1   221 	    3 zero_pad		bit(36),
  1   222 	    3 status_code		fixed bin(35),	/* attribute: status code associated with entry.	*/
  1   223 	Niacls			fixed bin,	/* temporary: number of entries in IACL descriptor*/
  1   224 	PDiacl			ptr,		/* ptr to:    a segment IACL descriptor.	*/
  1   225 	Viacl_1			fixed bin int static options(constant) init (1),
  1   226 						/* version:   version of segment IACL descriptor.	*/
  1   227 	Tiacl			fixed bin int static options(constant) init (10);
  1   228 						/* attribute: type of a segment IACL descriptor.	*/
  1   229 
  1   230      dcl	1 Dnames			based (PDnames),	/* name attribute descriptor.			*/
  1   231 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   232 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   233 	  2 T			fixed bin,	/* descriptor: type = Tnames.			*/
  1   234 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   235 	  2 N			fixed bin,	/* attribute: number of names.		*/
  1   236 	  2 names (Nnames refer (Dnames.N))
  1   237 				char(32),		/* attribute: names.			*/
  1   238 	Nnames			fixed bin,	/* temporary: number of names in name descriptor.	*/
  1   239 	PDnames			ptr,		/* ptr to:    a name descriptor.		*/
  1   240 	Vnames_1			fixed bin int static options(constant) init (1),
  1   241 						/* version:   version of names descriptor.	*/
  1   242 	Tnames			fixed bin int static options(constant) init (1);
  1   243 						/* attribute: type of a name descriptor.	*/
  1   244 
  1   245      dcl	1 Dnodes			based (PDnodes),	/* descriptor for array of immediately-inferior	*/
  1   246 						/* nodes.					*/
  1   247 	  2 header,
  1   248 	    3 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   249 	    3 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   250 	    3 T			fixed bin,	/* descriptor: type = Tnodes.			*/
  1   251 	    3 Pnext		ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   252 	    3 C			fixed bin(35),	/* attribute: error code from filling array.	*/
  1   253 	    3 N			fixed bin,	/* attribute: number of nodes in node array.	*/
  1   254 	  2 nodes (Nnodes refer (Dnodes.N))		/* attribute: node array			*/
  1   255 				like node,
  1   256 	Nnodes			fixed bin,	/* temporary: number of nodes in node array.	*/
  1   257 	PDnodes			ptr,		/* ptr to:    a node array descriptor.		*/
  1   258 	Vnodes_1			fixed bin int static options(constant) init (1),
  1   259 						/* version:   version of nodes descriptor.	*/
  1   260 	Tnodes			fixed bin int static options(constant) init (2);
  1   261 						/* attribute: type of a node descriptor.	*/
  1   262 
  1   263      dcl	1 Dobj			based (PDobj),	/* an object_info_ descriptor.		*/
  1   264 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   265 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   266 	  2 T			fixed bin,	/* descriptor: type = Tobj.			*/
  1   267 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   268 	  2 info,
  1   269 	    3 Otext		fixed bin(35),	/* attribute: offset of text.			*/
  1   270 	    3 Odefinitions		fixed bin(35),	/* attribute: offset of definitions.		*/
  1   271 	    3 Olink		fixed bin(35),	/* attribute: offset of linkage section.	*/
  1   272 	    3 Ostatic		fixed bin(35),	/* attribute: offset of static section.		*/
  1   273 	    3 Osymbols		fixed bin(35),	/* attribute: offset of symbol section.		*/
  1   274 	    3 Obreaks		fixed bin(35),	/* attribute: offset of break map.		*/
  1   275 	    3 Ltext		fixed bin(35),	/* attribute: length of text, in words.		*/
  1   276 	    3 Ldefinitions		fixed bin(35),	/* attribute: length of definitions, in words.	*/
  1   277 	    3 Llink		fixed bin(35),	/* attribute: length of linkage section, in words.*/
  1   278 	    3 Lstatic		fixed bin(35),	/* attribute: length of static section, in words.	*/
  1   279 	    3 Lsymbols		fixed bin(35),	/* attribute: length of symbol section, in words.	*/
  1   280 	    3 Lbreaks		fixed bin(35),	/* attribute: length of break map, in words.	*/
  1   281 	    3 format		aligned,
  1   282 	      4 old_format		bit(1) unal,	/* attribute: segment is in old format.		*/
  1   283 	      4 bound		bit(1) unal,	/* attribute: a bound segment.		*/
  1   284 	      4 relocatable		bit(1) unal,	/* attribute: object is relocatable.		*/
  1   285 	      4 procedure		bit(1) unal,	/* attribute: executable procedure.		*/
  1   286 	      4 standard		bit(1) unal,	/* attribute: standard object segment.		*/
  1   287 	      4 gate		bit(1) unal,	/* attribute: gate procedure.			*/
  1   288 	      4 separate_static	bit(1) unal,	/* attribute: proc has separate static section.	*/
  1   289 	      4 links_in_text	bit(1) unal,	/* attribute: proc has links in text section.	*/
  1   290 	      4 pad		bit(28) unal,
  1   291 	    3 entry_bound		fixed bin(35),	/* attribute: entry point bound for a gate.	*/
  1   292 	    3 Otext_links		fixed bin(35),	/* attribute: offset of first link in text section*/
  1   293 	    3 compiler		char(8),		/* attribute: compiler of this object segment.	*/
  1   294 	    3 compile_time		fixed bin(71),	/* attribute: date/time of compilation.		*/
  1   295 	    3 userid		char(32),		/* attribute: id of user who compiled segment.	*/
  1   296 	    3 cversion,				/* attribite: compiler version string.		*/
  1   297 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   298 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   299 	    3 comment,				/* attribute: compiler-generated comment.	*/
  1   300 	      4 O			fixed bin(17) unal,	/*	    offset			*/
  1   301 	      4 L			fixed bin(17) unal,	/*	    length			*/
  1   302 	    3 Osource		fixed bin(35),	/* attribute: offset of source map.		*/
  1   303 	  2 cversion		char(64) varying,	/* attribute: compiler version number      	*/
  1   304 	  2 comment		char(64) varying,	/* attribute: compiler's comment info	   	*/
  1   305 	PDobj			ptr,		/* ptr to:    an object_info_ descriptor.	*/
  1   306 	Vobj_1			fixed bin int static options(constant) init (1),
  1   307 						/* version:   version of object_info_ descriptor.	*/
  1   308 	Tobj			fixed bin int static options(constant) init (3);
  1   309 						/* attribute: type of a node descriptor.	*/
  1   310 
  1   311      dcl	1 Dsearch_proc		based (PDsearch_proc),
  1   312 						/* library root search_proc attribute descriptor.	*/
  1   313 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   314 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   315 	  2 T			fixed bin,	/* descriptor: type = Tsearch_proc.		*/
  1   316 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   317 	  2 search_proc		char(65) varying,	/* attribute: name of library search procedure.	*/
  1   318 	PDsearch_proc		ptr,		/* ptr to:    a search_proc info descriptor.	*/
  1   319 	Vsearch_proc_1		fixed bin int static options(constant) init (1),
  1   320 						/* version:   version of search_proc info descrip.*/
  1   321 	Tsearch_proc		fixed bin int static options(constant) init (5);
  1   322 						/* attribute: type of a search_proc descriptor.	*/
  1   323 
  1   324      dcl	1 Duser			based (PDuser),	/* user attribute descriptor.			*/
  1   325 	  2 length		fixed bin(17) unal,	/* descriptor: length, in words.		*/
  1   326 	  2 version		fixed bin(17) unal,	/* descriptor: version number = 1.		*/
  1   327 	  2 T			fixed bin,	/* descriptor: type = Tuser.			*/
  1   328 	  2 Pnext			ptr,		/* ptr to:    next descriptor attached to node.	*/
  1   329 	  2 label			char(18),		/* attribute: label to be used for this field in	*/
  1   330 						/*            output.			*/
  1   331 	  2 L			fixed bin,	/* attribute: length of user info string.	*/
  1   332 	  2 info			char(Luser refer (Duser.L)),
  1   333 						/* attribute: user info string.		*/
  1   334 	Luser			fixed bin,	/* temporary: length of user info string.	*/
  1   335 	PDuser			ptr,		/* ptr to:    a user info descriptor.		*/
  1   336 	Vuser_1			fixed bin int static options(constant) init (1),
  1   337 						/* version:   version of user info descriptor.	*/
  1   338 	Tuser			fixed bin int static options(constant) init (6);
  1   339 						/* attribute: type of a user descriptor.	*/
  1   340 
  2     1 /* START OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  2     2 
  2     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2     4 	/*									*/
  2     5 	/* N__a_m_e:  lib_Svalid_req_.incl.pl1						*/
  2     6 	/*									*/
  2     7 	/*      This include segment defines the switches which request/validate the fields	*/
  2     8 	/* in a status node produced by lib_get_tree_.  This segment, lib_Scontrol_.incl.pl1,	*/
  2     9 	/* and lib_args_.incl.pl1 define the complete set of structures required as input to	*/
  2    10 	/* the lib_descriptor_ subroutine.  This subroutine is called by all of the library	*/
  2    11 	/* descriptor commands to obtain information about entries in a library.		*/
  2    12 	/*									*/
  2    13 	/*      If a switch is on, then the corresponding information in the node is valid, or 	*/
  2    14 	/* is requested for output.							*/
  2    15 	/*									*/
  2    16 	/* S__t_a_t_u_s									*/
  2    17 	/*									*/
  2    18 	/* 0) Created on:   April 8, 1975  by  G. C. Dixon				*/
  2    19 	/*									*/
  2    20 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    21 
  2    22 
  2    23      dcl	1 Svalid_req		aligned based,
  2    24 	  2 primary_name		bit(1) unal,	/* switch: output includes primary name	   	*/
  2    25 	  2 matching_names		bit(1) unal,	/* switch: output includes matching names  	*/
  2    26 	  2 names			bit(1) unal,	/* switch: output includes all names	   	*/
  2    27 
  2    28 	  2 pathname		bit(1) unal,	/* switch: output include pathname of node target	*/
  2    29 	  2 kids			bit(1) unal,	/* switch: children nodes (inferior) exist	*/
  2    30 	  2 kids_error		bit(1) unal,	/* switch: error occurred obtaining kid's info	*/
  2    31 
  2    32 	  2 type			bit(1) unal,	/* switch: type 			   	*/
  2    33 	  2 mode			bit(1) unal,	/* switch: user's access mode to node target	*/
  2    34 	  2 safety		bit(1) unal,	/* switch: safety switch setting		*/
  2    35 
  2    36 	  2 aim			bit(1) unal,	/* switch: Access Isolation Mechanism switches	*/
  2    37 	  2 copy			bit(1) unal,	/* switch: copy-on-write switch setting		*/
  2    38 	  2 unique_id		bit(1) unal,	/* switch: unique identifier		   	*/
  2    39 
  2    40 	  2 author		bit(1) unal,	/* switch: author of node target		*/
  2    41 	  2 dtem			bit(1) unal,	/* switch: date attributes modified	   	*/
  2    42 	  2 dtd			bit(1) unal,	/* switch: date dumped		   	*/
  2    43 
  2    44 	  2 link_target		bit(1) unal,	/* switch: target pathname of link node		*/
  2    45 	  2 dtm			bit(1) unal,	/* switch: date modified		   	*/
  2    46 	  2 dtu			bit(1) unal,	/* switch: date used		   	*/
  2    47 
  2    48 	  2 rb			bit(1) unal,	/* switch: ring brackets		   	*/
  2    49 	  2 access_class		bit(1) unal,	/* switch: AIM access class		   	*/
  2    50 	  2 records_used		bit(1) unal,	/* switch: records used		   	*/
  2    51 
  2    52 	  2 current_length		bit(1) unal,	/* switch: current length		   	*/
  2    53 	  2 max_length		bit(1) unal,	/* switch: maximum length			*/
  2    54 	  2 msf_indicator		bit(1) unal,	/* switch: count of MSF components.		*/
  2    55 
  2    56 	  2 bit_count		bit(1) unal,	/* switch: bit count		   	*/
  2    57 	  2 bit_count_author	bit(1) unal,	/* switch: bit count author.			*/
  2    58 	  2 offset		bit(1) unal,	/* switch: offset from segment base	   	*/
  2    59 
  2    60 	  2 entry_bound		bit(1) unal,	/* switch: call limit for gate node		*/
  2    61 	  2 lvid			bit(1) unal,	/* switch: logical volume id	   		*/
  2    62 	  2 pvid			bit(1) unal,	/* switch: physical volume id			*/
  2    63 
  2    64 	  2 quota			bit(1) unal,	/* switch: directory quota information		*/
  2    65 	  2 acl			bit(1) unal,	/* switch: ACL			   	*/
  2    66 	  2 iacl			bit(1) unal,	/* switch: initial ACLs		   	*/
  2    67 
  2    68 	  2 dtc			bit(1) unal,	/* switch: date-time compiled      		*/
  2    69 	  2 compiler_name		bit(1) unal,	/* switch: name of compiler			*/
  2    70 	  2 compiler_version	bit(1) unal,	/* switch: compiler version number         	*/
  2    71 
  2    72 	  2 compiler_options	bit(1) unal,	/* switch: compiler options info	   	*/
  2    73 	  2 object_info		bit(1) unal,	/* switch: other object segment info       	*/
  2    74 	  2 not_ascii		bit(1) unal,	/* switch: contents is not printable       	*/
  2    75 
  2    76 	  2 user			bit(1) unal,	/* switch: user-defined node information	*/
  2    77 	  2 root_search_proc	bit(1) unal,	/* switch: root search procedure info.		*/
  2    78 	  2 prev_mode		bit(1) unal,	/* switch: user's previous acces mode set.	*/
  2    79 	  2 pad			bit(26) unal,
  2    80 
  2    81 	  2 delete		bit(1) unal,	/* switch: on (for lcln) if node to be deleted.	*/
  2    82 
  2    83 	  2 cross_ref		bit(1) unal,	/* switch: cross-reference all names       	*/
  2    84 	  2 level			bit(1) unal,	/* switch: output status tree level number	*/
  2    85 	  2 new_line		bit(1) unal;	/* switch: output begins with newline char	*/
  2    86 
  2    87 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    88 	/*									*/
  2    89 	/*      The following declarations define a series of bit strings to be overlaid by 	*/
  2    90 	/* structures which are exactly like Svalid_req above, except for their level 1 name.	*/
  2    91 	/* These structures are used throughout the library descriptor commands and subroutines.	*/
  2    92 	/*									*/
  2    93 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  2    94 
  2    95 
  2    96      dcl	1 S			aligned based (addr(Srequirements)) like Svalid_req,
  2    97 	Srequirements		bit(72) aligned;
  2    98 
  2    99 /* END OF:	lib_Svalid_req_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   341 
  1   342 
  1   343      dcl	1 Svalid			aligned based(addr(node.Svalid)) like Svalid_req,
  1   344 	1 Sreq			aligned based(addr(node.Sreq)) like Svalid_req;
  1   345 
  3     1 /* START OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  3     2 
  3     3 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3     4 	/*									*/
  3     5 	/* N__a_m_e:  lib_Scontrol_.incl.pl1						*/
  3     6 	/*									*/
  3     7 	/*      This include segment defines the control switches used by library descriptor	*/
  3     8 	/* commands and subroutines.  These switches control the amount of information which is	*/
  3     9 	/* attached to each node of the tree by lib_get_tree_.  This segment, lib_args_.incl.pl1,	*/
  3    10 	/* and lib_Svalid_req_.incl.pl1 define the complete set of structures required as input	*/
  3    11 	/* to the lib_descriptor_ subroutine.						*/
  3    12 	/*									*/
  3    13 	/* S__t_a_t_u_s									*/
  3    14 	/*									*/
  3    15 	/* 0) Created on:  April 8, 1975  by  G. C. Dixon					*/
  3    16 	/* 1) Modified on: October 24, 1983 by Jim Lippard to add page_length, first_match	*/
  3    17 	/*									*/
  3    18 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  3    19 
  3    20      dcl	1 Sc			aligned based (addr (Scontrol)),
  3    21 	  2 acl			bit(1) unal,	/* switch: return ACL for library entries.	*/
  3    22 	  2 all_status		bit(1) unal,	/* switch: return extra status information.	*/
  3    23 	  2 chase			bit(1) unal,	/* switch: link entries are to be chased.	*/
  3    24 
  3    25 	  2 check_archive		bit(1) unal,	/* switch: see if contents of entry is archive.	*/
  3    26 	  2 check_ascii		bit(1) unal,	/* switch: see if contents of entry is ascii.	*/
  3    27 	  2 components		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    28 						/*         nodes of the tree, and about all the	*/
  3    29 						/*	 nodes below the parent.		*/
  3    30 
  3    31 	  2 container		bit(1) unal,	/* switch: return info about parent of terminal	*/
  3    32 						/*         nodes of the tree.			*/
  3    33 	  2 default		bit(1) unal,	/* switch: use default requirement switch settings*/
  3    34 	  2 iacl			bit(1) unal,	/* switch: return initial ACLs for library entries*/
  3    35 
  3    36 	  2 object_info		bit(1) unal,	/* switch: return object info for object segments.*/
  3    37 	  2 quota			bit(1) unal,	/* switch: return quota information.		*/
  3    38 	  2 retain		bit(1) unal,	/* switch: print information about nodes awaiting	*/
  3    39 						/*         deletion.			*/
  3    40 
  3    41 	  2 pad			bit(10) unal,
  3    42 
  3    43 	  2 first_match		bit(1) unal,	/* switch: stop after first match		*/
  3    44 	  2 page_length		bit(1) unal,	/* switch: page length of output		*/
  3    45 
  3    46 	  2 delete		bit(1) unal,	/* switch: delete library entries		*/
  3    47 	  2 descriptor		bit(1) unal,	/* switch: library descriptor			*/
  3    48 	  2 exclude		bit(1) unal,	/* switch: exclusion search names.		*/
  3    49 
  3    50 	  2 footing		bit(1) unal,	/* switch: footing for output pages.		*/
  3    51 	  2 heading		bit(1) unal,	/* switch: heading for 1st output page.		*/
  3    52 	  2 into_path		bit(1) unal,	/* switch: path into which entries are fetched.	*/
  3    53 
  3    54 	  2 library		bit(1) unal,	/* switch: library names			*/
  3    55 	  2 list			bit(1) unal,	/* switch: list library entries		*/
  3    56 	  2 long			bit(1) unal,	/* switch: long output format required.		*/
  3    57 
  3    58 	  2 output_file		bit(1) unal,	/* switch: pathname of output file		*/
  3    59 	  2 search_names		bit(1) unal,	/* switch: search names			*/
  3    60 	  2 time			bit(1) unal,	/* switch: grace time for deletion of entries.	*/
  3    61 	Scontrol			bit(36) aligned;	/* switches: aligned copy of control switches.	*/
  3    62 
  3    63 /* END OF:	lib_Scontrol_.incl.pl1		  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
  1   346 
  1   347 
  1   348 
  1   349 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   350 	/*									*/
  1   351 	/*      The following entry type attributes have been defined.  Note that the types 	*/
  1   352 	/* for segments, archive components, and msf components all have the characteristic	*/
  1   353 	/* that:		mod (type, 2) = 1;						*/
  1   354 	/*									*/
  1   355 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   356 
  1   357 
  1   358      dcl (Tlink			init (0),
  1   359 	Tsegment			init (1),
  1   360 	Tdirectory		init (2),
  1   361 	Tmsf			init (3),
  1   362 	Tmsf_comp			init (4),
  1   363 	Tarchive			init (5),
  1   364 	Tarchive_comp		init (6)) fixed bin(17) int static options(constant);
  1   365 
  1   366 
  1   367 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   368 	/*									*/
  1   369 	/*      The following character string arrays identify each entry type attribute by name.	*/
  1   370 	/* Both brief and long string arrays are provided.				*/
  1   371 	/*									*/
  1   372 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  1   373 
  1   374      dcl	node_type (0:6)		char(32) varying aligned int static options(constant) init (
  1   375 				"link",
  1   376 				"segment",
  1   377 				"directory",
  1   378 				"multisegment file",
  1   379 				"multi-segment file component",
  1   380 				"archive",
  1   381 				"archive component"),
  1   382 	brief_node_type (0:6)	char(12) varying aligned int static options(constant) init (
  1   383 				"link",
  1   384 				"segment",
  1   385 				"directory",
  1   386 				"msf",
  1   387 				"msf comp",
  1   388 				"archive",
  1   389 				"arch comp");
  1   390 
  1   391 
  1   392 /*  END OF:	lib_node_.incl.pl1			  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  */
      173 
      174 	end lib_ptr_and_bc_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    02/15/84  0819.1  lib_ptr_and_bc_.pl1               >special_ldd>on>6588>lib_ptr_and_bc_.pl1
173          1    08/16/79  1752.9  lib_node_.incl.pl1                >ldd>include>lib_node_.incl.pl1
1-341        2    02/28/77  1409.3  lib_Svalid_req_.incl.pl1          >ldd>include>lib_Svalid_req_.incl.pl1
1-346        3    02/15/84  0754.6  lib_Scontrol_.incl.pl1            >special_ldd>on>6588>lib_Scontrol_.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Acode                                  parameter       fixed bin(35,0)          dcl 39 set ref 15 78* 86* 94* 107* 111* 119* 141*
                                                                                  151 151*
Dnames                                 based           structure                level 1 unaligned dcl 1-230
Dnodes                                 based           structure                level 1 unaligned dcl 1-245
N                         5            based           fixed bin(17,0)          level 3 in structure "Dnodes" dcl 1-245 in procedure
                                                                                  "lib_ptr_and_bc_" ref 107 133 133
N                         4            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 1-230 in procedure
                                                                                  "lib_ptr_and_bc_" ref 137 139
PD                        2            based           pointer                  level 2 dcl 1-69 ref 105 129 135
PDnames                         000200 automatic       pointer                  dcl 1-230 set ref 135* 135* 136 137 137 139
PDnodes                         000202 automatic       pointer                  dcl 1-245 set ref 105* 105* 106 107 107 107 129*
                                                                                  129* 130 133 133 135 139
Pnext                     2            based           pointer                  level 3 in structure "Dnodes" dcl 1-245 in procedure
                                                                                  "lib_ptr_and_bc_" ref 106 130
Pnext                     2            based           pointer                  level 2 in structure "Dnames" dcl 1-230 in procedure
                                                                                  "lib_ptr_and_bc_" ref 136
Pnode                                  parameter       pointer                  dcl 1-69 set ref 15 79 80* 83 84 89 89 93 94 97 98
                                                                                  99 103 104 105 117 122 126 126 126 129
Pparent                                based           pointer                  level 2 dcl 1-69 set ref 94*
Ptarget_node                           parameter       pointer                  dcl 39 set ref 15 84* 99* 107* 132* 139* 140 141
                                                                                  141* 141*
Svalid                                 based           structure                level 1 dcl 1-343 in procedure "lib_ptr_and_bc_"
Svalid                    4            based           bit(72)                  level 2 in structure "node" dcl 1-69 in procedure
                                                                                  "lib_ptr_and_bc_" set ref 104 126
Svalid_req                             based           structure                level 1 dcl 2-23
T                         1            based           fixed bin(17,0)          level 3 in structure "Dnodes" dcl 1-245 in procedure
                                                                                  "lib_ptr_and_bc_" ref 105 129
T                         1            based           fixed bin(17,0)          level 2 in structure "Dnames" dcl 1-230 in procedure
                                                                                  "lib_ptr_and_bc_" ref 135
T                        10            based           fixed bin(35,0)          level 2 in structure "node" dcl 1-69 in procedure
                                                                                  "lib_ptr_and_bc_" ref 79 89 93 103 117 122 126
Tarchive                               constant        fixed bin(17,0)          initial dcl 1-358 ref 89
Tarchive_comp                          constant        fixed bin(17,0)          initial dcl 1-358 ref 93
Tdirectory                             constant        fixed bin(17,0)          initial dcl 1-358 ref 117
Tlink                                  constant        fixed bin(17,0)          initial dcl 1-358 ref 103
Tmsf                                   constant        fixed bin(17,0)          initial dcl 1-358 ref 126
Tmsf_comp                              constant        fixed bin(17,0)          initial dcl 1-358 ref 122
Tnames                                 constant        fixed bin(17,0)          initial dcl 1-230 ref 135
Tnodes                                 constant        fixed bin(17,0)          initial dcl 1-245 ref 105 129
Tsegment                               constant        fixed bin(17,0)          initial dcl 1-358 ref 79
addr                                                   builtin function         dcl 62 ref 104 107 107 126 135 139
bc                                     parameter       fixed bin(24,0)          dcl 39 set ref 15 83* 98* 107* 141*
bit_count                43            based           fixed bin(35,0)          level 2 dcl 1-69 ref 83 98
char_number                     000220 automatic       picture(6)               unaligned dcl 160 set ref 164* 166 167
code                            000100 automatic       fixed bin(35,0)          dcl 54 set ref 81* 86
dir                             000101 automatic       varying char(168)        dcl 54 set ref 80* 81
ent                             000154 automatic       varying char(32)         dcl 54 set ref 80* 81
error_table_$dirseg             000014 external static fixed bin(35,0)          dcl 71 ref 119
error_table_$improper_data_format
                                000016 external static fixed bin(35,0)          dcl 71 ref 111
error_table_$noentry            000020 external static fixed bin(35,0)          dcl 71 ref 151
hcs_$initiate                   000010 constant        entry                    external dcl 66 ref 81
header                                 based           structure                level 2 unaligned dcl 1-245
i                               000222 automatic       fixed bin(17,0)          dcl 160 in procedure "char_form" set ref 166* 167
i                               000165 automatic       fixed bin(17,0)          dcl 54 in procedure "lib_ptr_and_bc_" set ref 133*
                                                                                  135 139*
j                               000166 automatic       fixed bin(17,0)          dcl 54 set ref 137* 137* 139
kids                      0(04)        based           bit(1)                   level 2 packed unaligned dcl 1-343 ref 104 126
lib_node_path_                  000012 constant        entry                    external dcl 66 ref 80
min                                                    builtin function         dcl 62 ref 133
msf_comp_no                            parameter       fixed bin(24,0)          dcl 39 set ref 15 107* 126 131* 133 133 141* 144*
                                                                                  144
msf_indicator            42            based           fixed bin(35,0)          level 2 dcl 1-69 ref 126
name                            000167 automatic       char(32)                 dcl 54 set ref 131* 137
names                     5            based           char(32)                 array level 2 packed unaligned dcl 1-230 ref 137
node                                   based           structure                level 1 unaligned dcl 1-69
nodes                     6            based           structure                array level 2 unaligned dcl 1-245 set ref 107 107
                                                                                  135 139
null                                                   builtin function         dcl 62 ref 82 94 94 96 110 114 118 132 140 141 143
                                                                                  146 147 149 151
number                                 parameter       fixed bin(24,0)          dcl 160 ref 157 164
offset                   55            based           fixed bin(35,0)          level 2 dcl 1-69 ref 89 97
pointer                                                builtin function         dcl 62 ref 97
ptr                                    parameter       pointer                  dcl 39 set ref 15 81* 82 94* 96 97* 97 107* 110*
                                                                                  114* 118* 141* 143* 146* 147* 149* 151
substr                                                 builtin function         dcl 62 ref 167
verify                                                 builtin function         dcl 62 ref 166

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
D                                      based           structure                level 1 unaligned dcl 1-146
Dacl                                   based           structure                level 1 unaligned dcl 1-153
Ddir_acl                               based           structure                level 1 unaligned dcl 1-172
Ddir_iacl                              based           structure                level 1 unaligned dcl 1-190
Diacl                                  based           structure                level 1 unaligned dcl 1-209
Dobj                                   based           structure                level 1 unaligned dcl 1-263
Dsearch_proc                           based           structure                level 1 unaligned dcl 1-311
Duser                                  based           structure                level 1 unaligned dcl 1-324
Luser                                  automatic       fixed bin(17,0)          dcl 1-324
Nacls                                  automatic       fixed bin(17,0)          dcl 1-153
Ndir_acls                              automatic       fixed bin(17,0)          dcl 1-172
Ndir_iacls                             automatic       fixed bin(17,0)          dcl 1-190
Niacls                                 automatic       fixed bin(17,0)          dcl 1-209
Nnames                                 automatic       fixed bin(17,0)          dcl 1-230
Nnodes                                 automatic       fixed bin(17,0)          dcl 1-245
PD                                     automatic       pointer                  dcl 1-146
PDacl                                  automatic       pointer                  dcl 1-153
PDdir_acl                              automatic       pointer                  dcl 1-172
PDdir_iacl                             automatic       pointer                  dcl 1-190
PDiacl                                 automatic       pointer                  dcl 1-209
PDobj                                  automatic       pointer                  dcl 1-263
PDsearch_proc                          automatic       pointer                  dcl 1-311
PDuser                                 automatic       pointer                  dcl 1-324
S                                      based           structure                level 1 dcl 2-96
Sc                                     based           structure                level 1 dcl 3-20
Scontrol                               automatic       bit(36)                  dcl 3-20
Sreq                                   based           structure                level 1 dcl 1-343
Srequirements                          automatic       bit(72)                  dcl 2-96
Tacl                                   internal static fixed bin(17,0)          initial dcl 1-153
Tdir_acl                               internal static fixed bin(17,0)          initial dcl 1-172
Tdir_iacl                              internal static fixed bin(17,0)          initial dcl 1-190
Tiacl                                  internal static fixed bin(17,0)          initial dcl 1-209
Tobj                                   internal static fixed bin(17,0)          initial dcl 1-263
Tsearch_proc                           internal static fixed bin(17,0)          initial dcl 1-311
Tuser                                  internal static fixed bin(17,0)          initial dcl 1-324
Vacl_1                                 internal static fixed bin(17,0)          initial dcl 1-153
Vdir_acl_1                             internal static fixed bin(17,0)          initial dcl 1-172
Vdir_iacl_1                            internal static fixed bin(17,0)          initial dcl 1-190
Viacl_1                                internal static fixed bin(17,0)          initial dcl 1-209
Vnames_1                               internal static fixed bin(17,0)          initial dcl 1-230
Vnodes_1                               internal static fixed bin(17,0)          initial dcl 1-245
Vobj_1                                 internal static fixed bin(17,0)          initial dcl 1-263
Vsearch_proc_1                         internal static fixed bin(17,0)          initial dcl 1-311
Vuser_1                                internal static fixed bin(17,0)          initial dcl 1-324
brief_node_type                        internal static varying char(12)         initial array dcl 1-374
link_node                              based           structure                level 1 unaligned dcl 1-30
node_type                              internal static varying char(32)         initial array dcl 1-374

NAMES DECLARED BY EXPLICIT CONTEXT.
char_form                       000551 constant        entry                    internal dcl 157 ref 131
lib_ptr_and_bc_                 000020 constant        entry                    external dcl 15 ref 94 107 141
like_archive_component          000162 constant        label                    dcl 94 ref 91
like_segment                    000034 constant        label                    dcl 80 ref 89 122

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0       704         726     611         714
Length      1152     611        22         207      73           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
lib_ptr_and_bc_                     197 external procedure  is an external procedure.  
char_form                               internal procedure  shares stack frame of external procedure lib_ptr_and_bc_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
lib_ptr_and_bc_          000100 code                        lib_ptr_and_bc_
                         000101 dir                         lib_ptr_and_bc_
                         000154 ent                         lib_ptr_and_bc_
                         000165 i                           lib_ptr_and_bc_
                         000166 j                           lib_ptr_and_bc_
                         000167 name                        lib_ptr_and_bc_
                         000200 PDnames                     lib_ptr_and_bc_
                         000202 PDnodes                     lib_ptr_and_bc_
                         000220 char_number                 char_form
                         000222 i                           char_form

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            call_ext_in         call_ext_out_desc   call_ext_out        return              shorten_stack
ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
hcs_$initiate                 lib_node_path_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$dirseg           error_table_$improper_data_format                           error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     15 000012        78 000025        79 000027        80 000034        81 000050        82 000134        83 000142
     84 000146        85 000147        86 000150        87 000152        89 000153        91 000157        93 000160
     94 000162        96 000206        97 000213        98 000222        99 000226       101 000227       103 000230
    104 000232       105 000235       106 000244       107 000247       110 000276       111 000301       113 000304
    114 000305       115 000307       117 000310       118 000312       119 000314       120 000316       122 000317
    126 000321       129 000332       130 000340       131 000343       132 000354       133 000357       135 000373
    136 000405       137 000410       138 000426       139 000430       140 000442       141 000473       143 000521
    144 000523       145 000525       146 000526       147 000531       149 000534       151 000536       152 000550
    157 000551       164 000553       166 000564       167 000576


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
