	COMPILATION LISTING OF SEGMENT azm_why_
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 08/08/88  1127.1 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-11-02,Farley), approve(87-07-09,MCR7746),
       12*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       13*     Added a check for a valid mc.pr6 prior to calling azm_stack_trace_.
       14*  2) change(87-04-14,Parisek), approve(87-07-09,MCR7746),
       15*     audit(87-07-20,Fawcett), install(87-07-28,MR12.1-1049):
       16*     Check for valid message in the crash message field.
       17*  3) change(87-09-09,Parisek), approve(88-03-09,MCR7861),
       18*     audit(88-07-08,Farley), install(88-07-12,MR12.2-1055):
       19*     Change references of BOS to Bootload or BCE.
       20*                                                   END HISTORY COMMENTS */
       21 
       22 
       23 azm_why_: proc;
       24 	return;
       25 
       26           /*****************************************************************************/
       27           /*                                                                           */
       28 	/* This was originaly written by R. A. Fawcett in the MR9 time frame         */
       29 	/* rewritten by same for MR11 in Sept of 1984 (but only a small improvment). */
       30 	/* entries azm_why_$print_locks, azm_why_$who and azm_why_$mcs	       */
       31 	/* were also added.						       */
       32 	/* Modified Oct 8, 1984 so that mc_area is allocated and then freed.         */
       33 	/* Modified Jan 21, 1985 by B. Braun to use flagbox.incl.pl1 not	       */
       34 	/*       fgbx.incl.pl1.(phx18002)				       */
       35 	/* Modified Jan 21, 1985 by BLB change calling sequence to azm_stack_trace_  */
       36 	/* Modified March 1986 by P. Leatherman to print the crash message if present*/
       37 	/*                                                                           */
       38 	/*****************************************************************************/
       39 
       40 dcl  P_sci_ptr ptr;
       41 dcl  P_amu_info_ptr ptr;
       42 dcl  P_code fixed bin (35);
       43 
       44 /* Automatic */
       45 
       46 dcl  an_entry_found_sw bit (1);
       47 dcl  bad_guy_known bit (1);
       48 dcl  bootload_cpu_tag fixed bin (35);
       49 dcl  bootload_cpu_ptr ptr;
       50 dcl  could_not_set_lock_sw bit (1);
       51 dcl  code fixed bin (35);
       52 dcl  fault_vnum fixed bin;
       53 dcl  fim_num fixed bin (17);
       54 dcl  fim_type_fault bit (1);
       55 dcl  flag_box_area (100) fixed bin (35);
       56 dcl  inter_code fixed bin (35);
       57 dcl  1 hard_ptrs like hardcore_cur;
       58 dcl  lock_apte_offset fixed bin (18);
       59 dcl  lock_index fixed bin (17);
       60 dcl  lock_word (0:6) bit (36);
       61 dcl  look_for_syserr_sw bit (1);
       62 dcl  loop_exit bit (1);
       63 dcl  1 mc_info (6),
       64        2 ptr ptr,
       65        2 name char (32);
       66 dcl  mc_info_idx fixed bin;
       67 dcl  mc_found_frame_sw bit (1);	
       68 dcl  mc_name char (32);
       69 dcl  no_print_process bit (1);
       70 dcl  pointer_index fixed bin;
       71 dcl  prds_num fixed bin;
       72 dcl  ring_zero_stack bit (1);
       73 dcl  sci_ptr ptr;
       74 dcl  1 scu_inst,
       75        2 address fixed bin unal,
       76        2 pad bit (18) unal;
       77 dcl  stack_base_segno fixed bin;
       78 dcl  stack_idx fixed bin;
       79 dcl  stack_temp_ptrs (0:7) ptr;
       80 dcl  t_pr_name char (4);
       81 dcl  temp_indx fixed bin;
       82 dcl  temp_mcp ptr;
       83 dcl  temp_name char (32) aligned;
       84 dcl  temp_num fixed bin;
       85 dcl  temp_stack_ptr ptr;
       86 dcl  temp_word bit (36) aligned;
       87 dcl  trouble_pending fixed bin (35);
       88 dcl  trouble_pid fixed bin (35);
       89 dcl  words_requested fixed bin (18);
       90 
       91 dcl (trouble_ptr,
       92      trouble_pid_ptr,
       93      lock_ptr,
       94      check_entry_ptr,
       95      stack_ptr,
       96      pds_signal_ptr,
       97      pds_pgflt_ptr,
       98      pds_fim_ptr,
       99      prds_sys_troub_ptr,
      100      prds_int_ptr,
      101      prds_fim_ptr,
      102      real_mcp,
      103      temp_ptr)			ptr;
      104 
      105 /* Based */
      106 
      107 dcl  based_word bit(36) aligned based(temp_ptr);
      108 dcl  1 mc_area like mc based (mcp);
      109 dcl  prs_size (0:7) ptr based;
      110 dcl  1 regs_size like mc.regs based;
      111 
      112 /* Static */
      113 
      114 dcl  PDS_FIM fixed init (1) static options (constant);
      115 dcl  PRDS_FIM fixed init (2) static options (constant);
      116 dcl  PDS_SIG fixed init (3) static options (constant);
      117 dcl  PRDS_SYS fixed init (4) static options (constant);
      118 dcl  PDS_PGF fixed init (5) static options (constant);
      119 dcl  PRDS_INT fixed init (6) static options (constant);
      120 dcl  cpu_names (0:7) char (1) static options (constant) init (
      121 "a", "b", "c", "d", "e", "f", "g", "h");
      122 dcl  lock_seg (0:6) char (32) int static options (constant) init (
      123 "tc_data", "sst_seg", "sst_seg", "scs", "tty_buf", "tty_buf","disk_seg");
      124 dcl  lock_symbol (0:6) char (32) int static options (constant) init (
      125 "apt_lock", "ptl", "astl", "connect_lock", "slock", "timer_lock","lock");
      126 dcl  disk_seg_lock_index fixed bin int static options (constant) init (6);
      127 dcl  ptl_lock_index fixed bin (17) int static options (constant) init (1);
      128 dcl  scu_inst_word fixed bin (18) int static options (constant) init (120);
      129 
      130 /* Entries */
      131 
      132 dcl  amu_$definition_offset entry (ptr, char (*), char (*), fixed bin (35)) returns (fixed bin (18)),
      133      amu_$definition_set_from entry (ptr, char (*), ptr, fixed bin (35)),
      134      amu_$definition_set_prn entry (ptr, char (*), fixed bin, fixed bin (18), fixed bin (35)),
      135      amu_$definition_get_prn entry (ptr, char (*), ptr, fixed bin (35)),
      136      amu_$do_translation_hunt_ptr entry (ptr, ptr, ptr, fixed bin (35)),
      137      amu_$error_for_caller entry () options (variable),
      138      amu_$fdump_mpt_current_process entry (ptr),
      139      amu_$fdump_mpt_change_idx entry (ptr, fixed bin),
      140      amu_$fdump_mpt_revert_idx entry (ptr),
      141      amu_$fdump_mpt_temp_change_idx entry (ptr, fixed bin),
      142      amu_$return_val_idx_from_dbr entry (ptr, fixed bin (24)) returns (fixed bin),
      143      amu_$tc_data_print_this_apte entry (ptr, fixed bin (18), fixed bin (35));
      144 	
      145 
      146 dcl  azm_verify_dump_ams_$af entry (ptr, bit (1), bit (1), fixed bin (35)) returns (bit (1));
      147 dcl  azm_stack_trace_ entry (char(*), ptr, ptr, ptr, bit (1), bit (1), bit (1), bit (1), fixed bin, fixed bin (35));
      148 dcl  azm_stack_trace_$check_for_entry entry (char(*), ptr, ptr, ptr, ptr, fixed bin (35));
      149 dcl  azm_stack_trace_$check_for_mc entry (char(*), ptr, ptr, ptr, bit (1), fixed bin (35));
      150 dcl  azm_stack_trace_$check_for_syserr entry (char(*), ptr, ptr, ptr, fixed bin (35));
      151 dcl  ioa_ entry () options (variable);
      152 dcl  azm_display_mc_ entry (ptr, ptr, ptr, ptr, fixed bin (35));
      153 dcl  amu_$definition_ptr entry (ptr, char (*), char (*), fixed bin (35)) returns (ptr);
      154 dcl  amu_$do_translation entry (ptr, fixed bin, ptr, fixed bin (18), fixed bin (18), fixed bin (35));
      155 dcl  amu_$slt_search_seg_num entry (ptr, ptr, char (32) aligned, fixed bin, fixed bin (35));
      156 dcl  amu_$hardcore_info_set_cur_ptrs entry (ptr, ptr);
      157 dcl  (
      158      amu_et_$not_implemented,
      159      amu_et_$seg_not_dumped,
      160      amu_et_$entry_not_found,
      161      amu_et_$no_valid_stacks,
      162      error_table_$action_not_performed,
      163      error_table_$noentry
      164      ) fixed bin (35) ext static;
      165 
      166 dcl  (addr, baseno, baseptr, hbound, lbound, pointer,
      167       index, null, fixed, rel, rtrim,
      168       size, substr, unspec)		builtin;
      169 
      170 dcl (any_other, cleanup)		condition;
      171 	
      172 
      173 
      174 
      175 azm_why_$find_bad_guy:
      176      entry (P_sci_ptr, P_amu_info_ptr, P_code);
      177 
      178 	amu_info_ptr = P_amu_info_ptr;
      179 	sci_ptr = P_sci_ptr;
      180 	if (amu_info.type ^= FDUMP_TYPE) & (amu_info.type ^= FDUMP_PROCESS_TYPE) then do;
      181 	     P_code = amu_et_$not_implemented;
      182 	     return;
      183 	     end;
      184 	P_code, code = 0;
      185 	loop_exit = "0"b;
      186 	mcp = null();
      187 	on cleanup begin;
      188 	   if mcp ^= null() then free mc_area;
      189 	   end;
      190 	could_not_set_lock_sw, bad_guy_known = "0"b;
      191 	temp_indx = process_idx;
      192 	call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, temp_indx);
      193 						/* remember where */
      194 	hardcore_cur_ptr = addr (hard_ptrs);
      195 	temp_name = "flagbox";
      196 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      197 	call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp, temp_name, temp_num, code);
      198 	if code ^= 0 then do;
      199 	     call ioa_ ("Cannot get flagbox.");
      200 	     goto flagbox_done;
      201 	     end;
      202 	fgbxp = addr (flag_box_area);
      203 	words_requested = hbound (flag_box_area, 1);
      204 	call amu_$do_translation (amu_info_ptr, temp_num, fgbxp, 0, words_requested, code);
      205 	if code ^= 0 then do;
      206 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      207 	     goto flagbox_done;
      208 	     end;
      209 	if index (fgbx.message, " ") = 0 then call ioa_ ("^/Crash Message:^/^5t^a^/", fgbx.message);
      210 flagbox_done:
      211 	if azm_verify_dump_ams_$af (amu_info_ptr, "1"b, "1"b, code) then do;
      212 	     if code ^= 0 then go to NEXT;
      213 	     call ioa_ ("Inconsistency found in Dump Associative Memories.");
      214 	     bootload_cpu_ptr = amu_$definition_ptr (amu_info_ptr, "scs", "bos_processor_tag", code);
      215 	     if code ^= 0 then do;
      216 		call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      217 		P_code = code;
      218 		return;
      219 		end;
      220 	     words_requested = 1;	
      221 	     call amu_$do_translation (amu_info_ptr, fixed (baseno (bootload_cpu_ptr), 17), addr (bootload_cpu_tag),
      222 		fixed (rel (bootload_cpu_ptr), 18), words_requested, code);
      223 	     if code ^= 0 then do;
      224 		call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      225 		P_code = code;
      226 		return;
      227 		end;
      228 	     call ioa_ ("^-Bootload cpu is ^a", cpu_names (bootload_cpu_tag));
      229 	     end;
      230 NEXT:
      231 	an_entry_found_sw,mc_found_frame_sw = "0"b;
      232 	temp_name = "fim";
      233 	call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp, temp_name, fim_num, code);
      234 	allocate mc_area set (mcp);
      235 	scup = addr (mc.scu);
      236 	code = 0;					/*  First is the bad guy in scs$trouble_processid ?? */
      237 	call who_is_it;
      238 	if loop_exit then bad_guy_known = "1"b;		/* Check for fim_type if valid trouble pending */
      239 	trouble_ptr = amu_$definition_ptr (amu_info_ptr, "scs", "sys_trouble_pending", code);
      240 	if code ^= 0 then do;
      241 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      242 	     P_code = code;
      243 	     goto common_return;
      244 	     end;
      245           words_requested = 1;
      246 	call amu_$do_translation (amu_info_ptr, fixed (baseno (trouble_ptr), 17), addr (trouble_pending),
      247 	     fixed (rel (trouble_ptr), 18), words_requested, code);
      248 	if code ^= 0 then do;
      249 	     call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      250 	     P_code = code;
      251 	     goto common_return;
      252 	     end;
      253 	if trouble_pending >= lbound (sys_trouble_reason, 1) & trouble_pending <= hbound (sys_trouble_reason, 1)
      254 	then do;
      255 	     fim_type_fault = "1"b;
      256 	     call mc_info_init;
      257 	     words_requested = size (mc);
      258 	     call amu_$do_translation (amu_info_ptr, fixed (baseno (pds_fim_ptr), 17), mcp,
      259 		fixed (rel (pds_fim_ptr), 18), words_requested, code);
      260 	     if bad_guy_known then goto trouble_type (trouble_pending);
      261 	     else do;
      262 /* This may be a very early dump */
      263 	        mc_info_idx = PDS_FIM;
      264 	        real_mcp = mc_info (mc_info_idx).ptr;
      265 	        mc_name = mc_info (mc_info_idx).name;
      266 	        goto call_fim_type;
      267 	        end;
      268 	     end;
      269 	if ^bad_guy_known then goto could_not_find;
      270 	goto bad_guy_non_fim;
      271 
      272 trouble_type (-7):					/* Execute fault by operator */
      273 
      274           real_mcp = mc_info(PRDS_SYS).ptr;
      275 	mc_name = mc_info (PRDS_SYS).name;
      276 	call amu_$do_translation (amu_info_ptr, fixed (baseno (real_mcp), 17), mcp, fixed (rel (real_mcp), 18), 48,
      277 	     code);          
      278 	if code = 0 then do;
      279 	   temp_word = "0"b;
      280 	   arg_bits_ptr = addr (temp_word);
      281 	   arg_bits_def.ppr = "1"b;
      282 	   call azm_display_mc_ (sci_ptr, amu_info_ptr, mcp, arg_bits_ptr, code);
      283 	   end;
      284 	else call ioa_ ("^a", sys_trouble_reason (trouble_pending));
      285 	code = 0;
      286 	call list_locks ("1"b);
      287 	call check_mcs;
      288 	goto common_return;
      289 
      290 
      291 trouble_type (-4):					/* "Fault/Interrupt with PLT set" */
      292 	call print_the_lock (ptl_lock_index);
      293 	pointer_index = 2;
      294 	goto common_other;
      295 
      296 trouble_type (-1):					/* "Page fault while on prds"  */
      297 						/* page_fault uses the ap pointer to look at machine conditions */
      298 	pointer_index = 0;
      299 	goto common_other;
      300 trouble_type (-2):
      301 trouble_type (-3):
      302 trouble_type (-5):
      303 trouble_type (-6):
      304 trouble_type (-8):
      305 trouble_type (-9):
      306 trouble_type (-10):
      307 trouble_type (-11):					/* just incase others are added */
      308 trouble_type (-12):
      309 trouble_type (-13):
      310 trouble_type (-14):
      311 trouble_type (-15):					/* All others */
      312 	pointer_index = 2;
      313 common_other:
      314 	temp_name = "fault_vector";
      315 	call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp, temp_name, fault_vnum, code);
      316 	if code ^= 0 then do;
      317 	     P_code = code;
      318 	     goto could_not_find;
      319 	     end;
      320 	temp_ptr = addr (scu_inst);
      321 	words_requested = 1;
      322 	call amu_$do_translation (amu_info_ptr, fault_vnum, temp_ptr, scu_inst_word, words_requested, code);
      323 	if code ^= 0 then do;
      324 	     P_code = code;
      325 	     goto could_not_find;
      326 	     end;
      327 	temp_num = scu_inst.address;
      328 	words_requested = size (scu_inst) + 1;
      329 	call amu_$do_translation (amu_info_ptr, fault_vnum, addr (temp_ptr), (temp_num), words_requested, code);
      330 	if code ^= 0 then do;
      331 	     P_code = code;
      332 	     goto could_not_find;
      333 	     end;
      334 	temp_mcp = pointer (temp_ptr,0);
      335 	temp_num = size(prs_size) + size(regs_size);
      336 	temp_num = fixed (rel (temp_ptr), 17) - temp_num;
      337 	temp_num = temp_num + (pointer_index * 2);
      338 	words_requested = 2;
      339 	call amu_$do_translation (amu_info_ptr, fixed (baseno (temp_ptr), 17), addr (temp_mcp), (temp_num), words_requested, code);
      340 	if code ^= 0 then goto could_not_find;
      341 	do mc_info_idx = 1 to 6;
      342 	     if mc_info (mc_info_idx).ptr = temp_mcp then do;
      343 		real_mcp = mc_info (mc_info_idx).ptr;
      344 		mc_name = mc_info (mc_info_idx).name;
      345 		goto call_fim_type;
      346 		end;
      347 	end;
      348 
      349 
      350 could_not_find:					/* could not find the bad guy */
      351 	call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      352 	call ioa_ ("Could not find the failing process.");
      353 
      354 	if fgbx.bce_entry ^= 0 then call ioa_ ("Manual return to BCE ?");
      355 
      356 	if ^could_not_set_lock_sw then call list_locks ("1"b);
      357 common_return:
      358 	if P_code = error_table_$action_not_performed then P_code = 0;
      359 	if ^(an_entry_found_sw | mc_found_frame_sw) then
      360 	   P_code = error_table_$action_not_performed;
      361 	if ^no_print_process then call amu_$fdump_mpt_current_process (amu_info_ptr);
      362           if mcp ^= null() then free mc_area;
      363 	return;
      364 
      365 call_fim_type:
      366 	call ioa_ ("^a", sys_trouble_reason (trouble_pending));
      367 	words_requested = size (mc);
      368 	call amu_$do_translation (amu_info_ptr, fixed (baseno (real_mcp), 17), mcp, fixed (rel (real_mcp), 18), words_requested,
      369 	     code);
      370 	if code ^= 0 then goto could_not_find;
      371 	if ^bad_guy_known  then do;
      372 	   do mc_info_idx = 1 to 6 while (^mc_found_frame_sw);
      373 	      if unspec (scu) = "0"b then do;
      374 	         real_mcp = mc_info (mc_info_idx).ptr;
      375 	         mc_name = mc_info (mc_info_idx).name;
      376 	         call amu_$do_translation (amu_info_ptr,
      377 		  fixed (baseno (real_mcp), 17),
      378 		  mcp, fixed (rel (real_mcp), 18), 48,code);	       
      379 	         end;
      380 	      else do;
      381 	         mc_found_frame_sw = "1"b;
      382 	         call ioa_ ("Will use machine conditions at ^a",mc_name);
      383 	         end;
      384 	      end;
      385 	   end;
      386 	else do;
      387 	   if trouble_pending = trbl_prds_pf then do;
      388 	      if scu.fi_num ^= "10001"b | scu.fi_flag ^= "1"b then
      389 	         goto bad_guy_non_fim;
      390 	      if fixed (baseno (mc.prs (6)), 17) ^=
      391 	         hardcore_info.prds then goto bad_guy_non_fim;
      392 	      end;
      393 	   mc_found_frame_sw = "1"b;
      394 	   end;
      395 	if ^mc_found_frame_sw then goto exit_via_fim;
      396 	call mc_fim_type (bad_guy_known);
      397 	if code ^= 0 then goto exit_via_fim;
      398 	temp_ptr = amu_$definition_ptr (amu_info_ptr, "active_all_rings_data", "stack_base_segno", code);
      399 	if code ^= 0 then do;
      400 	   if bad_guy_known then goto exit_via_fim;
      401 	   else do;
      402 	      on any_other begin;
      403 	        code = error_table_$action_not_performed;
      404 	         goto bad_data;
      405 	         end;
      406 
      407 	      if addr(mc.prs(6)) -> its.its_mod = ITS_MODIFIER then
      408 	         if addr(mc.prs(6)) -> its.mod = "0"b then
      409 	         if mc.prs(6) ^= null () then do;
      410 	      call azm_stack_trace_ ("why", sci_ptr, amu_info_ptr,
      411 	         pointer (mc.prs(6),0), "0"b, "0"b, "0"b, "1"b, 0, code);
      412 	      if code = amu_et_$no_valid_stacks then code = 0;
      413 	      end;
      414 bad_data:	   
      415 	      revert any_other;
      416 	      goto bad_guy_non_fim;
      417 	      end;
      418 	   end;
      419 
      420 	on any_other begin;
      421 	   code = error_table_$action_not_performed;
      422 	   goto bad_stack_data;
      423 	   end;
      424 	if addr(mc.prs(6)) -> its.its_mod = ITS_MODIFIER then
      425 	     if addr(mc.prs(6)) -> its.mod = "0"b then
      426 	          if mc.prs(6) ^= null () then do;
      427 		     call azm_stack_trace_ ("why", sci_ptr, amu_info_ptr, pointer(mc.prs(6),0),
      428 			"0"b, "0"b, "0"b, "1"b, 0, code);
      429 		     if code = amu_et_$no_valid_stacks then code = 0;
      430 		end;
      431 exit_via_fim:
      432 	P_code = code;
      433 	goto common_return;
      434 
      435 
      436 bad_guy_non_fim:
      437 	on any_other begin;
      438 	   code = error_table_$action_not_performed;
      439 	   goto bad_stack_data;
      440 	   end;
      441 	call non_fim_type;
      442 bad_stack_data:
      443 	revert any_other;
      444 	P_code = code;
      445 	goto common_return;				/* end find the bad_guy */
      446 
      447 azm_why_$print_locks:
      448      entry (P_sci_ptr, P_amu_info_ptr, P_lock_symb, P_set, P_code);
      449 dcl P_lock_symb char (*);
      450 dcl P_set bit (1);
      451 	amu_info_ptr = P_amu_info_ptr;
      452 	sci_ptr = P_sci_ptr;
      453 	if (amu_info.type ^= FDUMP_TYPE) & (amu_info.type ^= FDUMP_PROCESS_TYPE) then do;
      454 	     P_code = amu_et_$not_implemented;
      455 	     return;
      456 	     end;
      457 	
      458 	P_code, code = 0;
      459 
      460 	could_not_set_lock_sw, bad_guy_known = "0"b;
      461 	hardcore_cur_ptr = addr (hard_ptrs);
      462 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      463 	if P_lock_symb = "" then call list_locks (P_set);
      464 	else do lock_index = 0 to hbound (lock_symbol, 1);
      465 	   if P_lock_symb = lock_symbol (lock_index) then do;
      466 	      call print_the_lock (lock_index);
      467 	      if P_set then call set_to_lock;
      468 	      end;
      469 	   end;
      470 lock_exit:
      471 	
      472 	P_code = code;
      473 	return;
      474 
      475 azm_why_$who:
      476      entry (P_sci_ptr, P_amu_info_ptr, P_code);
      477 
      478 	amu_info_ptr = P_amu_info_ptr;
      479 	sci_ptr = P_sci_ptr;
      480 	if (amu_info.type ^= FDUMP_TYPE) & (amu_info.type ^= FDUMP_PROCESS_TYPE) then do;
      481 	     P_code = amu_et_$not_implemented;
      482 	     return;
      483 	     end;
      484 	P_code, code = 0;
      485 	hardcore_cur_ptr = addr (hard_ptrs);
      486 	call amu_$hardcore_info_set_cur_ptrs (amu_info_ptr, hardcore_cur_ptr);
      487 	call who_is_it;
      488 	if loop_exit = "0"b then
      489 	     P_code = error_table_$action_not_performed;
      490 	else P_code = 0;
      491 	return;
      492 azm_why_$mcs:
      493      entry (P_sci_ptr, P_amu_info_ptr, P_code);
      494 	amu_info_ptr = P_amu_info_ptr;
      495 	sci_ptr = P_sci_ptr;
      496 	if (amu_info.type ^= FDUMP_TYPE) & (amu_info.type ^= FDUMP_PROCESS_TYPE) then do;
      497 	     P_code = amu_et_$not_implemented;
      498 	     return;
      499 	     end;
      500 	P_code, code = 0;
      501 	mc_found_frame_sw = "0"b;
      502 	call check_mcs;
      503 	if mc_found_frame_sw then P_code = 0;
      504 	else P_code = code;
      505 	return;
      506 
      507 mc_info_init:
      508      proc;
      509 	pds_fim_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "fim_data", code);
      510 	if code ^= 0 then goto could_not_find;
      511 	mc_info (PDS_FIM).ptr = pds_fim_ptr;
      512 	mc_info (PDS_FIM).name = "pds$fim_data";
      513 
      514 	pds_pgflt_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "page_fault_data", code);
      515 	mc_info (PDS_PGF).ptr = pds_pgflt_ptr;
      516 	mc_info (PDS_PGF).name = "pds$page_fault_data";
      517 
      518 	pds_signal_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "signal_data", code);
      519 	mc_info (PDS_SIG).ptr = pds_signal_ptr;
      520 	mc_info (PDS_SIG).name = "pds$signal_data";
      521 
      522 	prds_fim_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "fim_data", code);
      523 	mc_info (PRDS_FIM).ptr = prds_fim_ptr;
      524 	mc_info (PRDS_FIM).name = "prds$fim_data";
      525 
      526 	prds_num = fixed (baseno (mc_info (PRDS_FIM).ptr), 17);
      527 	prds_int_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "interrupt_data", code);
      528 	mc_info (PRDS_INT).ptr = prds_int_ptr;
      529 	mc_info (PRDS_INT).name = "prds$interrupt_data";
      530 
      531 	prds_sys_troub_ptr = amu_$definition_ptr (amu_info_ptr, "prds", "sys_trouble_data", code);
      532 	mc_info (PRDS_SYS).ptr = prds_sys_troub_ptr;
      533 	mc_info (PRDS_SYS).name = "prds$sys_trouble_data";
      534      end mc_info_init;
      535 
      536 non_fim_type:
      537      proc;
      538 
      539 /* Now we must search the stacks (those that can be used by hardcore) for call_bce and syserr_real */
      540 
      541 /* First look for syserr_real */
      542           an_entry_found_sw = "0"b;
      543 	look_for_syserr_sw = "1"b;
      544 	call check_stacks;
      545 	look_for_syserr_sw = "0"b;
      546 	if code ^= 0 then do;
      547 	   if (code ^= amu_et_$entry_not_found) & (code ^= amu_et_$no_valid_stacks) & (code ^= error_table_$noentry)
      548 	      then
      549 	      call amu_$error_for_caller (amu_info_ptr, code, "why", "looking for syserr");
      550 
      551 /* no call to syserr then look for call_bce */
      552 	   check_entry_ptr = amu_$definition_ptr (amu_info_ptr, "call_bce", "call_bce", code);
      553 	   if code ^= 0 then do;
      554 	      call amu_$error_for_caller (amu_info_ptr, code, "why", "looking for call_bce$call_bce");
      555 	      code = 0;
      556 	      goto call_check_mcs;
      557 	      end;
      558 	   call check_stacks;
      559 	   if code = 0 then an_entry_found_sw = "1"b;
      560 	   else code = 0;
      561 	   end;
      562 	else an_entry_found_sw = "1"b;
      563 call_check_mcs:
      564 	call check_mcs;
      565 	if code = error_table_$action_not_performed then code = 0;
      566      end non_fim_type;
      567 
      568 check_mcs: proc;
      569 	code = 0;
      570 	if idle_process () then do;
      571 	   return;		/* idle processes don't have a stack */
      572 	   end;
      573 	temp_ptr = amu_$definition_ptr (amu_info_ptr, "pds", "stacks", code);
      574 	if code ^= 0 then do;
      575 	   return;
      576 	   end;
      577 	words_requested = size (stack_temp_ptrs (*));   
      578 	call amu_$do_translation (amu_info_ptr, fixed (baseno (temp_ptr), 17), addr (stack_temp_ptrs),
      579 	     fixed (rel (temp_ptr), 18), words_requested, code);
      580 
      581 	if code ^= 0 then do;
      582 	   return;
      583 	   end;
      584 	do stack_idx = 7 by -1 to 0;
      585 	   if stack_idx = 0 then
      586 	      ring_zero_stack = "1"b;
      587 	   else ring_zero_stack = "0"b;
      588 	   if stack_temp_ptrs (stack_idx) ^= null then do;
      589 	      call azm_stack_trace_$check_for_mc
      590 	         ("why", sci_ptr, amu_info_ptr, stack_temp_ptrs (stack_idx),
      591 	         ring_zero_stack, code);
      592 	      if code ^= 0 then do;
      593 	         if (code ^= amu_et_$no_valid_stacks) & (code ^= amu_et_$seg_not_dumped)
      594 		  & (code ^= error_table_$action_not_performed) then
      595 		  call amu_$error_for_caller (amu_info_ptr, code,
      596 		  "why", "stack ^p", stack_temp_ptrs (stack_idx));
      597 	         if code = amu_et_$no_valid_stacks then code = 0;
      598 	         end;
      599 	      else mc_found_frame_sw = "1"b;
      600 	      end;
      601 	   end;
      602 	end check_mcs;
      603 
      604 check_stacks:
      605      proc;
      606 
      607 
      608 /* Try prds */
      609 	stack_ptr = baseptr (substr (unspec (hardcore_info.prds), 19));
      610 	if look_for_syserr_sw then
      611 	     call azm_stack_trace_$check_for_syserr ("why", sci_ptr, amu_info_ptr, stack_ptr, code);
      612 	else call azm_stack_trace_$check_for_entry ("why", sci_ptr, amu_info_ptr, stack_ptr, check_entry_ptr, code);
      613 	if code = 0 then do;
      614 	   an_entry_found_sw = "1"b;
      615 	   return;
      616 	   end;
      617 	if code = amu_et_$no_valid_stacks then code = 0;
      618 /* setup for stack_0 */
      619 	temp_ptr = amu_$definition_ptr (amu_info_ptr, "active_all_rings_data", "stack_base_segno", code);
      620 	if code ^= 0 then return;
      621 	words_requested = 1;
      622 	call amu_$do_translation (amu_info_ptr, fixed (baseno (temp_ptr), 17), addr (stack_base_segno),
      623 	     fixed (rel (temp_ptr), 18), words_requested, code);
      624 	if code ^= 0 then return;			/* first check stack_0 */
      625 
      626 	stack_ptr = baseptr (substr (unspec (stack_base_segno), 19));
      627 	if look_for_syserr_sw then
      628 	     call azm_stack_trace_$check_for_syserr ("why", sci_ptr, amu_info_ptr, stack_ptr, code);
      629 	else call azm_stack_trace_$check_for_entry ("why", sci_ptr, amu_info_ptr, stack_ptr, check_entry_ptr, code);
      630 	if code ^= 0 then do;
      631 	     if code = amu_et_$seg_not_dumped then do;	/* stack_0 not in dump try inzr_stk0 */
      632 		code = 0;
      633 		temp_name = "inzr_stk0";
      634 		call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp, temp_name, stack_base_segno,
      635 		     code);
      636 		if code ^= 0 then return;
      637 		stack_ptr = baseptr (substr (unspec (stack_base_segno), 19));
      638 		if look_for_syserr_sw then
      639 		     call azm_stack_trace_$check_for_syserr ("why", sci_ptr, amu_info_ptr, stack_ptr, code);
      640 		else call azm_stack_trace_$check_for_entry ("why", sci_ptr, amu_info_ptr, stack_ptr, check_entry_ptr, code);
      641 		if code = 0 then an_entry_found_sw = "1"b;
      642 		end;
      643 	     end;
      644 	   if code = 0 then an_entry_found_sw = "1"b;
      645      end check_stacks;
      646 
      647 
      648 idle_process:
      649      proc () returns (bit (1));
      650 dcl  based_char char (32) based (t_ptr);
      651 dcl  code fixed bin (35);
      652 dcl  idle_sw bit (1);
      653 dcl  t_data (8) fixed bin (35);
      654 dcl  t_idx fixed bin;
      655 dcl  t_offset fixed bin (18);
      656 dcl  t_ptr ptr;
      657 dcl  t_segno fixed bin;
      658 
      659 	if amu_info.process_info_ptr -> process_info.apte.foreign_ptr = null () then
      660 	     aptep = amu_info.process_info_ptr -> process_info.apte.local_ptr;
      661 	else aptep = amu_info.process_info_ptr -> process_info.apte.foreign_ptr;
      662 	if aptep = null () then return ("0"b);
      663 
      664 	code = 0;
      665 	idle_sw = "0"b;
      666 	call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, amu_info.process_idx);
      667 						/* this way revert will always work */
      668 	t_idx = amu_$return_val_idx_from_dbr (amu_info_ptr, fixed (substr (unspec (apte.dbr), 1, 24), 24));
      669 	if t_idx = -1 then goto END_IDLE;		/* process is not in dump so assume its not idle  */
      670 
      671 	call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, t_idx);
      672 	t_ptr = addr (t_data);
      673 	t_segno = hardcore_info.segno.pds;
      674 	t_offset = amu_$definition_offset (amu_info_ptr, "pds", "process_group_id", code);
      675 	if code ^= 0 then
      676 	     goto END_IDLE;
      677 
      678 	words_requested = size (t_data);
      679 	call amu_$do_translation (amu_info_ptr, t_segno, t_ptr, t_offset, words_requested, code);
      680 	if code ^= 0 then goto END_IDLE;		/* can't get id, assume its not idle */
      681 	if index (based_char, "Idle") ^= 0 then idle_sw = "1"b;
      682 
      683 END_IDLE:
      684 	call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      685 	return (idle_sw);
      686 
      687      end idle_process;
      688 
      689 mc_fim_type:
      690      proc (set_it);
      691 dcl  set_it bit (1);
      692 
      693 	temp_word = "0"b;
      694 	arg_bits_ptr = addr (temp_word);
      695 	arg_bits_def.ppr, arg_bits_def.tpr = "1"b;
      696 	arg_bits_def.set_ptr = set_it;
      697 	call azm_display_mc_ (sci_ptr, amu_info_ptr, mcp, arg_bits_ptr, code);
      698 	if code = 0 & set_it then do;
      699 	     t_pr_name = "prmc";
      700 	     call amu_$definition_set_prn (amu_info_ptr, t_pr_name, fixed (baseno (real_mcp), 17),
      701 		fixed (rel (real_mcp), 18), code);
      702 	     t_pr_name = "prs";
      703 	     call amu_$definition_set_from (amu_info_ptr, t_pr_name, mcp, code);
      704 	     t_pr_name = "pr6";
      705 	     call amu_$definition_get_prn (amu_info_ptr, t_pr_name, temp_ptr, code);
      706 	     temp_stack_ptr = temp_ptr;
      707 	     t_pr_name = "prfr";
      708 	     call amu_$definition_set_prn (amu_info_ptr, t_pr_name, fixed (baseno (temp_ptr), 17),
      709 		fixed (rel (temp_ptr), 18), code);
      710 	     end;
      711      end mc_fim_type;
      712 
      713 list_locks:
      714      proc (set_for_lock);
      715 dcl  set_for_lock bit (1);
      716      lock_word (*) = "0"b;
      717      do lock_index = 0 to hbound (lock_word, 1);
      718         call print_the_lock (lock_index);
      719         end;
      720      if ^set_for_lock then return;
      721 
      722 /* start at 1 because the tc_data lock does not contain a process_id */
      723      do lock_index = 1 to hbound (lock_word, 1);
      724         if lock_word (lock_index) ^= "0"b then do;
      725 	 call set_to_lock;
      726 	 return;
      727 	 end;
      728         end;
      729      could_not_set_lock_sw = "1"b;
      730      end list_locks;
      731 
      732 set_to_lock:
      733       proc;
      734       if lock_word(lock_index) = "0"b then do;
      735          could_not_set_lock_sw = "1"b;
      736          return;
      737          end;
      738 
      739       if process_info.pid = lock_word (lock_index) then do;
      740 						/* this is easy */
      741          no_print_process = "1"b;
      742          call ioa_ ("^a$^a locked by current process",
      743 	  lock_seg (lock_index), lock_symbol (lock_index));
      744          loop_exit = "1"b;
      745          return;
      746          end;
      747       do temp_indx = 0 to hbound (fdump_process_table.array, 1);
      748          if fdump_process_table.array (temp_indx).apte_offset
      749 	  = fixed (substr (unspec (lock_word (lock_index)), 1, 18), 18) then do;
      750 						/* Looks like this is the guy so setup the proc hold for it */
      751 	  call amu_$fdump_mpt_change_idx (amu_info_ptr, temp_indx);
      752 	  call ioa_ ("Setting process for ^a$^a",
      753 	     lock_seg (lock_index), lock_symbol (lock_index));
      754 	  call amu_$fdump_mpt_temp_change_idx (amu_info_ptr, temp_indx);
      755 	  no_print_process = "0"b;
      756 	  return;
      757 	  end;
      758          end;
      759       call ioa_ ("Could not find process holding lock.");
      760       could_not_set_lock_sw = "1"b;
      761       end set_to_lock;
      762 
      763 
      764 print_the_lock:
      765      proc (index);
      766 dcl  seg_symb char (32);
      767 dcl  offset_symb char (32);
      768 dcl  index fixed bin;
      769 dcl  lock_name char (32);
      770 dcl  1 dim_check aligned,
      771      2 pad bit (18) unal,
      772      2 mbz bit (18) unal;
      773 
      774 	seg_symb = lock_seg (index);
      775 	offset_symb = lock_symbol (index);
      776 	lock_name = rtrim (seg_symb) || "$" || rtrim (offset_symb);
      777 	lock_apte_offset = 0;
      778 	if index = disk_seg_lock_index then do;
      779 	   temp_name = "disk_seg";
      780 	   call amu_$slt_search_seg_num (hardcore_cur.sltp, hardcore_cur.sltntp, temp_name, temp_num, code);
      781 	   words_requested = 1;
      782 	   call amu_$do_translation (amu_info_ptr,temp_num,addr(dim_check),
      783 	      fixed(rel(addr(baseptr(temp_num) -> disk_data.array(1))),18), words_requested,code);
      784 	   if dim_check.mbz ^= "0"b then do;
      785 	      call ioa_ ("^5x^32a not found", lock_name);
      786 	      lock_word(index) = "0"b;
      787 	      return;
      788 	      end;
      789 	   lock_ptr = pointer(baseptr(temp_num),
      790 	      fixed(rel(addr(baseptr(temp_num) -> disk_data.lock)),17));
      791 	   end;
      792 	else lock_ptr = amu_$definition_ptr (amu_info_ptr, seg_symb, offset_symb, inter_code);
      793 	temp_ptr = null ();
      794 	call amu_$do_translation_hunt_ptr (amu_info_ptr, lock_ptr, temp_ptr, code);
      795 	if temp_ptr = null then do;
      796 	   lock_word (index) = "0"b;
      797 	   if ^bad_guy_known then do;
      798 	      call ioa_ ("^5x^32a not found", lock_name);
      799 	      return;
      800 	      end;
      801 	   if inter_code ^= 0 then do;
      802 	      call amu_$error_for_caller (amu_info_ptr, inter_code, "why",
      803 	         "Resolving ^a$^a", rtrim (seg_symb),rtrim (offset_symb));
      804 	      code = inter_code;
      805 	      return;
      806 	      end;
      807 	   call amu_$error_for_caller (amu_info_ptr, 0, "why",
      808 	      "Cannot find ^a$^a", rtrim (seg_symb),rtrim (offset_symb));
      809 	   return;
      810 	   end;
      811 
      812 	lock_word (index) = based_word;
      813 	lock_apte_offset = fixed (substr (unspec (based_word), 1, 18), 18);
      814 	if index = 0 then do;
      815 	     call ioa_ ("^5x^32a ^w", lock_name, based_word);
      816 	     return;
      817 	     end;
      818 	if based_word ^= "0"b & substr (based_word, 1, 3) ^= "7"b3 then do;
      819 	     call ioa_ ("^5x^32a locked by:", lock_name);
      820 	     call amu_$tc_data_print_this_apte (amu_info_ptr, lock_apte_offset, code);
      821 	     if code ^= 0 then return;
      822 	     call ioa_ (" ");
      823 	     end;
      824 	else call ioa_ ("^5x^32a ^[unlocked^;^w^]", lock_name, (based_word = "0"b), based_word);
      825      end print_the_lock;
      826 
      827 who_is_it:
      828      proc;
      829 	loop_exit = "0"b;
      830 	no_print_process = "0"b;
      831 	trouble_pid_ptr = amu_$definition_ptr (amu_info_ptr, "scs", "trouble_processid", code);
      832 	if trouble_pid_ptr ^= null () then do;		/* we may know the bad guy */
      833 	     words_requested = 1;
      834 	     call amu_$do_translation (amu_info_ptr, fixed (baseno (trouble_pid_ptr), 17), addr (trouble_pid),
      835 		fixed (rel (trouble_pid_ptr), 18), words_requested, code);
      836 	     if code ^= 0 then do;
      837 		call amu_$fdump_mpt_revert_idx (amu_info_ptr);
      838 		P_code = code;
      839 		return;
      840 		end;
      841 
      842 /* looks better and better */
      843 	     if trouble_pid ^= 0 then do;		/* This should be it */
      844 		if process_info.pid = unspec (trouble_pid) then do;
      845 						/* this is easy */
      846 		     no_print_process = "1"b;
      847 		     loop_exit = "1"b;
      848 		     return;
      849 		     end;
      850 		do temp_indx = 0 to hbound (fdump_process_table.array, 1);
      851 		     if fdump_process_table.array (temp_indx).apte_offset
      852 			= fixed (substr (unspec (trouble_pid), 1, 18), 18) then do;
      853 			call amu_$fdump_mpt_change_idx (amu_info_ptr, temp_indx);
      854 			loop_exit = "1"b;
      855 			end;
      856 		end;
      857 		end;
      858 	     end;
      859      end who_is_it;
      860 
  1     1 /* Begin include file ...... dskdcl.incl.pl1 */
  1     2 
  1     3 /****^  HISTORY COMMENTS:
  1     4*  1) change(85-09-09,Fawcett), approve(85-09-09,MCR6979),
  1     5*     audit(86-01-17,CLJones), install(86-03-21,MR12.0-1033):
  1     6*     Support for FIPS dev 0.
  1     7*  2) change(88-05-10,Farley), approve(88-06-03,MCR7906),
  1     8*     audit(88-08-03,Fawcett), install(88-08-08,MR12.2-1080):
  1     9*     Added reconnect_announce_time to chantab to allow announcement of
  1    10*     reconnects at a throttled rate.  Otherwise only report them in the syserr
  1    11*     log.  Also added IO_TYPE constant array for displaying I/O type.
  1    12*                                                   END HISTORY COMMENTS */
  1    13 
  1    14 /* Structures used by the Disk DIM */
  1    15 
  1    16 /* Modified 84-03-21 by T. Oke for system wide free queue. */
  1    17 /* Modified 84-04-24 by T. Oke for dynamic channel table. */
  1    18 /* Modified 84-05-03 by T. Oke to hold sx for azm analysis. */
  1    19 /* Modified 84-05-14 by T. Oke for larger quentry and adaptive optimization. */
  1    20 /* Modifies 84-11-26 by R. A. Fawcett for device 0 (fips) */
  1    21 
  1    22 /* format: style4,delnl,insnl,tree,ifthenstmt,indnoniterend */
  1    23 
  1    24 dcl  disk_seg$ ext;					/* disk data segment */
  1    25 
  1    26 dcl  disksp ptr,					/* pointer to disk subsystem info */
  1    27      diskp ptr,					/* pointer to disk DIM info structure */
  1    28      optp ptr,					/* pointer to opt_info */
  1    29      sysp ptr;					/* pointer to sys_info */
  1    30 
  1    31 dcl  1 disk_data based (disksp) aligned,		/* disk subsystem information */
  1    32        2 subsystems fixed bin,			/* number of subsystems */
  1    33        2 free_offset bit (18),			/* offset of first unused location in segment */
  1    34        2 status_mask bit (36),			/* mask for checking for disk error */
  1    35        2 lock bit (36) unal,				/* disk_data lock */
  1    36        2 free_q like qht,				/* head/tail offsets */
  1    37        2 free_q_size fixed bin,			/* length of queue */
  1    38        2 array (32),				/* per subsystem info */
  1    39          (
  1    40          3 offset bit (18),				/* location of data for this subsystem */
  1    41          3 mbz bit (18),				/* low 18 of old  style indirect word */
  1    42          3 name char (4)
  1    43          ) unal,					/* name of subsystem */
  1    44        2 stagnate_time fixed bin (35),			/* stagnatation period */
  1    45        2 bail_outs fixed bin (35),			/* times ALM called PL1 */
  1    46        2 pad bit (36),				/* double word align */
  1    47        2 max_depth_reset_time fixed bin (71),		/* time max_reset done */
  1    48 						/* Upper bound is MAX_IO_TYPE, hard coded to avoid dynamic calculation */
  1    49        2 sys_info (0:6) like sys_info,			/* MUST BE DOUBLE WORD ALIGNED */
  1    50        2 free_q_entries (2 refer (disk_data.free_q_size)) like quentry;
  1    51 
  1    52 
  1    53 /* The following system table is used to hold the maximum queue loading
  1    54*   permitted system-wide for each IO type.  From the current loading and
  1    55*   the maximum loading a multiplier fraction is calculated.  These combine
  1    56*   to produce the final optimization multiplier to derive a Logcial Seek
  1    57*   from a Physical Seek. */
  1    58 
  1    59 dcl  1 sys_info aligned based (sysp),
  1    60        3 depth float bin (27),			/* current load */
  1    61        3 max_depth float bin (27),			/* max permissible */
  1    62        3 fraction float bin (27),			/* load fraction */
  1    63        3 depth_map bit (18) unaligned,			/* which depth counter */
  1    64        3 pad bit (18) unaligned;
  1    65 
  1    66 /* Maximum number of channels per sub-system.  Must be a power of two.  It must
  1    67*   be at or below the size of disk_init's chan_array size.  Shift factor is for
  1    68*   dctl's use. */
  1    69 
  1    70 dcl  dskdcl_chans_per_subsys fixed bin static options (constant) initial (32);
  1    71 dcl  dskdcl_chans_per_subsys_shift fixed bin static options (constant) initial (5);
  1    72 
  1    73 
  1    74 dcl  1 disktab based (diskp) aligned,			/* control structure for DIM's */
  1    75        2 lock bit (36) unal,				/* data base lock */
  1    76        2 nchan fixed bin,				/* number of disk channels */
  1    77        2 first_dev fixed bin unal,			/* frist device number  0 or 1 */
  1    78        2 last_dev fixed bin unal,			/* highest disk drive number */
  1    79        2 channels_online fixed bin,			/* number of disk channels actually in use */
  1    80        2 dev_busy bit (72),				/* busy bit for each device (only 0-63 used) */
  1    81        2 dev_queued bit (72),				/* requests queued bit for each device (only 0-63 used) */
  1    82        2 abs_mem_addr fixed bin (26) unsigned,		/* absolute memory address of this structure */
  1    83        2 channels bit (18) unal,			/* location of chantab for this subsystem */
  1    84        2 dev_index fixed bin (17) unal,			/* current device to check */
  1    85        2 errors fixed bin,				/* error count */
  1    86        2 ferrors fixed bin,				/* fatal error count */
  1    87        2 edac_errors fixed bin,			/* count of EDAC correctable errors */
  1    88        2 call_lock_meters like disk_lock_meters,		/* lock meters for call side of DIM */
  1    89        2 int_lock_meters like disk_lock_meters,		/* lock meters for interrupt side of DIM */
  1    90        2 alloc_wait_meters like disk_lock_meters,		/* meters for queue entry allocations */
  1    91        2 run_lock_meters like disk_lock_meters,		/* lock meters for run calls */
  1    92        2 devtab (0:0 refer (disktab.last_dev)) like devtab; /* device information table */
  1    93 
  1    94 dcl  1 disk_channel_table (1 refer (disktab.nchan)) like chantab based aligned;
  1    95 
  1    96 
  1    97 dcl  qp ptr,					/* pointer to queue entry */
  1    98      cp ptr;					/* pointer to channel information table */
  1    99 
  1   100 
  1   101 /* Queue entry, 6 words.  Cylinder and sector variables are over-size for
  1   102*   expansion space.  They will always be positive and upper bits can be
  1   103*   stolen for other fields.
  1   104*
  1   105*   Entries are forward and back linked to permit easy chasing and removal. */
  1   106 
  1   107 dcl  1 quentry based (qp) aligned,			/* queue entry */
  1   108 						/* WORD 1 */
  1   109        2 next bit (18) unaligned,			/* forward link */
  1   110        2 prev bit (18) unaligned,			/* back link */
  1   111 						/* WORD 2 */
  1   112        2 intrpt bit (1) unaligned,			/* completion interrupt desired */
  1   113        2 used bit (1) unaligned,			/* entry in use */
  1   114        2 type fixed bin (4) unsigned unaligned,		/* IO type */
  1   115        2 pad bit (6) unaligned,			/* future expansion */
  1   116        2 coreadd bit (24) unaligned,			/* main memory address */
  1   117 						/* WORD 3 */
  1   118        2 pvtx fixed bin (8) unsigned unaligned,		/* for AZM/ol_dump */
  1   119        2 pdi fixed bin (6) unsigned unaligned,		/* physical device */
  1   120        2 dev fixed bin (6) unsigned unaligned,		/* device in sub-sys */
  1   121        2 pad2 bit (5) unaligned,
  1   122        2 cylinder fixed bin (11) unsigned unaligned,	/* cylinder of request */
  1   123 						/* WORD 4 */
  1   124        2 n_sectors fixed bin (6) unsigned unaligned,	/* # sectors of IO */
  1   125        2 pad3 bit (9) unaligned,
  1   126        2 sector bit (21) unaligned,			/* device sector desired */
  1   127 						/* WORDS 5&6 */
  1   128        2 time fixed bin (71);				/* clock at queue */
  1   129 
  1   130 
  1   131 
  1   132 dcl  1 chantab based (cp) aligned,			/* channel information table */
  1   133        2 chx fixed bin (35),				/* io_manager channel index */
  1   134        2 ioi_ctx fixed bin (35),			/* ioi channel table index */
  1   135        2 statusp ptr,				/* pointer to hardware status word */
  1   136        2 chanid char (8),				/* channel name */
  1   137        (
  1   138        2 pad0 bit (18),
  1   139        2 in_use bit (1),				/* non-zero if channel being used */
  1   140        2 active bit (1),				/* non-zero if channel active */
  1   141        2 rsr bit (1),				/* non-zero if RSR in progress */
  1   142        2 ioi_use bit (1),				/* non-zero if channel usurped by IOI */
  1   143        2 inop bit (1),				/* non-zero if channel inoperative */
  1   144        2 broken bit (1),				/* non-zero if channel broken */
  1   145        2 action_code bit (2),				/* saved from status */
  1   146        2 pad1 bit (10)
  1   147        ) unal,
  1   148        (
  1   149        2 qrp bit (18),				/* rel ptr to queue entry */
  1   150        2 pad2 bit (3),
  1   151        2 command bit (6),				/* peripheral command */
  1   152        2 erct fixed bin (8)
  1   153        ) unal,					/* error retry count */
  1   154        2 select_data,				/* data passed to IOM on select */
  1   155          (
  1   156          3 limit bit (12),				/* limit on number of sectors */
  1   157          3 mbz bit (3),
  1   158          3 sector bit (21)
  1   159          ) unaligned,				/* sector address */
  1   160        2 reconnect_announce_time fixed bin (52),		/* reconnect announcement throttle */
  1   161        2 connect_time fixed bin (52),			/* time of last connect */
  1   162        2 connects fixed bin,				/* count of connects performed */
  1   163        2 detailed_status (0:17) bit (8) unal,		/* detailed status bytes */
  1   164        2 rstdcw bit (36),				/* restore command */
  1   165        2 scdcw bit (36),				/* select command */
  1   166        2 sddcw bit (36),				/* select data xfer */
  1   167        2 dcdcw bit (36),				/* command to read or write */
  1   168        2 dddcw bit (36),				/* data xfer DCW */
  1   169        2 dscdcw bit (36),				/* RSR command */
  1   170        2 dsddcw bit (36),				/* RSR data xfer */
  1   171        2 rssdcw bit (36),				/* RSS command */
  1   172        2 status bit (36) aligned,			/* saved status */
  1   173 						/* Lossage counters for interrupt loss. */
  1   174        2 no_io_terminate fixed bin (35),		/* no t bit from io_manager$get_status */
  1   175        2 terminate_not_active fixed bin (35),		/* terminate, but not active */
  1   176        2 no_status_terminate fixed bin (35),		/* interrupt with no terminate */
  1   177        2 status_from_run fixed bin (35);		/* status missed til run called */
  1   178 
  1   179 dcl  1 qht aligned based,				/* queue head/tail structure */
  1   180        2 sum fixed bin (35),				/* sum of depths */
  1   181        2 count fixed bin (35),			/* allocs */
  1   182        2 max_depth fixed bin (17) unaligned,		/* high water mark */
  1   183        2 depth fixed bin (17) unaligned,		/* current depth */
  1   184        2 head bit (18) unaligned,			/* queue head */
  1   185        2 tail bit (18) unaligned;			/* queue tail */
  1   186 
  1   187 dcl  dp ptr,					/* pointer to device information table */
  1   188      pvtdip ptr;					/* pointer to dim_info in PVT entry */
  1   189 
  1   190 dcl  1 devtab based (dp) aligned,			/* device information table */
  1   191        (
  1   192        2 pvtx fixed bin (8),				/* index of PVT entry for device */
  1   193        2 inop bit (1),				/* device inoperative */
  1   194        2 was_broken bit (1),				/* device previously broken */
  1   195        2 broken bit (1),				/* device down */
  1   196        2 abandoned bit (1),				/* device lost and gone forever */
  1   197        2 forward bit (1),				/* moving low->high */
  1   198        2 pad bit (10),
  1   199        2 buddy unsigned fixed bin (6),			/* other device on this spindle or 0 */
  1   200        2 pdi unsigned fixed bin (6)
  1   201        ) unal,					/* primary device index */
  1   202        2 cylinder fixed bin (35),			/* current cylinder position */
  1   203        2 comb fixed bin (35),				/* number of combs */
  1   204        2 pad1 fixed bin (35),
  1   205        2 time_inop fixed bin (52),			/* time drive became inoperative */
  1   206        2 wq like qht,				/* work queue */
  1   207 						/* Upper bound must be MAX_IO_TYPE, constant to avoid dynamic calculation. */
  1   208        2 opt_info (0:6) like opt_info;			/* optimizer */
  1   209 
  1   210 
  1   211 /* Optimizing table for device. Must be even multiple words long. */
  1   212 /* Slope and intercept define a straight line of y = intercept - slope*x
  1   213*   Multiplier is calculated from this and current system loading.
  1   214*
  1   215*   sys_info is the offset to the relevant system queue loading fraction. */
  1   216 
  1   217 dcl  1 opt_info aligned based (optp),
  1   218        3 multiplier float bin (27),			/* depth mult */
  1   219        3 slope float bin (27),			/* slope of line */
  1   220        3 intercept float bin (27),			/* Y intercept */
  1   221        3 sys_info bit (18) unaligned,			/* offset to sys_info */
  1   222        3 depth fixed bin (17) unaligned,		/* elements in queue */
  1   223        3 channel_wait fixed bin (52),			/* total channel time waiting */
  1   224        3 queue_wait fixed bin (52),			/* total queue time waiting */
  1   225        3 seek_sum fixed bin (35) unaligned,		/* sum of seeks */
  1   226        3 seek_count fixed bin (35) unaligned;		/* number of seeks */
  1   227 
  1   228 
  1   229 dcl  1 pvtdi based (pvtdip) aligned,			/* disk DIM info in PVT entry */
  1   230        (
  1   231        2 sx fixed bin (11),				/* structure index */
  1   232        2 usable_sect_per_cyl fixed bin (11),		/* # of usable sectors on disk cylinder */
  1   233        2 unused_sect_per_cyl fixed bin (11)
  1   234        ) unal;					/* # of unused sectors at end of cylinder */
  1   235 
  1   236 dcl  1 disk_lock_meters based aligned,			/* lock meters for disk DIM */
  1   237        2 count fixed bin,				/* total number of attempts */
  1   238        2 waits fixed bin,				/* number of attempts which required waiting */
  1   239        2 wait_time fixed bin (52);			/* total time spent waiting */
  1   240 
  1   241 dcl  (
  1   242      RST_LISTX init (1),				/* listx for restore */
  1   243      SC_LISTX init (2),				/* listx for select */
  1   244      DSC_LISTX init (6),				/* listx for RSR */
  1   245      RSS_LISTX init (8)
  1   246      ) fixed bin (12) static options (constant);		/* listx for RSS */
  1   247 
  1   248 /* IO types defined.  Value is also index of write_map to determine if
  1   249*   the IO type is a read or a write. */
  1   250 
  1   251 dcl  (
  1   252      PAGE_READ init (0),
  1   253      PAGE_WRITE init (1),
  1   254      VTOC_READ init (2),
  1   255      VTOC_WRITE init (3),
  1   256      TEST init (4),
  1   257      BOOTLOAD_READ init (5),
  1   258      BOOTLOAD_WRITE init (6),
  1   259      MAX_IO_TYPE init (6)
  1   260      ) fixed bin (4) static options (constant);
  1   261 
  1   262 dcl  IO_TYPE (0:6) char (16)
  1   263 	initial ("Page Read", "Page Write", "VTOC Read", "VTOC Write", "Test", "Bootload Read", "Bootload Write")
  1   264 	static options (constant);
  1   265 
  1   266 /* Map indexed by IO type to determine if operation is a read or write. */
  1   267 
  1   268 dcl  write_mapping bit (7) initial ("0101001"b) static options (constant);
  1   269 dcl  write_map (0:6) bit (1) defined (write_mapping);
  1   270 
  1   271 /* Map indexed by IO type to determine if operation is a sector IO. */
  1   272 
  1   273 dcl  sector_mapping bit (7) initial ("0011111"b) static options (constant);
  1   274 dcl  sector_map (0:6) bit (1) defined (sector_mapping);
  1   275 
  1   276 /* Map indexed by IO type to determine if operation is done on behalf of bce */
  1   277 
  1   278 dcl  bootload_mapping bit (7) initial ("0000011"b) static options (constant);
  1   279 dcl  bootload_map (0:6) bit (1) defined (bootload_mapping);
  1   280 
  1   281 /* End of include file ...... dskdcl.incl.pl1 */
      861 
      862 
  2     1 /*  */
  2     2 /* BEGIN INCLUDE FILE  mc.incl.pl1   Created Dec 72 for 6180 - WSS. */
  2     3 /* Modified 06/07/76 by Greenberg for mc.resignal */
  2     4 /* Modified 07/07/76 by Morris for fault register data */
  2     5 /* Modified 08/28/80 by J. A. Bush for the DPS8/70M CVPU */
  2     6 /* Modified '82 to make values constant */
  2     7 
  2     8 /* words 0-15 pointer registers */
  2     9 
  2    10 dcl  mcp ptr;
  2    11 
  2    12 dcl 1 mc based (mcp) aligned,
  2    13     2 prs (0:7) ptr,				/* POINTER  REGISTERS */
  2    14    (2 regs,					/* registers */
  2    15       3 x (0:7) bit (18),				/* index registers */
  2    16       3 a bit (36),					/* accumulator */
  2    17       3 q bit (36),					/* q-register */
  2    18       3 e bit (8),					/* exponent */
  2    19       3 pad1 bit (28),
  2    20       3 t bit (27),					/* timer register */
  2    21       3 pad2 bit (6),
  2    22       3 ralr bit (3),				/* ring alarm register */
  2    23 
  2    24     2 scu (0:7) bit (36),
  2    25 
  2    26     2 mask bit (72),				/* mem controller mask at time of fault */
  2    27     2 ips_temp bit (36),				/* Temporary storage for IPS info */
  2    28     2 errcode fixed bin (35),				/* fault handler's error code */
  2    29     2 fim_temp,
  2    30       3 unique_index bit (18) unal,			/* unique index for restarting faults */
  2    31       3 resignal bit (1) unal,			/* recompute signal name with fcode below */
  2    32       3 fcode bit (17) unal,				/* fault code used as index to FIM table and SCT */
  2    33     2 fault_reg bit (36),				/* fault register */
  2    34     2 pad2 bit (1),
  2    35     2 cpu_type fixed bin (2) unsigned,			/* L68 = 0, DPS8/70M = 1 */
  2    36     2 ext_fault_reg bit (15),				/* extended fault reg for DPS8/70M CPU */
  2    37     2 fault_time bit (54),				/* time of fault */
  2    38 
  2    39     2 eis_info (0:7) bit (36)) unaligned;
  2    40 
  2    41 
  2    42 dcl (apx fixed bin init (0),
  2    43      abx fixed bin init (1),
  2    44      bpx fixed bin init (2),
  2    45      bbx fixed bin init (3),
  2    46      lpx fixed bin init (4),
  2    47      lbx fixed bin init (5),
  2    48      spx fixed bin init (6),
  2    49      sbx fixed bin init (7)) internal static options (constant);
  2    50 
  2    51 
  2    52 
  2    53 
  2    54 dcl  scup ptr;
  2    55 
  2    56 dcl 1 scu based (scup) aligned,			/* SCU DATA */
  2    57 
  2    58 
  2    59 /*	WORD (0)		*/
  2    60 
  2    61    (2 ppr,					/* PROCEDURE POINTER REGISTER */
  2    62       3 prr bit (3),				/* procedure ring register */
  2    63       3 psr bit (15),				/* procedure segment register */
  2    64       3 p bit (1),					/* procedure privileged bit */
  2    65 
  2    66     2 apu,					/* APPENDING UNIT STATUS */
  2    67       3 xsf bit (1),				/* ext seg flag - IT modification */
  2    68       3 sdwm bit (1),				/* match in SDW Ass. Mem. */
  2    69       3 sd_on bit (1),				/* SDW Ass. Mem.  ON */
  2    70       3 ptwm bit (1),				/* match in PTW Ass. Mem. */
  2    71       3 pt_on bit (1),				/* PTW Ass. Mem.  ON */
  2    72       3 pi_ap bit (1),				/* Instr Fetch or Append cycle */
  2    73       3 dsptw bit (1),				/* Fetch of DSPTW */
  2    74       3 sdwnp bit (1),				/* Fetch of SDW non paged */
  2    75       3 sdwp bit (1),				/* Fetch of SDW paged */
  2    76       3 ptw bit (1),				/* Fetch of PTW */
  2    77       3 ptw2 bit (1),				/* Fetch of pre-paged PTW */
  2    78       3 fap bit (1),				/* Fetch of final address paged */
  2    79       3 fanp bit (1),				/* Fetch of final address non-paged */
  2    80       3 fabs bit (1),				/* Fetch of final address absolute */
  2    81 
  2    82     2 fault_cntr bit (3),				/* number of retrys of EIS instructions */
  2    83 
  2    84 
  2    85 /*	WORD (1)		*/
  2    86 
  2    87     2 fd,						/* FAULT  DATA */
  2    88       3 iro bit (1),				/* illegal ring order */
  2    89       3 oeb bit (1),				/* out of execute bracket */
  2    90       3 e_off bit (1),				/* no execute */
  2    91       3 orb bit (1),				/* out of read bracket */
  2    92       3 r_off bit (1),				/* no read */
  2    93       3 owb bit (1),				/* out of write bracket */
  2    94       3 w_off bit (1),				/* no write */
  2    95       3 no_ga bit (1),				/* not a gate */
  2    96       3 ocb bit (1),				/* out of call bracket */
  2    97       3 ocall bit (1),				/* outward call */
  2    98       3 boc bit (1),				/* bad outward call */
  2    99       3 inret bit (1),				/* inward return */
  2   100       3 crt bit (1),				/* cross ring transfer */
  2   101       3 ralr bit (1),				/* ring alarm register */
  2   102       3 am_er bit (1),				/* associative memory fault */
  2   103       3 oosb bit (1),				/* out of segment bounds */
  2   104       3 paru bit (1),				/* processor parity upper */
  2   105       3 parl bit (1),				/* processor parity lower */
  2   106       3 onc_1 bit (1),				/* op not complete type 1 */
  2   107       3 onc_2 bit (1),				/* op not complete type 2 */
  2   108 
  2   109     2 port_stat,					/* PORT  STATUS */
  2   110       3 ial bit (4),				/* illegal action lines */
  2   111       3 iac bit (3),				/* illegal action channel */
  2   112       3 con_chan bit (3),				/* connect channel */
  2   113 
  2   114     2 fi_num bit (5),				/* (fault/interrupt)  number */
  2   115     2 fi_flag bit (1),				/*  1 => fault,  0 => interrupt  */
  2   116 
  2   117 
  2   118 /*	WORD (2)		*/
  2   119 
  2   120     2 tpr,					/* TEMPORARY POINTER REGISTER */
  2   121       3 trr bit (3),				/* temporary ring register */
  2   122       3 tsr bit (15),				/* temporary segment register */
  2   123 
  2   124     2 pad2 bit (9),
  2   125 
  2   126     2 cpu_no bit (3),				/* CPU number */
  2   127 
  2   128     2 delta bit (6),				/* tally modification DELTA */
  2   129 
  2   130 
  2   131 /*	WORD (3)		*/
  2   132 
  2   133     2 word3 bit (18),
  2   134 
  2   135     2 tsr_stat,					/* TSR STATUS for 1,2,&3 word instructions */
  2   136       3 tsna,					/* Word 1 status */
  2   137         4 prn bit (3),				/* Word 1  PR  number */
  2   138         4 prv bit (1),				/* Word 1  PR  valid bit */
  2   139       3 tsnb,					/* Word 2  status */
  2   140         4 prn bit (3),				/* Word 2  PR  number */
  2   141         4 prv bit (1),				/* Word 2  PR  valid bit */
  2   142       3 tsnc,					/* Word 3  status */
  2   143         4 prn bit (3),				/* Word 3  PR  number */
  2   144         4 prv bit (1),				/* Word 3  PR  valid bit */
  2   145 
  2   146     2 tpr_tbr bit (6),				/* TPR.TBR  field */
  2   147 
  2   148 
  2   149 /* 	WORD (4)		*/
  2   150 
  2   151     2 ilc bit (18),					/* INSTRUCTION  COUNTER */
  2   152 
  2   153     2 ir,						/* INDICATOR  REGISTERS */
  2   154       3 zero bit (1),				/* zero indicator */
  2   155       3 neg bit (1),				/* negative indicator */
  2   156       3 carry bit (1),				/* carryry indicator */
  2   157       3 ovfl bit (1),				/* overflow indicator */
  2   158       3 eovf bit (1),				/* eponent overflow */
  2   159       3 eufl bit (1),				/* exponent underflow */
  2   160       3 oflm bit (1),				/* overflow mask */
  2   161       3 tro bit (1),				/* tally runout */
  2   162       3 par bit (1),				/* parity error */
  2   163       3 parm bit (1),				/* parity mask */
  2   164       3 bm bit (1),					/* ^bar mode */
  2   165       3 tru bit (1),				/* truncation mode */
  2   166       3 mif bit (1),				/* multi-word instruction mode */
  2   167       3 abs bit (1),				/* absolute mode */
  2   168       3 hex bit (1),				/* hexadecimal exponent mode */
  2   169       3 pad bit (3),
  2   170 
  2   171 
  2   172 /*	WORD (5)		*/
  2   173 
  2   174     2 ca bit (18),					/* COMPUTED  ADDRESS */
  2   175 
  2   176     2 cu,						/* CONTROL UNIT STATUS */
  2   177       3 rf bit (1),					/* on first cycle of repeat instr */
  2   178       3 rpt bit (1),				/* repeat instruction */
  2   179       3 rd bit (1),					/* repeat double instruction */
  2   180       3 rl bit (1),					/* repeat link instruciton */
  2   181       3 pot bit (1),				/* IT  modification */
  2   182       3 pon bit (1),				/* return type instruction */
  2   183       3 xde bit (1),				/* XDE from Even location */
  2   184       3 xdo bit (1),				/* XDE from Odd  location */
  2   185       3 poa bit (1),				/* operation preparation */
  2   186       3 rfi bit (1),				/* tells CPU to refetch instruction */
  2   187       3 its bit (1),				/* ITS modification */
  2   188       3 if bit (1),					/* fault occured during instruction fetch */
  2   189 
  2   190     2 cpu_tag bit (6)) unaligned,			/* computed tag field */
  2   191 
  2   192 
  2   193 /*	WORDS (6,7)	*/
  2   194 
  2   195     2 even_inst bit (36),				/* even instruction of faulting pair */
  2   196 
  2   197     2 odd_inst bit (36);				/* odd  instruction of faulting pair */
  2   198 
  2   199 
  2   200 
  2   201 
  2   202 
  2   203 
  2   204 /*	ALTERNATE   SCU  DECLARATION		*/
  2   205 
  2   206 
  2   207 dcl 1 scux based (scup) aligned,
  2   208 
  2   209    (2 pad0 bit (36),
  2   210 
  2   211     2 fd,						/* GROUP II  FAULT DATA */
  2   212       3 isn bit (1),				/* illegal segment number */
  2   213       3 ioc bit (1),				/* illegal op  code  */
  2   214       3 ia_am bit (1),				/* illegal address - modifier */
  2   215       3 isp bit (1),				/* illegal slave  procedure */
  2   216       3 ipr bit (1),				/* illegal procedure */
  2   217       3 nea bit (1),				/* non existent address */
  2   218       3 oobb bit (1),				/* out of bounds */
  2   219       3 pad bit (29),
  2   220 
  2   221     2 pad2 bit (36),
  2   222 
  2   223     2 pad3a bit (18),
  2   224 
  2   225     2 tsr_stat (0:2),				/* TSR  STATUS  as an  ARRAY */
  2   226       3 prn bit (3),				/* PR  number */
  2   227       3 prv bit (1),				/* PR  valid bit */
  2   228 
  2   229     2 pad3b bit (6)) unaligned,
  2   230 
  2   231     2 pad45 (0:1) bit (36),
  2   232 
  2   233     2 instr (0:1) bit (36);				/* Instruction ARRAY */
  2   234 
  2   235 
  2   236 
  2   237 /*  END INCLUDE FILE   mc.incl.pl1 */
      863 
      864 
  3     1 /* Begin amu_mc.incl.pl1 */
  3     2 
  3     3 dcl number_val_args fixed bin (17) init (23) static options (constant);
  3     4 
  3     5 dcl valid_mc_arg (24) char (8) init 
  3     6 ("-dump",		    /*  mc from bos dump */
  3     7 "-lg",		    /*  all of the info stored at the given pointer */
  3     8 "-scu","-ppr","-tpr","-inst",   /*  scu data or trs or psr (if scu then not psr nor tsr) */
  3     9 "-reg",		    /*  basic ou regs */
  3    10 "-misc","-code","-flt","-tm", /* misc line of mc data if misc then not others */
  3    11 "-eis",		    /* eis info if MIF flag in scu_data */	
  3    12 "-prs","-pr0","-pr1","-pr2","-pr3","-pr4","-pr5","-pr6","-pr7", /* pointer regs if prs then not the others */
  3    13 "-vbf","-oct","-set")  /* control args */
  3    14  static options (constant);
  3    15 
  3    16 /* the next structuers all all the same real data word and a dcl'ed in
  3    17*     many ways to make the code easer to write and undersand, only time
  3    18*     will tell if this is the correct end result. If any are changed they 
  3    19*     all must by changed, The bit order must corespond to valid_mc_arg */
  3    20 
  3    21 
  3    22 	
  3    23 dcl 1 arg_bits based (arg_bits_ptr) aligned,
  3    24     2 request_arg(number_val_args) bit (1) unal;
  3    25 
  3    26 dcl 1 what_prs based (arg_bits_ptr) aligned,
  3    27     2 pad bit (13) unal,
  3    28     2 pregs (0:7) bit (1) unal,
  3    29     2 padr bit (16);
  3    30 	
  3    31 
  3    32 dcl 1 arg_bits_def based (arg_bits_ptr),
  3    33     2 dump bit (1) unal,
  3    34     2 all bit (1) unal,
  3    35     2 scu bit (1) unal,
  3    36     2 ppr bit (1) unal,
  3    37     2 tpr bit (1) unal,
  3    38     2 inst bit (1) unal,
  3    39     2 regs bit (1) unal,
  3    40     2 xreg (0:7) bit (1) unal,
  3    41     2 areg bit (1) unal,
  3    42     2 qreg bit (1) unal,
  3    43     2 mis bit (1) unal,
  3    44     2 mc_err bit (1) unal,
  3    45     2 flt bit (1) unal,
  3    46     2 tm bit (1) unal,
  3    47     2 eis bit (1) unal,
  3    48     2 prs bit (1) unal,
  3    49     2 pr (0:7) bit (1) unal,
  3    50     2 long bit (1) unal,
  3    51     2 set_ptr bit (1) unal,
  3    52     2 mc_stored bit (1) unal,
  3    53     2 rest_bits bit (1) unal;   /* bits to fill out the word **/
  3    54 	
  3    55 	
  3    56 
  3    57 dcl arg_bits_ptr ptr;
  3    58 	
  3    59 /* End amu_mc.incl.pl1 */
      865 
      866 
  4     1 /*	BEGIN INCLUDE FILE amu_info.incl.pl1		*/
  4     2 
  4     3 dcl 1 amu_info aligned based (amu_info_ptr),
  4     4     2 version char (8) aligned,			/* AMU_INFO_VERSION */
  4     5     2 flags aligned,
  4     6       3 early_dump bit(1) unal,
  4     7       3 pad  bit(35) unal,
  4     8     2 type fixed bin unal,				/* One of the types below */
  4     9     2 time_created fixed bin (71) aligned,		/* time created -- for debugging purposes */
  4    10     2 chain,					/* a chain of all the amu_info's which exist */
  4    11       3 prev pointer unaligned,
  4    12       3 next pointer unaligned,
  4    13 
  4    14     2 area_ptr pointer,				/* pointer to area used for allocating things */
  4    15 
  4    16     2 translation_table_ptr pointer,			/* pointer to address map -- always present */
  4    17 						/*   SEE: amu_translation.incl.pl1 */
  4    18     2 fdump_info_ptr pointer, 			
  4    19 						/* pointer to FDUMP info, present if looking at an FDUMP */
  4    20 						/*   SEE: amu_fdump_info.incl.pl1 */
  4    21 						/* old_uid_table pointer if looking at a SAVED PROC. */
  4    22 						/* See: amu_old_uid_table			*/
  4    23 	
  4    24 
  4    25     2 hardcore_info_ptr pointer,			/* pointer to hardcore information -- always present */
  4    26 						/*   SEE: amu_hardcore_info.incl.pl1 */
  4    27     2 copy_chain pointer,				/* pointer to info about segment copies */
  4    28 						/*   SEE: amu_copy_info.incl.pl1 */
  4    29     2 process_info_ptr pointer,			/* pointer to process info for this translation */
  4    30 						/*   SEE: amu_process_info.incl.pl1 */
  4    31     2 process_idx fixed bin,				/* index of process in translation-specifc process table */
  4    32 
  4    33     2 proc_idx_hold fixed bin,			/* a place to keep the index when a changing to another proc */
  4    34 
  4    35     2 error_info,					/* various info about how amu_error_ is to behave */
  4    36       3 error_flags aligned,
  4    37         4 handler_exists bit (1) unaligned,		/* set to indicate existence of an amu_error handler */
  4    38         4 in_subsystem bit (1) unaligned,		/* This amu_info belongs to an ssu_ maintained subsystem */
  4    39         4 pad bit (34) unaligned,
  4    40       3 sci_ptr pointer,				/* sci_ptr for subsystem, if in_subsystem = "1"b */
  4    41     2 definitions_info_ptr ptr;
  4    42 
  4    43 dcl  amu_area area based (amu_info.area_ptr);
  4    44 
  4    45 dcl  amu_info_ptr pointer;
  4    46 
  4    47 dcl (FDUMP_TYPE		init (1037),		/* the various legitimate types of amu_info's */
  4    48      FDUMP_PROCESS_TYPE	init (1038),
  4    49      ONLINE_TYPE		init (1039),
  4    50      ONLINE_PROCESS_TYPE	init (1040),
  4    51      NETWORK_FDUMP_TYPE	init (1041),
  4    52      NETWORK_ONLINE_TYPE	init (1042),
  4    53      SAVED_PROC_TYPE	init (1043),
  4    54      INDIRECT_TYPE		init (1044)) fixed bin internal static options (constant);
  4    55 
  4    56 dcl  AMU_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_v1");
  4    57 dcl  AMU_INFO_VERSION char (8) internal static options (constant) init ("amu_v1");
  4    58 dcl  AMU_INFO_VERSION_2 char (8) internal static options (constant) init ("amu_v2");
  4    59 
  4    60 dcl  PDIR_SUFFIX		char(4) init("pdir") int static options(constant);
  4    61 
  4    62 /*	END INCLUDE FILE amu_info.incl.pl1		*/
      867 
      868 
  5     1 /*	BEGIN INCLUDE FILE amu_process_info.incl.pl1	*/
  5     2 
  5     3 /* This structure describes information about a single process in an address
  5     4*   translation. It is only relevant for translations involving the online system
  5     5*   or an FDUMP. */
  5     6 
  5     7 dcl 1 process_info aligned based (amu_info.process_info_ptr), /* information about a single process */
  5     8     2 pid bit (36) aligned,				/* process_id of this process */
  5     9     2 address_map_ptr pointer unaligned,		/* pointer to address map */
  5    10     2 idx fixed bin,				/* index of process in FDUMP, or apte index if online */
  5    11     2 state fixed bin,				/* state, from the APTE -- only good for FDUMP */
  5    12 
  5    13     2 dbr fixed bin (71),				/* DBR of this process */
  5    14 
  5    15     2 apte aligned, 				/* pointer to this process's APTE */
  5    16       3 foreign_ptr pointer unaligned,
  5    17       3 local_ptr pointer unaligned,
  5    18     2 prds aligned like process_info.apte, 		/* and PRDS, IFF it has one (is running) -- volatile */
  5    19     2 dseg aligned like process_info.apte, 		/* DSEG -- These values must be constantly recalculated */
  5    20     2 pds aligned like process_info.apte,		/* PDS --- for an online process, if phcs transparency */
  5    21     2 kst aligned like process_info.apte,		/* KST --- is not in use. */
  5    22 
  5    23     2 dump_segx,					/* index of first and last seg belonging to this */
  5    24       3 first fixed bin,				/* process in bos_dump.seg_array, or zero if none */
  5    25       3 last fixed bin,				/* this information is only valid for a process in a dump */
  5    26 
  5    27     2 pad1 fixed bin;
  5    28 
  5    29 /*	END INCLUDE FILE amu_process_info.incl.pl1	*/
      869 
      870 
  6     1 /*	BEGIN INCLUDE FILE amu_fdump_info.incl.pl1	*/
  6     2 
  6     3 dcl 1 fdump_info aligned based (amu_info.fdump_info_ptr),
  6     4     2 version char (8),
  6     5     2 ref_count fixed bin,				/* number of initiations */
  6     6 
  6     7     2 erf_name char (32),				/* ERF name for this dump */
  6     8     2 dump_dname char (168),				/* location of the dump */
  6     9     2 dump_ename char (32),				/* ename of component zero */
  6    10     2 system_id char (8),				/* the system_id of this erf */
  6    11     2 version_id char (8),				/* the version id of this erf */
  6    12     2 dump_seg_0_uid bit (36) aligned,			/* for determining EQ-ness and gullibility checking */
  6    13 
  6    14     2 n_dump_segs fixed bin,				/* number of real segs in the dump */
  6    15     2 copy_block_ptr pointer, 			/* pointer to chain of temp segment blocks */
  6    16 
  6    17     2 dump_seg_ptr (0:31) pointer,			/* pointer and length arrays */
  6    18     2 dump_seg_lth (0:31) fixed bin (18),
  6    19 
  6    20     2 fdump_process_table_ptr pointer;			/* pointer to array describing processes */
  6    21 
  6    22 
  6    23 dcl 1 fdump_process_table aligned based (fdump_info.fdump_process_table_ptr),
  6    24     2 size fixed bin,				/* number of entries */
  6    25 
  6    26     2 array (0:alloc_fdump_process_table_size - 1 refer (fdump_process_table.size)) like fp_table;
  6    27 
  6    28 dcl 1 fp_table based (fp_table_ptr),
  6    29       2 first_seg fixed bin,
  6    30       2 last_seg fixed bin,
  6    31       2 process_info_ptr pointer unaligned,		/* pointer to process_info structure, if filled in */
  6    32       2 dmp_seg_indx fixed bin,			/* dump seg index where process can be found */
  6    33       2 dmp_seg_offset fixed bin (24),			/* offset in the segment refered to by dmp_seg_indx where process starts */
  6    34       2 cpu_name char (1),
  6    35       2 dbr fixed bin (24),				/* address portion of DBR */
  6    36       2 apte_offset fixed bin (18);
  6    37 
  6    38 dcl fp_table_ptr ptr;
  6    39 
  6    40 dcl  alloc_fdump_process_table_size fixed bin;
  6    41 
  6    42 dcl  AMU_FDUMP_INFO_VERSION_1 char (8) internal static options (constant) init ("amu_erf1");
  6    43 dcl  AMU_FDUMP_INFO_VERSION char (8) internal static options (constant) init ("amu_erf1");
  6    44 
  6    45 /*	END INCLUDE FILE amu_fdump_info.incl.pl1	*/
      871 
      872 
  7     1 /*	BEGIN INCLUDE FILE amu_hardcore_info.incl.pl1	*/
  7     2 
  7     3 /* This structure contains information about the hardcore supervisor address
  7     4*   space for an address translation. */
  7     5 
  7     6 dcl 1 hardcore_info aligned based (amu_info.hardcore_info_ptr),
  7     7 
  7     8     2 pointers,					/* assorted pointers to various useful items */
  7     9       3 slt aligned,				/* SLT */
  7    10         4 fptr pointer unaligned,			/* address in foreign address space */
  7    11         4 lptr pointer unaligned,			/* location in local address space */
  7    12       3 sltnt aligned like hardcore_info.slt,		/* SLT names segment */
  7    13       3 definitions aligned like hardcore_info.slt,	/* hardcore definitions_ segment */
  7    14 
  7    15       3 sst aligned like hardcore_info.slt,		/* SST */
  7    16       3 tc_data aligned like hardcore_info.slt,		/* TC_DATA */
  7    17       3 sstnt aligned like hardcore_info.slt,		/* SSTNT (if any -- foreign_ptr = null if not) */
  7    18       3 upt aligned like hardcore_info.slt,		/* unpaged_page_tables (if any -- foreign_ptr = null if not) */
  7    19 
  7    20     2 segno,					/* segment numbers of various per-process/per-processor segs */
  7    21       3 prds fixed bin (15),				/* segno of PRDS */
  7    22       3 dseg fixed bin (15),				/* DSEG */
  7    23       3 pds fixed bin (15),				/* PDS */
  7    24       3 kst fixed bin (15),				/* KST */
  7    25       3 stack_0 fixed bin (15),			/* segno of stack_0 -- first one in stack group */
  7    26       3 unpaged_page_tables fixed bin(15),		/* segno of unpaged_page_tables if it exists */
  7    27 
  7    28     2 apt,					/* information about the APT */
  7    29       3 foreign_ptr pointer unaligned,			/* foreign and local pointers to tcm.apt */
  7    30       3 local_ptr pointer unaligned,
  7    31       3 count fixed bin,				/* number of APTEs */
  7    32       3 size fixed bin,				/* size of a single APTE */
  7    33 
  7    34     2 hcs_count fixed bin,				/* highest hardcore segno */
  7    35 
  7    36     2 pad1 fixed bin;
  7    37 
  7    38 dcl hardcore_cur_ptr ptr;
  7    39 
  7    40 dcl 1 hardcore_cur based (hardcore_cur_ptr),
  7    41     2 sltp ptr,
  7    42     2 sltntp ptr,
  7    43     2 defp ptr,
  7    44     2 sstp ptr,
  7    45     2 tc_datap ptr,
  7    46     2 sstntp ptr,
  7    47     2 uptp ptr;
  7    48 	
  7    49     
  7    50 
  7    51 
  7    52 /*	END INCLUDE FILE amu_hardcore_info.incl.pl1	*/
      873 
      874 
  8     1 /* BEGIN INCLUDE FILE ... flagbox.incl.pl1 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(87-02-26,Farley), approve(87-04-15,MCR7661),
  8     6*     audit(87-04-21,Fawcett), install(87-04-28,MR12.1-1028):
  8     7*     Added io_reconfig flag to inhibit BCE from attempting an emergency
  8     8*     shutdown when the data in memory could be corrupted.
  8     9*                                                   END HISTORY COMMENTS */
  8    10 
  8    11 
  8    12 /* last modified 5/3/77 by Noel I. Morris	*/
  8    13 /* Modified 8/79 by R.J.C. Kissel to add FNP blast message. */
  8    14 /* Modified 7/82 BIM for recognizable sentinel field */
  8    15 /* Modified for bootload Multics flagbox starting in 8/83 by Keith Loepere. */
  8    16 
  8    17 /* The contents of this segment are data shared by Multics and bce.
  8    18*   This entity occupies the locations within the toehold starting at 40o
  8    19*   (not counting the toehold_used spacer at the beginning). */
  8    20 
  8    21 dcl  flagbox$ ext;
  8    22 dcl  fgbxp ptr;
  8    23 
  8    24 dcl 1 fgbx based (fgbxp) aligned,
  8    25     2 toehold_used (32) bit (36) aligned,		/* flagbox seg now mapped onto all of first page of toehold -
  8    26*						This is what was unused before. */
  8    27     2 flags (36) bit (1) unal,			/* communications switches */
  8    28     2 slt_segno bit (18),				/* segment # of the SLT */
  8    29     2 pad1 fixed bin,
  8    30     2 rtb,					/* return to bce info */
  8    31      (3 ssenb bit (1),				/* "1"b if storage system enabled */
  8    32       3 call_bce bit (1),				/* "1"b if bce called by operator */
  8    33       3 shut bit (1),				/* "1"b if bce called after shutdown */
  8    34       3 mess bit (1),				/* "1"b if message has been provided */
  8    35       3 alert bit (1),				/* "1"b if audible alarm to be sounded */
  8    36       3 breakpoint bit (1),				/* "1"b is breakpoint caused call to bce */
  8    37       3 manual_crash bit (1),				/* either manual entry or execute fault */
  8    38       3 io_reconfig bit (1),				/* "1"b if I/O reconfiguration */
  8    39 						/* could cause memory corruption */
  8    40       3 pad bit (21),
  8    41       3 bce_entry fixed bin (6) uns) unal,		/* type of entry into bce
  8    42*						   00o => Multics entry
  8    43*						   20o => manual entry
  8    44*						   40o => esd entry */
  8    45     2 sentinel char (32) aligned,			/* set by bce (for now) */
  8    46     2 sst_sdw bit (72),				/* set by init_sst */
  8    47     2 hc_dbr bit (72),				/* set by start_cpu, idle DBR */
  8    48     2 message char (64),				/* message for return to bce */
  8    49     2 return_to_bce_command char (128) unal;		/* command to run upon crash/shutdown */
  8    50 
  8    51 declare FLAGBOX_SENTINEL char (32) init ("Flagbox & Toehold Valid") int static options (constant);
  8    52 
  8    53 /* END INCLUDE FILE ... flagbox.incl.pl1 */
      875 
      876 
  9     1 /* Begin include file sys_trouble_codes.incl.pl1 changed BIM 82-13-05 */
  9     2 /* Made sys_trouble_reason char (36) so as to hold strings defined, KPL */
  9     3 /* format: style3 */
  9     4 
  9     5 dcl	sys_trouble_reason	(-11:-1) char (36) var static options (constant) init (
  9     6 						/** **/
  9     7 			"Ring 0 derail",		/** 11 never print this */
  9     8 			"Fault while in bound_interceptors",
  9     9 						/** 10 **/
  9    10 			"Fault while in masked environment",
  9    11 						/** 9 **/
  9    12 			"Out-of-Segment-Bound on prds",
  9    13 						/** 8 **/
  9    14 			"Execute fault by operator",	/** 7 **/
  9    15 			"Unexpected fault",		/** 6 **/
  9    16 			"Unrecognized fault",	/** 5 **/
  9    17 			"Fault/Interrupt with PTL set",
  9    18 						/** 4 **/
  9    19 			"Fault in idle process",	/** 3 **/
  9    20 			"Fault/Interrupt while on prds",
  9    21 						/** 2 **/
  9    22 			"Page fault while on prds"	/** 1 **/
  9    23 			);
  9    24 
  9    25 dcl	trbl_r0_drl_flt	fixed bin (35) init (-11) static options (constant);
  9    26 dcl	trbl_fim_flt	fixed bin (35) init (-10) static options (constant);
  9    27 dcl	trbl_fault_masked	fixed bin (35) init (-9) static options (constant);
  9    28 dcl	trbl_oosb_prds	fixed bin (35) init (-8) static options (constant);
  9    29 dcl	trbl_exec_flt	fixed bin (35) init (-7) static options (constant);
  9    30 dcl	trbl_unexp_flt	fixed bin (35) init (-6) static options (constant);
  9    31 dcl	trbl_illeg_flt	fixed bin (35) init (-5) static options (constant);
  9    32 dcl	trbl_ptl_fi	fixed bin (35) init (-4) static options (constant);
  9    33 dcl	trbl_idle_flt	fixed bin (35) init (-3) static options (constant);
  9    34 dcl	trbl_prds_fi	fixed bin (35) init (-2) static options (constant);
  9    35 dcl	trbl_prds_pf	fixed bin (35) init (-1) static options (constant);
  9    36 
  9    37 /* End include file sys_trouble_codes.incl.pl1 */
      877 
      878 
 10     1 /*  BEGIN INCLUDE FILE ... apte.incl.pl1 */
 10     2 
 10     3 /* Modified 1984-11-11 by E. Swenson for IPC event channel validation. */
 10     4 
 10     5 dcl  aptep pointer;
 10     6 
 10     7 dcl 1 apte based (aptep) aligned,			/* APT entry declaration for an active (known) process */
 10     8     2 thread unaligned,				/* List thread */
 10     9       3 fp bit (18),				/* Forward pointer */
 10    10       3 bp bit (18),				/* Backward pointer */
 10    11     2 flags unaligned,				/* Flags and miscellaneous */
 10    12       3 mbz bit (1),				/* This bit must be zero (sentinel bit) */
 10    13       3 wakeup_waiting bit (1),			/* ON if process has received wakeup */
 10    14       3 stop_pending bit (1),				/* ON if process has received stop connect */
 10    15       3 pre_empted bit (1),				/* ON if process is being pre-empted by get_processor */
 10    16       3 hproc bit (1),				/* ON if process is hardcore process */
 10    17       3 loaded bit (1),				/* ON if required per-process pages are in memory and wired */
 10    18       3 eligible bit (1),				/* ON if process is eligible */
 10    19       3 idle bit (1),				/* ON if  this is an idle process */
 10    20       3 interaction bit (1),				/* ON if process has interacted recently */
 10    21       3 pre_empt_pending bit (1),			/* ON if process has received pre-empt connect */
 10    22       3 default_procs_required bit (1),			/* ON if apte.procs_required is system default */
 10    23       3 realtime_burst bit (1),			/* ON if next eligibility is realtime */
 10    24       3 always_loaded bit (1),			/* ON if process is not to be unloaded */
 10    25       3 dbr_loaded bit (1),				/* ON if DBR is loaded on some CPU */
 10    26       3 being_loaded bit (1),				/* ON if somebody loading this process */
 10    27       3 shared_stack_0 bit (1),			/* ON if a shared stack_0 is assigned */
 10    28       3 page_wait_flag bit (1),			/* flag ON if waiting for page */
 10    29       3 firstsw bit (1),				/* OFF until process is intialized */
 10    30       3 state bit (18),				/* execution state */
 10    31     2 page_faults fixed bin (35),			/* total page faults for the process */
 10    32     2 processid bit (36),				/* bit 0-17: offset of ATPE */
 10    33 						/* bit 18-35: sequential number */
 10    34     2 te fixed bin (35),				/* virtual time since eligibility award */
 10    35     2 ts fixed bin (35),				/* virtual time since scheduling */
 10    36     2 ti fixed bin (35),				/* virtual time since interaction */
 10    37     2 timax fixed bin (35),				/* maximum value allowed for apte.ti */
 10    38 
 10    39 /* * * * * * * * */
 10    40 
 10    41     2 ipc_pointers unaligned,
 10    42       3 event_thread bit (18),			/* relative pointer to ITT list */
 10    43       3 pad3 bit (18),
 10    44     2 ips_message bit (36),				/* IPS signals pending */
 10    45     2 asteps unaligned,				/* relative ASTE pointers */
 10    46       3 pds bit (18),				/* PDS (per-process) */
 10    47       3 dseg bit (18),				/* DSEG (per-process) */
 10    48       3 prds bit (18),				/* PRDS (per-processor) */
 10    49     2 savex7 bit (18) unaligned,			/* x7 at call to getwork (return point in pxss) */
 10    50     2 term_processid bit (36),			/* process to send wakeup at temination */
 10    51     2 lock_id bit (36),				/* File System unqieu ID associated with process */
 10    52     2 time_used_clock fixed bin (71),			/* Total CPU time when process last lost CPU */
 10    53 
 10    54 /* * * * * * * * */
 10    55 
 10    56     2 wait_event bit (36) aligned,			/* Event ID process awaiting */
 10    57     2 wct_index bit (18) unaligned,			/* rel offset of WCTE */
 10    58     2 flags2 unaligned,
 10    59       3 priority_scheduling bit (1),			/* ON if guaranteed eligibility */
 10    60       3 special_wakeups bit (6),			/* Special wakeup channels */
 10    61       3 pad7 bit (7),
 10    62       3 batch bit (1),				/* ON if absentee */
 10    63       3 pr_tag bit (3),				/* CPU tag running or last run */
 10    64     2 state_change_time fixed bin (71),			/* Time apte.state last changed */
 10    65     2 alarm_event fixed bin (71),			/* wakeup event for alarm clock manager */
 10    66     2 alarm_time_thread bit (18) unaligned,		/* thread of processes with pending alarms */
 10    67     2 alarm_time bit (54) unaligned,			/* wakeup time for alarm */
 10    68 
 10    69 /* * * * * * */
 10    70 
 10    71     2 term_channel fixed bin (71),			/* wakeup event for account overflow */
 10    72     2 ws_size fixed bin,				/* working set estimate for the process */
 10    73     2 temax fixed bin (35),				/* maximum eligibility slice (vcpu) */
 10    74     2 deadline fixed bin (71),			/* time of next run */
 10    75     2 lock bit (18) unaligned,			/* 0 => APTE locked, unlocked => return point of last unlock */
 10    76     2 unusable bit (18) unaligned,			/* locking routines destroy */
 10    77     2 cpu_monitor fixed bin (35),			/* if not 0, send wakeup to term_processid when virtual cpu
 10    78*						/* reaches this (units = 1/1024 sec) */
 10    79     2 paging_measure fixed bin (71),			/* cumulative memory units */
 10    80     2 access_authorization bit (72),			/* authorization of this process */
 10    81     2 dbr fixed bin (71),				/* DBR value (constant since DSEG entry-held) */
 10    82 
 10    83     2 virtual_cpu_time fixed bin (71),			/* cumulative virtual CPU time for the process */
 10    84     2 ittes_sent fixed bin (18),			/* Unprocessed ITTs sent by this process */
 10    85     2 ittes_got fixed bin (18),			/* Unprocessed ITTs received by this process */
 10    86 
 10    87 /*  Cells used to drive and instrument finite-state model for response time
 10    88*    measurement. Maintained by meter_response_time */
 10    89 
 10    90     2 current_response_state fixed bin (17) unaligned,	/* Process state in modle */
 10    91     2 pad18 bit (18) unaligned,
 10    92     2 number_processing fixed bin (35),			/* Number interactions */
 10    93     2 last_response_state_time fixed bin (71),		/* Clock time at last response state change */
 10    94     2 total_processing_time fixed bin (71),		/* Total interaction processing time */
 10    95 
 10    96 /* * * * * * */
 10    97 
 10    98     2 begin_interaction_vcpu fixed bin (71),		/* Virtual cpu at beginning of last interaction */
 10    99 
 10   100 /*  End of cells for finite-state model */
 10   101 
 10   102     2 saved_temax fixed bin (35),			/* temax at eligibility award */
 10   103     2 procs_required bit (8) unaligned,			/* bit mask of CPUs this process can run */
 10   104     2 pad4 bit (28) unaligned,
 10   105     2 ipc_r_offset fixed bin (18) unsigned,
 10   106     2 ipc_r_factor fixed bin (35) unsigned,
 10   107     2 apad (10) fixed bin (35);
 10   108 
 10   109 /*  END INCLUDE FILE ... apte.incl.pl1 */
      879 
      880 
 11     1 /* BEGIN INCLUDE FILE its.incl.pl1
 11     2*   modified 27 July 79 by JRDavis to add its_unsigned
 11     3*   Internal format of ITS pointer, including ring-number field for follow-on processor */
 11     4 
 11     5 dcl 1 its based aligned,				/* declaration for ITS type pointer */
 11     6     2 pad1 bit (3) unaligned,
 11     7     2 segno bit (15) unaligned,			/* segment number within the pointer */
 11     8     2 ringno bit (3) unaligned,			/* ring number within the pointer */
 11     9     2 pad2 bit (9) unaligned,
 11    10     2 its_mod bit (6) unaligned,			/* should be 43(8) */
 11    11 
 11    12     2 offset bit (18) unaligned,			/* word offset within the addressed segment */
 11    13     2 pad3 bit (3) unaligned,
 11    14     2 bit_offset bit (6) unaligned,			/* bit offset within the word */
 11    15     2 pad4 bit (3) unaligned,
 11    16     2 mod bit (6) unaligned;				/* further modification */
 11    17 
 11    18 dcl 1 itp based aligned,				/* declaration for ITP type pointer */
 11    19     2 pr_no bit (3) unaligned,			/* number of pointer register to use */
 11    20     2 pad1 bit (27) unaligned,
 11    21     2 itp_mod bit (6) unaligned,			/* should be 41(8) */
 11    22 
 11    23     2 offset bit (18) unaligned,			/* word offset from pointer register word offset */
 11    24     2 pad2 bit (3) unaligned,
 11    25     2 bit_offset bit (6) unaligned,			/* bit offset relative to new word offset */
 11    26     2 pad3 bit (3) unaligned,
 11    27     2 mod bit (6) unaligned;				/* further modification */
 11    28 
 11    29 
 11    30 dcl 1 its_unsigned based aligned,			/* just like its, but with unsigned binary */
 11    31     2 pad1 bit (3) unaligned,
 11    32     2 segno fixed bin (15) unsigned unaligned,
 11    33     2 ringno fixed bin (3) unsigned unaligned,
 11    34     2 pad2 bit (9) unaligned,
 11    35     2 its_mod bit (6) unaligned,
 11    36 
 11    37     2 offset fixed bin (18) unsigned unaligned,
 11    38     2 pad3 bit (3) unaligned,
 11    39     2 bit_offset fixed bin (6) unsigned unaligned,
 11    40     2 pad4 bit (3) unaligned,
 11    41     2 mod bit (6) unaligned;
 11    42 
 11    43 dcl 1 itp_unsigned based aligned,			/* just like itp, but with unsigned binary where appropriate */
 11    44     2 pr_no fixed bin (3) unsigned unaligned,
 11    45     2 pad1 bit (27) unaligned,
 11    46     2 itp_mod bit (6) unaligned,
 11    47 
 11    48     2 offset fixed bin (18) unsigned unaligned,
 11    49     2 pad2 bit (3) unaligned,
 11    50     2 bit_offset fixed bin (6) unsigned unaligned,
 11    51     2 pad3 bit (3) unaligned,
 11    52     2 mod bit (6) unaligned;
 11    53 
 11    54 
 11    55 dcl  ITS_MODIFIER bit (6) unaligned internal static options (constant) init ("43"b3);
 11    56 dcl  ITP_MODIFIER bit (6) unaligned internal static options (constant) init ("41"b3);
 11    57 
 11    58 /* END INCLUDE FILE   its.incl.pl1 */
      881 
      882 
      883 
      884      end azm_why_;
      885 
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/08/88  1115.1  azm_why_.pl1                      >special_ldd>install>MR12.2-1080>azm_why_.pl1
861          1    08/08/88  1111.3  dskdcl.incl.pl1                   >special_ldd>install>MR12.2-1080>dskdcl.incl.pl1
863          2    12/15/83  1100.4  mc.incl.pl1                       >ldd>include>mc.incl.pl1
865          3    09/22/83  1102.5  amu_mc.incl.pl1                   >ldd>include>amu_mc.incl.pl1
867          4    11/20/84  0856.1  amu_info.incl.pl1                 >ldd>include>amu_info.incl.pl1
869          5    11/20/84  0856.2  amu_process_info.incl.pl1         >ldd>include>amu_process_info.incl.pl1
871          6    09/22/83  1102.5  amu_fdump_info.incl.pl1           >ldd>include>amu_fdump_info.incl.pl1
873          7    11/20/84  0854.8  amu_hardcore_info.incl.pl1        >ldd>include>amu_hardcore_info.incl.pl1
875          8    04/30/87  1513.7  flagbox.incl.pl1                  >ldd>include>flagbox.incl.pl1
877          9    07/11/84  0937.3  sys_trouble_codes.incl.pl1        >ldd>include>sys_trouble_codes.incl.pl1
879         10    01/06/85  1422.2  apte.incl.pl1                     >ldd>include>apte.incl.pl1
881         11    11/26/79  1320.6  its.incl.pl1                      >ldd>include>its.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
FDUMP_PROCESS_TYPE                     constant        fixed bin(17,0)          initial dcl 4-47 ref 180 453 480 496
FDUMP_TYPE                             constant        fixed bin(17,0)          initial dcl 4-47 ref 180 453 480 496
ITS_MODIFIER                           constant        bit(6)                   initial packed unaligned dcl 11-55 ref 407 424
PDS_FIM                                constant        fixed bin(17,0)          initial dcl 114 ref 263 511 512
PDS_PGF                                constant        fixed bin(17,0)          initial dcl 118 ref 515 516
PDS_SIG                                constant        fixed bin(17,0)          initial dcl 116 ref 519 520
PRDS_FIM                               constant        fixed bin(17,0)          initial dcl 115 ref 523 524 526
PRDS_INT                               constant        fixed bin(17,0)          initial dcl 119 ref 528 529
PRDS_SYS                               constant        fixed bin(17,0)          initial dcl 117 ref 272 275 532 533
P_amu_info_ptr                         parameter       pointer                  dcl 41 ref 175 178 447 451 475 478 492 494
P_code                                 parameter       fixed bin(35,0)          dcl 42 set ref 175 181* 184* 217* 225* 242* 250*
                                                                                  317* 324* 331* 357 357* 359* 431* 444* 447 454*
                                                                                  458* 470* 475 481* 484* 488* 490* 492 497* 500*
                                                                                  503* 504* 838*
P_lock_symb                            parameter       char                     packed unaligned dcl 449 ref 447 463 465
P_sci_ptr                              parameter       pointer                  dcl 40 ref 175 179 447 452 475 479 492 495
P_set                                  parameter       bit(1)                   packed unaligned dcl 450 set ref 447 463* 467
addr                                                   builtin function         dcl 166 ref 194 202 221 221 235 246 246 280 320 329
                                                                                  329 339 339 407 407 424 424 461 485 578 578 622
                                                                                  622 672 694 782 782 782 782 789 834 834
address                         000426 automatic       fixed bin(17,0)          level 2 packed packed unaligned dcl 74 set ref 327
amu_$definition_get_prn         000016 constant        entry                    external dcl 132 ref 705
amu_$definition_offset          000010 constant        entry                    external dcl 132 ref 674
amu_$definition_ptr             000056 constant        entry                    external dcl 153 ref 214 239 398 509 514 518 522 527
                                                                                  531 552 573 619 792 831
amu_$definition_set_from        000012 constant        entry                    external dcl 132 ref 703
amu_$definition_set_prn         000014 constant        entry                    external dcl 132 ref 700 708
amu_$do_translation             000060 constant        entry                    external dcl 154 ref 204 221 246 258 276 322 329 339
                                                                                  368 376 578 622 679 782 834
amu_$do_translation_hunt_ptr    000020 constant        entry                    external dcl 132 ref 794
amu_$error_for_caller           000022 constant        entry                    external dcl 132 ref 547 554 593 802 807
amu_$fdump_mpt_change_idx       000026 constant        entry                    external dcl 132 ref 751 853
amu_$fdump_mpt_current_process  000024 constant        entry                    external dcl 132 ref 361
amu_$fdump_mpt_revert_idx       000030 constant        entry                    external dcl 132 ref 206 216 224 241 249 350 683 837
amu_$fdump_mpt_temp_change_idx  000032 constant        entry                    external dcl 132 ref 192 666 671 754
amu_$hardcore_info_set_cur_ptrs 000064 constant        entry                    external dcl 156 ref 196 462 486
amu_$return_val_idx_from_dbr    000034 constant        entry                    external dcl 132 ref 668
amu_$slt_search_seg_num         000062 constant        entry                    external dcl 155 ref 197 233 315 634 780
amu_$tc_data_print_this_apte    000036 constant        entry                    external dcl 132 ref 820
amu_et_$entry_not_found         000072 external static fixed bin(35,0)          dcl 157 ref 547
amu_et_$no_valid_stacks         000074 external static fixed bin(35,0)          dcl 157 ref 412 429 547 593 597 617
amu_et_$not_implemented         000066 external static fixed bin(35,0)          dcl 157 ref 181 454 481 497
amu_et_$seg_not_dumped          000070 external static fixed bin(35,0)          dcl 157 ref 593 631
amu_info                               based           structure                level 1 dcl 4-3
amu_info_ptr                    000552 automatic       pointer                  dcl 4-45 set ref 178* 180 180 191 192* 196* 204*
                                                                                  206* 210* 214* 216* 221* 224* 239* 241* 246* 249*
                                                                                  258* 276* 282* 322* 329* 339* 350* 361* 368* 376*
                                                                                  390 398* 410* 427* 451* 453 453 462* 478* 480 480
                                                                                  486* 494* 496 496 509* 514* 518* 522* 527* 531*
                                                                                  547* 552* 554* 573* 578* 589* 593* 609 610* 612*
                                                                                  619* 622* 627* 629* 638* 640* 659 659 661 666* 666
                                                                                  668* 671* 673 674* 679* 683* 697* 700* 703* 705*
                                                                                  708* 739 747 748 751* 754* 782* 792* 794* 802*
                                                                                  807* 820* 831* 834* 837* 844 850 851 853*
an_entry_found_sw               000100 automatic       bit(1)                   packed unaligned dcl 46 set ref 230* 359 542* 559*
                                                                                  562* 614* 641* 644*
any_other                       000530 stack reference condition                dcl 170 ref 402 414 420 436 442
apte                                   based           structure                level 1 dcl 10-7 in procedure "azm_why_"
apte                      6            based           structure                level 2 in structure "process_info" dcl 5-7
                                                                                  in procedure "azm_why_"
apte_offset              10            based           fixed bin(18,0)          array level 3 dcl 6-23 ref 748 851
aptep                           000560 automatic       pointer                  dcl 10-5 set ref 659* 661* 662 668 668
arg_bits_def                           based           structure                level 1 packed packed unaligned dcl 3-32
arg_bits_ptr                    000550 automatic       pointer                  dcl 3-57 set ref 280* 281 282* 694* 695 695 696 697*
array                     1            based           structure                array level 2 in structure "fdump_process_table"
                                                                                  dcl 6-23 in procedure "azm_why_" ref 747 850
array                    11            based           structure                array level 2 in structure "disk_data" dcl 1-31
                                                                                  in procedure "azm_why_" set ref 782 782
azm_display_mc_                 000054 constant        entry                    external dcl 152 ref 282 697
azm_stack_trace_                000042 constant        entry                    external dcl 147 ref 410 427
azm_stack_trace_$check_for_entry
                                000044 constant        entry                    external dcl 148 ref 612 629 640
azm_stack_trace_$check_for_mc   000046 constant        entry                    external dcl 149 ref 589
azm_stack_trace_$check_for_syserr
                                000050 constant        entry                    external dcl 150 ref 610 627 638
azm_verify_dump_ams_$af         000040 constant        entry                    external dcl 146 ref 210
bad_guy_known                   000101 automatic       bit(1)                   packed unaligned dcl 47 set ref 190* 238* 260 269
                                                                                  371 396* 400 460* 797
based_char                             based           char(32)                 packed unaligned dcl 650 ref 681
based_word                             based           bit(36)                  dcl 107 set ref 812 813 815* 818 818 824 824*
baseno                                                 builtin function         dcl 166 ref 221 221 246 246 258 258 276 276 339 339
                                                                                  368 368 376 376 390 526 578 578 622 622 700 700
                                                                                  708 708 834 834
baseptr                                                builtin function         dcl 166 ref 609 626 637 782 782 789 789
bce_entry                43(29)        based           fixed bin(6,0)           level 3 packed packed unsigned unaligned dcl 8-24
                                                                                  ref 354
bootload_cpu_ptr                000104 automatic       pointer                  dcl 49 set ref 214* 221 221 221 221
bootload_cpu_tag                000102 automatic       fixed bin(35,0)          dcl 48 set ref 221 221 228
chantab                                based           structure                level 1 dcl 1-132
check_entry_ptr                 000504 automatic       pointer                  dcl 91 set ref 552* 612* 629* 640*
cleanup                         000536 stack reference condition                dcl 170 ref 187
code                            000107 automatic       fixed bin(35,0)          dcl 51 in procedure "azm_why_" set ref 184* 197* 198
                                                                                  204* 205 210* 212 214* 215 217 221* 223 225 233*
                                                                                  236* 239* 240 242 246* 248 250 258* 276* 278 282*
                                                                                  285* 315* 316 317 322* 323 324 329* 330 331 339*
                                                                                  340 368* 370 376* 397 398* 399 403* 410* 412 412*
                                                                                  421* 427* 429 429* 431 438* 444 458* 470 484* 500*
                                                                                  504 509* 510 514* 518* 522* 527* 531* 546 547 547
                                                                                  547 547* 552* 553 554* 555* 559 560* 565 565* 569*
                                                                                  573* 574 578* 581 589* 592 593 593 593 593* 597
                                                                                  597* 610* 612* 613 617 617* 619* 620 622* 624 627*
                                                                                  629* 630 631 632* 634* 636 638* 640* 641 644 697*
                                                                                  698 700* 703* 705* 708* 780* 782* 794* 804* 820*
                                                                                  821 831* 834* 836 838
code                            000622 automatic       fixed bin(35,0)          dcl 651 in procedure "idle_process" set ref 664*
                                                                                  674* 675 679* 680
could_not_set_lock_sw           000106 automatic       bit(1)                   packed unaligned dcl 50 set ref 190* 356 460* 729*
                                                                                  735* 760*
cpu_names                       000356 constant        char(1)                  initial array packed unaligned dcl 120 set ref 228*
dbr                      44            based           fixed bin(71,0)          level 2 dcl 10-7 ref 668 668
devtab                                 based           structure                level 1 dcl 1-190
dim_check                       000726 automatic       structure                level 1 dcl 770 set ref 782 782
disk_data                              based           structure                level 1 dcl 1-31
disk_lock_meters                       based           structure                level 1 dcl 1-236
disk_seg_lock_index                    constant        fixed bin(17,0)          initial dcl 126 ref 778
error_table_$action_not_performed
                                000076 external static fixed bin(35,0)          dcl 157 ref 357 359 403 421 438 488 565 593
error_table_$noentry            000100 external static fixed bin(35,0)          dcl 157 ref 547
fault_vnum                      000110 automatic       fixed bin(17,0)          dcl 52 set ref 315* 322* 329*
fdump_info                             based           structure                level 1 dcl 6-3
fdump_info_ptr           14            based           pointer                  level 2 dcl 4-3 ref 747 748 850 851
fdump_process_table                    based           structure                level 1 dcl 6-23
fdump_process_table_ptr
                        246            based           pointer                  level 2 dcl 6-3 ref 747 748 850 851
fgbx                                   based           structure                level 1 dcl 8-24
fgbxp                           000556 automatic       pointer                  dcl 8-22 set ref 202* 204* 209 209 354
fi_flag                   1(35)        based           bit(1)                   level 2 packed packed unaligned dcl 2-56 ref 388
fi_num                    1(30)        based           bit(5)                   level 2 packed packed unaligned dcl 2-56 ref 388
fim_num                         000111 automatic       fixed bin(17,0)          dcl 53 set ref 233*
fim_type_fault                  000112 automatic       bit(1)                   packed unaligned dcl 54 set ref 255*
fixed                                                  builtin function         dcl 166 ref 221 221 221 221 246 246 246 246 258 258
                                                                                  258 258 276 276 276 276 336 339 339 368 368 368
                                                                                  368 376 376 376 376 390 526 578 578 578 578 622
                                                                                  622 622 622 668 668 700 700 700 700 708 708 708
                                                                                  708 748 782 782 789 813 834 834 834 834 851
flag_box_area                   000113 automatic       fixed bin(35,0)          array dcl 55 set ref 202 203
foreign_ptr               6            based           pointer                  level 3 packed packed unaligned dcl 5-7 ref 659 661
fp_table                               based           structure                level 1 unaligned dcl 6-28
hard_ptrs                       000260 automatic       structure                level 1 unaligned dcl 57 set ref 194 461 485
hardcore_cur                           based           structure                level 1 unaligned dcl 7-40
hardcore_cur_ptr                000554 automatic       pointer                  dcl 7-38 set ref 194* 196* 197 197 233 233 315 315
                                                                                  461* 462* 485* 486* 634 634 780 780
hardcore_info                          based           structure                level 1 dcl 7-6
hardcore_info_ptr        16            based           pointer                  level 2 dcl 4-3 ref 390 609 673
hbound                                                 builtin function         dcl 166 ref 203 253 464 717 723 747 850
idle_sw                         000623 automatic       bit(1)                   packed unaligned dcl 652 set ref 665* 681* 685
index                                                  builtin function         dcl 166 in procedure "azm_why_" ref 209 681
index                                  parameter       fixed bin(17,0)          dcl 768 in procedure "print_the_lock" ref 764 774
                                                                                  775 778 786 796 812 814
inter_code                      000257 automatic       fixed bin(35,0)          dcl 56 set ref 792* 801 802* 804
ioa_                            000052 constant        entry                    external dcl 151 ref 199 209 213 228 284 352 354 365
                                                                                  382 742 752 759 785 798 815 819 822 824
its                                    based           structure                level 1 dcl 11-5
its_mod                   0(30)        based           bit(6)                   level 2 packed packed unaligned dcl 11-5 ref 407 424
lbound                                                 builtin function         dcl 166 ref 253
local_ptr                 7            based           pointer                  level 3 packed packed unaligned dcl 5-7 ref 659
lock                      3            based           bit(36)                  level 2 packed packed unaligned dcl 1-31 set ref 789
lock_apte_offset                000276 automatic       fixed bin(18,0)          dcl 58 set ref 777* 813* 820*
lock_index                      000277 automatic       fixed bin(17,0)          dcl 59 set ref 464* 465 466* 717* 718* 723* 724* 734
                                                                                  739 742 742 748 752 752
lock_name                       000716 automatic       char(32)                 packed unaligned dcl 769 set ref 776* 785* 798* 815*
                                                                                  819* 824*
lock_ptr                        000502 automatic       pointer                  dcl 91 set ref 789* 792* 794*
lock_seg                        000266 constant        char(32)                 initial array packed unaligned dcl 122 set ref 742*
                                                                                  752* 774
lock_symbol                     000176 constant        char(32)                 initial array packed unaligned dcl 124 set ref 464
                                                                                  465 742* 752* 775
lock_word                       000300 automatic       bit(36)                  array packed unaligned dcl 60 set ref 716* 717 723
                                                                                  724 734 739 748 786* 796* 812*
look_for_syserr_sw              000307 automatic       bit(1)                   packed unaligned dcl 61 set ref 543* 545* 610 627
                                                                                  638
loop_exit                       000310 automatic       bit(1)                   packed unaligned dcl 62 set ref 185* 238 488 744*
                                                                                  829* 847* 854*
mbz                       0(18) 000726 automatic       bit(18)                  level 2 packed packed unaligned dcl 770 set ref 784
mc                                     based           structure                level 1 dcl 2-12 set ref 257 367
mc_area                                based           structure                level 1 unaligned dcl 108 ref 188 234 362
mc_found_frame_sw               000407 automatic       bit(1)                   packed unaligned dcl 67 set ref 230* 359 372 381*
                                                                                  393* 395 501* 503 599*
mc_info                         000312 automatic       structure                array level 1 unaligned dcl 63
mc_info_idx                     000406 automatic       fixed bin(17,0)          dcl 66 set ref 263* 264 265 341* 342 343 344* 372*
                                                                                  374 375*
mc_name                         000410 automatic       char(32)                 packed unaligned dcl 68 set ref 265* 275* 344* 375*
                                                                                  382*
mcp                             000544 automatic       pointer                  dcl 2-10 set ref 186* 188 188 234* 235 257 258* 276*
                                                                                  282* 362 362 367 368* 376* 390 407 407 407 410 410
                                                                                  424 424 424 427 427 697* 703*
message                  60            based           char(64)                 level 2 dcl 8-24 set ref 209 209*
mod                       1(30)        based           bit(6)                   level 2 packed packed unaligned dcl 11-5 ref 407 424
name                      2     000312 automatic       char(32)                 array level 2 packed packed unaligned dcl 63 set ref
                                                                                  265 275 344 375 512* 516* 520* 524* 529* 533*
no_print_process                000420 automatic       bit(1)                   packed unaligned dcl 69 set ref 361 741* 755* 830*
                                                                                  846*
null                                                   builtin function         dcl 166 ref 186 188 362 407 424 588 659 662 793 795
                                                                                  832
number_val_args                        internal static fixed bin(17,0)          initial dcl 3-3 ref 3-23
offset_symb                     000706 automatic       char(32)                 packed unaligned dcl 767 set ref 775* 776 792* 802
                                                                                  802 807 807
opt_info                               based           structure                level 1 dcl 1-217
pds                      20            based           fixed bin(15,0)          level 3 dcl 7-6 ref 673
pds_fim_ptr                     000514 automatic       pointer                  dcl 91 set ref 258 258 258 258 509* 511
pds_pgflt_ptr                   000512 automatic       pointer                  dcl 91 set ref 514* 515
pds_signal_ptr                  000510 automatic       pointer                  dcl 91 set ref 518* 519
pid                                    based           bit(36)                  level 2 dcl 5-7 ref 739 844
pointer                                                builtin function         dcl 166 ref 334 410 410 427 427 789
pointer_index                   000421 automatic       fixed bin(17,0)          dcl 70 set ref 293* 296* 300* 337
pointers                               based           structure                level 2 dcl 7-6
ppr                       0(03)        based           bit(1)                   level 2 packed packed unaligned dcl 3-32 set ref
                                                                                  281* 695*
prds                     16            based           fixed bin(15,0)          level 3 dcl 7-6 ref 390 609
prds_fim_ptr                    000522 automatic       pointer                  dcl 91 set ref 522* 523
prds_int_ptr                    000520 automatic       pointer                  dcl 91 set ref 527* 528
prds_num                        000422 automatic       fixed bin(17,0)          dcl 71 set ref 526*
prds_sys_troub_ptr              000516 automatic       pointer                  dcl 91 set ref 531* 532
process_idx              24            based           fixed bin(17,0)          level 2 dcl 4-3 set ref 191 666*
process_info                           based           structure                level 1 dcl 5-7
process_info_ptr         22            based           pointer                  level 2 dcl 4-3 ref 659 659 661 739 844
prs                                    based           pointer                  array level 2 dcl 2-12 set ref 390 407 407 407 410
                                                                                  410 424 424 424 427 427
prs_size                               based           pointer                  array dcl 109 ref 335
ptl_lock_index                         constant        fixed bin(17,0)          initial dcl 127 set ref 291*
ptr                             000312 automatic       pointer                  array level 2 dcl 63 set ref 264 272 342 343 374
                                                                                  511* 515* 519* 523* 526 528* 532*
qht                                    based           structure                level 1 dcl 1-179
quentry                                based           structure                level 1 dcl 1-107
real_mcp                        000524 automatic       pointer                  dcl 91 set ref 264* 272* 276 276 276 276 343* 368
                                                                                  368 368 368 374* 376 376 376 376 700 700 700 700
regs                     20            based           structure                level 2 in structure "mc" packed packed unaligned
                                                                                  dcl 2-12 in procedure "azm_why_"
regs                     20            based           structure                level 2 in structure "mc_area" packed packed
                                                                                  unaligned dcl 108 in procedure "azm_why_"
regs_size                              based           structure                level 1 packed packed unaligned dcl 110 ref 335
rel                                                    builtin function         dcl 166 ref 221 221 246 246 258 258 276 276 336 368
                                                                                  368 376 376 578 578 622 622 700 700 708 708 782
                                                                                  782 789 834 834
ring_zero_stack                 000423 automatic       bit(1)                   packed unaligned dcl 72 set ref 585* 587* 589*
rtb                      43            based           structure                level 2 dcl 8-24
rtrim                                                  builtin function         dcl 166 ref 776 776 802 802 802 802 807 807 807 807
sci_ptr                         000424 automatic       pointer                  dcl 73 set ref 179* 282* 410* 427* 452* 479* 495*
                                                                                  589* 610* 612* 627* 629* 638* 640* 697*
scu                                    based           structure                level 1 dcl 2-56 in procedure "azm_why_" ref 373
scu                      30            based           bit(36)                  array level 2 in structure "mc" packed packed
                                                                                  unaligned dcl 2-12 in procedure "azm_why_" set ref
                                                                                  235
scu_inst                        000426 automatic       structure                level 1 packed packed unaligned dcl 74 set ref 320
                                                                                  328
scu_inst_word                   000175 constant        fixed bin(18,0)          initial dcl 128 set ref 322*
scup                            000546 automatic       pointer                  dcl 2-54 set ref 235* 373 388 388
seg_symb                        000676 automatic       char(32)                 packed unaligned dcl 766 set ref 774* 776 792* 802
                                                                                  802 807 807
segno                    16            based           structure                level 2 dcl 7-6
set_for_lock                           parameter       bit(1)                   packed unaligned dcl 715 ref 713 720
set_it                                 parameter       bit(1)                   packed unaligned dcl 691 ref 689 696 698
set_ptr                   0(32)        based           bit(1)                   level 2 packed packed unaligned dcl 3-32 set ref
                                                                                  696*
size                                                   builtin function         dcl 166 in procedure "azm_why_" ref 257 328 335 335
                                                                                  367 577 678
size                                   based           fixed bin(17,0)          level 2 in structure "fdump_process_table" dcl 6-23
                                                                                  in procedure "azm_why_" ref 747 850
slt                                    based           structure                level 3 dcl 7-6
sltntp                    2            based           pointer                  level 2 dcl 7-40 set ref 197* 233* 315* 634* 780*
sltp                                   based           pointer                  level 2 dcl 7-40 set ref 197* 233* 315* 634* 780*
stack_base_segno                000427 automatic       fixed bin(17,0)          dcl 77 set ref 622 622 626 634* 637
stack_idx                       000430 automatic       fixed bin(17,0)          dcl 78 set ref 584* 585 588 589 593*
stack_ptr                       000506 automatic       pointer                  dcl 91 set ref 609* 610* 612* 626* 627* 629* 637*
                                                                                  638* 640*
stack_temp_ptrs                 000432 automatic       pointer                  array dcl 79 set ref 577 578 578 588 589* 593*
substr                                                 builtin function         dcl 166 ref 609 626 637 668 668 748 813 818 851
sys_info                               based           structure                level 1 dcl 1-59
sys_trouble_reason              000017 constant        varying char(36)         initial array dcl 9-5 set ref 253 253 284* 365*
t_data                          000624 automatic       fixed bin(35,0)          array dcl 653 set ref 672 678
t_idx                           000634 automatic       fixed bin(17,0)          dcl 654 set ref 668* 669 671*
t_offset                        000635 automatic       fixed bin(18,0)          dcl 655 set ref 674* 679*
t_pr_name                       000452 automatic       char(4)                  packed unaligned dcl 80 set ref 699* 700* 702* 703*
                                                                                  704* 705* 707* 708*
t_ptr                           000636 automatic       pointer                  dcl 656 set ref 672* 679* 681
t_segno                         000640 automatic       fixed bin(17,0)          dcl 657 set ref 673* 679*
temp_indx                       000453 automatic       fixed bin(17,0)          dcl 81 set ref 191* 192* 747* 748 751* 754* 850* 851
                                                                                  853*
temp_mcp                        000454 automatic       pointer                  dcl 82 set ref 334* 339 339 342
temp_name                       000456 automatic       char(32)                 dcl 83 set ref 195* 197* 232* 233* 313* 315* 633*
                                                                                  634* 779* 780*
temp_num                        000466 automatic       fixed bin(17,0)          dcl 84 set ref 197* 204* 327* 329 335* 336* 336 337*
                                                                                  337 339 780* 782* 782 782 789 789
temp_ptr                        000526 automatic       pointer                  dcl 91 set ref 320* 322* 329 329 334 336 339 339
                                                                                  398* 573* 578 578 578 578 619* 622 622 622 622
                                                                                  705* 706 708 708 708 708 793* 794* 795 812 813 815
                                                                                  818 818 824 824
temp_stack_ptr                  000470 automatic       pointer                  dcl 85 set ref 706*
temp_word                       000472 automatic       bit(36)                  dcl 86 set ref 279* 280 693* 694
tpr                       0(04)        based           bit(1)                   level 2 packed packed unaligned dcl 3-32 set ref
                                                                                  695*
trbl_prds_pf                    007174 constant        fixed bin(35,0)          initial dcl 9-35 ref 387
trouble_pending                 000473 automatic       fixed bin(35,0)          dcl 87 set ref 246 246 253 253 260 284 365 387
trouble_pid                     000474 automatic       fixed bin(35,0)          dcl 88 set ref 834 834 843 844 851
trouble_pid_ptr                 000500 automatic       pointer                  dcl 91 set ref 831* 832 834 834 834 834
trouble_ptr                     000476 automatic       pointer                  dcl 91 set ref 239* 246 246 246 246
type                      3            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 4-3 ref 180 180
                                                                                  453 453 480 480 496 496
unspec                                                 builtin function         dcl 166 ref 373 609 626 637 668 668 748 813 844 851
words_requested                 000475 automatic       fixed bin(18,0)          dcl 89 set ref 203* 204* 220* 221* 245* 246* 257*
                                                                                  258* 321* 322* 328* 329* 338* 339* 367* 368* 577*
                                                                                  578* 621* 622* 678* 679* 781* 782* 833* 834*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
AMU_FDUMP_INFO_VERSION                 internal static char(8)                  initial packed unaligned dcl 6-43
AMU_FDUMP_INFO_VERSION_1               internal static char(8)                  initial packed unaligned dcl 6-42
AMU_INFO_VERSION                       internal static char(8)                  initial packed unaligned dcl 4-57
AMU_INFO_VERSION_1                     internal static char(8)                  initial packed unaligned dcl 4-56
AMU_INFO_VERSION_2                     internal static char(8)                  initial packed unaligned dcl 4-58
BOOTLOAD_READ                          internal static fixed bin(4,0)           initial dcl 1-251
BOOTLOAD_WRITE                         internal static fixed bin(4,0)           initial dcl 1-251
DSC_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
FLAGBOX_SENTINEL                       internal static char(32)                 initial packed unaligned dcl 8-51
INDIRECT_TYPE                          internal static fixed bin(17,0)          initial dcl 4-47
IO_TYPE                                internal static char(16)                 initial array packed unaligned dcl 1-262
ITP_MODIFIER                           internal static bit(6)                   initial packed unaligned dcl 11-56
MAX_IO_TYPE                            internal static fixed bin(4,0)           initial dcl 1-251
NETWORK_FDUMP_TYPE                     internal static fixed bin(17,0)          initial dcl 4-47
NETWORK_ONLINE_TYPE                    internal static fixed bin(17,0)          initial dcl 4-47
ONLINE_PROCESS_TYPE                    internal static fixed bin(17,0)          initial dcl 4-47
ONLINE_TYPE                            internal static fixed bin(17,0)          initial dcl 4-47
PAGE_READ                              internal static fixed bin(4,0)           initial dcl 1-251
PAGE_WRITE                             internal static fixed bin(4,0)           initial dcl 1-251
PDIR_SUFFIX                            internal static char(4)                  initial packed unaligned dcl 4-60
RSS_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
RST_LISTX                              internal static fixed bin(12,0)          initial dcl 1-241
SAVED_PROC_TYPE                        internal static fixed bin(17,0)          initial dcl 4-47
SC_LISTX                               internal static fixed bin(12,0)          initial dcl 1-241
TEST                                   internal static fixed bin(4,0)           initial dcl 1-251
VTOC_READ                              internal static fixed bin(4,0)           initial dcl 1-251
VTOC_WRITE                             internal static fixed bin(4,0)           initial dcl 1-251
abx                                    internal static fixed bin(17,0)          initial dcl 2-42
alloc_fdump_process_table_size         automatic       fixed bin(17,0)          dcl 6-40
amu_area                               based           area(1024)               dcl 4-43
apx                                    internal static fixed bin(17,0)          initial dcl 2-42
arg_bits                               based           structure                level 1 dcl 3-23
bbx                                    internal static fixed bin(17,0)          initial dcl 2-42
bootload_map                           defined         bit(1)                   array packed unaligned dcl 1-279
bootload_mapping                       internal static bit(7)                   initial packed unaligned dcl 1-278
bpx                                    internal static fixed bin(17,0)          initial dcl 2-42
cp                                     automatic       pointer                  dcl 1-97
disk_channel_table                     based           structure                array level 1 dcl 1-94
disk_seg$                              external static fixed bin(17,0)          dcl 1-24
diskp                                  automatic       pointer                  dcl 1-26
disksp                                 automatic       pointer                  dcl 1-26
disktab                                based           structure                level 1 dcl 1-74
dp                                     automatic       pointer                  dcl 1-187
dskdcl_chans_per_subsys                internal static fixed bin(17,0)          initial dcl 1-70
dskdcl_chans_per_subsys_shift          internal static fixed bin(17,0)          initial dcl 1-71
flagbox$                               external static fixed bin(17,0)          dcl 8-21
fp_table_ptr                           automatic       pointer                  dcl 6-38
itp                                    based           structure                level 1 dcl 11-18
itp_unsigned                           based           structure                level 1 dcl 11-43
its_unsigned                           based           structure                level 1 dcl 11-30
lbx                                    internal static fixed bin(17,0)          initial dcl 2-42
lpx                                    internal static fixed bin(17,0)          initial dcl 2-42
optp                                   automatic       pointer                  dcl 1-26
pvtdi                                  based           structure                level 1 dcl 1-229
pvtdip                                 automatic       pointer                  dcl 1-187
qp                                     automatic       pointer                  dcl 1-97
sbx                                    internal static fixed bin(17,0)          initial dcl 2-42
scux                                   based           structure                level 1 dcl 2-207
sector_map                             defined         bit(1)                   array packed unaligned dcl 1-274
sector_mapping                         internal static bit(7)                   initial packed unaligned dcl 1-273
spx                                    internal static fixed bin(17,0)          initial dcl 2-42
sysp                                   automatic       pointer                  dcl 1-26
trbl_exec_flt                          internal static fixed bin(35,0)          initial dcl 9-29
trbl_fault_masked                      internal static fixed bin(35,0)          initial dcl 9-27
trbl_fim_flt                           internal static fixed bin(35,0)          initial dcl 9-26
trbl_idle_flt                          internal static fixed bin(35,0)          initial dcl 9-33
trbl_illeg_flt                         internal static fixed bin(35,0)          initial dcl 9-31
trbl_oosb_prds                         internal static fixed bin(35,0)          initial dcl 9-28
trbl_prds_fi                           internal static fixed bin(35,0)          initial dcl 9-34
trbl_ptl_fi                            internal static fixed bin(35,0)          initial dcl 9-32
trbl_r0_drl_flt                        internal static fixed bin(35,0)          initial dcl 9-25
trbl_unexp_flt                         internal static fixed bin(35,0)          initial dcl 9-30
valid_mc_arg                           internal static char(8)                  initial array packed unaligned dcl 3-5
what_prs                               based           structure                level 1 dcl 3-26
write_map                              defined         bit(1)                   array packed unaligned dcl 1-269
write_mapping                          internal static bit(7)                   initial packed unaligned dcl 1-268

NAMES DECLARED BY EXPLICIT CONTEXT.
END_IDLE                        005342 constant        label                    dcl 683 ref 669 675 680
NEXT                            001472 constant        label                    dcl 230 ref 212
azm_why_                        000774 constant        entry                    external dcl 23
azm_why_$find_bad_guy           001006 constant        entry                    external dcl 175
azm_why_$mcs                    003430 constant        entry                    external dcl 492
azm_why_$print_locks            003213 constant        entry                    external dcl 447
azm_why_$who                    003346 constant        entry                    external dcl 475
bad_data                        003024 constant        label                    dcl 414 ref 404
bad_guy_non_fim                 003157 constant        label                    dcl 436 ref 270 388 390 416
bad_stack_data                  003202 constant        label                    dcl 442 ref 422 439
call_check_mcs                  004214 constant        label                    dcl 563 ref 556
call_fim_type                   002411 constant        label                    dcl 365 ref 266 345
check_mcs                       004223 constant        entry                    internal dcl 568 ref 287 502 563
check_stacks                    004473 constant        entry                    internal dcl 604 ref 544 558
common_other                    002073 constant        label                    dcl 313 ref 294 299
common_return                   002357 constant        label                    dcl 357 ref 243 251 288 433 445
could_not_find                  002305 constant        label                    dcl 350 ref 269 318 325 332 340 370 510
exit_via_fim                    003154 constant        label                    dcl 431 ref 395 397 400
flagbox_done                    001261 constant        label                    dcl 210 ref 200 207
idle_process                    005142 constant        entry                    internal dcl 648 ref 570
list_locks                      005610 constant        entry                    internal dcl 713 ref 286 356 463
lock_exit                       003341 constant        label                    dcl 470
mc_fim_type                     005357 constant        entry                    internal dcl 689 ref 396
mc_info_init                    003475 constant        entry                    internal dcl 507 ref 256
non_fim_type                    004037 constant        entry                    internal dcl 536 ref 441
print_the_lock                  006040 constant        entry                    internal dcl 764 ref 291 466 718
set_to_lock                     005660 constant        entry                    internal dcl 732 ref 467 725
trouble_type                    000000 constant        label                    array(-15:-1) dcl 272 ref 260
who_is_it                       006751 constant        entry                    internal dcl 827 ref 237 487

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      7720       10022    7177        7730
Length     10562    7177       102         524     520           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
azm_why_                           1024 external procedure  is an external procedure.  
on unit on line 187                  64 on unit               
on unit on line 402                  64 on unit               
on unit on line 420                  64 on unit               
on unit on line 436                  64 on unit               
mc_info_init                            internal procedure  shares stack frame of external procedure azm_why_.  
non_fim_type                            internal procedure  shares stack frame of external procedure azm_why_.  
check_mcs                               internal procedure  shares stack frame of external procedure azm_why_.  
check_stacks                            internal procedure  shares stack frame of external procedure azm_why_.  
idle_process                            internal procedure  shares stack frame of external procedure azm_why_.  
mc_fim_type                             internal procedure  shares stack frame of external procedure azm_why_.  
list_locks                              internal procedure  shares stack frame of external procedure azm_why_.  
set_to_lock                             internal procedure  shares stack frame of external procedure azm_why_.  
print_the_lock                          internal procedure  shares stack frame of external procedure azm_why_.  
who_is_it                               internal procedure  shares stack frame of external procedure azm_why_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
azm_why_                 000100 an_entry_found_sw           azm_why_
                         000101 bad_guy_known               azm_why_
                         000102 bootload_cpu_tag            azm_why_
                         000104 bootload_cpu_ptr            azm_why_
                         000106 could_not_set_lock_sw       azm_why_
                         000107 code                        azm_why_
                         000110 fault_vnum                  azm_why_
                         000111 fim_num                     azm_why_
                         000112 fim_type_fault              azm_why_
                         000113 flag_box_area               azm_why_
                         000257 inter_code                  azm_why_
                         000260 hard_ptrs                   azm_why_
                         000276 lock_apte_offset            azm_why_
                         000277 lock_index                  azm_why_
                         000300 lock_word                   azm_why_
                         000307 look_for_syserr_sw          azm_why_
                         000310 loop_exit                   azm_why_
                         000312 mc_info                     azm_why_
                         000406 mc_info_idx                 azm_why_
                         000407 mc_found_frame_sw           azm_why_
                         000410 mc_name                     azm_why_
                         000420 no_print_process            azm_why_
                         000421 pointer_index               azm_why_
                         000422 prds_num                    azm_why_
                         000423 ring_zero_stack             azm_why_
                         000424 sci_ptr                     azm_why_
                         000426 scu_inst                    azm_why_
                         000427 stack_base_segno            azm_why_
                         000430 stack_idx                   azm_why_
                         000432 stack_temp_ptrs             azm_why_
                         000452 t_pr_name                   azm_why_
                         000453 temp_indx                   azm_why_
                         000454 temp_mcp                    azm_why_
                         000456 temp_name                   azm_why_
                         000466 temp_num                    azm_why_
                         000470 temp_stack_ptr              azm_why_
                         000472 temp_word                   azm_why_
                         000473 trouble_pending             azm_why_
                         000474 trouble_pid                 azm_why_
                         000475 words_requested             azm_why_
                         000476 trouble_ptr                 azm_why_
                         000500 trouble_pid_ptr             azm_why_
                         000502 lock_ptr                    azm_why_
                         000504 check_entry_ptr             azm_why_
                         000506 stack_ptr                   azm_why_
                         000510 pds_signal_ptr              azm_why_
                         000512 pds_pgflt_ptr               azm_why_
                         000514 pds_fim_ptr                 azm_why_
                         000516 prds_sys_troub_ptr          azm_why_
                         000520 prds_int_ptr                azm_why_
                         000522 prds_fim_ptr                azm_why_
                         000524 real_mcp                    azm_why_
                         000526 temp_ptr                    azm_why_
                         000544 mcp                         azm_why_
                         000546 scup                        azm_why_
                         000550 arg_bits_ptr                azm_why_
                         000552 amu_info_ptr                azm_why_
                         000554 hardcore_cur_ptr            azm_why_
                         000556 fgbxp                       azm_why_
                         000560 aptep                       azm_why_
                         000622 code                        idle_process
                         000623 idle_sw                     idle_process
                         000624 t_data                      idle_process
                         000634 t_idx                       idle_process
                         000635 t_offset                    idle_process
                         000636 t_ptr                       idle_process
                         000640 t_segno                     idle_process
                         000676 seg_symb                    print_the_lock
                         000706 offset_symb                 print_the_lock
                         000716 lock_name                   print_the_lock
                         000726 dim_check                   print_the_lock

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        return_mac
tra_ext_1           enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry
set_chars_eis       index_chars_eis     alloc_storage       op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
amu_$definition_get_prn       amu_$definition_offset        amu_$definition_ptr           amu_$definition_set_from
amu_$definition_set_prn       amu_$do_translation           amu_$do_translation_hunt_ptr  amu_$error_for_caller
amu_$fdump_mpt_change_idx     amu_$fdump_mpt_current_process                              amu_$fdump_mpt_revert_idx
amu_$fdump_mpt_temp_change_idx                              amu_$hardcore_info_set_cur_ptrs
amu_$return_val_idx_from_dbr  amu_$slt_search_seg_num       amu_$tc_data_print_this_apte  azm_display_mc_
azm_stack_trace_              azm_stack_trace_$check_for_entry                            azm_stack_trace_$check_for_mc
azm_stack_trace_$check_for_syserr                           azm_verify_dump_ams_$af       ioa_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
amu_et_$entry_not_found       amu_et_$no_valid_stacks       amu_et_$not_implemented       amu_et_$seg_not_dumped
error_table_$action_not_performed                           error_table_$noentry




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     23 000773        24 001001       175 001002       178 001016       179 001022       180 001025       181 001034
    182 001037       184 001040       185 001042       186 001043       187 001045       188 001061       189 001070
    190 001071       191 001073       192 001076       194 001107       195 001111       196 001114       197 001125
    198 001145       199 001147       200 001166       202 001167       203 001171       204 001173       205 001215
    206 001217       207 001226       209 001227       210 001261       212 001306       213 001310       214 001324
    215 001361       216 001363       217 001372       218 001374       220 001375       221 001377       223 001431
    224 001433       225 001442       226 001444       228 001445       230 001472       232 001474       233 001477
    234 001517       235 001523       236 001525       237 001526       238 001527       239 001533       240 001570
    241 001572       242 001601       243 001603       245 001604       246 001606       248 001640       249 001642
    250 001651       251 001653       253 001654       255 001661       256 001663       257 001664       258 001666
    260 001716       263 001723       264 001725       265 001730       266 001734       269 001735       270 001740
    272 001741       275 001744       276 001750       278 002002       279 002004       280 002005       281 002007
    282 002012       283 002031       284 002032       285 002053       286 002054       287 002060       288 002061
    291 002062       293 002064       294 002066       296 002067       299 002070       300 002071       313 002073
    315 002076       316 002116       317 002120       318 002121       320 002122       321 002124       322 002126
    323 002147       324 002151       325 002152       327 002153       328 002156       329 002160       330 002205
    331 002207       332 002210       334 002211       335 002213       336 002215       337 002220       338 002223
    339 002225       340 002256       341 002260       342 002265       343 002273       344 002276       345 002302
    347 002303       350 002305       352 002314       354 002330       356 002351       357 002357       359 002364
    361 002372       362 002402       363 002410       365 002411       367 002432       368 002434       370 002464
    371 002466       372 002471       373 002501       374 002506       375 002511       376 002515       379 002547
    381 002550       382 002552       384 002572       385 002574       387 002575       388 002600       390 002612
    393 002622       395 002624       396 002626       397 002630       398 002632       399 002671       400 002673
    402 002676       403 002712       404 002715       407 002720       410 002734       412 003017       414 003024
    416 003025       420 003026       421 003042       422 003045       424 003050       427 003064       429 003147
    431 003154       433 003156       436 003157       438 003173       439 003176       441 003201       442 003202
    444 003203       445 003205       447 003206       451 003231       452 003235       453 003240       454 003247
    455 003252       458 003253       460 003255       461 003260       462 003262       463 003273       464 003311
    465 003315       466 003326       467 003330       469 003337       470 003341       473 003343       475 003344
    478 003356       479 003362       480 003365       481 003374       482 003377       484 003400       485 003402
    486 003404       487 003415       488 003416       490 003424       491 003425       492 003426       494 003440
    495 003444       496 003447       497 003456       498 003461       500 003462       501 003464       502 003465
    503 003466       504 003472       505 003474       507 003475       509 003476       510 003532       511 003534
    512 003537       514 003543       515 003601       516 003604       518 003610       519 003646       520 003651
    522 003655       523 003711       524 003714       526 003720       527 003724       528 003762       529 003765
    531 003771       532 004027       533 004032       534 004036       536 004037       542 004040       543 004041
    544 004043       545 004044       546 004045       547 004047       552 004112       553 004144       554 004146
    555 004200       556 004201       558 004202       559 004203       560 004210       561 004211       562 004212
    563 004214       565 004215       566 004222       568 004223       569 004224       570 004225       571 004232
    573 004233       574 004267       575 004271       577 004272       578 004274       581 004326       582 004330
    584 004331       585 004336       587 004342       588 004344       589 004352       592 004410       593 004412
    597 004457       598 004464       599 004465       601 004467       602 004472       604 004473       609 004474
    610 004503       612 004537       613 004573       614 004575       615 004577       617 004600       619 004604
    620 004642       621 004645       622 004647       624 004701       626 004704       627 004711       629 004745
    630 005001       631 005003       632 005006       633 005007       634 005012       636 005031       637 005034
    638 005041       640 005075       641 005131       644 005135       645 005141       648 005142       659 005144
    661 005154       662 005156       664 005167       665 005170       666 005171       668 005202       669 005221
    671 005224       672 005235       673 005237       674 005243       675 005302       678 005304       679 005306
    680 005327       681 005331       683 005342       685 005351       689 005357       693 005361       694 005362
    695 005364       696 005372       697 005376       698 005415       699 005425       700 005427       702 005467
    703 005471       704 005515       705 005517       706 005543       707 005545       708 005547       711 005607
    713 005610       716 005612       717 005622       718 005627       719 005631       720 005633       723 005642
    724 005647       725 005651       726 005652       728 005653       729 005655       730 005657       732 005660
    734 005661       735 005664       736 005666       739 005667       741 005672       742 005674       744 005721
    745 005723       747 005724       748 005733       751 005745       752 005756       754 006004       755 006015
    756 006016       758 006017       759 006021       760 006035       761 006037       764 006040       774 006042
    775 006050       776 006054       777 006126       778 006130       779 006134       780 006137       781 006157
    782 006161       784 006214       785 006217       786 006237       787 006242       789 006243       791 006253
    792 006254       793 006303       794 006305       795 006322       796 006326       797 006331       798 006334
    799 006354       801 006355       802 006357       804 006462       805 006465       807 006466       809 006574
    812 006576       813 006602       814 006605       815 006607       816 006634       818 006635       819 006643
    820 006663       821 006676       822 006701       823 006714       824 006715       825 006750       827 006751
    829 006752       830 006753       831 006754       832 007014       833 007020       834 007022       836 007054
    837 007056       838 007065       839 007067       843 007070       844 007072       846 007076       847 007100
    848 007101       850 007102       851 007111       853 007122       854 007133       856 007135       859 007137


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
