	COMPILATION LISTING OF SEGMENT comp_dir_info
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/23/82  1033.7 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 comp_dir_info: proc;
       12 
       13 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       14 	/*									*/
       15 	/* comp_dir_info - compare two saved directories					*/
       16 	/*									*/
       17 	/* Status:								*/
       18 	/*									*/
       19 	/* 0) Created   May, 1973 by T. H. VanVleck					*/
       20 	/* 1) Modified  July, 1982 by Jim Lippard to only print 2 dir ring brackets		*/
       21 	/* 2) Modified  Oct, 1982 by G. C. Dixon to modernize the code			*/
       22 	/*									*/
       23 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       24 
       25 dcl  al fixed bin(21),				/* length of arg */
       26      an fixed bin,
       27      ap ptr,					/* ptr to arg */
       28     (datstr1, datstr2) char (24),
       29      ec fixed bin (35),				/* error code */
       30      en1 char (32),
       31     (fdir1, fdir2) char (168),
       32     (fent1, fent2) char (32),
       33     (firstadd, firstdelete) bit (1),
       34     (fptr1, fptr2) ptr,
       35      headed bit (1),
       36     (i, k, m, n) fixed bin,
       37      loud bit (1),
       38     (n1, n2) fixed bin,
       39      nacl fixed bin,
       40     (name1x, name2x) fixed bin,
       41      nchanges fixed bin,
       42     (np1, np2) ptr,
       43     (type1, type2) fixed bin,
       44      uid1 bit (36) aligned,
       45      verbosity fixed bin,
       46      xp ptr,
       47     (xp1, xp2) ptr;
       48 
       49 dcl (addr, binary, fixed, index, max, null, ptr, substr) builtin;
       50 
       51 dcl  cleanup condition;
       52 
       53 dcl  bchr char (al) unal based (ap),			/* pickup for argument */
       54      names (100) char (32) aligned based;		/* names from star */
       55 
       56 dcl  com_err_ entry options (variable),
       57      cu_$arg_ptr entry (fixed bin, ptr, fixed bin(21), fixed bin(35)),
       58      date_time_ entry (fixed bin(71), char(*)),
       59      date_time_$fstime entry (bit(36) aligned, char(*)),
       60      expand_pathname_$add_suffix entry (char(*), char(*), char(*), char(*), fixed bin(35)),
       61      hcs_$initiate entry (char(*), char(*), char(*), fixed bin(1), fixed bin(2), ptr, fixed bin(35)),
       62      hcs_$terminate_noname entry (ptr, fixed bin(35)),
       63      ioa_ entry options (variable),
       64      ioa_$rsnnl entry options (variable),
       65      list_dir_info_	entry (ptr, fixed bin, char(1)),
       66      mdc_$find_lvname entry (bit (36), char (*) aligned, fixed bin (35));
       67 
       68 dcl  TAB char (1) int static options(constant) init("	"),
       69     (error_table_$bad_arg,
       70      error_table_$badopt) fixed bin(35) ext static,
       71      segtype (0:2) char (4) aligned int static options(constant) init("link", "seg ", "dir ");
       72 
  1     1 /* BEGIN INCLUDE FILE ... saved_dir_info.incl.pl1 */
  1     2 /* Modified 07/10/82 by Jim Lippard to only have 2 dir ring brackets */
  1     3 
  1     4 dcl 1 fseg based (fptr) aligned,
  1     5     2 fpath char (168) unal,
  1     6     2 timeof fixed bin (71),
  1     7     2 nents fixed bin,
  1     8     2 freep fixed bin,
  1     9     2 fpad (4) fixed bin,
  1    10     2 ffirst fixed bin;
  1    11 
  1    12 dcl fptr ptr;
  1    13 
  1    14 dcl 1 seg_rec based (xp) aligned,
  1    15     2 fnext bit (18),
  1    16     2 n_names fixed bin,
  1    17     2 brstat,
  1    18       3 type bit (2) unal,
  1    19       3 nnames bit (16) unal,
  1    20       3 nrp bit (18) unal,
  1    21       3 dtm bit (36) unal,
  1    22       3 dtu bit (36) unal,
  1    23       3 mode bit (5) unal,
  1    24       3 padding bit (13) unal,
  1    25       3 records bit (18) unal,
  1    26       3 dtd bit (36) unal,
  1    27       3 dtem bit (36) unal,
  1    28       3 lvid bit (36) unal,
  1    29       3 curlen bit (12) unal,
  1    30       3 bitcnt bit (24) unal,
  1    31       3 pad1 bit (8) unal,
  1    32       3 copysw bit (1) unal,
  1    33       3 tpd bit (1) unal,
  1    34       3 mdir bit (1) unal,
  1    35       3 damaged bit (1) unal,
  1    36       3 pad2 bit (6) unal,
  1    37       3 rbs (0:2) bit (6) unal,
  1    38       3 uid bit (36) unal,
  1    39     2 bc_author char (32) unal,
  1    40     2 author char (32) unal,
  1    41     2 max_lth fixed bin (19),
  1    42     2 ssw bit (1) unal,
  1    43     2 pad0 bit(35) unal,
  1    44     2 nacls fixed bin,
  1    45     2 acls (dummy refer (seg_rec.nacls)),
  1    46       3 access_name char (32),
  1    47       3 modes bit (36),
  1    48     2 names (dummy refer (seg_rec.n_names)),
  1    49       3 name char (32),
  1    50     2 end_seg_rec fixed bin;
  1    51 
  1    52 dcl 1 dir_rec based (xp) aligned,
  1    53     2 fnext bit (18),
  1    54     2 n_names fixed bin,
  1    55     2 brstat,
  1    56       3 type bit (2) unal,
  1    57       3 nnames bit (16) unal,
  1    58       3 nrp bit (18) unal,
  1    59       3 dtm bit (36) unal,
  1    60       3 dtu bit (36) unal,
  1    61       3 mode bit (5) unal,
  1    62       3 padding bit (13) unal,
  1    63       3 records bit (18) unal,
  1    64       3 dtd bit (36) unal,
  1    65       3 dtem bit (36) unal,
  1    66       3 slvid bit (36) unal,
  1    67       3 curlen bit (12) unal,
  1    68       3 bitcnt bit (24) unal,
  1    69       3 pad1 bit (8) unal,
  1    70       3 copysw bit (1) unal,
  1    71       3 tpd bit (1) unal,
  1    72       3 mdir bit (1) unal,				/* TRUE if mater dir */
  1    73       3 damaged bit (1) unal,
  1    74       3 pad2 bit (6) unal,
  1    75       3 rbs (0:1) bit (6) unal,
  1    76       3 pad3 bit (6) unal,
  1    77       3 uid bit (36) unal,
  1    78     2 bc_author char (32) unal,
  1    79     2 author char (32) unal,
  1    80     2 max_lth fixed bin (19),
  1    81     2 ssw bit (1) unal,
  1    82     2 pad0 bit(35) unal,
  1    83     2 quota fixed bin (18),
  1    84     2 nacls fixed bin,
  1    85     2 acls (dummy refer (dir_rec.nacls)),
  1    86       3 access_name char (32),
  1    87       3 modes bit (36),
  1    88     2 nisacls fixed bin,
  1    89     2 isacls (dummy refer (dir_rec.nisacls)),
  1    90       3 access_name char (32),
  1    91       3 modes bit (36),
  1    92     2 nidacls fixed bin,
  1    93     2 idacls (dummy refer (dir_rec.nidacls)),
  1    94       3 access_name char (32),
  1    95       3 modes bit (36),
  1    96     2 ncacls fixed bin,
  1    97     2 cacls (dummy refer (dir_rec.ncacls)),
  1    98       3 access_name char (32),
  1    99       3 modes bit (36),
  1   100     2 names (dummy refer (dir_rec.n_names)),
  1   101       3 name char (32),
  1   102     2 end_dir_rec fixed bin;
  1   103 
  1   104 dcl 1 link_rec based (xp) aligned,
  1   105     2 fnext bit (18),
  1   106     2 n_names fixed bin,
  1   107     2 brstat,
  1   108       3 type bit (2) unal,
  1   109       3 nnames bit (16) unal,
  1   110       3 nrp bit (18) unal,
  1   111       3 dtem bit (36) unal,
  1   112       3 dtd bit (36) unal,
  1   113       3 pnl bit (18) unal,
  1   114       3 pnrp bit (18) unal,
  1   115     2 target char (168),
  1   116     2 names (dummy refer (link_rec.n_names)),
  1   117       3 name char (32),
  1   118     2 end_link_rec fixed bin;
  1   119 
  1   120 dcl 1 aclval (nacl) based (tp) aligned,
  1   121     2 access_name char (32),
  1   122     2 modes bit (36);
  1   123 
  1   124 dcl tp ptr;
  1   125 
  1   126 /* END INCLUDE FILE ... saved_dir_info.incl.pl1 */
       73 
       74 
       75 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
       76 
       77 
       78 	call cu_$arg_ptr (1, ap, al, ec);
       79 	if ec ^= 0 then do;
       80 ER:	   call com_err_ (ec, "comp_dir_info", "
       81 Usage:  comp_dir_info dir_info_path1 dir_info_path2 {-control_arg}
       82 Args:   -brief, -bf
       83         -verbose
       84         -long, -lg");
       85 	   return;
       86 	   end;
       87 	call expand_pathname_$add_suffix (bchr, "dir_info", fdir1, fent1, ec);
       88 	if ec ^= 0 then do;
       89 	   call com_err_ (ec, "comp_dir_info", "^a", bchr);
       90 	   return;
       91 	   end;
       92 
       93 	call cu_$arg_ptr (2, ap, al, ec);
       94 	if ec ^= 0 then go to ER;
       95 	call expand_pathname_$add_suffix (bchr, "dir_info", fdir2, fent2, ec);
       96 	if ec ^= 0 then do;
       97 	   call com_err_ (ec, "comp_dir_info", "^a", bchr);
       98 	   return;
       99 	   end;
      100 
      101 	loud = "0"b;
      102 	verbosity = 1;
      103 	nchanges = 0;
      104 	firstdelete, firstadd = "1"b;
      105 	ec = 0;
      106 	do an = 3 by 1 while (ec = 0);
      107 	   call cu_$arg_ptr (an, ap, al, ec);
      108 	   if ec = 0 then do;
      109 	      if bchr = "-long" | bchr = "-lg" then do;
      110 	         loud = "1"b;
      111 	         verbosity = 2;
      112 	         end;
      113 	      else if bchr = "-verbose" | bchr = "-vb" then do;
      114 	         loud = "1"b;
      115 	         verbosity = 3;
      116 	         end;
      117 	      else if bchr = "-brief" | bchr = "-bf" then do;
      118 	         loud = "0"b;
      119 	         verbosity = 0;
      120 	         end;
      121 	      else do;
      122 	         if index(bchr,"-") = 1 then
      123 		  ec = error_table_$badopt;
      124 	         else
      125 		  ec = error_table_$bad_arg;
      126 	         call com_err_ (ec, "comp_dir_info", "^a", bchr);
      127 	         return;
      128 	         end;
      129 	      end;
      130 	   end;
      131 
      132           fptr1 = null;
      133 	fptr2 = null;
      134 	on cleanup call janitor();
      135 
      136 	call hcs_$initiate (fdir1, fent1, "", 0, 0, fptr1, ec);
      137 	if fptr1 = null then do;
      138 	   call com_err_ (ec, "comp_dir_info", "Accessing dir_info segment
      139 (^a^[>^]^a).", fdir1, fdir1^=">", fent1);
      140 	   go to EXIT;
      141 	   end;
      142 
      143 	call hcs_$initiate (fdir2, fent2, "", 0, 0, fptr2, ec);
      144 	if fptr2 = null then do;
      145 	   call com_err_ (ec, "comp_dir_info", "Accessing dir_info segment
      146 (^a^[>^]^a).", fdir2, fdir2^=">", fent2);
      147 	   go to EXIT;
      148 	   end;
      149 
      150 	if verbosity > 0 then do;			/* Print titles */
      151 	   call date_time_ (fptr1 -> fseg.timeof, datstr1);
      152 	   call date_time_ (fptr2 -> fseg.timeof, datstr2);
      153 	   call ioa_ ("^|Comparing ^a as of ^a^/^7xto ^a as of ^a",
      154 	      fptr1 -> fseg.fpath, datstr1, fptr2 -> fseg.fpath, datstr2);
      155 	   end;
      156 	n1 = fptr1 -> fseg.nents + 1;			/* add one because dir itself is in there. */
      157 	n2 = fptr2 -> fseg.nents + 1;
      158 
      159 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      160 	/*									*/
      161 	/* This begin block contains the main loop.  We take one entry at a time from the old	*/
      162 	/* segment, and look for it in the new segment.  A match on unique ID is preferred, or	*/
      163 	/* else a match of any name in the new entry for the primary name on the old entry.	*/
      164 	/*									*/
      165 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      166 
      167 COMPARE_BLOCK:
      168 	begin;
      169 
      170 dcl  x1 bit (n1);					/* if i'th bit of x1 is on, entry in old was deleted */
      171 dcl  x2 bit (n2);					/* If i'th bit of x2 is on, entry in new was matched. */
      172 dcl (x1count, x2count) fixed bin;
      173 
      174 	   x1 = "0"b;				/* Clear check arrays. */
      175 	   x2 = "0"b;
      176 	   x1count = 0;
      177 	   x2count = n2;
      178 
      179 	   name1x = 1;
      180 	   xp1 = addr (fptr1 -> fseg.ffirst);
      181 
      182 LOOP:	   if xp1 -> seg_rec.type = "01"b then do;
      183 	      type1 = 1;
      184 	      np1 = addr (xp1 -> seg_rec.names);
      185 	      uid1 = xp1 -> seg_rec.uid;
      186 	      end;
      187 	   else if xp1 -> dir_rec.type = "10"b then do;
      188 	      type1 = 2;
      189 	      np1 = addr (xp1 -> dir_rec.names);
      190 	      uid1 = xp1 -> dir_rec.uid;
      191 	      end;
      192 	   else do;
      193 	      type1 = 0;
      194 	      np1 = addr (xp1 -> link_rec.names);
      195 	      uid1 = (36)"0"b;
      196 	      end;
      197 	   en1 = np1 -> names (1);
      198 
      199 	   name2x = 1;
      200 	   xp2 = addr (fptr2 -> fseg.ffirst);
      201 SEARCH:	   if x2count = 0 then go to NOTTHERE;
      202 	   if substr (x2, name2x, 1) then go to NEXT;
      203 	   type2 = fixed (xp2 -> seg_rec.type);
      204 	   if type2 = 1 then np2 = addr (xp2 -> seg_rec.names);
      205 	   else if type2 = 2 then np2 = addr (xp2 -> dir_rec.names);
      206 	   else np2 = addr (xp2 -> link_rec.names);
      207 	   if type2 ^= 0 then
      208 	      if uid1 = xp2 -> seg_rec.uid then go to MATCH;
      209 	   do i = 1 to xp2 -> seg_rec.n_names;
      210 	      if np2 -> names (i) = en1 then if type1 = type2 then go to MATCH;
      211 	      end;
      212 NEXT:	   if xp2 -> seg_rec.fnext then do;
      213 	      xp2 = ptr (xp2, xp2 -> seg_rec.fnext);
      214 	      name2x = name2x + 1;
      215 	      go to SEARCH;
      216 	      end;
      217 
      218 NOTTHERE:	   nchanges = nchanges + 1;
      219 	   substr (x1, name1x, 1) = "1"b;		/* Entry was deleted. */
      220 	   x1count = x1count + 1;
      221 	   go to SKIP1;
      222 
      223 
      224 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      225 	/*									*/
      226 	/* This section is entered when we have found an entry in both the old and new dir_info	*/
      227 	/* segments, with either a UID match or a name match, and the same type		*/
      228 	/*									*/
      229 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      230 
      231 MATCH:	   substr (x2, name2x, 1) = "1"b;
      232 	   x2count = x2count - 1;
      233 	   headed = "0"b;
      234 	   m = xp2 -> seg_rec.n_names;
      235 
      236 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      237 	/*									*/
      238 	/* This section compares the names on the old and new entries.			*/
      239 	/*									*/
      240 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      241 
      242 NAME_BLOCK:  begin;
      243 
      244 dcl  nfg bit (m);					/* if i'th bit of nfg is on, name was matched */
      245 dcl  nfg_count fixed bin;
      246 
      247 	      nfg_count = m;
      248 	      nfg = "0"b;
      249 	      do i = 1 to xp1 -> seg_rec.n_names;
      250 	         n = index (np1 -> names (i), " ");
      251 	         do k = 1 to m while (nfg_count > 0);
      252 		  if ^substr (nfg, k, 1) then	/* Make sure name not matched already */
      253 		  if np1 -> names (i) = np2 -> names (k) then do;
      254 		     substr (nfg, k, 1) = "1"b;
      255 		     nfg_count = nfg_count - 1;
      256 		     go to BREAK;			/* Name is matched. */
      257 		     end;
      258 		  end;
      259 	         if ^headed then call head;		/* Leftover old name. */
      260 	         call ioa_ ("^-name deleted:^-^a", np1 -> names (i));
      261 BREAK:	         end;
      262 
      263 	      do i = 1 to m while (nfg_count > 0);	/* Check for unmatched new names */
      264 	         if ^substr (nfg, i, 1) then do;
      265 		  nfg_count = nfg_count - 1;
      266 		  if ^headed then call head;
      267 		  call ioa_ ("^-name added:^-^a", np2 -> names (i));
      268 		  end;
      269 	         end;
      270 	      end NAME_BLOCK;
      271 
      272 
      273 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      274 	/*									*/
      275 	/* Now we check the rest of the entry to see what has been modified.			*/
      276 	/*									*/
      277 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      278 
      279 	   if type1 = 0 then do;			/* If link, check target */
      280 	      if xp1 -> link_rec.target ^= xp2 -> link_rec.target then do;
      281 	         if ^headed then call head;
      282 	         call ioa_ ("^-link target changed from ^a  to  ^a",
      283 		  xp1 -> link_rec.target, xp2 -> link_rec.target);
      284 	         end;
      285 	      if loud then do;
      286 	         if xp1 -> link_rec.dtem ^= xp2 -> link_rec.dtem then do;
      287 		  if ^headed then call head;
      288 		  call ioa_ ("^-date link modified changed from ^a  to  ^a",
      289 		     datec (xp1 -> link_rec.dtem), datec (xp2 -> link_rec.dtem));
      290 		  end;
      291 	         end;
      292 	      go to SKIP1;
      293 	      end;
      294 
      295 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      296 	/*									*/
      297 	/* Segment or directory. Check for changes.					*/
      298 	/*									*/
      299 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      300 
      301 	   if xp1 -> seg_rec.rbs (0) ^= xp2 -> seg_rec.rbs (0) then go to XRB;
      302 	   if xp1 -> seg_rec.rbs (1) ^= xp2 -> seg_rec.rbs (1) then go to XRB;
      303 	   if xp1 -> seg_rec.rbs (2) ^= xp2 -> seg_rec.rbs (2) then do;
      304 XRB:	      if ^headed then call head;
      305 	      call ioa_ ("^-ring brackets changed from ^d,^d^[,^d^;^s^] to ^d,^d^[,^d^;^s^]",
      306 	         fixed (binary (xp1 -> seg_rec.rbs (0)), 35),
      307 	         fixed (binary (xp1 -> seg_rec.rbs (1)), 35),
      308 	         segtype (type1) ^= "dir ",
      309 	         fixed (binary (xp1 -> seg_rec.rbs (2)), 35),
      310 	         fixed (binary (xp2 -> seg_rec.rbs (0)), 35),
      311 	         fixed (binary (xp2 -> seg_rec.rbs (1)), 35),
      312 	         segtype (type2) ^= "dir ",
      313 	         fixed (binary (xp2 -> seg_rec.rbs (2)), 35));
      314 	      end;
      315 	   if xp1 -> dir_rec.damaged ^= xp2 -> dir_rec.damaged then do;
      316 	      if ^headed then call head;
      317 	      call ioa_ ("^-damaged changed from ^[ON^;OFF^]  to  ^[ON^;OFF^]",
      318 	         xp1 -> dir_rec.damaged, xp2 -> dir_rec.damaged);
      319 	      end;
      320 
      321 	   if loud then do;
      322 	      if xp1 -> dir_rec.ssw ^= xp2 -> dir_rec.ssw then do;
      323 	         if ^headed then call head;
      324 	         call ioa_ ("^-safety switch changed from ^[ON^;OFF^]  to  ^[ON^;OFF^]",
      325 		  xp1 -> dir_rec.ssw, xp2 -> dir_rec.ssw);
      326 	         if xp1 -> dir_rec.tpd ^= xp2 -> dir_rec.tpd then do;
      327 		  if ^headed then call head;
      328 		  call ioa_ ("^-tpd changed from ^[ON^;OFF^]  to  ^[ON^;OFF^]",
      329 		     xp1 -> dir_rec.tpd, xp2 -> dir_rec.tpd);
      330 		  end;
      331 	         end;
      332 	      if xp1 -> dir_rec.author ^= xp2 -> dir_rec.author then do;
      333 	         if ^headed then call head;
      334 	         call ioa_ ("^-author changed from ^a  to  ^a",
      335 		  xp1 -> dir_rec.author, xp2 -> dir_rec.author);
      336 	         end;
      337 	      if xp1 -> dir_rec.bc_author ^= xp2 -> dir_rec.bc_author then do;
      338 	         if ^headed then call head;
      339 	         call ioa_ ("^-bit count author changed from ^a  to  ^a",
      340 		  xp1 -> dir_rec.bc_author, xp2 -> dir_rec.bc_author);
      341 	         end;
      342 	      if type1 = 1 then do;
      343 	         call compare_acl (addr (xp1 -> seg_rec.acls), addr (xp2 -> seg_rec.acls),
      344 		  xp1 -> seg_rec.nacls, xp2 -> seg_rec.nacls, "ACL", 1);
      345 	         end;
      346 	      else do;
      347 	         call compare_acl (addr (xp1 -> dir_rec.acls), addr (xp2 -> dir_rec.acls),
      348 		  xp1 -> dir_rec.nacls, xp2 -> dir_rec.nacls, "ACL", 2);
      349 	         end;
      350 	      end;
      351 
      352 	   else do;				/* Non-loud mode. */
      353 	      if type1 = 2 then			/* if dir */
      354 	         if xp1 -> dir_rec.nacls > 0 then if xp2 -> dir_rec.nacls = 0 then go to ZACL;
      355 	      if type1 = 1 then			/* else if seg */
      356 	      if xp1 -> seg_rec.nacls > 0 then
      357 	      if xp2 -> seg_rec.nacls = 0 then do;
      358 ZACL:	         if ^headed then call head;
      359 	         call ioa_ ("^-ACL has been deleted");
      360 	         end;
      361 	      end;
      362 
      363 	   if type1 = 1 then do;			/* segment? */
      364 	      if loud then do;
      365 	         if xp1 -> seg_rec.dtem ^= xp2 -> seg_rec.dtem then do;
      366 		  if ^headed then call head;
      367 		  call ioa_ ("^-date branch modified changed from ^a  to  ^a",
      368 		     datec (xp1 -> seg_rec.dtem), datec (xp2 -> seg_rec.dtem));
      369 		  end;
      370 	         if verbosity = 3 then do;
      371 		  if (xp1 -> seg_rec.lvid ^= "0"b) & (xp1 -> seg_rec.lvid ^= xp2 -> seg_rec.lvid) then do;
      372 		     if ^headed then call head;
      373 		     call ioa_ ("^-volume changed from ^a  to  ^a",
      374 		        volnc (xp1 -> seg_rec.lvid), volnc (xp2 -> seg_rec.lvid));
      375 		     end;
      376 		  if xp1 -> seg_rec.dtm ^= xp2 -> seg_rec.dtm then do;
      377 		     if ^headed then call head;
      378 		     call ioa_ ("^-date modified changed from ^a  to  ^a",
      379 		        datec (xp1 -> seg_rec.dtm), datec (xp2 -> seg_rec.dtm));
      380 		     end;
      381 		  if xp1 -> seg_rec.bitcnt ^= xp2 -> seg_rec.bitcnt then do;
      382 		     if ^headed then call head;
      383 		     call ioa_ ("^-bit count changed from ^d  to  ^d",
      384 		        fixed (binary (xp1 -> seg_rec.bitcnt), 35), fixed (binary (xp2 -> seg_rec.bitcnt), 35));
      385 		     end;
      386 		  end;
      387 	         if xp1 -> seg_rec.records ^= xp2 -> seg_rec.records then do;
      388 		  if ^headed then call head;
      389 		  call ioa_ ("^-records used changed from ^d  to  ^d",
      390 		     fixed (binary (xp1 -> seg_rec.records), 35), fixed (binary (xp2 -> seg_rec.records), 35));
      391 		  end;
      392 	         if xp1 -> dir_rec.max_lth ^= xp2 -> dir_rec.max_lth then do;
      393 		  if ^headed then call head;
      394 		  call ioa_ ("^-max length changed from ^d  to  ^d",
      395 		     xp1 -> dir_rec.max_lth, xp2 -> dir_rec.max_lth);
      396 		  end;
      397 	         end;
      398 	      else do;
      399 	         if xp1 -> seg_rec.records then
      400 	         if xp2 -> seg_rec.records = "0"b then do;
      401 		  if ^headed then call head;
      402 		  call ioa_ ("^-segment has been truncated");
      403 		  end;
      404 	         end;
      405 	      end;
      406 
      407 	   else do;				/* directory */
      408 	      if (xp1 -> dir_rec.slvid ^= "0"b) & (xp1 -> dir_rec.slvid ^= xp2 -> dir_rec.slvid) then do;
      409 	         if ^headed then call head;
      410 	         call ioa_ ("^-sons volume changed from ^a  to  ^a",
      411 		  volnc (xp1 -> dir_rec.slvid), volnc (xp2 -> dir_rec.slvid));
      412 	         end;
      413 	      if xp1 -> dir_rec.mdir ^= xp2 -> dir_rec.mdir then do;
      414 	         if ^headed then call head;
      415 	         call ioa_ ("^-mdir changed from ^[ON^;OFF^]  to  ^[ON^;OFF^]",
      416 		  xp1 -> dir_rec.mdir, xp2 -> dir_rec.mdir);
      417 	         end;
      418 	      if xp1 -> dir_rec.quota ^= xp2 -> dir_rec.quota then do;
      419 	         if ^headed then call head;
      420 	         call ioa_ ("^-quota changed from ^d  to  ^d",
      421 		  xp1 -> dir_rec.quota, xp2 -> dir_rec.quota);
      422 	         end;
      423 	      if xp1 -> seg_rec.bitcnt ^= xp2 -> seg_rec.bitcnt then do;
      424 	         if ^headed then call head;
      425 	         call ioa_ ("^-msf indicator changed from ^d  to  ^d",
      426 		  fixed (binary (xp1 -> seg_rec.bitcnt), 35), fixed (binary (xp2 -> seg_rec.bitcnt), 35));
      427 	         end;
      428 	      if verbosity = 3 then do;
      429 	         if xp1 -> seg_rec.dtem ^= xp2 -> seg_rec.dtem then do;
      430 		  if ^headed then call head;
      431 		  call ioa_ ("^-date branch modified changed from ^a  to  ^a",
      432 		     datec (xp1 -> seg_rec.dtem), datec (xp2 -> seg_rec.dtem));
      433 		  end;
      434 	         if xp1 -> seg_rec.dtm ^= xp2 -> seg_rec.dtm then do;
      435 		  if ^headed then call head;
      436 		  call ioa_ ("^-date modified changed from ^a  to  ^a",
      437 		     datec (xp1 -> seg_rec.dtm), datec (xp2 -> seg_rec.dtm));
      438 		  end;
      439 	         end;
      440 	      if loud then do;
      441 	         call compare_acl (addr (xp1 -> dir_rec.isacls), addr (xp2 -> dir_rec.isacls),
      442 		  xp1 -> dir_rec.nisacls, xp2 -> dir_rec.nisacls, "initial seg acl", 1);
      443 	         call compare_acl (addr (xp1 -> dir_rec.idacls), addr (xp2 -> dir_rec.idacls),
      444 		  xp1 -> dir_rec.nidacls, xp2 -> dir_rec.nidacls, "initial dir acl", 2);
      445 	         end;
      446 	      end;
      447 
      448 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      449 	/*									*/
      450 	/* Go on to the next record in the old dir_info segment.				*/
      451 	/*									*/
      452 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      453 
      454 SKIP1:	   if xp1 -> seg_rec.fnext then do;
      455 	      xp1 = ptr (xp1, xp1 -> seg_rec.fnext);
      456 	      name1x = name1x + 1;
      457 	      go to LOOP;
      458 	      end;
      459 
      460 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      461 	/*									*/
      462 	/* End of scan over old dir_info segment, which began at label "LOOP"			*/
      463 	/*									*/
      464 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      465 
      466 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      467 	/*									*/
      468 	/* Scan old dir_info segment for any segments which were deleted.			*/
      469 	/*									*/
      470 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      471 
      472 	   i = 1;
      473 	   xp1 = addr (fptr1 -> fseg.ffirst);
      474 LOOP2A:	   if substr (x1, i, 1) then do;
      475 	      x1count = x1count - 1;
      476 	      type1 = fixed (xp1 -> seg_rec.type);
      477 	      if type1 = 1 then np1 = addr (xp1 -> seg_rec.names);
      478 	      else if type1 = 2 then np1 = addr (xp1 -> dir_rec.names);
      479 	      else np1 = addr (xp1 -> link_rec.names);
      480 	      if firstdelete then do;
      481 	         call ioa_ ("^/^/");
      482 	         firstdelete = "0"b;
      483 	         end;
      484 	      call ioa_ ("^/deleted:^-^a ^a", segtype (type1), np1 -> names (1));
      485 	      call list_dir_info_ (xp1, verbosity, TAB);
      486 	      end;
      487 	   if x1count > 0 then
      488 	   if xp1 -> seg_rec.fnext then do;
      489 	      i = i + 1;
      490 	      xp1 = ptr (xp1, xp1 -> seg_rec.fnext);
      491 	      go to LOOP2A;
      492 	      end;
      493 
      494 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      495 	/*									*/
      496 	/* Hunt for any entries in the new segment which have been added.			*/
      497 	/*									*/
      498 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      499 
      500 	   i = 1;
      501 	   xp2 = addr (fptr2 -> fseg.ffirst);
      502 LOOP2:	   if ^substr (x2, i, 1) then do;
      503 	      x2count = x2count - 1;
      504 	      type2 = fixed (xp2 -> seg_rec.type);
      505 	      if type2 = 1 then np2 = addr (xp2 -> seg_rec.names);
      506 	      else if type2 = 2 then np2 = addr (xp2 -> dir_rec.names);
      507 	      else np2 = addr (xp2 -> link_rec.names);
      508 	      nchanges = nchanges + 1;
      509 	      if firstadd then do;
      510 	         call ioa_ ("^/^/");
      511 	         firstadd = "0"b;
      512 	         end;
      513 	      call ioa_ ("^/added:^-^a ^a", segtype (type2), np2 -> names (1));
      514 	      call list_dir_info_ (xp2, verbosity, TAB);
      515 	      end;
      516 	   if x2count > 0 then
      517 	   if xp2 -> seg_rec.fnext then do;
      518 	      i = i + 1;
      519 	      xp2 = ptr (xp2, xp2 -> seg_rec.fnext);
      520 	      go to LOOP2;
      521 	      end;
      522 	   end COMPARE_BLOCK;
      523 
      524 	if nchanges = 0 then call ioa_ ("Identical");
      525 	call ioa_ ("");
      526 
      527 EXIT:	call janitor();
      528 	return;
      529 
      530 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      531 
      532 
      533 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      534 	/*									*/
      535 	/*		I  N  T  E  R  N  A  L        P  R  O  C  E  D  U  R  E  S		*/
      536 	/*									*/
      537 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      538 
      539 
      540 cmode:	proc (x, t) returns (char (5) aligned);
      541 
      542 dcl  x bit (36) aligned;
      543 dcl  t fixed bin;
      544 
      545 dcl  ans char (5) aligned;
      546 dcl (i, k) fixed bin;
      547 dcl  xmode (2, 5) char (1) int static options(constant) init("r", "e", "w", "a", "", "s", "m", "a", "", "");
      548 
      549 	k = 1;
      550 	ans = "";
      551 	do i = 1 to 5;
      552 	   if substr (x, i, 1) then do;
      553 	      substr (ans, k, 1) = xmode (t, i);
      554 	      k = k + 1;
      555 	      end;
      556 	   end;
      557 
      558 	if ans = "" then ans = "null";
      559 	return (ans);
      560 
      561 	end cmode;
      562 
      563 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      564 
      565 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      566 
      567 
      568 compare_acl:
      569 	proc (p1, p2, n1, n2, prefix, acltype);
      570 
      571 dcl (p1, p2) ptr,
      572     (n1, n2) fixed bin,
      573      prefix char (*),
      574      acltype fixed bin;
      575 
      576 dcl  aclbit bit (n2),
      577     (i, j) fixed bin,
      578      tcount fixed bin;
      579 
      580 	aclbit = "0"b;
      581 	tcount = n2;
      582 
      583 	nacl = max(n1,n2);
      584 	do i = 1 to n1;
      585 	   do j = 1 to n2;
      586 	      if p1 -> aclval.access_name (i) = p2 -> aclval.access_name (j) then do;
      587 	         substr (aclbit, j, 1) = "1"b;
      588 	         tcount = tcount - 1;
      589 	         if p1 -> aclval.modes (i) = p2 -> aclval.modes (j) then go to ACLOK;
      590 	         if ^headed then call head;
      591 	         call ioa_ ("^-^a for ^a changed from ^a  to  ^a",
      592 		  prefix, p2 -> aclval.access_name (j),
      593 		  cmode (p1 -> aclval.modes (i), acltype), cmode (p2 -> aclval.modes (j), acltype));
      594 	         go to ACLOK;
      595 	         end;
      596 	      end;
      597 	   if ^headed then call head;
      598 	   call ioa_ ("^-^a deleted: ^a ^a",
      599 	      prefix, cmode (p1 -> aclval.modes (i), acltype), p1 -> aclval.access_name (i));
      600 ACLOK:	   end;
      601 
      602 	do i = 1 to n2 while (tcount > 0);
      603 	   if ^substr (aclbit, i, 1) then do;
      604 	      tcount = tcount - 1;
      605 	      if ^headed then call head;
      606 	      call ioa_ ("^-^a added: ^a ^a",
      607 	         prefix, cmode (p2 -> aclval.modes (i), acltype), p2 -> aclval.access_name (i));
      608 	      end;
      609 	   end;
      610 
      611 	end compare_acl;
      612 
      613 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      614 
      615 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      616 
      617 
      618 datec:	proc (x) returns (char (24));
      619 
      620 dcl  x bit (36);
      621 
      622 dcl  datstr char (24);
      623 
      624 	call date_time_$fstime ((x), datstr);
      625 	return (datstr);
      626 
      627 	end datec;
      628 
      629 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      630 
      631 
      632 head:	proc;
      633 
      634 	headed = "1"b;
      635 	call ioa_ ("^/modified:^-^a ^a", segtype (type1), en1);
      636 	nchanges = nchanges + 1;
      637 
      638 	end head;
      639 
      640 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      641 
      642 
      643 janitor:  proc();
      644 
      645 	if fptr1 ^= null then
      646 	   call hcs_$terminate_noname (fptr1, ec);
      647 	if fptr2 ^= null then
      648 	   call hcs_$terminate_noname (fptr2, ec);
      649 
      650 	end janitor;
      651 
      652 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      653 
      654 
      655 volnc:	proc (x) returns (char (32) aligned);
      656 
      657 dcl  x bit (36);
      658 
      659 dcl  lvname char (32) aligned, code fixed bin (35);
      660 
      661 	call mdc_$find_lvname (x, lvname, code);
      662 	if code ^= 0 then call ioa_$rsnnl ("^w", lvname, code, x);
      663 	return (lvname);
      664 
      665 	end volnc;
      666 
      667 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      668 
      669 
      670        end comp_dir_info;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/22/82  1111.4  comp_dir_info.pl1                 >spec>on>11/22/82>comp_dir_info.pl1
73           1    11/19/82  1625.1  saved_dir_info.incl.pl1           >ldd>include>saved_dir_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
TAB                             000006 constant        char(1)                  initial unaligned dcl 68 set ref 485* 514*
access_name                            based           char(32)                 array level 2 dcl 1-120 set ref 586 586 591* 598*
                                                                                  606*
aclbit                          000112 automatic       bit                      unaligned dcl 576 set ref 580* 587* 603
acls                     37            based           structure                array level 2 in structure "seg_rec" dcl 1-14
                                                                                  in procedure "comp_dir_info" set ref 343 343 343
                                                                                  343
acls                     40            based           structure                array level 2 in structure "dir_rec" dcl 1-52
                                                                                  in procedure "comp_dir_info" set ref 347 347 347
                                                                                  347
acltype                                parameter       fixed bin(17,0)          dcl 571 set ref 568 591* 591* 591* 591* 598* 598*
                                                                                  606* 606*
aclval                                 based           structure                array level 1 dcl 1-120
addr                                                   builtin function         dcl 49 ref 180 184 189 194 200 204 205 206 343 343
                                                                                  343 343 347 347 347 347 441 441 441 441 443 443
                                                                                  443 443 473 477 478 479 501 505 506 507
al                              000100 automatic       fixed bin(21,0)          dcl 25 set ref 78* 87 87 89 89 93* 95 95 97 97 107*
                                                                                  109 109 113 113 117 117 122 126 126
an                              000101 automatic       fixed bin(17,0)          dcl 25 set ref 106* 107*
ans                             000106 automatic       char(5)                  dcl 545 set ref 550* 553* 558 558* 559
ap                              000102 automatic       pointer                  dcl 25 set ref 78* 87 89 93* 95 97 107* 109 109 113
                                                                                  113 117 117 122 126
author                   24            based           char(32)                 level 2 packed unaligned dcl 1-52 set ref 332 332
                                                                                  334* 334*
bc_author                14            based           char(32)                 level 2 packed unaligned dcl 1-52 set ref 337 337
                                                                                  339* 339*
bchr                                   based           char                     unaligned dcl 53 set ref 87* 89* 95* 97* 109 109 113
                                                                                  113 117 117 122 126*
binary                                                 builtin function         dcl 49 ref 305 305 305 305 305 305 305 305 305 305
                                                                                  305 305 383 383 383 383 389 389 389 389 425 425
                                                                                  425 425
bitcnt                   11(12)        based           bit(24)                  level 3 packed unaligned dcl 1-14 ref 381 381 383
                                                                                  383 383 383 423 423 425 425 425 425
brstat                    2            based           structure                level 2 in structure "seg_rec" dcl 1-14 in procedure
                                                                                  "comp_dir_info"
brstat                    2            based           structure                level 2 in structure "link_rec" dcl 1-104
                                                                                  in procedure "comp_dir_info"
brstat                    2            based           structure                level 2 in structure "dir_rec" dcl 1-52 in procedure
                                                                                  "comp_dir_info"
cleanup                         000334 stack reference condition                dcl 51 ref 134
code                            000146 automatic       fixed bin(35,0)          dcl 659 set ref 661* 662 662*
com_err_                        000010 constant        entry                    external dcl 56 ref 80 89 97 126 138 145
cu_$arg_ptr                     000012 constant        entry                    external dcl 56 ref 78 93 107
damaged                  12(11)        based           bit(1)                   level 3 packed unaligned dcl 1-52 set ref 315 315
                                                                                  317* 317*
date_time_                      000014 constant        entry                    external dcl 56 ref 151 152
date_time_$fstime               000016 constant        entry                    external dcl 56 ref 624
datstr                          000122 automatic       char(24)                 unaligned dcl 622 set ref 624* 625
datstr1                         000104 automatic       char(24)                 unaligned dcl 25 set ref 151* 153*
datstr2                         000112 automatic       char(24)                 unaligned dcl 25 set ref 152* 153*
dir_rec                                based           structure                level 1 dcl 1-52
dtem                      3            based           bit(36)                  level 3 in structure "link_rec" packed unaligned
                                                                                  dcl 1-104 in procedure "comp_dir_info" set ref 286
                                                                                  286 288* 288* 288* 288*
dtem                      7            based           bit(36)                  level 3 in structure "seg_rec" packed unaligned
                                                                                  dcl 1-14 in procedure "comp_dir_info" set ref 365
                                                                                  365 367* 367* 367* 367* 429 429 431* 431* 431*
                                                                                  431*
dtm                       3            based           bit(36)                  level 3 packed unaligned dcl 1-14 set ref 376 376
                                                                                  378* 378* 378* 378* 434 434 436* 436* 436* 436*
ec                              000120 automatic       fixed bin(35,0)          dcl 25 set ref 78* 79 80* 87* 88 89* 93* 94 95* 96
                                                                                  97* 105* 106 107* 108 122* 124* 126* 136* 138*
                                                                                  143* 145* 645* 647*
en1                             000121 automatic       char(32)                 unaligned dcl 25 set ref 197* 210 635*
error_table_$bad_arg            000036 external static fixed bin(35,0)          dcl 68 ref 124
error_table_$badopt             000040 external static fixed bin(35,0)          dcl 68 ref 122
expand_pathname_$add_suffix     000020 constant        entry                    external dcl 56 ref 87 95
fdir1                           000131 automatic       char(168)                unaligned dcl 25 set ref 87* 136* 138* 138
fdir2                           000203 automatic       char(168)                unaligned dcl 25 set ref 95* 143* 145* 145
fent1                           000255 automatic       char(32)                 unaligned dcl 25 set ref 87* 136* 138*
fent2                           000265 automatic       char(32)                 unaligned dcl 25 set ref 95* 143* 145*
ffirst                   62            based           fixed bin(17,0)          level 2 dcl 1-4 set ref 180 200 473 501
firstadd                        000275 automatic       bit(1)                   unaligned dcl 25 set ref 104* 509 511*
firstdelete                     000276 automatic       bit(1)                   unaligned dcl 25 set ref 104* 480 482*
fixed                                                  builtin function         dcl 49 ref 203 305 305 305 305 305 305 305 305 305
                                                                                  305 305 305 383 383 383 383 389 389 389 389 425
                                                                                  425 425 425 476 504
fnext                                  based           bit(18)                  level 2 dcl 1-14 ref 212 213 454 455 487 490 516 519
fpath                                  based           char(168)                level 2 packed unaligned dcl 1-4 set ref 153* 153*
fptr1                           000300 automatic       pointer                  dcl 25 set ref 132* 136* 137 151 153 156 180 473 645
                                                                                  645*
fptr2                           000302 automatic       pointer                  dcl 25 set ref 133* 143* 144 152 153 157 200 501 647
                                                                                  647*
fseg                                   based           structure                level 1 dcl 1-4
hcs_$initiate                   000022 constant        entry                    external dcl 56 ref 136 143
hcs_$terminate_noname           000024 constant        entry                    external dcl 56 ref 645 647
headed                          000304 automatic       bit(1)                   unaligned dcl 25 set ref 233* 259 266 281 287 304
                                                                                  316 323 327 333 338 358 366 372 377 382 388 393
                                                                                  401 409 414 419 424 430 435 590 597 605 634*
i                               000305 automatic       fixed bin(17,0)          dcl 25 in procedure "comp_dir_info" set ref 209*
                                                                                  210* 249* 250 252 260* 263* 264 267* 472* 474 489*
                                                                                  489 500* 502 518* 518
i                               000112 automatic       fixed bin(17,0)          dcl 576 in procedure "compare_acl" set ref 584* 586
                                                                                  589 591 591 598 598 598* 602* 603 606 606 606*
i                               000110 automatic       fixed bin(17,0)          dcl 546 in procedure "cmode" set ref 551* 552 553*
idacls                                 based           structure                array level 2 dcl 1-52 set ref 443 443 443 443
index                                                  builtin function         dcl 49 ref 122 250
ioa_                            000026 constant        entry                    external dcl 56 ref 153 260 267 282 288 305 317 324
                                                                                  328 334 339 359 367 373 378 383 389 394 402 410
                                                                                  415 420 425 431 436 481 484 510 513 524 525 591
                                                                                  598 606 635
ioa_$rsnnl                      000030 constant        entry                    external dcl 56 ref 662
isacls                                 based           structure                array level 2 dcl 1-52 set ref 441 441 441 441
j                               000113 automatic       fixed bin(17,0)          dcl 576 set ref 585* 586 587 589 591 591 591*
k                               000111 automatic       fixed bin(17,0)          dcl 546 in procedure "cmode" set ref 549* 553 554*
                                                                                  554
k                               000306 automatic       fixed bin(17,0)          dcl 25 in procedure "comp_dir_info" set ref 251* 252
                                                                                  252 254*
link_rec                               based           structure                level 1 dcl 1-104
list_dir_info_                  000032 constant        entry                    external dcl 56 ref 485 514
loud                            000311 automatic       bit(1)                   unaligned dcl 25 set ref 101* 110* 114* 118* 285 321
                                                                                  364 440
lvid                     10            based           bit(36)                  level 3 packed unaligned dcl 1-14 set ref 371 371
                                                                                  371 373* 373* 373* 373*
lvname                          000136 automatic       char(32)                 dcl 659 set ref 661* 662* 663
m                               000307 automatic       fixed bin(17,0)          dcl 25 set ref 234* 244 247 251 263
max                                                    builtin function         dcl 49 ref 583
max_lth                  34            based           fixed bin(19,0)          level 2 dcl 1-52 set ref 392 392 394* 394*
mdc_$find_lvname                000034 constant        entry                    external dcl 56 ref 661
mdir                     12(10)        based           bit(1)                   level 3 packed unaligned dcl 1-52 set ref 413 413
                                                                                  415* 415*
modes                    10            based           bit(36)                  array level 2 dcl 1-120 set ref 589 589 591* 591*
                                                                                  591* 591* 598* 598* 606* 606*
n                               000310 automatic       fixed bin(17,0)          dcl 25 set ref 250*
n1                              000312 automatic       fixed bin(17,0)          dcl 25 in procedure "comp_dir_info" set ref 156* 170
n1                                     parameter       fixed bin(17,0)          dcl 571 in procedure "compare_acl" ref 568 583 584
n2                              000313 automatic       fixed bin(17,0)          dcl 25 in procedure "comp_dir_info" set ref 157* 171
                                                                                  177
n2                                     parameter       fixed bin(17,0)          dcl 571 in procedure "compare_acl" ref 568 576 581
                                                                                  583 585 602
n_names                   1            based           fixed bin(17,0)          level 2 dcl 1-14 ref 209 234 249
nacl                            000314 automatic       fixed bin(17,0)          dcl 25 set ref 583*
nacls                    37            based           fixed bin(17,0)          level 2 in structure "dir_rec" dcl 1-52 in procedure
                                                                                  "comp_dir_info" set ref 189 189 189 189 189 189
                                                                                  189 189 205 205 205 205 205 205 205 205 347* 347*
                                                                                  353 353 441 441 441 441 441 441 443 443 443 443
                                                                                  443 443 443 443 443 443 443 443 478 478 478 478
                                                                                  478 478 478 478 506 506 506 506 506 506 506 506
nacls                    36            based           fixed bin(17,0)          level 2 in structure "seg_rec" dcl 1-14 in procedure
                                                                                  "comp_dir_info" set ref 184 204 343* 343* 355 355
                                                                                  477 505
name1x                          000315 automatic       fixed bin(17,0)          dcl 25 set ref 179* 219 456* 456
name2x                          000316 automatic       fixed bin(17,0)          dcl 25 set ref 199* 202 214* 214 231
names                    60            based           structure                array level 2 in structure "link_rec" dcl 1-104
                                                                                  in procedure "comp_dir_info" set ref 194 206 479
                                                                                  507
names                                  based           char(32)                 array dcl 53 in procedure "comp_dir_info" set ref
                                                                                  197 210 250 252 252 260* 267* 484* 513*
names                                  based           structure                array level 2 in structure "seg_rec" dcl 1-14
                                                                                  in procedure "comp_dir_info" set ref 184 204 477
                                                                                  505
names                                  based           structure                array level 2 in structure "dir_rec" dcl 1-52
                                                                                  in procedure "comp_dir_info" set ref 189 205 478
                                                                                  506
ncacls                                 based           fixed bin(17,0)          level 2 dcl 1-52 ref 189 205 478 506
nchanges                        000317 automatic       fixed bin(17,0)          dcl 25 set ref 103* 218* 218 508* 508 524 636* 636
nents                    54            based           fixed bin(17,0)          level 2 dcl 1-4 ref 156 157
nfg                             000100 automatic       bit                      unaligned dcl 244 set ref 248* 252 254* 264
nfg_count                       000100 automatic       fixed bin(17,0)          dcl 245 set ref 247* 251 255* 255 263 265* 265
nidacls                                based           fixed bin(17,0)          level 2 dcl 1-52 set ref 189 189 205 205 443* 443*
                                                                                  478 478 506 506
nisacls                                based           fixed bin(17,0)          level 2 dcl 1-52 set ref 189 189 189 189 205 205 205
                                                                                  205 441* 441* 443 443 443 443 443 443 478 478 478
                                                                                  478 506 506 506 506
np1                             000320 automatic       pointer                  dcl 25 set ref 184* 189* 194* 197 250 252 260 477*
                                                                                  478* 479* 484
np2                             000322 automatic       pointer                  dcl 25 set ref 204* 205* 206* 210 252 267 505* 506*
                                                                                  507* 513
null                                                   builtin function         dcl 49 ref 132 133 137 144 645 647
p1                                     parameter       pointer                  dcl 571 ref 568 586 589 591 591 598 598 598
p2                                     parameter       pointer                  dcl 571 ref 568 586 589 591 591 591 606 606 606
prefix                                 parameter       char                     unaligned dcl 571 set ref 568 591* 598* 606*
ptr                                                    builtin function         dcl 49 ref 213 455 490 519
quota                    36            based           fixed bin(18,0)          level 2 dcl 1-52 set ref 418 418 420* 420*
rbs                      12(18)        based           bit(6)                   array level 3 packed unaligned dcl 1-14 ref 301 301
                                                                                  302 302 303 303 305 305 305 305 305 305 305 305
                                                                                  305 305 305 305
records                   5(18)        based           bit(18)                  level 3 packed unaligned dcl 1-14 ref 387 387 389
                                                                                  389 389 389 399 399
seg_rec                                based           structure                level 1 dcl 1-14
segtype                         000003 constant        char(4)                  initial array dcl 68 set ref 305 305 484* 513* 635*
slvid                    10            based           bit(36)                  level 3 packed unaligned dcl 1-52 set ref 408 408
                                                                                  408 410* 410* 410* 410*
ssw                      35            based           bit(1)                   level 2 packed unaligned dcl 1-52 set ref 322 322
                                                                                  324* 324*
substr                                                 builtin function         dcl 49 set ref 202 219* 231* 252 254* 264 474 502
                                                                                  552 553* 587* 603
t                                      parameter       fixed bin(17,0)          dcl 543 ref 540 553
target                    6            based           char(168)                level 2 dcl 1-104 set ref 280 280 282* 282*
tcount                          000114 automatic       fixed bin(17,0)          dcl 576 set ref 581* 588* 588 602 604* 604
timeof                   52            based           fixed bin(71,0)          level 2 dcl 1-4 set ref 151* 152*
tpd                      12(09)        based           bit(1)                   level 3 packed unaligned dcl 1-52 set ref 326 326
                                                                                  328* 328*
type                      2            based           bit(2)                   level 3 in structure "seg_rec" packed unaligned
                                                                                  dcl 1-14 in procedure "comp_dir_info" ref 182 203
                                                                                  476 504
type                      2            based           bit(2)                   level 3 in structure "dir_rec" packed unaligned
                                                                                  dcl 1-52 in procedure "comp_dir_info" ref 187
type1                           000324 automatic       fixed bin(17,0)          dcl 25 set ref 183* 188* 193* 210 279 305 342 353
                                                                                  355 363 476* 477 478 484 635
type2                           000325 automatic       fixed bin(17,0)          dcl 25 set ref 203* 204 205 207 210 305 504* 505 506
                                                                                  513
uid                      13            based           bit(36)                  level 3 in structure "dir_rec" packed unaligned
                                                                                  dcl 1-52 in procedure "comp_dir_info" ref 190
uid                      13            based           bit(36)                  level 3 in structure "seg_rec" packed unaligned
                                                                                  dcl 1-14 in procedure "comp_dir_info" ref 185 207
uid1                            000326 automatic       bit(36)                  dcl 25 set ref 185* 190* 195* 207
verbosity                       000327 automatic       fixed bin(17,0)          dcl 25 set ref 102* 111* 115* 119* 150 370 428 485*
                                                                                  514*
x                                      parameter       bit(36)                  dcl 542 in procedure "cmode" ref 540 552
x                                      parameter       bit(36)                  unaligned dcl 620 in procedure "datec" ref 618 624
x                                      parameter       bit(36)                  unaligned dcl 657 in procedure "volnc" set ref 655
                                                                                  661* 662*
x1                              000100 automatic       bit                      unaligned dcl 170 set ref 174* 219* 474
x1count                         000100 automatic       fixed bin(17,0)          dcl 172 set ref 176* 220* 220 475* 475 487
x2                              000100 automatic       bit                      unaligned dcl 171 set ref 175* 202 231* 502
x2count                         000101 automatic       fixed bin(17,0)          dcl 172 set ref 177* 201 232* 232 503* 503 516
xmode                           000000 constant        char(1)                  initial array unaligned dcl 547 ref 553
xp1                             000330 automatic       pointer                  dcl 25 set ref 180* 182 184 185 187 189 190 194 249
                                                                                  280 282 286 288 288 301 302 303 305 305 305 305
                                                                                  305 305 315 317 322 324 326 328 332 334 337 339
                                                                                  343 343 343 347 347 347 353 355 365 367 367 371
                                                                                  371 373 373 376 378 378 381 383 383 387 389 389
                                                                                  392 394 399 408 408 410 410 413 415 418 420 423
                                                                                  425 425 429 431 431 434 436 436 441 441 441 443
                                                                                  443 443 454 455* 455 455 473* 476 477 478 479 485*
                                                                                  487 490* 490 490
xp2                             000332 automatic       pointer                  dcl 25 set ref 200* 203 204 205 206 207 209 212 213*
                                                                                  213 213 234 280 282 286 288 288 301 302 303 305
                                                                                  305 305 305 305 305 315 317 322 324 326 328 332
                                                                                  334 337 339 343 343 343 347 347 347 353 355 365
                                                                                  367 367 371 373 373 376 378 378 381 383 383 387
                                                                                  389 389 392 394 399 408 410 410 413 415 418 420
                                                                                  423 425 425 429 431 431 434 436 436 441 441 441
                                                                                  443 443 443 501* 504 505 506 507 514* 516 519* 519
                                                                                  519

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
fptr                                   automatic       pointer                  dcl 1-12
tp                                     automatic       pointer                  dcl 1-124
xp                                     automatic       pointer                  dcl 25

NAMES DECLARED BY EXPLICIT CONTEXT.
ACLOK                           006012 constant        label                    dcl 600 ref 589 594
BREAK                           002366 constant        label                    dcl 261 ref 256
COMPARE_BLOCK                   001700 constant        label                    dcl 167
ER                              000642 constant        label                    dcl 80 ref 94
EXIT                            005407 constant        label                    dcl 527 ref 140 147
LOOP                            001747 constant        label                    dcl 182 ref 457
LOOP2                           005176 constant        label                    dcl 502 ref 520
LOOP2A                          005011 constant        label                    dcl 474 ref 491
MATCH                           002177 constant        label                    dcl 231 ref 207 210
NAME_BLOCK                      002212 constant        label                    dcl 242
NEXT                            002157 constant        label                    dcl 212 ref 202
NOTTHERE                        002166 constant        label                    dcl 218 ref 201
SEARCH                          002044 constant        label                    dcl 201 ref 215
SKIP1                           004774 constant        label                    dcl 454 ref 221 292
XRB                             002651 constant        label                    dcl 304 ref 301 302
ZACL                            003442 constant        label                    dcl 358 ref 353
cmode                           005414 constant        entry                    internal dcl 540 ref 591 591 591 591 598 598 606 606
comp_dir_info                   000615 constant        entry                    external dcl 11
compare_acl                     005471 constant        entry                    internal dcl 568 ref 343 347 441 443
datec                           006133 constant        entry                    internal dcl 618 ref 288 288 288 288 367 367 367 367
                                                                                  378 378 378 378 431 431 431 431 436 436 436 436
head                            006165 constant        entry                    internal dcl 632 ref 259 266 281 287 304 316 323 327
                                                                                  333 338 358 366 372 377 382 388 393 401 409 414
                                                                                  419 424 430 435 590 597 605
janitor                         006225 constant        entry                    internal dcl 643 ref 134 527
volnc                           006266 constant        entry                    internal dcl 655 ref 373 373 373 373 410 410 410 410

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6556        6620    6352        6566
Length      7064    6352        42         227     204           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
comp_dir_info                       286 external procedure  is an external procedure.  
on unit on line 134                  64 on unit               
begin block on line 167             270 begin block         uses auto adjustable storage.  
begin block on line 242              90 begin block         uses auto adjustable storage.  
cmode                                   internal procedure  shares stack frame of internal procedure compare_acl.  
compare_acl                         138 internal procedure  uses auto adjustable storage.  
datec                                   internal procedure  shares stack frame of begin block on line 167.  
head                                 84 internal procedure  is called by several nonquick procedures.  
janitor                              70 internal procedure  is called by several nonquick procedures.  
volnc                                   internal procedure  shares stack frame of begin block on line 167.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
begin block on line 167  000100 x1                          begin block on line 167
                         000100 x1count                     begin block on line 167
                         000100 x2                          begin block on line 167
                         000101 x2count                     begin block on line 167
                         000122 datstr                      datec
                         000136 lvname                      volnc
                         000146 code                        volnc
begin block on line 242  000100 nfg                         begin block on line 242
                         000100 nfg_count                   begin block on line 242
comp_dir_info            000100 al                          comp_dir_info
                         000101 an                          comp_dir_info
                         000102 ap                          comp_dir_info
                         000104 datstr1                     comp_dir_info
                         000112 datstr2                     comp_dir_info
                         000120 ec                          comp_dir_info
                         000121 en1                         comp_dir_info
                         000131 fdir1                       comp_dir_info
                         000203 fdir2                       comp_dir_info
                         000255 fent1                       comp_dir_info
                         000265 fent2                       comp_dir_info
                         000275 firstadd                    comp_dir_info
                         000276 firstdelete                 comp_dir_info
                         000300 fptr1                       comp_dir_info
                         000302 fptr2                       comp_dir_info
                         000304 headed                      comp_dir_info
                         000305 i                           comp_dir_info
                         000306 k                           comp_dir_info
                         000307 m                           comp_dir_info
                         000310 n                           comp_dir_info
                         000311 loud                        comp_dir_info
                         000312 n1                          comp_dir_info
                         000313 n2                          comp_dir_info
                         000314 nacl                        comp_dir_info
                         000315 name1x                      comp_dir_info
                         000316 name2x                      comp_dir_info
                         000317 nchanges                    comp_dir_info
                         000320 np1                         comp_dir_info
                         000322 np2                         comp_dir_info
                         000324 type1                       comp_dir_info
                         000325 type2                       comp_dir_info
                         000326 uid1                        comp_dir_info
                         000327 verbosity                   comp_dir_info
                         000330 xp1                         comp_dir_info
                         000332 xp2                         comp_dir_info
compare_acl              000106 ans                         cmode
                         000110 i                           cmode
                         000111 k                           cmode
                         000112 aclbit                      compare_acl
                         000112 i                           compare_acl
                         000113 j                           compare_acl
                         000114 tcount                      compare_acl

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_ne_as             enter_begin         leave_begin         call_ext_out_desc   call_ext_out        call_int_this
call_int_other_desc call_int_other      return              alloc_auto_adj      enable              ext_entry
int_entry           int_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_ptr                   date_time_                    date_time_$fstime
expand_pathname_$add_suffix   hcs_$initiate                 hcs_$terminate_noname         ioa_
ioa_$rsnnl                    list_dir_info_                mdc_$find_lvname

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000614        78 000622        79 000640        80 000642        85 000674        87 000675        88 000733
     89 000735        90 000775        93 000776        94 001015        95 001017        96 001055        97 001057
     98 001117       101 001120       102 001121       103 001123       104 001124       105 001127       106 001130
    107 001134       108 001151       109 001153       110 001165       111 001167       112 001171       113 001172
    114 001202       115 001204       116 001206       117 001207       118 001217       119 001220       120 001221
    122 001222       124 001240       126 001243       127 001302       130 001303       132 001305       133 001307
    134 001310       136 001332       137 001375       138 001401       140 001454       143 001455       144 001520
    145 001524       147 001577       150 001600       151 001602       152 001620       153 001636       156 001670
    157 001674       167 001700       170 001703       171 001713       174 001722       175 001731       176 001737
    177 001740       179 001742       180 001744       182 001747       183 001755       184 001757       185 001763
    186 001765       187 001766       188 001772       189 001774       190 002025       191 002027       193 002030
    194 002031       195 002033       197 002034       199 002037       200 002041       201 002044       202 002046
    203 002055       204 002061       205 002070       206 002124       207 002126       209 002133       210 002143
    211 002155       212 002157       213 002161       214 002164       215 002165       218 002166       219 002170
    220 002175       221 002176       231 002177       232 002204       233 002206       234 002207       242 002212
    244 002215       247 002226       248 002230       249 002236       250 002250       251 002264       252 002277
    254 002322       255 002325       256 002327       258 002330       259 002332       260 002341       261 002366
    263 002372       264 002405       265 002413       266 002415       267 002424       269 002454       270 002460
    279 002461       280 002464       281 002472       282 002501       285 002527       286 002532       287 002537
    288 002546       292 002615       301 002616       302 002631       303 002642       304 002651       305 002660
    315 002771       316 003005       317 003014       321 003045       322 003050       323 003061       324 003070
    326 003116       327 003132       328 003141       332 003172       333 003201       334 003210       337 003236
    338 003245       339 003254       342 003302       343 003306       345 003352       347 003353       350 003417
    353 003420       355 003431       358 003442       359 003451       363 003465       364 003471       365 003473
    366 003500       367 003507       370 003556       371 003562       372 003570       373 003577       376 003645
    377 003653       378 003662       381 003731       382 003743       383 003752       387 004006       388 004020
    389 004027       392 004063       393 004071       394 004100       397 004126       399 004127       401 004137
    402 004146       405 004162       408 004163       409 004171       410 004200       413 004247       414 004263
    415 004272       418 004323       419 004331       420 004340       423 004366       424 004400       425 004407
    428 004443       429 004447       430 004454       431 004463       434 004532       435 004540       436 004547
    440 004616       441 004621       443 004677       454 004774       455 004777       456 005002       457 005003
    472 005004       473 005006       474 005011       475 005020       476 005022       477 005026       478 005035
    479 005071       480 005073       481 005075       482 005110       484 005112       485 005142       487 005156
    489 005163       490 005164       491 005167       500 005170       501 005173       502 005176       503 005205
    504 005207       505 005213       506 005222       507 005256       508 005260       509 005261       510 005263
    511 005276       513 005300       514 005330       516 005344       518 005351       519 005352       520 005355
    522 005356       524 005357       525 005376       527 005407       528 005413       540 005414       549 005416
    550 005420       551 005422       552 005427       553 005435       554 005444       556 005445       558 005447
    559 005461       568 005470       576 005504       580 005514       581 005522       583 005524       584 005531
    585 005540       586 005550       587 005572       588 005577       589 005601       590 005605       591 005615
    594 005720       596 005721       597 005723       598 005733       600 006012       602 006014       603 006026
    604 006034       605 006036       606 006046       609 006130       611 006132       618 006133       624 006135
    625 006156       632 006164       634 006172       635 006175       636 006221       638 006223       643 006224
    645 006232       647 006247       650 006265       655 006266       661 006270       662 006311       663 006343


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
