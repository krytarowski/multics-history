	COMPILATION LISTING OF SEGMENT do_prt_request_
	Compiled by: Multics PL/I Compiler, Release 33a, of May 30, 1990
	Compiled at: ACTC Technologies Inc.          
	Compiled on: 10/01/90  1529.0 mdt Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) BULL HN Information Systems Inc., 1990   *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Bull Inc., 1988                *
        6*        *                                                         *
        7*        * Copyright, (C) Honeywell Information Systems Inc., 1984 *
        8*        *                                                         *
        9*        * Copyright (c) 1972 by Massachusetts Institute of        *
       10*        * Technology and Honeywell Information Systems, Inc.      *
       11*        *                                                         *
       12*        *********************************************************** */
       13 
       14 
       15 /* format: style4 */
       16 
       17 /* Procedure for printing I/O Daemon dprint requests */
       18 
       19 /* format: off */
       20 
       21 /* Adapted from output_request_ by J. C. Whitmore, Sept. 1977 */
       22 /* Modified by J. C. Whitmore, 4/78, for new dprint message format and bug fix */
       23 /* Modified by J. C. Whitmore, 7/78, for auto defer; cancel delete on device error; save current request */
       24 /* Modified by J. C. Whitmore, 11/78, to add path to device error msg, notify user on deferring request, and
       25*      fix req_status arg error msg */
       26 /* Modified by J. C. Whitmore, 3/79, to correct the size of string variables for correct assignments */
       27 /* Modified by J. C. Whitmore, 5/79, to use end-of-page order only when printing page labels */
       28 /* Modified by C. Hornig, 6/79, to take prt_ctl information out of static */
       29 /* Modified by J. C. Whitmore, 1/80, to limit the scope of system_privileges_ for send mail (V5.4) */
       30 /* Modified 04/01/81 by GA Texada to 1) make labels work all the time
       31*			       2) call head_sheet_$test when in a test environment */
       32 /* Modified: 11 December 1981 by G. Palter to support force_ctl_char, remove the call to head_sheet_$test as it has been
       33*      moved to iodd_ where it belongs,  and fix the following io_daemon error list entries:
       34*         0003: phx06955 phx11428
       35*	  When running an I/O daemon through remote_driver_ with the line specified as "user_i/o", the message printed
       36*	  by the "restart" request is cutoff in the middle as it is printed immediately before a "resetwrite" control
       37*	  order
       38*         0010: phx09171
       39*	  The module do_prt_request_ should issue a "runout" order after printing the tail sheet and before printing the
       40*	  charge message; otherwise, the charge message may appear in the middle of the tail sheet on remote printers
       41*	  with no attached console */
       42 /* Modified: November 1983 by C. Marker added support for force_nsep and no_separator */
       43 /* Modified: 25 June 1984 by C. Marker changed to notify the user when unable to set line modes. */
       44 /* Modified: 22 February 1984 by C. Marker changed to check if the page labels are the same as the access class of the segment and call access_audit_gate_$log_obj_ptr_user if they are not.  Changed to use version 5 message segments. */
       45 
       46 
       47 /****^  HISTORY COMMENTS:
       48*  1) change(87-05-10,Gilcrease), approve(87-08-06,MCR7686),
       49*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
       50*     Implement -nb output.
       51*  2) change(88-10-24,Brunelle), approve(88-10-24,MCR7911),
       52*     audit(88-10-25,Wallman), install(88-10-28,MR12.2-1199):
       53*     Upgrade to support version 5 of I/O daemon tables.  Also support single &
       54*     continuous forms paper; new head & tail sheet entry variables in
       55*     iodd_static; forms processing control string for single sheet paper; etc.
       56*  3) change(88-11-11,Brunelle), approve(88-11-11,MCR7911),
       57*     audit(88-11-14,Wallman), install(88-11-14,MR12.2-1212):
       58*     Correct problem of not suppressing trailing blank pages.
       59*  4) change(90-09-10,Itani), approve(90-09-10,MCR8198),
       60*     audit(90-09-21,WAAnderson), install(90-10-01,MR12.4-1034):
       61*     Correct the problem of indenting centered labels.
       62*                                                   END HISTORY COMMENTS */
       63 
       64 /* format: on */
       65 
       66 do_prt_request_: procedure (a_iocbp, a_stat_p, a_code);
       67 
       68 /* Parameters */
       69 
       70 dcl  a_iocbp ptr;					/* ptr to the io control block for iox_ */
       71 dcl  a_stat_p ptr;					/* the value of stat_p from caller */
       72 dcl  a_code fixed bin (35);				/* error code....used for driver_fatal_error */
       73 
       74 /* Automatic */
       75 
       76 dcl  access_class bit (72) aligned;			/* access class of user file */
       77 dcl  auth bit (72) aligned;				/* authorization used to set banner access class */
       78 dcl  auth_string char (680);				/* string form of auth */
       79 dcl  char_count fixed bin (24);			/* total number of chars if the file */
       80 dcl  chars_done fixed bin (24);			/* total chars printed between head & tail sheets */
       81 dcl  chgsw bit (1);					/* indicate whether to charge */
       82 dcl  ck_interval fixed bin;				/* number of lines between checkpoints */
       83 dcl  ck_mode char (12) aligned;			/* mode string for prtdim to set checkpoints */
       84 dcl  cmd_line char (80);				/* space for operator commands */
       85 dcl  code fixed bin (35);
       86 dcl  continuous_paper bit (1);			/* OFF is single sheet paper */
       87 dcl  control bit (36) aligned;
       88 dcl  copies_left fixed bin;				/* number if copies to be done this time thorugh */
       89 dcl  ctl_msg_sent bit (1);
       90 dcl  delete_msg char (32);
       91 dcl  desc_ptr ptr;
       92 dcl  dest char (24) aligned;
       93 dcl  device_error bit (1);
       94 dcl  ename char (32) aligned;				/* entry name of file for output */
       95 dcl  err_mess char (200) var;
       96 dcl  fcbp ptr;
       97 dcl  force_ck_pt bit (1) aligned;
       98 dcl  full_path char (168) aligned;
       99 dcl  head char (64) aligned;				/* temp for the header */
      100 dcl  header_done bit (1);				/* TRUE when header is printed */
      101 dcl  how fixed bin;					/* code for how the segment should be printed */
      102 dcl  i fixed bin;
      103 dcl  iocbp ptr;
      104 dcl  l fixed bin (24);
      105 dcl  last_error_count fixed bin;			/* last printer error count read */
      106 dcl  lg_msg char (100) aligned;
      107 dcl  lg_sw bit (1) aligned;
      108 dcl  line_mode char (32);				/* request modes for length & indentation */
      109 dcl  mailname char (32) aligned;
      110 dcl  max_comp fixed bin;
      111 dcl  msg char (256) aligned;				/* space for operator messages */
      112 dcl  n_sample_pages fixed bin;			/* count sample pages, to maintain alignment of paper */
      113 dcl  nep_mode_set bit (1);				/* TRUE if request is being done in nep mode */
      114 dcl  new_clock fixed bin (71);
      115 dcl  new_cpu fixed bin (52);
      116 dcl  new_pp fixed bin;
      117 dcl  new_rate fixed bin (35);				/* new estimate of transmission rate */
      118 dcl  new_waits fixed bin (35);
      119 dcl  nt fixed bin (24);				/* number of elements processed on read */
      120 dcl  old_clock fixed bin (71);
      121 dcl  old_cpu fixed bin (52);
      122 dcl  old_pp fixed bin;
      123 dcl  old_rate fixed bin (35);
      124 dcl  old_waits fixed bin (35);
      125 dcl  omode char (256);				/* mode returned form dim */
      126 dcl  paper_not_aligned bit (1) aligned;
      127 dcl  pic picture "(11)-9";				/* dummy for fixed bin to char conversion */
      128 dcl  printing bit (1);				/* TRUE when the actual printing is in progress */
      129 dcl  restart_source fixed bin;			/* restart was from master or slave */
      130 dcl  seconds fixed bin;
      131 dcl  segp ptr;
      132 dcl  set_page_labels bit (1);				/* TRUE - when we want to set labels */
      133 dcl  short_msg char (8) aligned;
      134 dcl  source fixed bin;				/* cmd source, master or slave */
      135 dcl  start_char_offset fixed bin (24);			/* file offset at start of printing */
      136 dcl  start_segp pointer;				/* pointer to first component if MSF otherwise to segment */
      137 dcl  starting_page fixed bin (24);
      138 dcl  stream char (32);				/* stream name for ios_ */
      139 dcl  terminal (2) char (32);				/* streams for 1) master, or 2) slave */
      140 dcl  time_est fixed bin;				/* estimated number of seconds to process request */
      141 dcl  user_dir char (168) aligned;			/* directory containing users' segment */
      142 dcl  val fixed bin;					/* for validation level */
      143 
      144 
      145 
      146 /* Internal Static */
      147 
      148 dcl  whoami char (32) int static options (constant) init ("do_prt_request_");
      149 dcl  master fixed bin int static options (constant) init (1);
      150 dcl  slave fixed bin int static options (constant) init (2);
      151 dcl  (both, log) fixed bin int static options (constant) init (0);
      152 dcl  normal fixed bin int static options (constant) init (1); /* normal streams for opr msgs */
      153 dcl  error fixed bin int static options (constant) init (2);/* code for error streams */
      154 dcl  tell_user bit (1) int static options (constant) init ("1"b); /* force error msg to user */
      155 						/* go by user notify flag */
      156 
      157 /* the following variables are for call to output_file */
      158 dcl  PRINT fixed bin int static options (constant) init (1);
      159 dcl  SAMPLE fixed bin int static options (constant) init (2);
      160 dcl  SKIP fixed bin int static options (constant) init (3);
      161 dcl  SAVE fixed bin int static options (constant) init (4);
      162 
      163 dcl  factor float bin int static options (constant) init (0.75e0); /* smoothing factor for rate estimate */
      164 dcl  stars char (40) int static options (constant) aligned init ((40)"*"); /* For error messages */
      165 
      166 dcl  privileged bit (1) static init ("1"b);		/* TRUE if we can call phcs_ */
      167 dcl  sys_priv bit (1) static init ("1"b);		/* TRUE if process cal call system_privilege_ */
      168 dcl  first_call bit (1) static init ("1"b);		/* TRUE on first call */
      169 dcl  fault_name char (32) aligned int static;
      170 dcl  request_data_p ptr int static init (null);
      171 
      172 dcl  err_label label int static;			/* point of return from condition handler */
      173 
      174 dcl  bad_chars char (5) defined BAD_CHARS position (2);
      175 dcl  nl_vt_ff char (3) defined BAD_CHARS position (4);	/* vert carriage control chars */
      176 dcl  space_ht_bs char (3) defined BAD_CHARS position (1);	/* horiz carriage control chars */
      177 dcl  VT char (1) defined BAD_CHARS position (5);		/* the vertical tab character */
      178 dcl  FF char (1) defined BAD_CHARS position (6);		/* the form feed character */
      179 						/* SP HT BS NL VT FF */
      180 dcl  BAD_CHARS char (6) int static options (constant) init (" 	
      181 ");
      182 
      183 /* External static */
      184 
      185 dcl  access_operations_$io_daemon_set_page_labels bit (36) aligned external static;
      186 dcl  error_table_$action_not_performed fixed bin (35) ext static;
      187 dcl  error_table_$ai_restricted ext static fixed bin (35);
      188 dcl  error_table_$dirseg ext static fixed bin (35);
      189 dcl  error_table_$eof_record fixed bin (35) ext static;
      190 dcl  error_table_$improper_data_format fixed bin (35) ext static;
      191 dcl  error_table_$moderr fixed bin (35) ext static;
      192 dcl  error_table_$noarg fixed bin (35) ext static;
      193 dcl  error_table_$noentry fixed bin (35) ext static;
      194 dcl  error_table_$out_of_bounds fixed bin (35) ext static;
      195 dcl  error_table_$request_pending fixed bin (35) ext static;
      196 
      197 
      198 
      199 /* External Entries */
      200 
      201 dcl  access_audit_gate_$log_obj_ptr_user entry options (variable);
      202 dcl  aim_check_$equal entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      203 dcl  aim_check_$greater entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      204 dcl  clock_ ext entry returns (fixed bin (71));		/* gets clock time */
      205 dcl  continue_to_signal_ entry (fixed bin (35));
      206 dcl  convert_authorization_$from_string entry (bit (72) aligned, char (*), fixed bin (35));
      207 dcl  convert_authorization_$to_string entry (bit (72) aligned, char (*), fixed bin (35));
      208 dcl  convert_ipc_code_ entry (fixed bin (35));
      209 dcl  convert_status_code_ entry (fixed bin (35), char (*) aligned, char (*) aligned);
      210 dcl  cpu_time_and_paging_ entry (fixed bin (35), fixed bin (52), fixed bin);
      211 dcl  cu_$level_get entry (fixed bin);
      212 dcl  date_time_ entry (fixed bin (71), char (*) aligned);
      213 dcl  hcs_$fs_get_mode ext entry (ptr, fixed bin (5), fixed bin (35));
      214 dcl  hcs_$fs_get_path_name entry (ptr, char (*) aligned, fixed bin, char (*) aligned, fixed bin (35));
      215 dcl  hcs_$get_access_class entry (char (*) aligned, char (*) aligned, bit (72) aligned, fixed bin (35));
      216 dcl  hcs_$get_user_effmode entry (char (*) aligned, char (*) aligned, char (*) aligned, fixed bin, fixed bin (5), fixed bin (35));
      217 dcl  hcs_$status_minf entry (char (*) aligned, char (*) aligned, fixed bin, fixed bin (2), fixed bin (24), fixed bin (35));
      218 dcl  io_daemon_account_ entry (entry, ptr);
      219 dcl  ioa_$rsnnl entry options (variable);
      220 dcl  iodd_command_processor_ entry (fixed bin, fixed bin, char (*), fixed bin (35));
      221 dcl  iodd_get_cmd_ entry (ptr, fixed bin, fixed bin (24), bit (36) aligned, char (*), fixed bin, fixed bin (35));
      222 dcl  iodd_msg_ entry options (variable);
      223 dcl  iodd_parse_$args entry (char (*) var, char (*)) returns (char (256) var);
      224 dcl  iodd_parse_$command entry (char (*), ptr, fixed bin (35));
      225 dcl  iox_$control entry (ptr, char (*), ptr, fixed bin (35));
      226 dcl  iox_$modes entry (ptr, char (*), char (*), fixed bin (35));
      227 dcl  iox_$put_chars entry (ptr, ptr, fixed bin (24), fixed bin (35));
      228 dcl  ipc_$block entry (ptr, ptr, fixed bin (35));
      229 dcl  ipc_$drain_chn entry (fixed bin (71), fixed bin (35));
      230 dcl  msf_manager_$close entry (ptr);
      231 dcl  msf_manager_$get_ptr entry (ptr, fixed bin, bit (1), ptr, fixed bin (24), fixed bin (35));
      232 dcl  msf_manager_$open entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
      233 dcl  phcs_$deactivate entry (ptr, fixed bin (35));
      234 dcl  phcs_$set_kst_attributes entry (fixed bin, ptr, fixed bin (35));
      235 dcl  probe entry ();
      236 dcl  read_allowed_ entry (bit (72) aligned, bit (72) aligned) returns (bit (1) aligned);
      237 dcl  send_mail_$access_class entry (char (*) aligned, char (*) aligned, ptr, bit (72) aligned, fixed bin (35));
      238 dcl  sys_info$max_seg_size fixed bin (35) ext static;
      239 dcl  system_privilege_$ipc_priv_off entry (fixed bin (35));
      240 dcl  system_privilege_$ipc_priv_on entry (fixed bin (35));
      241 dcl  system_privilege_$ring1_priv_off entry (fixed bin (35));
      242 dcl  system_privilege_$ring1_priv_on entry (fixed bin (35));
      243 dcl  timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2) aligned, fixed bin (71));
      244 dcl  write_control_form_ entry (char (*) aligned, char (*) aligned, ptr, fixed bin (35));
      245 
      246 
      247 
      248 /* Structures */
      249 
      250 dcl  1 ksta like kst_attributes aligned internal static;
      251 
      252 dcl  1 current aligned like print_driver_data.checkpoint;	/* this defines the current position in the file */
      253 
      254 dcl  1 ck aligned,					/* The checkpoint history for the current file */
      255        2 last fixed bin,				/* The last entry in the chain */
      256        2 entry (10),				/* one entry for each checkpoint */
      257          3 forward fixed bin,				/* the forward thread */
      258          3 point like print_driver_data.checkpoint;	/* this is the checkpoint data */
      259 
      260 dcl  1 position aligned like position_data;		/* see prt_order_info.incl.pl1 */
      261 dcl  1 pg_labels aligned like page_labels;		/* see prt_order_info.incl.pl1 */
      262 dcl  1 paper_info_data aligned like paper_info;		/* see prt_order_info.incl.pl1 */
      263 
      264 dcl  1 static_ctl aligned int static like prt_ctl;	/* the default control values */
      265 
      266 dcl  1 arg_list aligned,				/* for parsing command lines */
      267        2 max_tokens fixed bin,			/* the amount of space allocated */
      268        2 n_tokens fixed bin,				/* the number of tokens in the line */
      269        2 cmd char (64) var,				/* first token is the command */
      270        2 arg (3) char (64) var;			/* we allow three arguments max */
      271 
      272 dcl  1 ctl_wait_list aligned int static,		/* we block on this list for ctl form sync */
      273        2 number fixed bin,				/* number of ipc channels */
      274        2 channel fixed bin (71);			/* this is the channel (only one) */
      275 
      276 
      277 /* Builtins */
      278 
      279 dcl  (addr, baseno, binary, bit, char, convert, divide, fixed, float,
      280      hbound, length, ltrim, min, mod, null, rtrim, string, substr, translate,
      281      unspec, verify) builtin;
      282 
      283 
      284 /* Conditions */
      285 
      286 dcl  (cleanup, linkage_error, daemon_again, daemon_again_slave, daemon_kill,
      287      daemon_defer, daemon_cancel, daemon_save, size, conversion, any_other)
      288 	condition;
      289 
      290 
      291 
      292 /* Copy arguments and initialize pointers and control switches */
      293 
      294 	stat_p = a_stat_p;
      295 	iocbp = a_iocbp;
      296 	a_code = 0;				/* set to zero for now */
      297 	chgsw = "0"b;				/* assume no charge yet */
      298 	header_done = "0"b;				/* header not done yet */
      299 	set_page_labels = "0"b;			/* start with no labels assumed */
      300 	ck.last = 1;				/* use first checkpoint entry */
      301 	arg_list.max_tokens = 4;			/* only 4 tokens allowed in command lines */
      302 
      303 	terminal (master) = "user_output";		/* stream for master terminal output */
      304 	terminal (slave) = iodd_static.slave_output;	/* check for active before use */
      305 	last_error_count = -1;			/* set to undefined */
      306 	printing = "0"b;				/* tell handler for daemon_save - not printing yet */
      307 	continuous_paper = (iodd_static.paper_type = PAPER_TYPE_CONTINUOUS);
      308 
      309 	if first_call then do;			/* init variables and see if we have phcs_ access */
      310 	     call init_static_ctl ();
      311 	     on linkage_error
      312 		begin;
      313 		privileged = "0"b;
      314 		go to tough;
      315 	     end;
      316 	     string (ksta) = "0"b;			/*  make a null structure */
      317 	     call phcs_$set_kst_attributes (binary (baseno (stat_p), 18), addr (ksta), (0));
      318 
      319 /* This is a NOP - structure is 0. If we get here we are privileged */
      320 	     ksta.set.tpd, ksta.value.tpd = "1"b;	/* Dont put on bulkstore just for lil ole me */
      321 	     ksta.set.explicit_deactivate_ok, ksta.value.explicit_deactivate_ok = "1"b;
      322 	     ksta.set.allow_write = "1"b;		/* Dont let me wreck user seg by accident */
      323 	     ksta.set.tus, ksta.value.tus = "1"b;	/* Save a vtoc write */
      324 tough:	     revert linkage_error;
      325 	     first_call = "0"b;			/* First call initialization is done */
      326 	end;
      327 	if iodd_static.ctl_term.attached then do;	/* get ready to send message to ctl term */
      328 	     ctl_wait_list.number = 1;
      329 	     ctl_wait_list.channel = iodd_static.ctl_ev_chan;
      330 	end;
      331 	else ctl_wait_list.number = 0;		/* don't try to use this */
      332 
      333 	driver_status_ptr = iodd_static.driver_ptr;	/* get ptr to the current driver status seg */
      334 	evaluate_forms_info_output_ptr = driver_status.forms_validation_ptr;
      335 	prt_ctl_ptr = driver_status.dev_ctl_ptr;	/* get print control information */
      336 	if prt_ctl_ptr = null () then
      337 	     prt_ctl_ptr = addr (static_ctl);		/* default values */
      338 	desc_ptr = addr (driver_status.descriptor);	/* and to the request descriptor */
      339 	mseg_message_info_ptr = desc_ptr;		/* first part of desciptor is mseg_message_info */
      340 	dmp = addr (driver_status.message);		/* set dprint_msg default pointer */
      341 	driver_data_p = addr (desc_ptr -> request_descriptor.driver_data); /* get ptr to printer_driver_data */
      342 	request_data_p = addr (REQUEST);		/* for the single copy entry */
      343 	fcbp, segp = null;				/* set up for cleanup handler */
      344 	start_segp = null;
      345 	stream = driver_status.dev_out_stream;		/* record the switch name for easy reference */
      346 
      347 	on cleanup call clean_proc ();		/* establish a cleanup handler */
      348 
      349 	err_label = abort_request;
      350 
      351 /* Set up master structure used by this pgm. */
      352 
      353 	string (REQUEST.control_flags) = ""b;		/* clear all the flags */
      354 	REQUEST.requestor = mseg_message_info.sender_id;
      355 	REQUEST.continued = desc_ptr -> request_descriptor.continued;
      356 	REQUEST.restarted = desc_ptr -> request_descriptor.restarted;
      357 	REQUEST.priority_request = desc_ptr -> request_descriptor.priority_request;
      358 	REQUEST.separator = "1"b;			/* we always want a print separator first time */
      359 	REQUEST.device_name = driver_status.dev_name_label;
      360 	REQUEST.request_type = driver_status.req_type_label;
      361 	REQUEST.queue = desc_ptr -> request_descriptor.q;
      362 	REQUEST.charge_queue = desc_ptr -> request_descriptor.charge_q; /* coord may want a priority rate */
      363 	REQUEST.request_no = desc_ptr -> request_descriptor.seq_id; /* coord assigned the number */
      364 	REQUEST.restart_no = desc_ptr -> request_descriptor.prev_seq_id; /* previous number of request (0 = not restarted) */
      365 	REQUEST.contd_no = desc_ptr -> request_descriptor.contd_seq_id; /* previous number of continued request (0 = not continued) */
      366 	REQUEST.dpmp = dmp;
      367 	if dprint_msg.delete_sw then
      368 	     REQUEST.delete = 1;
      369 	else REQUEST.delete = 0;
      370 	REQUEST.line_nbrs = dprint_msg.line_nbrs;
      371 	REQUEST.single_sheet = (iodd_static.paper_type = PAPER_TYPE_SINGLE);
      372 	REQUEST.bit_count = 0;
      373 	REQUEST.line_count = 0;
      374 	REQUEST.page_count = 0;
      375 	REQUEST.punsw = 0;				/* we are printing only */
      376 	REQUEST.copies = dprint_msg.copies;
      377 	REQUEST.no_separator = dprint_msg.no_separator | prt_ctl.force_nsep;
      378 	if ^(REQUEST.continued | REQUEST.restarted) then
      379 	     print_driver_data.copies_done = 0;		/* no copies assumed, unless continued or restarted */
      380 						/* if none completed, it's not continued */
      381 	else if print_driver_data.copies_done < 1 then
      382 	     REQUEST.continued = "0"b;
      383 	print_driver_data.copies_done = min (print_driver_data.copies_done, REQUEST.copies - 1); /* be sure we do at least one copy */
      384 	copies_left = REQUEST.copies - print_driver_data.copies_done; /* might be partly done */
      385 	REQUEST.copy_no = print_driver_data.copies_done + 1; /* we start with the next copy */
      386 	REQUEST.notify = dprint_msg.notify;
      387 	REQUEST.output_mode = "";			/* clear in case of error message */
      388 	REQUEST.total_charge = 0e0;
      389 	REQUEST.charge = 0e0;
      390 	REQUEST.time_start_request = clock_ ();
      391 	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);
      392 
      393 	l = length (rtrim (REQUEST.requestor)) - 2;	/* get length of Person.Project */
      394 	mailname = substr (REQUEST.requestor, 1, l);
      395 	unspec (send_mail_info) = "0"b;
      396 	send_mail_info.version = send_mail_info_version_2;
      397 	send_mail_info.wakeup = "1"b;
      398 	send_mail_info.always_add = "1"b;
      399 	send_mail_info.sent_from = REQUEST.request_type;
      400 
      401 /* get pathname of file for operator and error messages */
      402 
      403 	user_dir = dprint_msg.dirname;
      404 	ename = dprint_msg.ename;
      405 	call ioa_$rsnnl ("^a^[>^]^a", full_path, l, user_dir, (user_dir ^= ">"), ename);
      406 
      407 	REQUEST.full_path = translate (full_path, "", bad_chars); /* force a page fault - HARDWARE BUG WRITEAROUND */
      408 	full_path = translate (full_path, "", bad_chars); /* remove bad chars for banner */
      409 	dprint_msg.destination = translate (dprint_msg.destination, "", bad_chars);
      410 	dprint_msg.heading = translate (dprint_msg.heading, "", bad_chars);
      411 	REQUEST.full_path = full_path;		/* save the clean copy */
      412 
      413 /*  record the processing of this request in the log  */
      414 
      415 	head = dprint_msg.heading;
      416 	if substr (head, 1, 5) = " for " then		/* see if dprint added something */
      417 	     head = substr (head, 6);			/* if so get rid of it */
      418 	if head ^= "" then
      419 	     call ioa_$rsnnl ("(for ""^a"" ", msg, l, head);
      420 	else do;
      421 	     l = 1;				/* no heading, get ready for a dest msg */
      422 	     msg = "(";
      423 	end;
      424 
      425 	dest = dprint_msg.destination;
      426 	if dest ^= "" then
      427 	     call ioa_$rsnnl ("^vaat ""^a"")", msg, l, (l), substr (msg, 1, l), dest);
      428 	else if l = 1 then
      429 	     msg = "";				/* no head or dest case */
      430 	else substr (msg, l, 1) = ")";		/* heading only case */
      431 
      432 	call iodd_msg_ (log, both, 0, "",		/* let the subr do the work */
      433 	     "Request ^d ^a q^d:  ^a^/^2x^[(^d copies) ^;^s^]^[priority ^d ^;^s^]from ^a ^a", REQUEST.request_no,
      434 	     REQUEST.request_type, REQUEST.queue, full_path, (copies_left > 1), copies_left, REQUEST.priority_request,
      435 	     REQUEST.charge_queue, REQUEST.requestor, msg);
      436 
      437 /* Now we can print a header banner if an error occurs */
      438 
      439 	err_mess = full_path;			/* let this sit here in case */
      440 
      441 /* Find the access class to use for the banner */
      442 
      443 	if aim_check_$greater (mseg_message_info.sender_authorization, driver_status.min_banner) then
      444 	     auth = mseg_message_info.sender_authorization;
      445 	else auth = driver_status.min_banner;		/* mark the output with auth */
      446 
      447 	call convert_authorization_$to_string (auth, auth_string, code); /* get string form */
      448 	if code ^= 0 then do;			/* oops....bad news */
      449 	     call fatal_error (tell_user);		/* tell the operator, and user */
      450 	     go to clean_out;			/* drop the request */
      451 	end;
      452 
      453 	l = length (rtrim (auth_string));		/* how long is the string */
      454 	if l > 132 then do;				/* too long for normal output..check for short form */
      455 	     call convert_authorization_$from_string (access_class, "system_high", code);
      456 	     if code ^= 0 then do;			/* oops....bad news */
      457 		call fatal_error (tell_user);		/* tell the operator, and user */
      458 		go to clean_out;			/* drop the request */
      459 	     end;
      460 	     if aim_check_$equal (auth, access_class) then
      461 		auth_string = "SYSTEM HIGH";		/* this is shorter */
      462 	end;					/* save all we can for the label */
      463 	REQUEST.access_class_string = char (auth_string, length (REQUEST.access_class_string));
      464 
      465 /* check the requestor's access to the pathname he specified */
      466 
      467 	val = mseg_message_info.sender_level;
      468 
      469 	call check_user_access (user_dir, ename, code);	/* use the internal proc to do the work */
      470 	if code ^= 0 then do;			/* oops....bad news */
      471 	     call fatal_error (tell_user);		/* tell the operator, and user */
      472 	     go to clean_out;			/* drop the request */
      473 	end;
      474 
      475 	call open_file (user_dir, ename, fcbp, max_comp, char_count, code); /* one call does a lot */
      476 	if code ^= 0 then do;			/* oops....bad news */
      477 	     call fatal_error (tell_user);		/* tell the operator, and user */
      478 	     go to clean_out;			/* drop the request */
      479 	end;
      480 
      481 /* set up variables for recording checkpoints as we go through the file */
      482 
      483 	ck_interval = 25;				/* define the interval for taking checkpoints */
      484 	pic = ck_interval;				/* get the char form */
      485 	ck_mode = "stop" || ltrim (pic);		/* express as the exact mode string */
      486 
      487 /* set up the starting page and initialize each checkpoint */
      488 
      489 	if (REQUEST.restarted | REQUEST.continued) & print_driver_data.checkpoint.page_no > 0 then
      490 	     current = print_driver_data.checkpoint;	/* use the last checkpoint as the start */
      491 	else do;
      492 	     current.page_no = 1;			/* the current position is top of page 1 */
      493 	     current.line_count = 0;
      494 	     current.comp_no = 0;			/* start at the head of the file */
      495 	     current.offset = 0;
      496 	     current.file_offset = 0;
      497 	end;
      498 
      499 	starting_page = current.page_no;
      500 
      501 	do i = 1 to hbound (ck.entry, 1);		/* init the checkpoints and set the threads */
      502 	     ck.point (i) = current;			/* each checkpoint is current position for starters */
      503 	     ck.entry (i).forward = i + 1;		/* each entry points to the next one */
      504 	end;
      505 	ck.entry (hbound (ck.entry, 1)).forward = 1;	/* the last entry points back to the start */
      506 
      507 /* with the true total bitcount, we can make an estimate of the time needed to do the request */
      508 
      509 	if driver_status.bit_rate_est > 0 then do;
      510 
      511 	     chars_done = char_count * copies_left - current.file_offset; /* total is chars / copy * copies */
      512 	     time_est = divide (chars_done * 9, driver_status.bit_rate_est, 17, 0);
      513 
      514 	     if (driver_status.defer_time_limit > 0) &	/* if a limit is defined, check it */
      515 		(time_est > driver_status.defer_time_limit + 6) then do; /* allow 6 sec fuzz */
      516 						/* so estimate will look bigger than limit in msg */
      517 		if REQUEST.priority_request then	/* priority requests go any way */
      518 		     msg = "Defer time limit suspended for priority request.";
      519 		else if REQUEST.restarted then	/* can't defer what is not in the queue */
      520 		     msg = "Restarted request exceeds time limit but cannot be deferred.";
      521 		else do;				/* drop this one */
      522 		     desc_ptr -> request_descriptor.keep_in_queue = "1"b;
      523 		     call iodd_msg_ (log, both, 0, "", "**Deferring request ^d. Printing time estimate: ^.1f mins.",
      524 			REQUEST.request_no, float (time_est) / 60.0e0);
      525 		     call ioa_$rsnnl ("Deferring request for ^a.^/Printing time estimate: ^.1f minutes.", msg, l,
      526 			REQUEST.full_path, float (time_est) / 60.0e0);
      527 		     call notify_user (substr (msg, 1, l));
      528 		     go to clean_out;
      529 		end;
      530 	     end;
      531 	     else msg = "";
      532 
      533 	     if time_est > 60 | msg ^= "" then		/* tell operator if request will exceed 1 minute */
      534 		call iodd_msg_ (log, slave, 0, "", "  Time estimate for request ^d:  ^.1f mins.^[^/^2x^a^]",
      535 		     REQUEST.request_no, float (time_est) / 60.0e0, (msg ^= ""), msg);
      536 	end;
      537 
      538 	call check_labels (user_dir, ename, start_segp, code);
      539 	if code ^= 0 then do;			/* oops....bad news */
      540 	     call fatal_error (tell_user);		/* tell the operator, and user */
      541 	     go to clean_out;			/* drop the request */
      542 	end;
      543 
      544 	call set_modes_and_labels;			/* set strings for later use */
      545 
      546 	if starting_page > 1 | REQUEST.copy_no > 1 then
      547 	     call iodd_msg_ (log, both, 0, "", "  Starting request ^d from page ^d of copy ^d of ^d.",
      548 		REQUEST.request_no, starting_page, REQUEST.copy_no, REQUEST.copies);
      549 
      550 /*  set up necessary condition handlers */
      551 
      552 	on daemon_kill go to flush_request;		/* flush the current request */
      553 	on daemon_cancel go to flush_request;		/* likewise,  the cancelled flag has been set */
      554 	on daemon_defer go to defer_request;		/* for this one be nice (and quiet?) */
      555 	on daemon_save
      556 	     begin;				/* save the current request at the current position */
      557 	     REQUEST.saved = "1"b;			/* get ready to mark tail sheet */
      558 	     if printing then do;
      559 		how = SAVE;
      560 		call iox_$modes (iocbp, "1pg,print", (""), code); /* make the dim return at bottom of page */
      561 	     end;
      562 	end;
      563 	on daemon_again
      564 	     begin;				/* to restart the current request.... */
      565 	     restart_source = master;			/* talking to the master terminal */
      566 	     go to check_reprint_position;
      567 	end;
      568 	on daemon_again_slave
      569 	     begin;				/* to restart the current request.... */
      570 	     restart_source = slave;			/* talking to slave terminal */
      571 	     go to check_reprint_position;
      572 	end;
      573 
      574 	iodd_static.request_in_progress = "1"b;		/* ready to accept kill, cancel etc. */
      575 	control = "101"b;				/* for command lines, wait and prompt slave */
      576 	paper_not_aligned = "0"b;			/* assume paper is aligned at top */
      577 	force_ck_pt = "1"b;				/* and make sure that our counters agree with the dim */
      578 	n_sample_pages = 0;				/* no samples yet for this request */
      579 
      580 	call iox_$control (iocbp, "reset", null, code);	/* clear everything */
      581 
      582 	if prt_ctl.no_auto_print then
      583 	     go to ask;				/* need operator instructions? */
      584 	else go to print_req;			/* no, sooo...let'er rip */
      585 
      586 
      587 /* this is the point where we come to restart the current request */
      588 
      589 restart_this_request:
      590 
      591 	REQUEST.continued = "1"b;			/* make this look like a continuation */
      592 	REQUEST.contd_no = REQUEST.request_no;		/* of this request */
      593 	REQUEST.charge = 0e0;
      594 	REQUEST.time_start_request = clock_ ();
      595 	call date_time_ (REQUEST.time_start_request, REQUEST.date_time_start_request);
      596 	control = "101"b;				/* wait for input and prompt */
      597 	err_mess = "";
      598 	paper_not_aligned = "1"b;			/* add 1 page */
      599 	if REQUEST.copy_no = 1 then
      600 	     REQUEST.separator = "1"b;		/* always mark copy no 1 */
      601 	call skip_to_page (starting_page, code);
      602 	if code ^= 0 then
      603 	     call iodd_msg_ (error, restart_source, code, whoami, "^/Error skiping to starting page.");
      604 
      605 
      606 
      607 /* Get another command */
      608 
      609 ask:
      610 	on conversion
      611 	     begin;
      612 	     call iodd_msg_ (normal, source, 0, "", "Argument conversion error.  Try again.");
      613 	     go to ask;
      614 	end;
      615 
      616 	on size
      617 	     begin;
      618 	     call iodd_msg_ (normal, source, 0, "", "Argument numerical size error.  Try again.");
      619 	     go to ask;
      620 	end;
      621 
      622 	call iodd_get_cmd_ (addr (cmd_line), 80, nt, control, "request", source, code); /* get a cmd */
      623 	if code ^= 0 then do;
      624 	     call driver_fatal_error (code, "Unable to read operator command.");
      625 	     go to clean_out;
      626 	end;
      627 
      628 	call iodd_parse_$command (substr (cmd_line, 1, nt), addr (arg_list), code); /* this was here, so use it */
      629 	if code ^= 0 then do;
      630 	     if code = error_table_$noarg then
      631 		go to ask;			/* be nice about blank lines */
      632 	     call iodd_msg_ (normal, source, 0, "", "Unable to parse command line ^a.", cmd_line);
      633 	     go to ask;
      634 	end;
      635 
      636 	if cmd = "help" then do;
      637 	     call iodd_msg_ (normal, source, 0, "", "Standard driver commands may be used, plus:^/");
      638 	     call iodd_msg_ (normal, source, 0, "", "   sample [N]    -print a sample page");
      639 	     call iodd_msg_ (normal, source, 0, "", "   print  [N]    -start normal printing");
      640 	     call iodd_msg_ (normal, source, 0, "",
      641 		"      Where N is an optional page number. (+N or -N is relative to current page)^/");
      642 	     call iodd_msg_ (normal, source, 0, "", "   copy N        -set the current copy number to N");
      643 	     call iodd_msg_ (normal, source, 0, "", "   req_status [-lg]  -print info about current request");
      644 	     call iodd_msg_ (normal, source, 0, "", "");
      645 	     go to ask;
      646 	end;
      647 
      648 	if source = master & iodd_static.test_entry then	/* when testing allow a call to db */
      649 	     if cmd = "probe" then do;
      650 		call iodd_msg_ (normal, source, 0, "", "Calling probe");
      651 		call probe ();
      652 		go to ask;
      653 	     end;
      654 
      655 	if cmd = "req_status" | cmd = "reqstatus" then do;
      656 	     if n_tokens > 1 then
      657 		if arg (1) = "-lg" | arg (1) = "-long" then
      658 		     lg_sw = "1"b;
      659 		else do;
      660 		     call iodd_msg_ (normal, source, 0, "", "Undefined argument ""^a"".  Use ""-lg"" or none.",
      661 			arg (1));
      662 		     go to ask;
      663 		end;
      664 	     else lg_sw = "0"b;
      665 
      666 	     call iodd_msg_ (normal, source, 0, "", "Request ^d: ^a^/^3xfile components :  ^d,   char count :  ^d",
      667 		REQUEST.request_no, full_path, max_comp + 1, char_count);
      668 	     if lg_sw then
      669 		call iodd_msg_ (normal, source, 0, "", "Current file position:");
      670 	     call iodd_msg_ (normal, source, 0, "", "^3xpage no:^12d^4xcurrent copy no: ^d", current.page_no,
      671 		REQUEST.copy_no);
      672 	     if lg_sw then do;
      673 		call iodd_msg_ (normal, source, 0, "",
      674 		     "^3xline count:^9d^/^3xcomp no:^12d^/^3xoffset:^13d^/^3xfile offset:^8d", current.line_count,
      675 		     current.comp_no, current.offset, current.file_offset);
      676 		call iox_$modes (iocbp, "", omode, code); /* get the current modes */
      677 		call iodd_msg_ (normal, source, 0, "", "^/^3xprinter mode: ^a", omode);
      678 		call iox_$control (iocbp, "get_position", addr (position), code);
      679 		call iodd_msg_ (normal, source, 0, "", "^3xdim at:  page ^d  line ^d  line_count ^d",
      680 		     position.page_number, position.line_number, position.total_lines);
      681 	     end;
      682 	     call iodd_msg_ (normal, source, 0, "", "");	/* a blank line before the command request */
      683 	     go to ask;
      684 
      685 	end;
      686 
      687 	if cmd = "sample" then do;
      688 	     if n_tokens > 1 then do;
      689 		call get_page_no (arg (1), starting_page, code);
      690 		if code ^= 0 then do;
      691 		     call iodd_msg_ (normal, source, 0, "", "Invalid page number: ^a", arg (1));
      692 		     go to ask;
      693 		end;
      694 	     end;
      695 	     else starting_page = current.page_no;
      696 
      697 /* if this is the first sample page, output a separator page if
      698*   1. continuous paper and expecting banner bars or
      699*   2. single sheet paper (at all times) */
      700 	     if (n_sample_pages = 0) then do;
      701 		if (continuous_paper & (prt_ctl.banner_bars = NORMAL_BANNER_BARS | prt_ctl.banner_bars = SINGLE_BANNER_BARS))
      702 		     | ^continuous_paper then do;
      703 		     call iox_$control (iocbp, "inside_page", null, code);
      704 		     call iodd_static.print_head_separator (iocbp, prt_ctl_ptr, "sample pages", code);
      705 		     call iox_$control (iocbp, "inside_page", null, code);
      706 
      707 /* count pages generated for separator page */
      708 		     if continuous_paper then
      709 			n_sample_pages = 2;
      710 		     else n_sample_pages = 1;
      711 		     REQUEST.separator = "1"b;
      712 		     force_ck_pt = "1"b;		/* don't count what we just printed */
      713 		end;
      714 	     end;
      715 
      716 	     call set_up_page_labels;			/* set up printer dim to output any page labels needed */
      717 
      718 	     call skip_to_page (starting_page, code);
      719 	     if code ^= 0 then do;
      720 		call iodd_msg_ (error, source, code, "", "^a^/Unable to skip to page.", err_mess);
      721 		go to ask;
      722 	     end;
      723 
      724 	     call output_file (SAMPLE, 0, code);	/* write one page at the current position in the file */
      725 	     if code ^= 0 then do;
      726 		call iodd_msg_ (error, source, code, "", "^a^/Error while printing sample page.", err_mess);
      727 	     end;
      728 
      729 	     n_sample_pages = n_sample_pages + 1;	/* bump the count of sample pages */
      730 
      731 	     go to ask;
      732 	end;
      733 
      734 	if cmd = "copy" then do;			/* enter copy number */
      735 	     if n_tokens > 1 then do;			/* be sure we have a value */
      736 		i = convert (i, arg (1));		/* convert to binary */
      737 		if i < 1 | i > REQUEST.copies then do;
      738 		     call iodd_msg_ (normal, source, 0, "", "Copy number must be in the range 1 to ^d.",
      739 			REQUEST.copies);
      740 		     go to ask;
      741 		end;
      742 		REQUEST.copy_no = i;
      743 		go to ask;
      744 	     end;
      745 	     call iodd_msg_ (normal, source, 0, "", "Expected argument missing.");
      746 	     go to ask;
      747 	end;
      748 
      749 	if cmd ^= "print" then do;			/* all other commands except print go to the std cp */
      750 	     force_ck_pt = "1"b;			/* in case a sample head sheet was printed */
      751 	     call iodd_command_processor_ (source, 3, substr (cmd_line, 1, nt), code);
      752 	     if code = 1 | code = 2 then do;
      753 		if code = 2 & cmd = "save" then
      754 		     go to clean_out;		/* save at this level is OK, just drop */
      755 		call iodd_msg_ (normal, source, 0, "", "Invalid command. Try again or type help for instructions.");
      756 	     end;
      757 	     call set_modes_and_labels;		/* in case the force modes were changed */
      758 	     go to ask;
      759 	end;
      760 
      761 /* now we have received  the print command and are ready to print the entire file */
      762 
      763 	if n_tokens > 1 then do;			/* was a page number specified? */
      764 	     call get_page_no (arg (1), starting_page, code);
      765 	     if code ^= 0 then do;
      766 		call iodd_msg_ (normal, source, 0, "", "Invalid page number: ^a", arg (1));
      767 		go to ask;
      768 	     end;
      769 	end;
      770 	else starting_page = current.page_no;
      771 
      772 	call skip_to_page (starting_page, code);	/* check it before the head banner is printed */
      773 	if code ^= 0 then do;
      774 	     call iodd_msg_ (error, source, code, "", "^a^/Unable to skip to page.", err_mess);
      775 	     go to ask;
      776 	end;
      777 
      778 	if source = master then
      779 	     iodd_static.master_hold = "0"b;
      780 	else if iodd_static.master_hold then do;	/* respect the master here too */
      781 	     call iodd_msg_ (normal, source, 0, "", "Driver is in hold by master terminal.");
      782 	     go to ask;
      783 	end;
      784 
      785 print_req:
      786 	REQUEST.cpu_time = 0;			/* reset the usage data */
      787 	REQUEST.real_time = 0;
      788 	REQUEST.page_waits = 0;
      789 	REQUEST.pre_pages = 0;
      790 	err_mess = "";				/* clear any residual junk */
      791 	starting_page = current.page_no;		/* the page to start this copy on */
      792 
      793 /* need to check for head sheet alignment on continuous forms? */
      794 	if n_sample_pages > 0 & continuous_paper then do;
      795 	     if mod (n_sample_pages, 2) = 0 then
      796 		call iox_$put_chars (iocbp, addr (FF), 1, code); /* this is really for remote devices */
      797 	end;
      798 
      799 	call iox_$control (iocbp, "get_error_count", addr (last_error_count), code);
      800 	if code ^= 0 then
      801 	     last_error_count = -1;			/* well we tried */
      802 
      803 /* Iff we are on single sheet paper, stop multiple blank pages by suppressing
      804*   consecutive form feeds */
      805 	if ^continuous_paper then
      806 	     call iox_$control (iocbp, "ff_suppress_on", null, code);
      807 
      808 	do while (REQUEST.copy_no <= REQUEST.copies);	/* once around for each copy */
      809 
      810 	     call print_head_banner (code);
      811 	     if code ^= 0 then do;
      812 		call driver_fatal_error (code, "Attempting to print head banner.");
      813 		go to clean_out;
      814 	     end;
      815 
      816 	     call set_up_page_labels;			/* set up printer dim to output any page labels */
      817 
      818 	     n_sample_pages = 0;			/* now we have a real head sheet */
      819 	     REQUEST.separator = "0"b;		/* we want separator bars only the first time */
      820 
      821 /*	now get to the correct top of page location and start printing */
      822 /*	assume that head_sheet and advertizing  (plus the FF above) will leave us at top inside page */
      823 /*	This only applies for continuous forms.  */
      824 
      825 	     if continuous_paper then do;
      826 		i = mod (starting_page, 2);		/* see if we are starting on an even or odd page */
      827 		if i = 0 then do;			/* if the paper is in the wrong position, align it */
      828 		     call iox_$put_chars (iocbp, addr (FF), 1, code);
      829 		end;
      830 	     end;
      831 
      832 /*	now, after all that paper motion, set the dim position to agree with the current position */
      833 
      834 	     force_ck_pt = "1"b;			/* set the position */
      835 	     paper_not_aligned = "0"b;		/* don't move the paper */
      836 
      837 	     call skip_to_page (starting_page, code);	/* sync with the dim */
      838 	     if code ^= 0 then do;
      839 		call driver_fatal_error (code, "First page synchronization.");
      840 		go to clean_out;
      841 	     end;
      842 
      843 	     if desc_ptr -> request_descriptor.saved then
      844 		how = SAVE;
      845 	     else how = PRINT;
      846 	     start_char_offset = current.file_offset;	/* get ready to see how many chars were done per sec */
      847 
      848 	     call iox_$control (iocbp, "runout", null, code); /* be sure head sheet is done before clock reading */
      849 
      850 	     call cpu_time_and_paging_ (old_waits, old_cpu, old_pp); /* keep time and page waits for accounting */
      851 	     old_clock = clock_ ();			/* time copy started */
      852 
      853 	     printing = "1"b;			/* tell daemon_save handler we are printing */
      854 
      855 /* check to see if the user wants raw output.  if so then turn it on */
      856 	     if evaluate_forms_info_output_ptr ^= null then do;
      857 		if evaluate_forms_info_output.special_length ^= 0 then do;
      858 		     if iodd_parse_$args ("output_type=", (evaluate_forms_info_output.special_string)) = "raw" then do;
      859 			call iox_$control (iocbp, "prt_conv_off", null (), (0));
      860 			call iox_$modes (iocbp, "rawo", "", (0));
      861 		     end;
      862 		end;
      863 	     end;
      864 
      865 	     call output_file (how, 0, code);		/* this will do it */
      866 						/* reset raw output if user has asked for it */
      867 	     if evaluate_forms_info_output_ptr ^= null then do;
      868 		if evaluate_forms_info_output.special_length ^= 0 then do;
      869 		     if iodd_parse_$args ("output_type=", (evaluate_forms_info_output.special_string)) = "raw" then do;
      870 			call iox_$control (iocbp, "prt_conv_on", null (), (0));
      871 			call iox_$modes (iocbp, "^rawo", "", (0));
      872 		     end;
      873 		end;
      874 	     end;
      875 
      876 	     if code ^= 0 then do;
      877 		if ^(desc_ptr -> request_descriptor.saved & code = error_table_$request_pending) then do; /* BAD */
      878 		     call driver_fatal_error (code, (err_mess));
      879 		     go to clean_out;
      880 		end;
      881 	     end;
      882 	     else print_driver_data.page_no = 0;	/* copy done, checkpoint is no longer valid */
      883 
      884 	     printing = "0"b;			/* the printing has been done */
      885 
      886 	     call iox_$control (iocbp, "runout", null, code); /* be sure copy is done before counting it */
      887 
      888 	     if ^desc_ptr -> request_descriptor.saved then/* if leaving this til later, don't charge now */
      889 		if REQUEST.copies > print_driver_data.copies_charged then do;
      890 		     chgsw = "1"b;			/* user honestly deserves these charges */
      891 		     print_driver_data.copies_charged = print_driver_data.copies_charged + 1;
      892 		end;
      893 		else chgsw = "0"b;
      894 	     else chgsw = "0"b;
      895 
      896 	     call charge_for_work;			/* do the accounting so we can put price on tail */
      897 
      898 	     if last_error_count = -1 then
      899 		device_error = ""b;			/* no error data */
      900 	     else do;
      901 		call iox_$control (iocbp, "get_error_count", addr (i), code);
      902 		if code ^= 0 | i > last_error_count then
      903 		     device_error = "1"b;
      904 		else device_error = "0"b;		/* we can figure the transfer rate */
      905 	     end;
      906 
      907 	     if ^(iodd_static.quit_during_request | device_error) then do; /* can we update the rate estimate? */
      908 		old_rate = driver_status.bit_rate_est;	/* get the last value */
      909 		chars_done = char_count - start_char_offset; /* chars printed in time interval */
      910 		seconds = divide (REQUEST.real_time, 1000000, 17); /* see how many seconds have passed */
      911 		if seconds < 1 then
      912 		     new_rate = old_rate;		/* avoid divide by zero */
      913 		else new_rate = divide (chars_done * 9, seconds, 17, 0); /* get bits/sec */
      914 		if old_rate > 0 then		/* use first good rate to start the estimate */
      915 		     new_rate = fixed (old_rate * factor + new_rate * (1e0 - factor));
      916 						/* use exp smoothing */
      917 		driver_status.bit_rate_est = new_rate;	/* put back new value */
      918 	     end;
      919 
      920 	     if REQUEST.saved then do;		/* mark the listing suspended */
      921 		call ioa_$rsnnl ("Processing suspended at page ^d.", err_mess, l, REQUEST.page_count);
      922 		call error_write (0, err_mess);
      923 	     end;
      924 
      925 	     call print_tail_banner (code);		/* this will put on the tail banner */
      926 	     if code ^= 0 then do;			/* some type of error..don't do it again */
      927 		call driver_fatal_error (code, "Attempting to write tail banner.");
      928 		go to clean_out;
      929 	     end;
      930 
      931 	     if desc_ptr -> request_descriptor.saved then
      932 		go to clean_out;			/* suspend this request and get the next */
      933 
      934 
      935 	     print_driver_data.copies_done = print_driver_data.copies_done + 1;
      936 	     REQUEST.copy_no = REQUEST.copy_no + 1;	/* get ready for next copy */
      937 	     header_done = "0"b;			/* ready for a new header */
      938 	     starting_page = 1;			/* start the next copy at the begining */
      939 
      940 	end;					/* done with this copy...check for more in while loop */
      941 
      942 /*	we are now done with the request...so clean up */
      943 
      944 	call iox_$control (iocbp, "runout", null, code);	/* be sure all printing is out before charge message */
      945 
      946 	call iodd_msg_ (log, both, 0, "", "  Charge for request ^d: $^.2f  (^d lines,  ^d pages^[ per copy)^;)^]",
      947 	     REQUEST.request_no, REQUEST.total_charge, REQUEST.line_count, REQUEST.page_count, (copies_left > 1));
      948 
      949 	if REQUEST.notify then do;
      950 	     call ioa_$rsnnl ("printed ^a $^.2f queue ^d ^a ^d", msg, l, REQUEST.full_path, REQUEST.total_charge,
      951 		REQUEST.queue, REQUEST.device_name, REQUEST.request_no);
      952 	     call notify_user (substr (msg, 1, l));
      953 	end;
      954 
      955 clean_out:					/* get ready for the next users' request */
      956 	if last_error_count > -1 then do;		/* if error count is defined */
      957 	     call iox_$control (iocbp, "get_error_count", addr (i), code);
      958 	     if code ^= 0 | i > last_error_count then	/* if errors are possible */
      959 		if ^desc_ptr -> request_descriptor.dont_delete then do; /* and user not told about it */
      960 		     if REQUEST.delete = 1 then do;	/* tell user we cancelled his delete request */
      961 			desc_ptr -> request_descriptor.dont_delete = "1"b;
      962 			call ioa_$rsnnl ("Device error during request ^d.  Segment ^a will not be deleted.", msg, l,
      963 			     REQUEST.request_no, REQUEST.full_path);
      964 			call notify_user (substr (msg, 1, l));
      965 		     end;
      966 		end;
      967 	end;
      968 
      969 	desc_ptr -> request_descriptor.finished = "1"b;	/* say we are done with it */
      970 	iodd_static.request_in_progress = "0"b;		/* no more commands can be effective */
      971 	call clean_proc ();				/* get junk out of the address space */
      972 	call iox_$control (iocbp, "runout", null, code);	/* make device disgorge */
      973 
      974 	return;
      975 
      976 check_reprint_position:
      977 
      978 /* on restart, we transfer back here to release the stack frame with the dim,
      979*   so the slave can again write to the remote device and request a cmd */
      980 	call restart_request (restart_source);		/* give the request position */
      981 	go to restart_this_request;			/* now go back and restart the request */
      982 
      983 
      984 
      985 /*  This is where the condition handlers "go to" when something has gone wrong */
      986 
      987 flush_request:					/* kill and cancel handlers jump back here */
      988 	msg = "Operator aborted listing";		/* message for kill and cancel */
      989 	chgsw = "0"b;				/* can't charge */
      990 	go to no_delete;
      991 
      992 abort_request:					/* unclaimed signals transfer to here */
      993 	chgsw = ""b;				/* assume we can't charge user */
      994 
      995 	msg = """" || rtrim (fault_name) || """ condition occured"; /* format basic message */
      996 
      997 	if fault_name = "seg_fault_error" &		/* user deleted seg, charge for what was done */
      998 	     iodd_static.segptr ^= null then do;
      999 	     chgsw = "1"b;
     1000 	     delete_msg = "";			/* forget to tell user we won't delete his seg */
     1001 	end;
     1002 	else do;
     1003 no_delete:
     1004 	     if REQUEST.delete ^= 0 then
     1005 		delete_msg = "; segment will not be deleted";
     1006 	     else delete_msg = "";
     1007 	end;
     1008 
     1009 	call ioa_$rsnnl ("^a during processing of request^a.", err_mess, l, msg, delete_msg);
     1010 
     1011 	code = 0;
     1012 
     1013 	call fatal_error (tell_user);			/* this will clean things up a bit */
     1014 
     1015 	go to clean_out;				/* now drop the request */
     1016 
     1017 
     1018 defer_request:					/* leave this in the queue for a while */
     1019 	err_mess = "Operator deferred request until a later time.";
     1020 	chgsw = ""b;
     1021 
     1022 	code = 0;
     1023 
     1024 	call fatal_error (tell_user);
     1025 
     1026 	go to clean_out;
     1027 
     1028 
     1029 
     1030 /* ======================================================================================= */
     1031 /* ==============================    INTERNAL PROCEDURES    ============================== */
     1032 /* ======================================================================================= */
     1033 
     1034 
     1035 
     1036 fatal_error: procedure (notify);
     1037 
     1038 dcl  notify bit (1);
     1039 
     1040 	REQUEST.notify = REQUEST.notify | notify;	/* set notify flag by arg if off */
     1041 
     1042 	if ^REQUEST.notify & ^header_done then
     1043 	     call print_head_banner ((0));		/* try to tell requestor */
     1044 
     1045 	if header_done then
     1046 	     call charge_for_work;			/* update REQUEST data if possible */
     1047 
     1048 	call error_write (code, err_mess);
     1049 
     1050 	if header_done then
     1051 	     call print_tail_banner ((0));		/* finish it off */
     1052 
     1053 	call iodd_msg_ (log, both, 0, "", "Processing of request ^d terminated.", REQUEST.request_no);
     1054 
     1055 	desc_ptr -> request_descriptor.dont_delete = "1"b;/* make sure we don't delete user seg */
     1056 
     1057 	return;					/* let the caller flush the request */
     1058 
     1059      end fatal_error;
     1060 
     1061 /* ===================================== */
     1062 
     1063 error_write: procedure (code, message);			/* for writing error messages to console &
     1064*						   request stream */
     1065 dcl  code fixed bin (35);
     1066 dcl  message char (*) varying;
     1067 
     1068 	short_msg, lg_msg = "";			/* clear any junk */
     1069 	if code ^= 0 then
     1070 	     call convert_status_code_ (code, short_msg, lg_msg);
     1071 
     1072 	call ioa_$rsnnl ("Request for ^a. ^a ^a", msg, l, REQUEST.full_path, lg_msg, message);
     1073 
     1074 	if REQUEST.notify then			/* this lets us be quiet about save and defer */
     1075 	     call notify_user (substr (msg, 1, l));
     1076 
     1077 	call iodd_msg_ (log, both, 0, "", "**Request ^d: ^a ^a", REQUEST.request_no, lg_msg, message);
     1078 
     1079 	if header_done then do;			/* must not do a "reset" or line and page count is lost */
     1080 	     call ioa_$rsnnl ("^2/^a^a^/io_daemon: ^a ^a^/^a^a^2/", msg, l, VT, stars, lg_msg, message, stars, VT);
     1081 	     call iox_$modes (iocbp, "default", omode, code);
     1082 	     call iox_$put_chars (iocbp, addr (msg), l, code);
     1083 	     call iox_$modes (iocbp, omode, (""), code);
     1084 	end;
     1085 	return;
     1086 
     1087      end error_write;
     1088 
     1089 
     1090 
     1091 notify_user: procedure (message);
     1092 
     1093 dcl  message char (*) aligned;
     1094 dcl  (ipc_ind, r1_ind, ec) fixed bin (35);
     1095 
     1096 	ipc_ind, r1_ind = -1;			/* set to non-zero to test call */
     1097 
     1098 	if ^sys_priv then
     1099 	     go to send_it;				/* if they failed once, .... */
     1100 
     1101 	on linkage_error
     1102 	     begin;
     1103 	     sys_priv = "0"b;			/* stop trying if we fail */
     1104 	     go to revert_handler;			/* send the message if possible */
     1105 	end;
     1106 
     1107 	on any_other
     1108 	     begin;
     1109 	     if r1_ind = 0 then
     1110 		call system_privilege_$ring1_priv_off (r1_ind);
     1111 	     if ipc_ind = 0 then
     1112 		call system_privilege_$ipc_priv_off (ipc_ind);
     1113 	     r1_ind, ipc_ind = -1;
     1114 	     call continue_to_signal_ (ec);
     1115 	end;
     1116 
     1117 	call system_privilege_$ring1_priv_on (r1_ind);
     1118 
     1119 	call system_privilege_$ipc_priv_on (ipc_ind);
     1120 
     1121 revert_handler:
     1122 	revert linkage_error;
     1123 
     1124 send_it:
     1125 	call send_mail_$access_class (mailname, message, addr (send_mail_info), mseg_message_info.sender_authorization,
     1126 	     ec);
     1127 
     1128 	if r1_ind = 0 then
     1129 	     call system_privilege_$ring1_priv_off (r1_ind);
     1130 
     1131 	if ipc_ind = 0 then
     1132 	     call system_privilege_$ipc_priv_off (ipc_ind);
     1133 
     1134 	return;
     1135 
     1136      end notify_user;
     1137 
     1138 
     1139 
     1140 charge_for_work: procedure ();
     1141 
     1142 /* Accounting section, done at end of processing each copy of output. */
     1143 
     1144 	new_clock = clock_ ();
     1145 	call cpu_time_and_paging_ (new_waits, new_cpu, new_pp);
     1146 
     1147 	position.line_number = 0;			/* for the tail banner proc */
     1148 	position.total_lines = 0;			/* Clear these items */
     1149 	position.page_number = 0;
     1150 	call iox_$control (iocbp, "get_position", addr (position), code);
     1151 
     1152 	REQUEST.line_count = position.total_lines;
     1153 	if position.line_number = 1 then
     1154 	     REQUEST.page_count = position.page_number - 1; /* if file ended with FF */
     1155 	else REQUEST.page_count = position.page_number;
     1156 	REQUEST.cpu_time = new_cpu - old_cpu;
     1157 	REQUEST.real_time = new_clock - old_clock;	/* real time for this copy */
     1158 	REQUEST.page_waits = fixed (new_waits - old_waits, 35);
     1159 	REQUEST.pre_pages = fixed (new_pp - old_pp, 35);
     1160 
     1161 	if chgsw then do;				/* charge him */
     1162 	     if driver_status.have_accounting then do;
     1163 		call io_daemon_account_ (driver_status.acct_entry, addr (REQUEST));
     1164 	     end;
     1165 	     else do;
     1166 		REQUEST.price_per_n_lines,		/* zap all charges to zero */
     1167 		     REQUEST.price_per_n_pages,
     1168 		     REQUEST.charge = 0e0;
     1169 		REQUEST.no_accounting = "1"b;		/* and flag it */
     1170 	     end;
     1171 	end;
     1172 	else REQUEST.charge = 0e0;			/* give user a break */
     1173 
     1174 	REQUEST.total_charge = REQUEST.total_charge + REQUEST.charge;
     1175 
     1176 	return;
     1177 
     1178      end charge_for_work;
     1179 
     1180 /* ============================== */
     1181 
     1182 driver_fatal_error: procedure (code, err_msg);
     1183 
     1184 
     1185 dcl  code fixed bin (35);
     1186 dcl  err_msg char (*);
     1187 
     1188 	call iodd_msg_ (error, both, code, whoami, "^a ^a ^/ Driver returning to command level.", err_msg, err_mess);
     1189 
     1190 	desc_ptr -> request_descriptor.dont_delete = "1"b;/* give a reprieve....in case */
     1191 	desc_ptr -> request_descriptor.keep_in_queue = "1"b;
     1192 
     1193 	a_code = code;				/* report driver_fatal_error */
     1194 
     1195 	return;
     1196 
     1197      end driver_fatal_error;
     1198 
     1199 
     1200 
     1201 check_labels: procedure (user_dir, ename, segptr, code);
     1202 
     1203 /* Internal procedure to check that the top and bottom labels are
     1204*   the access class of the segment. */
     1205 
     1206 dcl  access_class bit (72) aligned;
     1207 dcl  code fixed bin (35);
     1208 dcl  ename char (*) aligned;
     1209 dcl  level fixed bin;
     1210 dcl  user_dir char (*) aligned;
     1211 dcl  segptr pointer;
     1212 dcl  sys_info$access_class_floor bit (72) aligned external static;
     1213 
     1214 
     1215 dcl  1 local_audit_user_info aligned like audit_user_info;
     1216 dcl  1 local_audit_eventflags aligned like audit_event_flags;
     1217 
     1218 	code = 0;
     1219 
     1220 	if dprint_msg.top_label ^= dprint_msg.bottom_label then do;
     1221 LOG_AUDIT_MESSAGE:
     1222 	     call cu_$level_get (level);
     1223 	     unspec (local_audit_user_info) = ""b;
     1224 	     local_audit_user_info.version = audit_user_info_version_1;
     1225 	     local_audit_user_info.user_id = mseg_message_info.sender_id;
     1226 	     local_audit_user_info.ring = mseg_message_info.sender_level;
     1227 	     local_audit_user_info.process_id = mseg_message_info.sender_process_id;
     1228 	     local_audit_user_info.authorization = mseg_message_info.sender_authorization;
     1229 	     local_audit_user_info.authorization_range (1) = sys_info$access_class_floor;
     1230 	     local_audit_user_info.authorization_range (2) = mseg_message_info.sender_max_authorization;
     1231 	     local_audit_user_info.audit_flags = mseg_message_info.sender_audit;
     1232 
     1233 	     unspec (local_audit_eventflags) = ""b;
     1234 	     local_audit_eventflags.grant = "1"b;
     1235 
     1236 	     call access_audit_gate_$log_obj_ptr_user ("do_prt_request_", level, unspec (local_audit_eventflags),
     1237 		access_operations_$io_daemon_set_page_labels, segptr, 0, null (), 0, addr (local_audit_user_info));
     1238 
     1239 	     return;
     1240 	end;
     1241 
     1242 	call hcs_$get_access_class (user_dir, ename, access_class, code);
     1243 	if code ^= 0 then
     1244 	     return;
     1245 
     1246 	call convert_authorization_$from_string (authorization, rtrim (dprint_msg.top_label), code);
     1247 	if code ^= 0 then do;
     1248 	     code = 0;
     1249 	     goto LOG_AUDIT_MESSAGE;			/* This isn't an access class */
     1250 	end;
     1251 
     1252 	if ^(aim_check_$equal (access_class, authorization)) then
     1253 	     goto LOG_AUDIT_MESSAGE;
     1254 
     1255 	return;
     1256      end check_labels;
     1257 
     1258 check_user_access: procedure (user_dir, ename, ec);
     1259 
     1260 /* Internal procedure to check that the requestor has at least "r" access to
     1261*   the specified segment */
     1262 
     1263 dcl  user_dir char (*) aligned;
     1264 dcl  ename char (*) aligned;
     1265 dcl  code fixed bin (35);
     1266 dcl  ec fixed bin (35);
     1267 dcl  mode fixed bin (5);
     1268 dcl  access_class bit (72) aligned;
     1269 
     1270 	call hcs_$get_user_effmode (user_dir, ename, REQUEST.requestor, val, mode, code);
     1271 	if code ^= 0 then do;
     1272 	     if code = error_table_$noentry then
     1273 		err_mess = "";			/* simple case, just say no entry */
     1274 	     else err_mess = "Unable to get user's mode.";
     1275 	     ec = code;
     1276 	     return;
     1277 	end;
     1278 
     1279 	if (bit (mode, 5) & "01000"b) = "0"b then do;
     1280 	     err_mess = "User does not have read access.";
     1281 	     ec = error_table_$moderr;
     1282 	     return;
     1283 	end;
     1284 
     1285 	call hcs_$get_access_class (user_dir, ename, access_class, code);
     1286 	if code ^= 0 then do;
     1287 	     err_mess = "Unable to get access class of segment.";
     1288 	     ec = code;
     1289 	     return;
     1290 	end;
     1291 
     1292 	if ^read_allowed_ (mseg_message_info.sender_authorization, access_class) then do;
     1293 	     ec = error_table_$ai_restricted;
     1294 	     err_mess = "User not allowed to read segment.";
     1295 	     return;
     1296 	end;
     1297 
     1298 	ec = 0;					/* ok, user passed the checks */
     1299 
     1300 	return;
     1301 
     1302      end check_user_access;
     1303 
     1304 
     1305 
     1306 open_file: procedure (user_dir, ename, fcbp, max_comp, char_count, code);
     1307 
     1308 dcl  user_dir char (*) aligned;
     1309 dcl  ename char (*) aligned;
     1310 dcl  fcbp ptr;
     1311 dcl  max_comp fixed bin;
     1312 dcl  char_count fixed bin (24);
     1313 dcl  code fixed bin (35);
     1314 
     1315 dcl  comp_dir char (168) aligned;
     1316 dcl  comp_name char (32) aligned;
     1317 dcl  type fixed bin (2);
     1318 dcl  dir fixed bin int static options (constant) init (2);
     1319 dcl  dir_len fixed bin;
     1320 dcl  bc fixed bin (24);
     1321 dcl  mode fixed bin (5);
     1322 dcl  mult_ind fixed bin;
     1323 
     1324 
     1325 
     1326 	char_count = 0;				/* clear the count so we can accumulate file length */
     1327 
     1328 	call hcs_$status_minf (user_dir, ename, 1, type, bc, code); /* see what kind of a thing it is */
     1329 	if code ^= 0 then do;
     1330 	     err_mess = char ("Driver cannot get status of file: " || full_path, length (err_mess));
     1331 	     return;
     1332 	end;
     1333 
     1334 	if type = dir then				/* directory */
     1335 	     if bc < 1 then do;			/* it was a directory */
     1336 		code = error_table_$dirseg;
     1337 		return;
     1338 	     end;
     1339 	     else max_comp = bc - 1;			/* MSF - highest component is bitcount less one */
     1340 	else max_comp = 0;				/* SSF - highest component is 0 */
     1341 
     1342 	call msf_manager_$open (user_dir, ename, fcbp, code);
     1343 	if code ^= 0 then do;
     1344 	     err_mess = "Unable to open file: " || full_path;
     1345 	     return;
     1346 	end;
     1347 
     1348 	do mult_ind = 0 to max_comp;			/* now we look at each component */
     1349 
     1350 	     call msf_manager_$get_ptr (fcbp, mult_ind, "0"b, segp, bc, code);
     1351 	     if code ^= 0 then do;			/* we failed, don't try to do partial files */
     1352 		call ioa_$rsnnl ("Unable to get pointer to file component: ^d.", err_mess, dir_len, mult_ind);
     1353 		return;
     1354 	     end;
     1355 
     1356 	     if mult_ind = 0 then
     1357 		start_segp = segp;			/* this is the first component */
     1358 
     1359 /*		we got a pointer to something...where is it */
     1360 /*		and does the requestor have access to it? */
     1361 
     1362 	     call hcs_$fs_get_path_name (segp, comp_dir, dir_len, comp_name, code);
     1363 	     if code ^= 0 then do;
     1364 		err_mess = "Could not get file component pathname.";
     1365 		return;
     1366 	     end;
     1367 
     1368 	     call check_user_access (comp_dir, comp_name, code);
     1369 	     if code ^= 0 then do;			/* he tried to pull a fast one and got caught */
     1370 		err_mess = err_mess || "  " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
     1371 
     1372 /* most of err_mess was set by check_user_access */
     1373 		return;
     1374 	     end;
     1375 
     1376 	     if bc < 9 then do;			/* must be at least one char per component */
     1377 		code = error_table_$improper_data_format; /* choose a good error message */
     1378 		err_mess = "Zero length segment: " || substr (comp_dir, 1, dir_len) || ">" || comp_name;
     1379 		return;
     1380 	     end;
     1381 
     1382 	     REQUEST.bit_count = REQUEST.bit_count + bc;	/* total the bits for accounting */
     1383 
     1384 	     char_count = char_count + divide (bc, 9, 24, 0); /* get char count like output_file will */
     1385 
     1386 	     call hcs_$fs_get_mode (segp, mode, code);	/*  make sure daemon has access  */
     1387 	     if code ^= 0 then do;
     1388 		err_mess = "Driver process does not have access to segment.";
     1389 		return;
     1390 	     end;
     1391 	     if (bit (mode, 5) & "01000"b) = "0"b then do;
     1392 		err_mess = "Driver process does not have read access to segment.";
     1393 		code = error_table_$moderr;		/* give some access violation code */
     1394 		return;
     1395 	     end;
     1396 	end;
     1397 
     1398 
     1399 /* Now we know that the file is there and that the requestor has the correct access to it.
     1400*   The continued operation of the driver now assumes that the file will remain the same
     1401*   until the driver is done.  That is, the access will not change, the number of components will not
     1402*   change, and the size of each component will not change.  */
     1403 
     1404 
     1405      end open_file;
     1406 
     1407 
     1408 
     1409 output_file: procedure (how, ending_page, ec);
     1410 
     1411 dcl  how fixed bin;					/* how the file is to be output: sample print skip or save */
     1412 dcl  ending_page fixed bin (24);			/* where to stop when skipping */
     1413 dcl  ec fixed bin (35);				/* you guessed it, error code */
     1414 
     1415 dcl  bc fixed bin (24);
     1416 dcl  max_el fixed bin (24);
     1417 dcl  modes char (64);				/* mode string */
     1418 dcl  n fixed bin;
     1419 dcl  nel fixed bin (24);				/* number of chars to be printed on write */
     1420 dcl  nelt fixed bin (24);				/* number of chars processed by dim on return */
     1421 dcl  next fixed bin;
     1422 dcl  code fixed bin (35);				/* iox_ status code, local version */
     1423 
     1424 dcl  wp ptr;					/* working pointer into the segment */
     1425 dcl  char_pos (sys_info$max_seg_size * 4) char (1) based;	/* array of one char elements to get wp */
     1426 dcl  seg_string char (max_el) based (segp);
     1427 
     1428 dcl  1 temp aligned like print_driver_data.checkpoint;	/* temporary values for current position */
     1429 
     1430 dcl  1 save_position aligned like position_data;		/* temporary for position at start of sample */
     1431 
     1432 
     1433 	ec = 0;					/* clear the error code */
     1434 
     1435 	temp = current;				/* we will start at the current position */
     1436 
     1437 	if how = SAMPLE then do;			/* print 1 page and put all position counters back as found */
     1438 	     modes = "1pg,print," || ck_mode;		/* return after printing 1 page */
     1439 	     call iox_$control (iocbp, "get_position", addr (save_position), code); /* save dim position */
     1440 	     if code ^= 0 then do;
     1441 		err_mess = "From get_position order for sample.";
     1442 		ec = code;
     1443 		return;
     1444 	     end;
     1445 	end;
     1446 	else if how = SKIP then do;			/* process file to ending_page without printing,
     1447*						   but save checkpoints on the way */
     1448 	     n = ending_page - current.page_no;		/* see how close to the end we are */
     1449 	     if n < ck_interval then do;		/* if close, use a small interval */
     1450 		pic = n;				/* get the interval as ascii */
     1451 		modes = "stop" || ltrim (pic);	/* make a mode string for the dim */
     1452 	     end;
     1453 	     else modes = ck_mode;			/* if not close, use the normal interval */
     1454 
     1455 	     modes = char ("^print,^1pg," || modes, length (modes)); /* it is transparant in either case */
     1456 	end;
     1457 	else if how = SAVE then
     1458 	     modes = "print,1pg," || ck_mode;		/* for save, go to bottom of even page */
     1459 	else modes = "print,^1pg," || ck_mode;		/* default assumes how = print */
     1460 
     1461 	call iox_$control (iocbp, "runout", null, code);
     1462 	call iox_$modes (iocbp, modes, omode, code);	/* set the modes */
     1463 	if code ^= 0 then
     1464 	     call iodd_msg_ (error, both, code, whoami, "Changing mode during output init to: ^a^/  from: ^a", modes,
     1465 		omode);
     1466 
     1467 	segp = null;				/* don't try to deactivate */
     1468 
     1469 next_comp:					/* done with last component */
     1470 	if segp ^= null & privileged then
     1471 	     call phcs_$deactivate (segp, (0));		/* so try to deactivate the seg */
     1472 
     1473 	call msf_manager_$get_ptr (fcbp, temp.comp_no, "0"b, segp, bc, ec); /* get ptr to seg */
     1474 	if segp = null then do;
     1475 	     err_mess = "Invalid seg ptr to component.";
     1476 	     return;
     1477 	end;
     1478 
     1479 	if privileged then				/* .. do it (gently if possible) */
     1480 	     call phcs_$set_kst_attributes (binary (baseno (segp), 18), addr (ksta), (0));
     1481 
     1482 	max_el = divide (bc, 9, 24, 0);		/* see now many elements to write out */
     1483 
     1484 /* if this is last (or only) component of file, remove any trailing VT or FF chars */
     1485 	if temp.comp_no = max_comp then do;
     1486 	     max_el = length (rtrim (seg_string, nl_vt_ff));
     1487 	end;
     1488 
     1489 write_out:
     1490 	nel = max_el - temp.offset;			/* see how much is left to do */
     1491 	iodd_static.segptr = segp;			/* tell signal handler what segment we are using */
     1492 	wp = addr (segp -> char_pos (temp.offset + 1));	/* get ptr to next character */
     1493 
     1494 	call iox_$put_chars (iocbp, wp, nel, code);	/* This is the actual output of segment */
     1495 	iodd_static.segptr = null;			/* not referencing user seg now */
     1496 	if code ^= 0 then do;
     1497 	     if code ^= error_table_$request_pending then do; /* we only want one code */
     1498 		ec = code;
     1499 		err_mess = "IO error during output of file.";
     1500 		return;
     1501 	     end;
     1502 
     1503 /* code = error_table_$request_pending.  do something about it */
     1504 	     if how = SAMPLE then do;			/* Yes, and for sample we are done printing */
     1505 
     1506 sample_done:	call iox_$control (iocbp, "set_position", addr (save_position), code); /* restore position */
     1507 		if code ^= 0 then
     1508 		     call iodd_msg_ (error, both, code, whoami,
     1509 			"Unable to restore position, set_position order.");
     1510 
     1511 /* current position data was not changed */
     1512 
     1513 		modes = "^1pg," || ck_mode;		/* restore the default checkpoints */
     1514 
     1515 		call iox_$modes (iocbp, modes, omode, code);
     1516 		if code ^= 0 then
     1517 		     call iodd_msg_ (error, both, code, whoami, "Changing mode from ^a^/to ^a", omode, modes);
     1518 
     1519 		call iox_$control (iocbp, "runout", null, code); /* be sure it prints */
     1520 
     1521 		return;
     1522 	     end;
     1523 
     1524 /* hit checkpoint for save, skip or print */
     1525 	     call iox_$control (iocbp, "get_position", addr (position), code); /* see where we are */
     1526 	     if code ^= 0 then do;
     1527 		ec = code;
     1528 		err_mess = "Error on get_position order for checkpoint.";
     1529 		return;
     1530 	     end;
     1531 
     1532 	     nelt = position.total_chars - temp.file_offset; /* num chars done */
     1533 
     1534 	     if how = SKIP then do;			/* if skipping, check for end of file */
     1535 		if (nel = nelt) & (temp.comp_no = max_comp) then do; /* this is bad - hit EOF */
     1536 		     force_ck_pt = "1"b;		/* be sure we re-sync the dim */
     1537 		     ec = error_table_$eof_record;	/* report it as an error */
     1538 		     call ioa_$rsnnl ("EOF reached at end of page ^d.", err_mess, l,
     1539 			position.page_number - 1);
     1540 		     return;			/* the page count from the dim is one too high */
     1541 		end;
     1542 	     end;
     1543 
     1544 /* record the current position of the dim */
     1545 	     temp.page_no = position.page_number;
     1546 	     temp.line_count = position.total_lines;
     1547 	     temp.offset = temp.offset + nelt;
     1548 	     temp.file_offset = position.total_chars;
     1549 
     1550 	     current = temp;			/* say this is a real page position */
     1551 	     if how = PRINT | how = SAVE then
     1552 		print_driver_data.checkpoint = current; /* make things consistent */
     1553 
     1554 	     if how = SAVE then do;			/* getting ready to suspend request */
     1555 		n = mod (temp.page_no, 2);		/* check for even page */
     1556 		if n = 1 then do;			/* odd number means we just finished an even page */
     1557 		     ec = error_table_$request_pending; /* pass back "not finished" */
     1558 		     return;
     1559 		end;
     1560 	     end;
     1561 
     1562 	     if current.page_no >= (ck.point (ck.last).page_no + ck_interval) then do; /* worth saving it */
     1563 
     1564 		next = ck.entry (ck.last).forward;	/* find index of next checkpoint entry */
     1565 		ck.point (next) = current;		/* save the current checkpoint */
     1566 		ck.last = next;			/* advance the index */
     1567 	     end;
     1568 
     1569 	     if how = SKIP then do;			/* see if we have skipped enough */
     1570 
     1571 		if current.page_no = ending_page then
     1572 		     return;			/* all done */
     1573 
     1574 		if current.page_no > ending_page then do; /* OOPS - a counting error */
     1575 		     force_ck_pt = "1"b;		/* re-sync the dim */
     1576 		     ec = error_table_$out_of_bounds;	/* give an error code */
     1577 		     call ioa_$rsnnl ("Skipped over end page ^d, at ^d.", err_mess, l, ending_page,
     1578 			current.page_no);
     1579 		     return;
     1580 		end;
     1581 
     1582 		n = ending_page - current.page_no;	/* see how far we need to go */
     1583 
     1584 		if n < ck_interval then do;		/* if close, use a small interval */
     1585 
     1586 		     pic = n;			/* make it ascii */
     1587 		     modes = "stop" || ltrim (pic);	/* make the mode string */
     1588 
     1589 		     call iox_$modes (iocbp, modes, omode, code);
     1590 		     if code ^= 0 then
     1591 			call iodd_msg_ (error, both, code, whoami,
     1592 			     "Changing mode near end of skip to: ^a^/  from: ^a", modes, omode);
     1593 		end;
     1594 	     end;					/* end of skip mode checks */
     1595 	     if nelt < nel then
     1596 		go to write_out;			/* when more to do, do it */
     1597 	     else go to end_of_comp;			/* otherwise this component is done, get next one */
     1598 	end;					/* end of skip or print checkpoint processing */
     1599 
     1600 	temp.file_offset = temp.file_offset + nel;	/* record last output from this component */
     1601 
     1602 end_of_comp:					/* get set for the next component, or quit if done */
     1603 	if temp.comp_no = max_comp then		/* we are at real end of file */
     1604 	     if how = PRINT | how = SAVE then do;	/* this is good */
     1605 		if privileged & ((REQUEST.copy_no = REQUEST.copies) | (max_comp > 0)) then /* done for a while */
     1606 		     call phcs_$deactivate (segp, (0)); /* so let the pages go */
     1607 		segp = null;
     1608 		return;
     1609 	     end;
     1610 	     else if how = SKIP then do;
     1611 		ec = error_table_$eof_record;		/* tried to skip too far */
     1612 		call iox_$control (iocbp, "get_position", addr (position), code);
     1613 		if code ^= 0 then
     1614 		     call iodd_msg_ (error, both, code, whoami, "get_position order.");
     1615 		if position.line_number = 1 then
     1616 		     call ioa_$rsnnl ("EOF reached at end of page ^d.", err_mess, l, position.page_number - 1);
     1617 		else call ioa_$rsnnl ("EOF at page ^d, line ^d.", err_mess, l, position.page_number,
     1618 			position.line_number);
     1619 		force_ck_pt = "1"b;			/* tell caller we are out of sync */
     1620 		return;
     1621 	     end;
     1622 	     else do;				/* sample was the last partial page */
     1623 		call iox_$put_chars (iocbp, addr (FF), 1, code); /* align the page */
     1624 		go to sample_done;			/* let it go by */
     1625 	     end;
     1626 
     1627 	temp.comp_no = temp.comp_no + 1;		/* go on to the next component */
     1628 	temp.offset = 0;				/* start at the begining */
     1629 
     1630 	go to next_comp;				/* deactivate old and get new */
     1631 
     1632      end output_file;
     1633 
     1634 
     1635 
     1636 restart_request: procedure (source);
     1637 
     1638 /* internal procedure used to tell operator where the request was  */
     1639 
     1640 dcl  source fixed bin;
     1641 
     1642 dcl  code fixed bin (35);
     1643 dcl  pg_count_msg char (80);				/* message for last page processed */
     1644 dcl  restart_msg char (200);
     1645 dcl  i fixed bin;
     1646 
     1647 	call iox_$control (iocbp, "resetwrite", null, code); /* clear any junk out of the buffers */
     1648 
     1649 	call iox_$control (iocbp, "get_position", addr (position), code);
     1650 	if code ^= 0 then
     1651 	     starting_page = current.page_no;		/* last known page data */
     1652 	else starting_page = position.page_number - 5;	/* start back 5 pages unless otherwise instructed */
     1653 
     1654 	if starting_page < 1 then			/* be sure of a good page number */
     1655 	     starting_page = 1;
     1656 	call ioa_$rsnnl ("Driver positioned at page ^d of the file.", pg_count_msg, i, starting_page);
     1657 
     1658 	REQUEST.copy_no = min (REQUEST.copies, print_driver_data.copies_done + 1); /* assume this for now */
     1659 
     1660 	call ioa_$rsnnl ("Restarting request ^d at copy number ^d of ^d", restart_msg, i, REQUEST.request_no,
     1661 	     REQUEST.copy_no, REQUEST.copies);
     1662 	call iodd_msg_ (normal, source, 0, "", "^a^/^a^/", restart_msg, pg_count_msg);
     1663 
     1664 	return;
     1665 
     1666      end restart_request;
     1667 
     1668 
     1669 
     1670 get_page_no: procedure (a_page, a_pgn, ec);
     1671 
     1672 dcl  a_page char (*) var aligned;
     1673 dcl  a_pgn fixed bin (24);
     1674 dcl  ec fixed bin (35);
     1675 
     1676 dcl  sign char (1);
     1677 dcl  start fixed bin;
     1678 dcl  pgn fixed bin (24);
     1679 
     1680 
     1681 	ec = 0;					/* initialize the return code */
     1682 
     1683 	if a_page = "" then do;			/* for a null string, use the current position */
     1684 	     a_pgn = current.page_no;
     1685 	     return;
     1686 	end;
     1687 
     1688 	sign = substr (a_page, 1, 1);			/* see if this is a relative page number */
     1689 
     1690 	if sign = "+" | sign = "-" then
     1691 	     start = 2;
     1692 	else start = 1;				/* this is the start of the number part */
     1693 
     1694 	on conversion go to pgn_err;
     1695 	pgn = convert (pgn, substr (a_page, start));	/* convert it to binary */
     1696 
     1697 	if pgn < 1 then do;				/* make "--N" illegal */
     1698 pgn_err:
     1699 	     ec = 10;				/* and keep the numbers in range */
     1700 	     return;
     1701 	end;
     1702 
     1703 	if sign = "+" then
     1704 	     a_pgn = current.page_no + pgn;		/* forward N pages */
     1705 
     1706 	else if sign = "-" then
     1707 	     a_pgn = current.page_no - pgn;		/* back N pages */
     1708 
     1709 	else a_pgn = pgn;				/* an absolute page number */
     1710 
     1711 	if a_pgn < 1 then
     1712 	     a_pgn = 1;				/* can't go back past start  */
     1713 
     1714 	return;
     1715 
     1716      end get_page_no;
     1717 
     1718 
     1719 
     1720 skip_to_page: procedure (starting_pg, ec);
     1721 
     1722 dcl  starting_pg fixed bin (24);
     1723 dcl  ec fixed bin (35);
     1724 
     1725 dcl  target fixed bin (24);
     1726 dcl  i fixed bin;
     1727 dcl  pg fixed bin (24);
     1728 dcl  high_page fixed bin (24);
     1729 dcl  ind fixed bin;
     1730 dcl  next fixed bin;
     1731 dcl  code fixed bin (35);				/* local error code */
     1732 
     1733 
     1734 	ec = 0;					/* start clean */
     1735 
     1736 	target = starting_pg;			/* copy arg so we don't change the logic by accident */
     1737 
     1738 	call iox_$modes (iocbp, (REQUEST.output_mode), omode, code); /* must skip under users modes */
     1739 	if code ^= 0 then do;
     1740 	     ec = code;
     1741 	     err_mess = "Unable to set user modes for page skip.";
     1742 	     return;
     1743 	end;
     1744 
     1745 	if paper_not_aligned & continuous_paper then do;	/* we need to re sync the world */
     1746 	     call iox_$put_chars (iocbp, addr (FF), 1, code); /* first a FF */
     1747 	     if code ^= 0 then do;
     1748 		ec = code;
     1749 		err_mess = "IO error writing form feed to the printer.";
     1750 		return;
     1751 	     end;
     1752 	     call iox_$control (iocbp, "runout", null, code); /* be sure it is written */
     1753 	     paper_not_aligned = "0"b;		/* we are aligned now */
     1754 	     force_ck_pt = "1"b;			/* don't count the page just written */
     1755 	end;
     1756 
     1757 
     1758 	if ^force_ck_pt then			/* can we believe the current position */
     1759 	     if target = current.page_no then
     1760 		return;				/* we are already there */
     1761 
     1762 	high_page = 0;				/* highest page <_ target */
     1763 	ind = 0;					/* index of checkpoint for high_page */
     1764 
     1765 	do i = 1 to hbound (ck.entry, 1);		/* look at all entries...may not be in order */
     1766 
     1767 	     pg = ck.point (i).page_no;		/* get the page number */
     1768 	     if (pg <= target) & (pg > high_page) then do;/* see if it is highest <_ target */
     1769 		high_page = pg;
     1770 		ind = i;
     1771 	     end;
     1772 	end;
     1773 
     1774 	if ind = 0 then do;				/* start at begining */
     1775 
     1776 	     current.page_no, position.page_number = 1;	/* begining is at page 1 */
     1777 	     current.line_count, position.total_lines = 0;
     1778 	     current.comp_no = 0;			/* first MSF component */
     1779 	     current.offset = 0;			/* first char in the file */
     1780 	     current.file_offset, position.total_chars = 0;
     1781 	     next = ck.entry (ck.last).forward;		/* get index of next checkpoint */
     1782 	     ck.point (next) = current;		/* save the start as the next checkpoint */
     1783 	     ck.last = next;			/* advance the index */
     1784 
     1785 	end;
     1786 	else do;					/* we found a valid checkpoint */
     1787 
     1788 	     if ^force_ck_pt then
     1789 		if (high_page < current.page_no) & (target > current.page_no) then
     1790 		     go to forward;
     1791 
     1792 	     current.page_no, position.page_number = ck.point (ind).page_no;
     1793 	     current.line_count, position.total_lines = ck.point (ind).line_count;
     1794 	     current.comp_no = ck.point (ind).comp_no;
     1795 	     current.offset = ck.point (ind).offset;
     1796 	     current.file_offset, position.total_chars = ck.point (ind).file_offset;
     1797 	     ck.last = ind;				/* move the checkpoint index to this entry */
     1798 
     1799 	end;
     1800 
     1801 	call iox_$control (iocbp, "runout", null, code);
     1802 	call iox_$modes (iocbp, "^print", omode, code);	/* don't move the paper */
     1803 
     1804 	call iox_$put_chars (iocbp, addr (FF), 1, code);	/* make believe we wrote a FF */
     1805 
     1806 	call iox_$modes (iocbp, "print", omode, code);	/* back to normal mode */
     1807 
     1808 	call iox_$control (iocbp, "set_position", addr (position), code); /* set dim page and line positions */
     1809 	if code ^= 0 then do;			/* OOPS */
     1810 	     ec = code;
     1811 	     err_mess = "Unable to set position for checkpoint.";
     1812 	     return;
     1813 	end;
     1814 
     1815 	force_ck_pt = "0"b;				/* we can believe the current position data now */
     1816 
     1817 	if target = current.page_no then
     1818 	     return;				/* can't be less than current at this point */
     1819 
     1820 forward:
     1821 	call output_file (SKIP, target, ec);		/* now go forward to the top of the target page */
     1822 
     1823 	call iox_$control (iocbp, "runout", null, code);
     1824 	call iox_$modes (iocbp, "print", omode, code);	/* be sure we stay in print mode */
     1825 
     1826 	return;
     1827 
     1828      end skip_to_page;
     1829 
     1830 
     1831 
     1832 set_modes_and_labels: procedure ();
     1833 
     1834 dcl  nm char (256) var;
     1835 dcl  i fixed bin;
     1836 dcl  v char (12) var;
     1837 dcl  ll fixed bin;					/* line length for this request */
     1838 dcl  ind fixed bin;					/* line indentation */
     1839 dcl  temp_label char (136);				/* temporary for cleaning the label */
     1840 dcl  len fixed bin;
     1841 
     1842 /* since this request may have a different forms specification than the previous
     1843*   reset the paper size data based on this request */
     1844 	if ^continuous_paper then do;
     1845 	     if evaluate_forms_info_output_ptr ^= null then do;
     1846 		paper_info_data.phys_page_length = evaluate_forms_info_output.lines_per_page;
     1847 		paper_info_data.phys_line_length = evaluate_forms_info_output.chars_per_line;
     1848 		paper_info_data.lines_per_inch = evaluate_forms_info_output.lines_per_inch;
     1849 		call iox_$control (iocbp, "paper_info", addr (paper_info_data), code);
     1850 		if code ^= 0 then do;
     1851 		     call convert_status_code_ (code, short_msg, lg_msg);
     1852 		     call ioa_$rsnnl ("^a  while setting paper size info", msg, l, lg_msg);
     1853 		     call notify_user (substr (msg, 1, l));
     1854 
     1855 /* something happened while setting paper size info */
     1856 		     call driver_fatal_error (code, "Changing paper size info.");
     1857 		     go to clean_out;
     1858 		end;
     1859 		call iox_$control (iocbp, "reset", null, code); /* reset everything based on the new page/line lengths */
     1860 	     end;
     1861 	end;
     1862 
     1863 	nm = "";					/* clear the string */
     1864 	if dprint_msg.line_lth > 1 then do;
     1865 	     ll = min (dprint_msg.line_lth, prt_ctl.phys_line_length); /* save lth up to max for labels */
     1866 	     pic = ll;				/* convert to char form */
     1867 	     v = ltrim (rtrim (pic));			/* strip blanks */
     1868 	     nm = "ll" || v || ",";			/* make it into a mode string */
     1869 	end;
     1870 	else ll = prt_ctl.phys_line_length;
     1871 
     1872 	if dprint_msg.lmargin > 1 then do;
     1873 	     ind = dprint_msg.lmargin;		/* save the value */
     1874 	     pic = ind;				/* convert */
     1875 	     v = ltrim (rtrim (pic));
     1876 	     nm = nm || "in" || v || ",";
     1877 	end;
     1878 	else ind = 0;				/* default is no indentation */
     1879 
     1880 	i = length (nm);
     1881 	line_mode = nm;				/* save the ll and ind modes alone */
     1882 	if i > 0 then
     1883 	     substr (line_mode, i, 1) = "";		/* drop the last comma */
     1884 
     1885 	if dprint_msg.control.nep | prt_ctl.force_nep then do;
     1886 	     nm = nm || "noskip,";
     1887 	     nep_mode_set = "1"b;			/* labels are not valid in noskip */
     1888 	     set_page_labels = "0"b;			/* so be sure we turn them off */
     1889 	end;
     1890 	else nep_mode_set = "0"b;			/* try for labels */
     1891 	if dprint_msg.control.single then
     1892 	     nm = nm || "single,";
     1893 	if dprint_msg.control.non_edited then
     1894 	     nm = nm || "non_edited,";
     1895 	if dprint_msg.control.truncate then
     1896 	     nm = nm || "truncate,";
     1897 	if dprint_msg.page_lth > 1 then do;
     1898 	     pic = dprint_msg.page_lth;
     1899 	     v = ltrim (rtrim (pic));
     1900 	     nm = nm || "pl" || v || ",";
     1901 	end;
     1902 	if dprint_msg.esc | prt_ctl.force_esc then
     1903 	     nm = nm || "esc,";			/* do we need slew control */
     1904 	if dprint_msg.control.line_nbrs then		/* line numbers? */
     1905 	     nm = nm || "line_nbrs,";
     1906 	if prt_ctl.force_ctl_char then
     1907 	     nm = nm || "ctl_char,";			/* pass control characters to the printer */
     1908 	i = length (nm);				/* get the string length */
     1909 	REQUEST.output_mode = nm;
     1910 	if i > 0 then
     1911 	     substr (REQUEST.output_mode, i, 1) = "";	/* clobber the last comma */
     1912 
     1913 	pg_labels.top_label, pg_labels.bottom_label = " ";/* set leading blanks */
     1914 
     1915 	if ^nep_mode_set then do;			/* only if labels can be used */
     1916 
     1917 	     temp_label = translate (dprint_msg.top_label, " ", nl_vt_ff); /* remove naughty characters */
     1918 	     if verify (temp_label, space_ht_bs) > 0 then do; /* anything other than white space? */
     1919 		set_page_labels = "1"b;		/* set the labels in the main loop */
     1920 		len = length (rtrim (temp_label));	/* how long is  the label */
     1921 		if (ll > len) & dprint_msg.control.center_top_label then do;
     1922 		     len = divide (ll - len - ind, 2, 17, 0) - divide(ind, 2, 17, 0) + 1; /* calculate starting position (dim adds ind) */
     1923 		     substr (pg_labels.top_label, len) = temp_label; /* drop it in the right position */
     1924 		end;
     1925 		else pg_labels.top_label = temp_label;	/* put it in as given (almost) */
     1926 	     end;
     1927 
     1928 	     temp_label = translate (dprint_msg.bottom_label, " ", nl_vt_ff); /* do it again for the bottom label */
     1929 	     if verify (temp_label, space_ht_bs) > 0 then do;
     1930 		set_page_labels = "1"b;
     1931 		len = length (rtrim (temp_label));
     1932 		if (ll > len) & dprint_msg.control.center_bottom_label then do;
     1933 		     len = divide (ll - len - ind, 2, 17, 0) - divide(ind, 2, 17, 0) + 1;
     1934 		     substr (pg_labels.bottom_label, len) = temp_label;
     1935 		end;
     1936 		else pg_labels.bottom_label = temp_label;
     1937 	     end;
     1938 	end;
     1939 
     1940 	return;
     1941 
     1942      end set_modes_and_labels;
     1943 
     1944 
     1945 
     1946 print_head_banner: procedure (code);
     1947 
     1948 dcl  code fixed bin (35);				/* error code */
     1949 dcl  ec fixed bin (35);
     1950 
     1951 	iodd_static.quit_during_request = "0"b;		/* reset for each copy */
     1952 	code = 0;					/* clear the code */
     1953 
     1954 	if iodd_static.ctl_term.attached then do;	/* message to ctl term? */
     1955 	     call write_control_form_ (iodd_static.form_type, iodd_static.ctl_output, addr (REQUEST), ec);
     1956 	     if ec ^= 0 then do;
     1957 		if ec ^= error_table_$action_not_performed then do; /* this one is normal */
     1958 		     call iodd_msg_ (error, master, ec, whoami, "Writing message on control terminal.");
     1959 		     iodd_static.slave_hold = "1"b;	/* avoid automatic start */
     1960 		end;
     1961 		ctl_msg_sent = "0"b;		/* don't wait for bad message */
     1962 	     end;
     1963 	     else ctl_msg_sent = "1"b;		/* say all was well, so we can wait */
     1964 	     if ctl_wait_list.number = 1 & ctl_msg_sent then do; /* are we going to sync with the term? */
     1965 		call ipc_$drain_chn (ctl_wait_list.channel, ec);
     1966 		if ec ^= 0 then do;			/* avoid futher trouble, but not fatal */
     1967 		     ctl_wait_list.channel = 0;	/* stop trying */
     1968 		     ctl_wait_list.number = 0;
     1969 		     iodd_static.slave_hold = "1"b;
     1970 		     ctl_msg_sent = "0"b;		/* don't wait , no wakeup will come */
     1971 		     call convert_ipc_code_ (ec);
     1972 		     call iodd_msg_ (error, master, ec, whoami, "print_head_banner bad call to ipc_drain");
     1973 		end;
     1974 		else call timer_manager_$alarm_wakeup (driver_status.form_wait_time, "11"b, ctl_wait_list.channel);
     1975 	     end;
     1976 	end;
     1977 	else ctl_msg_sent = "0"b;			/* don't wait */
     1978 
     1979 	call iox_$control (iocbp, "reset", null, code);	/* get to a known format */
     1980 	call iox_$control (iocbp, "inside_page", null, code); /* and page position */
     1981 
     1982 	if ^REQUEST.no_separator | REQUEST.copy_no = 1 then do;
     1983 	     call iodd_static.print_head_sheet (iocbp, prt_ctl_ptr, addr (REQUEST), code); /* write head sheet */
     1984 	     if code = 0 then
     1985 		header_done = "1"b;			/* for the error routines */
     1986 	end;					/*	otherwise ignore the banner type and just align the paper */
     1987 
     1988 	call iox_$control (iocbp, "reset", null, code);	/* don't charge for advertizing */
     1989 	return;
     1990 
     1991      end print_head_banner;
     1992 
     1993 
     1994 
     1995 print_tail_banner: procedure (code);
     1996 
     1997 dcl  code fixed bin (35);
     1998 dcl  ec fixed bin (35);
     1999 dcl  odd_page bit (1);
     2000 
     2001 dcl  1 event_info aligned,				/* info returned from ipc_$block */
     2002        2 chan fixed bin (71),
     2003        2 message fixed bin (71),
     2004        2 sender bit (36),
     2005        2 origin fixed bin,
     2006        2 wait_list_index fixed bin;
     2007 
     2008 	code = 0;					/* clear the error code */
     2009 	odd_page = (mod (position.page_number, 2) = 1);	/* did we stop on an odd page? */
     2010 
     2011 	if nep_mode_set & continuous_paper then do;	/* in nep mode, check paper position */
     2012 	     if position.line_number > (prt_ctl.phys_page_length - divide (prt_ctl.lines_per_inch, 2, 17))
     2013 		& odd_page then do;
     2014 		call iox_$put_chars (iocbp, addr (FF), 1, code); /* move ahead when partially printed */
     2015 		odd_page = ""b;			/* now proceed as though we finished on even page */
     2016 	     end;
     2017 	end;
     2018 	else if set_page_labels then			/* if we owe a bottom label on last page */
     2019 	     call iox_$control (iocbp, "end_of_page", null, code);
     2020 
     2021 	call iox_$control (iocbp, "reset", null, code);	/* clear the counters and page labels */
     2022 
     2023 /* for remotes, move to the right page */
     2024 	if ^odd_page & iodd_static.attach_type ^= ATTACH_TYPE_IOM & continuous_paper then
     2025 	     call iox_$put_chars (iocbp, addr (FF), 1, code); /* move ahead when partially printed */
     2026 
     2027 	call iox_$control (iocbp, "outside_page", null, code);
     2028 	if ^REQUEST.no_separator | (REQUEST.copy_no = REQUEST.copies) then
     2029 	     call iodd_static.print_tail_sheet (iocbp, prt_ctl_ptr, addr (REQUEST), code);
     2030 
     2031 	if ^iodd_static.quit_during_request &		/* on quit, don't wait for ctl term  */
     2032 	     ctl_msg_sent then do;			/* avoid premature blocking */
     2033 	     call ipc_$block (addr (ctl_wait_list), addr (event_info), ec); /* wait for form to finish */
     2034 	     if ec ^= 0 then do;
     2035 		call convert_ipc_code_ (ec);
     2036 		call iodd_msg_ (error, master, ec, whoami, "Attempting to block for ctl_term.");
     2037 		iodd_static.slave_hold = "1"b;	/* go to cmd level */
     2038 	     end;
     2039 	end;
     2040 
     2041 	return;
     2042 
     2043      end print_tail_banner;
     2044 
     2045 
     2046 
     2047 init_static_ctl: procedure ();
     2048 
     2049 	string (static_ctl.flags) = ""b;
     2050 
     2051 	static_ctl.banner_type = NORMAL_BANNERS;
     2052 	static_ctl.banner_bars = NORMAL_BANNER_BARS;
     2053 	static_ctl.banner_indent = 0;
     2054 	static_ctl.banner_line = 1;
     2055 
     2056 	static_ctl.phys_line_length = 136;
     2057 	static_ctl.phys_page_length = 66;
     2058 	static_ctl.lines_per_inch = 6;
     2059 
     2060 	string (static_ctl.channel_stops) = "0"b;	/* no channel stops defined here */
     2061 
     2062 	return;
     2063 
     2064      end init_static_ctl;
     2065 
     2066 
     2067 clean_proc: procedure ();
     2068 
     2069 	iodd_static.segptr = null;			/* tell signal handler we are done with it */
     2070 
     2071 	if fcbp ^= null then do;
     2072 	     if segp ^= null then
     2073 		if privileged then
     2074 		     call phcs_$deactivate (segp, (0));
     2075 	     call msf_manager_$close (fcbp);
     2076 	end;
     2077 
     2078 	segp, fcbp = null;				/* because this is used for several functions */
     2079 
     2080 	return;
     2081 
     2082      end clean_proc;
     2083 
     2084 set_up_page_labels: proc;
     2085 
     2086 /* this routine will set up the printer to generate labels if they are needed */
     2087 
     2088 /* if this is single sheet paper and there is a control string to initialize
     2089*   the printer send it out now.  This is needed since head_sheet_ and
     2090*   tail_sheet_ programs for the printer might alter the characteristics of the
     2091*   printer in order to output their forms */
     2092 
     2093 	if ^continuous_paper then do;
     2094 	     if evaluate_forms_info_output_ptr ^= null then do;
     2095 		if evaluate_forms_info_output.escape_length ^= 0 then do;
     2096 		     call iox_$modes (iocbp, "rawo", "", code);
     2097 		     call iox_$control (iocbp, "prt_conv_off", null (), code);
     2098 		     call iox_$put_chars (iocbp, addr (evaluate_forms_info_output.escape_string),
     2099 			(evaluate_forms_info_output.escape_length), code);
     2100 		     call iox_$control (iocbp, "prt_conv_on", null (), code);
     2101 		     call iox_$modes (iocbp, "^rawo", "", code);
     2102 		end;
     2103 	     end;
     2104 	end;
     2105 
     2106 	if set_page_labels then do;			/* only if we need page labels */
     2107 	     if (prt_ctl.banner_type = NO_BANNERS & prt_ctl.banner_bars = NO_BANNER_BARS)
     2108 		| (prt_ctl.banner_type = NO_BANNERS & ^REQUEST.separator)
     2109 		| (REQUEST.no_separator & ^(REQUEST.copy_no = 1)) then
     2110 		call iox_$put_chars (iocbp, addr (FF), 1, code);
     2111 
     2112 /* move below page label position for this page */
     2113 	     call iox_$control (iocbp, "end_of_page", null, code);
     2114 	     call iox_$modes (iocbp, line_mode, omode, code);
     2115 	     if code ^= 0 then do;
     2116 		call convert_status_code_ (code, short_msg, lg_msg);
     2117 		call ioa_$rsnnl ("^a  while setting user line modes to: ^a^/  from: ^a", msg, l, lg_msg,
     2118 		     line_mode, omode);
     2119 		call notify_user (substr (msg, 1, l));
     2120 
     2121 /* The user tried to put the left margin after the right margin. */
     2122 		call driver_fatal_error (code, "Changing to user line modes.");
     2123 		go to clean_out;
     2124 	     end;
     2125 
     2126 	     call iox_$control (iocbp, "page_labels", addr (pg_labels), code);
     2127 	     if code ^= 0 then do;
     2128 		call driver_fatal_error (code, "Setting page_labels.");
     2129 		go to clean_out;
     2130 	     end;
     2131 	end;
     2132 	if (set_page_labels) |			/* get the top label out			*/
     2133 						/* regardless of anything else		*/
     2134 	     ^((prt_ctl.banner_type = NO_BANNERS & prt_ctl.banner_bars = NO_BANNER_BARS)
     2135 	     | (prt_ctl.banner_type = NO_BANNERS & ^REQUEST.separator)
     2136 	     | (REQUEST.no_separator & ^(REQUEST.copy_no = 1))) then /* if no labels then */
     2137 	     call iox_$put_chars (iocbp, addr (FF), 1, code); /* if not at top_inside_page, go there */
     2138 
     2139      end set_up_page_labels;
     2140 
     2141 
     2142 /* ======== OTHER EXTERNAL ENTRIES ========= */
     2143 
     2144 error_during_request: entry (cond);			/* for coming back after signal */
     2145 
     2146 dcl  cond char (*);
     2147 
     2148 	fault_name = cond;
     2149 	go to err_label;
     2150 
     2151 
     2152 single_copy: entry ();
     2153 
     2154 /* abort multiple copies on command */
     2155 
     2156 	request_data_p -> ordata.copies = 1;		/* force copy limit to 1 */
     2157 	return;
     2158 
     2159  /* begin include file - access_audit_user_info.incl.pl1 */
  1     2 
  1     3 /* 85-01-21 EJ Sharpe - changed (min max)_auth to auth range */
  1     4 /* 85-01-07 EJ Sharpe - added min_authorization */
  1     5 /* 84-10-09 EJ Sharpe - created */
  1     6 
  1     7 /* The structure defined here is passed to the access_audit_
  1     8*entrypoints which deal with proxy users:
  1     9**/
  1    10 
  1    11 dcl audit_user_info_ptr	pointer;
  1    12 
  1    13 dcl 1 audit_user_info  based (audit_user_info_ptr) aligned,
  1    14       2 version		char (8),
  1    15       2 user_id		char (32),
  1    16       2 ring		fixed bin (3) uns unal,
  1    17       2 pad		bit (33) unal,
  1    18       2 process_id		bit (36) aligned,
  1    19       2 authorization	bit (72) aligned,
  1    20       2 authorization_range	(2) bit (72) aligned,
  1    21       2 audit_flags		bit (36) aligned;
  1    22 
  1    23 dcl audit_user_info_version_1	char (8) init ("adtusrv1")
  1    24 	internal static options (constant);
  1    25 
  1    26 /* end include file - access_audit_user_info.incl.pl1 */
     2159 
     2160  /* begin include file - access_audit_eventflags.incl.pl1 */
  2     2 /* NOTE: This include file has an ALM counterpart made with cif.
  2     3*Keep it up to date. */
  2     4 
  2     5 dcl 1 audit_event_flags	based aligned,
  2     6       2 special_op	bit (1) unal,  /* special sys operation */
  2     7       2 grant	bit (1) unal,  /* operation was successful */
  2     8       2 admin_op	bit (1) unal,  /* administrative operation */
  2     9       2 priv_op	bit (1) unal,  /* privileged operation */
  2    10       2 cc_1_10	bit (1) unal,  /* small covert channel */
  2    11       2 cc_10_100	bit (1) unal,  /* moderate covert channel */
  2    12       2 receiver	bit (1) unal,  /* on receiving end of channel */
  2    13       2 pad	bit (29) unal;
  2    14 
  2    15 /* end include file - access_audit_eventflags.incl.pl1 */
     2160 
     2161  /* BEGIN INCLUDE FILE ... dprint_msg.incl.pl1 */
  3     2 /* Modified: November 1983 by C. Marker Added no_separator. */
  3     3 
  3     4 /****^  HISTORY COMMENTS:
  3     5*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
  3     6*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
  3     7*     Add line_nbrs bit for line-numbered printouts, version 4.
  3     8*  2) change(88-02-05,Farley), approve(88-02-05,PBF7686), audit(88-02-05,GWMay),
  3     9*     install(88-02-05,MR12.2-1022):
  3    10*     Corrected alignment of line_nbrs, was aligned s/b unaligned..
  3    11*  3) change(88-08-23,Farley), approve(88-09-16,MCR7911),
  3    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  3    13*     Increased size of forms field to 64 characters (was only 24), which
  3    14*     updates the version to 5.
  3    15*                                                   END HISTORY COMMENTS */
  3    16 
  3    17 
  3    18 dcl  dmp ptr;					/* ptr to message */
  3    19 
  3    20 dcl 1 dprint_msg based (dmp) aligned,			/* structure of a IO daemon print or punch request */
  3    21     2 header like queue_msg_hdr,			/* header for all standard queue messages */
  3    22     2 version fixed bin,				/* version of the dprint_msg used */
  3    23     2 copies fixed bin,				/* number of copies user requested */
  3    24     2 bit_count fixed bin (35),			/* the bitcount of the segment at request time */
  3    25     2 output_module fixed bin,			/* 1=print, 2=7punch, 3= mcc, 4=raw */
  3    26     2 control,					/* control flags. */
  3    27       3 nep bit (1) unal,				/* TRUE if printing over perforations */
  3    28       3 single bit (1) unal,				/* TRUE if ignore FF and VT */
  3    29       3 non_edited bit (1) unal,			/* TRUE if printing in non-edited mode */
  3    30       3 truncate bit (1) unal,			/* TRUE if truncating lines at line length */
  3    31       3 esc bit (1) unal,				/* TRUE if text escapes are to be processed */
  3    32       3 center_top_label bit (1) unal,			/* TRUE if top label to be centered */
  3    33       3 center_bottom_label bit (1) unal,		/* TRUE if bottom label to be centered */
  3    34       3 no_separator bit(1) unal,                           /* TRUE if the inner head a tail sheets of multiple copies are to be suppressed. */
  3    35       3 line_nbrs bit (1) unal,			/* TRUE if line numbers wanted */
  3    36       3 padding bit (27) unal,
  3    37     2 lmargin fixed bin,				/* indent from the left */
  3    38     2 line_lth fixed bin,				/* logical line length */
  3    39     2 page_lth fixed bin,				/* logical page length */
  3    40     2 heading_lth fixed bin,				/* number of chars in heading */
  3    41     2 top_label_lth fixed bin,			/* number of chars in the top label */
  3    42     2 bottom_label_lth fixed bin,			/* number of chars in bottom label */
  3    43     2 chan_stop_path_lth fixed bin,			/* number of chars in channel stop pathname */
  3    44     2 forms_name_lth fixed bin,			/* number of chars in forms name */
  3    45     2 future_fb_values (7) fixed bin,			/* make future versions possible */
  3    46     2 forms char (24),				/* name of special forms, or blank */
  3    47     2 destination char (24),				/* routing for output */
  3    48     2 heading char (head_max_lth refer (dprint_msg.heading_lth)), /* heading on page 1 */
  3    49     2 top_label char (label_max_lth refer (dprint_msg.top_label_lth)), /* top page heading for each page */
  3    50     2 bottom_label char (label_max_lth refer (dprint_msg.bottom_label_lth)), /* bottom page heading */
  3    51     2 chan_stop_path char (path_max_lth refer (dprint_msg.chan_stop_path_lth)), /* path of rqti seg with channel stops */
  3    52     2 forms_name char (forms_max_lth refer (dprint_msg.forms_name_lth)); /* forms name string */
  3    53 
  3    54 
  3    55 dcl  (
  3    56      head_max_lth init (64),				/* allocation size for heading */
  3    57      label_max_lth init (136),			/* allocation size for label fields */
  3    58      path_max_lth init (168),				/* allocation size for pathname fields */
  3    59      forms_max_lth init (64)				/* allocation size for forms name string */
  3    60      ) fixed bin int static options (constant);
  3    61 
  3    62 dcl  (
  3    63      dprint_msg_version_3 init (3),
  3    64      dprint_msg_version_4 init (4),
  3    65      dprint_msg_version_5 init (5)			/* current version */
  3    66      ) fixed bin int static options (constant);
  3    67 
  3    68 /* END INCLUDE FILE ... dprint_msg.incl.pl1 */
     2161 
     2162  /* BEGIN INCLUDE FILE...driver_status.incl.pl1 */
  4     2 
  4     3 
  4     4 
  4     5 /****^  HISTORY COMMENTS:
  4     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  4     7*     Ancient History
  4     8*     Coded by Robert S. Coren August 1973
  4     9*     Modified by J. Whitmore to structure data for the Access Isolation Mechanism
  4    10*     Modified by J. C. Whitmore, 5/78, for IO Daemon extensions
  4    11*     Modified by J. C. Whitmore, 8/79, to add the generic_type variable
  4    12*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
  4    13*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  4    14*     Upgraded for version 5 iod tables.  Changed the minor_args ftom string to
  4    15*     text_offset. Changed acct_ptr to acct_entry.  Added have_accounting bit
  4    16*     to denote accounting ^= nothing.
  4    17*                                                   END HISTORY COMMENTS */
  4    18 
  4    19 
  4    20 /* status data for a logical device driver */
  4    21 
  4    22 /* format: style4 */
  4    23 
  4    24 dcl  driver_status_ptr ptr;
  4    25 dcl  1 driver_status aligned based (driver_status_ptr),
  4    26        2 req_type_label char (32),			/* string to describe the request type */
  4    27        2 dev_name_label char (32),			/* string to describe the device */
  4    28        2 device_id char (32),				/* minor device name used by this logical driver */
  4    29        2 device_class_id char (32),			/* device class name used by this logical driver */
  4    30        2 coord_chan fixed bin (71),			/* ipc event channel for signals to coord. */
  4    31        2 driver_chan fixed bin (71),			/* ipc event channel for signals from coord. */
  4    32        2 last_wake_time fixed bin (71),			/* time last wakeup sent to coord */
  4    33        2 request_pending bit (36),			/* locking word for communication with coord */
  4    34 						/* 0 = ready for a request  */
  4    35 						/* driver pid = don't bug me */
  4    36 						/* coord  pid = got a request */
  4    37        2 status_flags,
  4    38          3 attached bit (1) unal,			/* minor device is attached for i/o */
  4    39          3 busy bit (1) unal,				/* driver doing request..tell coord when done */
  4    40          3 ready bit (1) unal,			/* driver is ready to handle requests */
  4    41          3 acknowledge bit (1) unal,			/* coordinator must reply to all wakeups */
  4    42          3 have_accounting bit (1) unal,		/* ON if accounting ^= nothing */
  4    43          3 pad bit (31) unal,
  4    44        2 list_index fixed bin,			/* index of this driver in the driver ptr list */
  4    45        2 dev_index fixed bin,				/* index in iod_device_tab of this minor device */
  4    46        2 maj_index fixed bin,				/* index in iod_device_tab of the corresponding major device */
  4    47        2 dev_class_index fixed bin,			/* index of device_class entry */
  4    48        2 minor_args unaligned like text_offset,		/* descriptive string for this minor device */
  4    49        2 min_banner bit (72) aligned,			/* min banner access class for marking output */
  4    50        2 acct_entry entry (char (*), char (*), ptr, fixed bin (35)) variable, /* entry variable to accounting procedure */
  4    51 						/* for this logical driver */
  4    52        2 rqti_ptr ptr,				/* pointer to the request type info seg */
  4    53        2 dev_out_iocbp ptr,				/* iocb pointer for dev_out_stream */
  4    54        2 dev_in_iocbp ptr,				/* iocb pointer for dev_in_stream */
  4    55        2 dev_out_stream char (32),			/* output stream for minor device */
  4    56        2 dev_in_stream char (32),			/* input stream for minor device */
  4    57        2 elem_size fixed bin,				/* element size for the stream */
  4    58        2 message_type fixed bin,			/* expected format of user request */
  4    59        2 form_wait_time fixed bin (71),			/* average time needed to write ctl term msg */
  4    60        2 forms_validation_ptr ptr,			/* forms validation data */
  4    61        2 dev_ptr1 ptr,				/* another one */
  4    62        2 dev_fb1 fixed bin,				/* a spare fixed bin variable for the driver */
  4    63        2 dev_fb2 fixed bin,				/* and another */
  4    64        2 dev_fb3 fixed bin,				/* and another */
  4    65        2 dev_fb4 fixed bin,				/* and the last spare fixed bin */
  4    66        2 dev_fb71 fixed bin (71),			/* a spare fixed bin  71  variable */
  4    67        2 dev_ctl_ptr ptr,				/* pointer to control structure for this device */
  4    68        2 bit_rate_est fixed bin (35),			/* output rate estimate - bits per second */
  4    69        2 defer_time_limit fixed bin (35),		/* max time allowed for a request - in seconds (0 = no limit) */
  4    70        2 generic_type char (32),			/* generic type of this minor device */
  4    71        2 status_pad (2) fixed bin (35),			/* save some room for later */
  4    72        2 descriptor like request_descriptor,		/* copy of request descriptor */
  4    73        2 desc_pad (13) fixed bin,
  4    74        2 message fixed bin;				/* place-holder for copy of request message */
  4    75 
  4    76 
  4    77 /* END INCLUDE FILE...driver_status.incl.pl1 */
     2162 
     2163  /* BEGIN INCLUDE FILE ... iod_constants.incl.pl1 */
  5     2 
  5     3 
  5     4 /****^  HISTORY COMMENTS:
  5     5*  1) change(88-08-31,Brunelle), approve(88-08-31,MCR7911),
  5     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  5     7*     Created.
  5     8*                                                   END HISTORY COMMENTS */
  5     9 
  5    10 /* This file contains constants used by the I/O Daemon software in various tables */
  5    11 
  5    12 /* format: style4 */
  5    13 
  5    14 /* literals for use with idte.attach_type & iodd_static.attach_type */
  5    15 dcl  (ATTACH_TYPE_IOM init (1),
  5    16      ATTACH_TYPE_TTY init (2),
  5    17      ATTACH_TYPE_DIAL init (3),
  5    18      ATTACH_TYPE_VARIABLE_LINE init (4)) fixed bin int static options (constant);
  5    19 
  5    20 /* literals for use with idte.ctl_attach_type & iodd_static.ctl_attach_type */
  5    21 dcl  (CTL_ATTACH_TYPE_TTY init (1),
  5    22      CTL_ATTACH_TYPE_DIAL init (2),
  5    23      CTL_ATTACH_TYPE_MC init (3)) fixed bin int static options (constant);
  5    24 
  5    25 /* literals for use with idte.paper_type & iodd_static.paper_type */
  5    26 dcl  (PAPER_TYPE_DEFAULT init (-1),
  5    27      PAPER_TYPE_SINGLE init (1),
  5    28      PAPER_TYPE_CONTINUOUS init (2)) fixed bin int static options (constant);
  5    29 
  5    30 /* END INCLUDE FILE ... iod_constants.incl.pl1 */
     2163 
     2164  /* BEGIN INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
  6     2 
  6     3 
  6     4 
  6     5 /****^  HISTORY COMMENTS:
  6     6*  1) change(88-01-27,Brunelle), approve(), audit(), install():
  6     7*     Ancient History
  6     8*     Created by J. Stern, 1/20/75
  6     9*     Modified by J. C. Whitmore April 1978 for enhancements
  6    10*     Modified by J. C. Whitmore, 10/78, for version 3 iod_tables format.
  6    11*     Modified by E. N. Kittlitz, 6/81, for version 4 iod_tables with expanded
  6    12*     q_group_tab
  6    13*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  6    14*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  6    15*     Change version number to reflect changes in q_group_tab and
  6    16*     iod_device_tab for laser printer support.  Added font tables.
  6    17*                                                   END HISTORY COMMENTS */
  6    18 
  6    19 
  6    20 /* format: style4 */
  6    21 
  6    22 dcl  ithp ptr;					/* ptr to io daemon dables and it's header */
  6    23 dcl  1 iod_tables_hdr aligned based (ithp),		/* header of data segment compiled by iod_table_compiler */
  6    24        2 version char (8),				/* version of this structure */
  6    25        2 date_time_compiled fixed bin (71),
  6    26        2 grace_time fixed bin (71),			/* grace time before deleting finished segment */
  6    27        2 max_queues fixed bin (17),			/* default number of priority queues per queue group */
  6    28        2 line_tab_offset fixed bin (18),		/* offset of line id table */
  6    29        2 device_tab_offset fixed bin (18),		/* offset of device table */
  6    30        2 minor_device_tab_offset fixed bin (18),		/* offset of minor device table */
  6    31        2 dev_class_tab_offset fixed bin (18),		/* offset of device class table */
  6    32        2 q_group_tab_offset fixed bin (18),		/* offset of queue group table */
  6    33        2 forms_info_tab_offset fixed bin (18),		/* offset of forms info tables */
  6    34        2 text_strings_offset fixed bin (18),
  6    35        2 start_of_tables fixed bin;			/* beginning of above tables, MUST start on even word boundry */
  6    36 
  6    37 /* Defines common text block to store virtually all text in the I/O daemon tables */
  6    38 dcl  text_strings_ptr ptr;
  6    39 dcl  1 text_strings aligned based (text_strings_ptr),
  6    40        2 length fixed bin,
  6    41        2 chars char (1 refer (text_strings.length)) unaligned;
  6    42 
  6    43 /* this defines text offsets used to locate i/o daemon tables strings in
  6    44*   the text_strings structure */
  6    45 dcl  1 text_offset based,
  6    46        2 first_char fixed bin (18) unsigned unaligned,
  6    47        2 total_chars fixed bin (18) unsigned unaligned;
  6    48 
  6    49 dcl  IODT_VERSION_5 char (8) int static options (constant) init ("IODT0005"); /* current version number */
  6    50 
  6    51 
  6    52 /* END INCLUDE FILE ... iod_tables_hdr.incl.pl1 */
     2164 
     2165  /* BEGIN INCLUDE FILE...iodd_static.incl.pl1 */
  7     2 
  7     3 
  7     4 /****^  HISTORY COMMENTS:
  7     5*  1) change(85-02-14,Homan), approve(87-04-06,MCR7656),
  7     6*     audit(87-06-13,Beattie), install(87-08-06,MR12.1-1068):
  7     7*     Add support for logout_on_hangup option.
  7     8*  2) change(88-02-18,Brunelle), approve(88-08-31,MCR7911),
  7     9*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
  7    10*     Add head/tail_sheet entry variables and paper_type variable.
  7    11*                                                   END HISTORY COMMENTS */
  7    12 
  7    13 /* format: style4 */
  7    14 
  7    15 dcl  stat_p int static ptr;
  7    16 
  7    17 dcl  1 iodd_static based (stat_p) aligned,
  7    18 
  7    19 /*    The first part is set only once for a device driver */
  7    20 
  7    21        2 ithp ptr,					/* pointer to iod tables header */
  7    22        2 ltp ptr,					/* pointer to line table */
  7    23        2 idtp ptr,					/* pointer to device tab */
  7    24        2 mdtp ptr,					/* pointer to minor device table */
  7    25        2 qgtp ptr,					/* pointer to q_group table */
  7    26        2 dev_class_ptr ptr,				/* pointer to device class table */
  7    27        2 text_strings_ptr ptr,			/* pointer to iod tables text strings */
  7    28        2 driver_list_ptr ptr,				/* pointer to list of driver status seg pointers */
  7    29        2 chan_list_ptr ptr,				/* pointer to list of event channels for blocking */
  7    30        2 sys_dir_ptr ptr,				/* ptr to 168 char string defining sys_dir */
  7    31        2 coord_proc_id bit (36),			/* process id of coordinator for wakeups */
  7    32        2 driver_proc_id bit (36),			/* process id of driver for locking */
  7    33        2 re_init_label label,				/* where to go after "re_init" or "slave_logout" */
  7    34        2 no_coord_label label,			/* where to go for a no_coord condition */
  7    35        2 log_stream char (32),			/* stream name used for log output */
  7    36        2 master_input char (32),			/* master console input stream for commands */
  7    37        2 master_output char (32),			/* master console output stream for messages */
  7    38        2 master_out ptr,				/* master output iocbp */
  7    39        2 master_in ptr,				/* master input iocbp */
  7    40        2 log_iocbp ptr,				/* log output iocbp */
  7    41        2 error_io ptr,				/* error i/o iocbp */
  7    42        2 dev_io_stream char (32),			/* stream used to attach the major device */
  7    43        2 dev_in_stream char (32),			/* input stream if different from dev_io_stream */
  7    44        2 dev_out_stream char (32),			/* output stream if different from dev_io_stream */
  7    45        2 device_dim char (32),			/* dim which drives the major device */
  7    46        2 attach_name char (32),			/* channel or dial id for attaching major device */
  7    47        2 attach_type fixed bin,			/* what previous is: 1 = iom, 2 = tty, 3 = dial, 4 = variable line */
  7    48        2 dev_dial_id char (8),			/* non null if device is to be dialed to driver */
  7    49        2 line_tab_idx fixed bin,			/* for attach type 4, this is the entry index, else 0 */
  7    50        2 dial_ev_chan fixed bin (71),			/* IPC chan for dial control */
  7    51        2 major_device char (32),			/* name of the major device */
  7    52        2 major_args unaligned like text_offset,		/* descriptive string for the major device */
  7    53        2 coord_cmd_chan fixed bin (71),			/* IPC chan to send commands to coord through coord_comm.ms */
  7    54        2 cmd_ack_chan fixed bin (71),			/* IPC chan for coord to return command status code */
  7    55        2 timer_chan fixed bin (71),			/* IPC chan for unblocking if nothing happens */
  7    56        2 io_daemon_version char (8),			/* current version number of the io daemon driver */
  7    57        2 extra_static (8) fixed bin (35),		/* unused space - non_dynamic */
  7    58        2 dummy_ptr ptr,				/* a dummy pointer for the driver module */
  7    59 
  7    60 /*    driver module entrypoints are defined by the following entry variables */
  7    61 
  7    62        2 driver_init entry variable options (variable),
  7    63        2 driver_request entry variable options (variable),
  7    64        2 driver_command entry variable options (variable),
  7    65        2 driver_default_handler entry variable options (variable),
  7    66 
  7    67 /*    entrypoints for head/tail_sheet_ entries */
  7    68        2 print_head_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  7    69        2 print_head_separator entry (ptr, ptr, char (*), fixed bin (35)) variable,
  7    70        2 print_tail_sheet entry (ptr, ptr, ptr, fixed bin (35)) variable,
  7    71 
  7    72        2 paper_type fixed bin,			/* type of paper being used */
  7    73 						/* 1 = single sheet */
  7    74 						/* 2 = continuous forms */
  7    75 
  7    76 /*   The remainder of the data may be dynamic during the device driver's existence */
  7    77 
  7    78        2 extra_dynamic (14) fixed bin (35),		/* unused space - dynamic */
  7    79        2 auto_logout_interval fixed bin,		/* minutes to wait for inactivity logout */
  7    80        2 requests_til_cmd fixed bin,			/* number of requests to go before returning to cmd level */
  7    81        2 assigned_devices fixed bin,			/* number of minor devices assigned to major device */
  7    82        2 current_devices fixed bin,			/* number of devices currently active in process */
  7    83        2 output_device char (32),			/* name of minor device currently in use */
  7    84        2 wakeup_time fixed bin (71),			/* time interval between timer wakeups */
  7    85        2 auto_start_delay fixed bin (71),		/* time to wait before performing an auto-start after quit */
  7    86        2 driver_ptr ptr,				/* pointer to driver status seg currently in use */
  7    87        2 segptr ptr,				/* ptr to current user segment being processed */
  7    88        2 flags,					/* control flags */
  7    89          3 initialized bit (1) unal,			/* all driver data bases are initialized */
  7    90          3 test_entry bit (1) unal,			/* driver test entry was called */
  7    91          3 request_in_progress bit (1) unal,		/* driver executing a request */
  7    92          3 recursion_flag bit (1) unal,			/* recursive unclaimed signal */
  7    93          3 no_coord_flag bit (1) unal,			/* process is ready to accept a no_coord signal */
  7    94          3 logout_pending bit (1) unal,			/* logout after all pending requests are done */
  7    95          3 master_hold bit (1) unal,			/* master_hold at command level */
  7    96          3 slave_hold bit (1) unal,			/* slave hold at command level */
  7    97          3 step bit (1) unal,				/* run in step mode */
  7    98          3 quit_during_request bit (1) unal,		/* a quit occured, don't wait for wakeup */
  7    99          3 runout_requests bit (1) unal,		/* hold after all pending requests are done */
  7   100          3 re_init_in_progress bit (1) unal,		/* driver processing a re_init signal */
  7   101          3 quit_signaled bit (1) unal,			/* set to "1"b by quit handler for anyone who is curious */
  7   102          3 auto_logout_pending bit (1) unal,		/* inactivity limit exceeded, logout after next wakeup */
  7   103          3 logout_on_hangup bit (1) unal,		/* logout instead of reinit if set */
  7   104          3 pad bit (21) unal,				/* unused space */
  7   105        2 slave,					/* slave control device data (ctl term or remote reader) */
  7   106          3 slave_input char (32),			/* slave input stream name */
  7   107          3 slave_output char (32),			/* slave output stream name */
  7   108          3 slave_pad fixed bin,			/* allocation breakage */
  7   109          3 slave_in ptr,				/* slave input iocbp */
  7   110          3 slave_out ptr,				/* slave output iocbp */
  7   111          3 slave_ev_chan fixed bin (71),		/* event channel the slave device blocks on */
  7   112          3 active bit (1) unal,			/* on if there is a slave */
  7   113          3 accept_input bit (1) unal,			/* on if commands may come from the slave */
  7   114          3 allow_quits bit (1) unal,			/* on if we allow slave to send quits */
  7   115          3 print_errors bit (1) unal,			/* on if errors will be sent to the slave */
  7   116          3 log_msg bit (1) unal,			/* on if log messages are to be sent to the slave */
  7   117          3 priv1 bit (1) unal,			/* driver_module defined slave privileges */
  7   118          3 priv2 bit (1) unal,
  7   119          3 priv3 bit (1) unal,
  7   120          3 echo_cmd bit (1) unal,			/* on if each slave cmd should be written back */
  7   121          3 slave_bit_pad bit (27) unal,			/* unused space */
  7   122        2 ctl_term,					/* control terminal data */
  7   123          3 ctl_attach_name char (32),			/* dial id, tty chan, or mrd_ device */
  7   124          3 ctl_attach_type fixed bin,			/* attach name meaning: 1=line, 2=dial, 3=mrd_source */
  7   125          3 ctl_pad fixed bin,				/* allocation breakage */
  7   126          3 ctl_dial_chan fixed bin (71),		/* ipc event channel for dial comm */
  7   127          3 ctl_input char (32),			/* ctl input stream name */
  7   128          3 ctl_output char (32),			/* ctl output stream name */
  7   129          3 ctl_io char (32),				/* ctl i/o stream name */
  7   130          3 ctl_dev_dim char (32),			/* ctl_io attached with this dim */
  7   131          3 ctl_ev_chan fixed bin (71),			/* IPC event chan ctl term blocks on */
  7   132          3 ctl_device char (32),			/* ctl terminal device name */
  7   133          3 form_type char (16),			/* format type if printing forms */
  7   134          3 attached bit (1) unal,			/* ctl term attached to process */
  7   135          3 forms bit (1) unal,			/* on if printing forms */
  7   136          3 pad bit (34) unal,
  7   137        2 admin_ec_name char (32),			/* name of the ec to use with the "x" command */
  7   138        2 expansion_space (100) fixed bin;		/* reserved space...use at your own risk */
  7   139 
  7   140 /* END INCLUDE FILE ... iodd_static.incl.pl1 */
     2165 
     2166  /* BEGIN INCLUDE FILE  kst_attributes.incl.pl1 WRITTEN 03/26/76  by  R. Bratt */
  8     2 
  8     3 dcl  kstap ptr;
  8     4 
  8     5 dcl 1 kst_attributes aligned based (kstap),
  8     6     2 set unaligned,				/* SPECIFIES WHICH ATTRIBUTES TO SET */
  8     7       3 (allow_write,
  8     8      tms,
  8     9      tus,
  8    10      tpd,
  8    11      audit,
  8    12      explicit_deactivate_ok) bit (1),
  8    13       3 pad bit (39),
  8    14     2 value unaligned,				/* SPECIFIES THE VALUE OF THE ATTRIBUTES TO BE SET */
  8    15       3 (allow_write,				/* allow write permission in sdw */
  8    16      tms,						/* don't update dtm */
  8    17      tus,						/* don't update dtu */
  8    18      tpd,						/* don't put on PD */
  8    19      audit,					/* audit */
  8    20      explicit_deactivate_ok) bit (1),			/* allow demand deactivation */
  8    21       3 pad bit (30);
  8    22 
  8    23 /* END INCLUDE FILE kst_attributes.incl.pl1                      */
     2166 
     2167  /* BEGIN INCLUDE FILE . . . mseg_message_info.incl.pl1 BIM 1984-10-10 */
  9     2 /* format: style3,idind30 */
  9     3 
  9     4 /* structure returned when message is read from a message segment */
  9     5 
  9     6 
  9     7 dcl	mseg_message_info_ptr	pointer;
  9     8 
  9     9 dcl	1 mseg_message_info		based (mseg_message_info_ptr) aligned,
  9    10 	  2 version		char (8) aligned,
  9    11 	  2 message_code		fixed bin,
  9    12 	  2 control_flags		unaligned,
  9    13 	    3 own			bit (1),
  9    14 	    3 delete		bit (1),
  9    15 	    3 pad			bit (34),
  9    16 	  2 ms_ptr		ptr,		/* pointer to message */
  9    17 	  2 ms_len		fixed bin (24),	/* length of message  in bits */
  9    18 	  2 ms_id			bit (72),		/* unique ID of message */
  9    19 						/* input in some cases */
  9    20 	  2 ms_access_class		bit (72),		/* message access class */
  9    21 	  2 sender_id		char (32) unaligned,/* process-group ID of sender */
  9    22 	  2 sender_process_id	bit (36) aligned,	/* if nonzero, process that sent */
  9    23 	  2 sender_level		fixed bin,	/* validation level of sender */
  9    24 	  2 sender_authorization	bit (72),		/* access authorization of message sender */
  9    25 	  2 sender_max_authorization	bit (72),		/* max authorization of sending process */
  9    26 	  2 sender_audit		bit (36) aligned;   /* audit flags */
  9    27 
  9    28 declare	MSEG_MESSAGE_INFO_V1	char (8) aligned init ("msegmi01") int static options (constant);
  9    29 
  9    30 declare	(
  9    31 	MSEG_READ_FIRST		init (1),
  9    32 	MSEG_READ_LAST		init (2),
  9    33 	MSEG_READ_SPECIFIED		init (3),
  9    34 	MSEG_READ_BEFORE_SPECIFIED	init (4),
  9    35 	MSEG_READ_AFTER_SPECIFIED	init (5))
  9    36 	fixed bin int static options (constant);
  9    37 
  9    38 declare  (MSEG_READ_OWN		init ("1"b),
  9    39 	MSEG_READ_DELETE		init ("01"b)
  9    40 	)			bit (36) aligned internal static options (constant);
  9    41 
  9    42 /* END INCLUDE FILE . . . mseg_message_info.incl.pl1 */
     2167 
     2168  /* BEGIN INCLUDE FILE ... output_request_data.incl.pl1 */
 10     2 
 10     3 /* Modified by R. McDonald May 1980 to include page charges (UNCA) */
 10     4 /* Modified by C. Marker October 1983 added no_separator */
 10     5 
 10     6 
 10     7 /****^  HISTORY COMMENTS:
 10     8*  1) change(87-05-10,Gilcrease), approve(87-05-13,MCR7686),
 10     9*     audit(88-02-01,Farley), install(88-02-02,MR12.2-1019):
 10    10*     Add the line_nbrs bit for line-numbered output.
 10    11*  2) change(88-08-19,Brunelle), approve(88-08-19,MCR7911),
 10    12*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 10    13*     Added single_sheet bit to denote if continuous paper.
 10    14*                                                   END HISTORY COMMENTS */
 10    15 
 10    16 
 10    17      dcl	   1 ordata	      based (ordatap) aligned,
 10    18 	     2 dpmp	      ptr,		/* Ptr to dprint_msg */
 10    19 	     2 requestor	      char (32),		/* Person.Proj.tag requesting */
 10    20 	     2 full_path	      char (168),		/* source of the output */
 10    21 	     2 queue	      fixed bin,		/* Queue requested. */
 10    22 	     2 copies	      fixed bin,		/* Copies requested. */
 10    23 	     2 copy_no	      fixed bin,		/* Number this copy */
 10    24 	     2 request_no	      fixed bin (35),	/* Number request assigned by coord */
 10    25 	     2 restart_no	      fixed bin (35),	/* old number of restarted request (0 = not restarted) */
 10    26 	     2 request_type	      char (32),		/* Name of device class wanted. */
 10    27 	     2 access_class_string char (280),		/* Access class - size limit for two printer lines */
 10    28 	     2 punsw	      fixed bin,		/* 0 = print, 1= punch */
 10    29 	     2 delete	      fixed bin,		/* 1= delete, 0= don't */
 10    30 	     2 device_name	      char (32),		/* Name of physical device used */
 10    31 	     2 output_mode	      char (128),		/* user's mode string for ios_$changemode */
 10    32 	     2 time_start_request fixed bin (71),	/* Clock time when picked request */
 10    33 	     2 date_time_start_request char (24),	/* .. in chars too */
 10    34 	     2 line_count	      fixed bin (24),	/* Line count returned by DIM */
 10    35 	     2 page_count	      fixed bin,		/* Page count returned by DIM */
 10    36 	     2 cpu_time	      fixed bin (71),	/* Total CPU usage while printing */
 10    37 	     2 real_time	      fixed bin (71),	/* Total realtime while printing */
 10    38 	     2 page_waits	      fixed bin,		/* Total page-waits while printing */
 10    39 	     2 pre_pages	      fixed bin,		/* Total pre-pages (???) .. */
 10    40 	     2 bit_count	      fixed bin (24),	/* Number of bits transmitted. */
 10    41 	     2 charge	      float bin,		/* What the thing cost. */
 10    42 	     2 control_flags,
 10    43 	       3 continued	      bit (1) unal,		/* request started by one driver and given to another */
 10    44 	       3 restarted	      bit (1) unal,		/* request is restarted */
 10    45 	       3 separator	      bit (1) unal,		/* used to determine necessity of a separator page  */
 10    46 	       3 notify	      bit (1) unal,		/* if should confirm to user */
 10    47 	       3 saved	      bit (1) unal,		/* request was suspended by operator, we'll save it */
 10    48 	       3 priority_request bit (1) unal,		/* operator said run now!! */
 10    49 	       3 no_separator     bit (1) unal,		/* suppress inner head and tail sheets when printing multiple copies */
 10    50 	       3 line_nbrs	      bit (1) unal,		/* if line-numbered output requested */
 10    51 	       3 single_sheet     bit (1) unal,		/* ON if single_sheet output */
 10    52 	       3 padding	      bit (27) unal,	/* not used */
 10    53 	     2 contd_no	      fixed bin (35),	/* old number of continued request (0 = not continued) */
 10    54 	     2 total_charge	      float bin,		/* total charge for all copies */
 10    55 	     2 price_per_n_lines  float bin,		/* line price rate used to compute charge */
 10    56 	     2 n_lines_for_price  fixed bin,		/* number of lines price is based on */
 10    57 	     2 charge_queue	      fixed bin,		/* base charge rate on this queue */
 10    58 	     2 price_per_n_pages  float bin,		/* page charge rate used to compute charge */
 10    59 	     2 n_pages_for_price  fixed bin,		/* number of pages price is based on */
 10    60 	     2 rs_number	      fixed bin (9) unsigned unaligned, /* rate_structure number used */
 10    61 	     2 rs_unavailable     bit (1) unaligned,	/* 1=>couldn't read SAT */
 10    62 	     2 no_accounting      bit (1) unaligned,	/* 1=>accounting:nothing in iod_tables */
 10    63 	     2 pad_bits	      bit (25) unaligned,
 10    64 	     2 line_nbr	      fixed bin (35),	/* current line number */
 10    65 	     2 pad_space	      (6) fixed bin (35);	/* save some room to grow */
 10    66 
 10    67      dcl	   ordatap	      ptr;		/* Ptr to above structure */
 10    68 
 10    69      dcl	   1 REQUEST	      like ordata aligned;	/* If wanted, a place to put the above thing */
 10    70 
 10    71 /* END INCLUDE FILE ... output_request_data.incl.pl1 */
     2168 
     2169  /* BEGIN INCLUDE FILE ... print_driver_data.incl.pl1 */
 11     2 
 11     3 
 11     4 dcl  driver_data_p ptr;
 11     5 
 11     6 /* the following structure must not be more than  252 bits (7 words) long, since it is the definition
 11     7*   of the driver data field in the request_descriptor.incl.pl1 */
 11     8 
 11     9 dcl 1 print_driver_data aligned based (driver_data_p),	/* defines driver data of request_descriptor */
 11    10     2 copies_done fixed bin (17) unal,			/* number of copies already printed */
 11    11     2 copies_charged fixed bin (17) unal,		/* number of copies already charged */
 11    12     2 pad fixed bin (35),				/* the only spare room */
 11    13     2 checkpoint,					/* the latest valid print checkpoint */
 11    14       3 comp_no fixed bin (17),			/* MSF component at top of page_no */
 11    15       3 offset fixed bin (24),			/* last character before top of page_no */
 11    16       3 page_no fixed bin (24),			/* next physical page to be printed */
 11    17       3 line_count fixed bin (24),			/* number of lines printed at this point */
 11    18       3 file_offset fixed bin (33);			/* characters from the start of the file */
 11    19 
 11    20 /* END INCLUDE FILE ... print_driver_data.incl.pl1 */
     2169 
     2170  /* BEGIN INCLUDE FILE ... prt_ctl.incl.pl1  */
 12     2 
 12     3 
 12     4 /****^  HISTORY COMMENTS:
 12     5*  1) change(88-02-23,Brunelle), approve(88-08-31,MCR7911),
 12     6*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 12     7*     Ancient History
 12     8*     Modified: 11 December 1981 by G. Palter to add force_ctl_char
 12     9*     Modified: November 1983 by C. Marker to add force_nsep
 12    10*  2) change(88-02-23,Brunelle), approve(88-08-31,MCR7911),
 12    11*     audit(88-09-29,Wallman), install(88-10-28,MR12.2-1199):
 12    12*     Literals for banner type and banner bars type added.
 12    13*                                                   END HISTORY COMMENTS */
 12    14 
 12    15 
 12    16 /* format: style4 */
 12    17 
 12    18 /* This structure is used by the IO Daemon to define the printer control functions */
 12    19 
 12    20 dcl  prt_ctl_ptr ptr;
 12    21 
 12    22 dcl  1 prt_ctl aligned based (prt_ctl_ptr),		/* printer control values */
 12    23        2 flags,
 12    24          3 force_nep bit (1) unal,			/* set noskip for the user */
 12    25          3 force_esc bit (1) unal,			/* set escape processing for the user */
 12    26          3 no_auto_print bit (1) unal,			/* ask for a cmd before each request is printed */
 12    27          3 meter bit (1) unal,			/* meter printer functions */
 12    28          3 force_ctl_char bit (1) unal,			/* set ctl_char mode for the user */
 12    29          3 force_nsep bit (1) unal,			/* supress printing of inner head and tail sheets for multiple copies */
 12    30          3 ctl_pad bit (30) unal,			/* default for future values */
 12    31        2 banner_type fixed bin,			/* 0 = no banners */
 12    32 						/* 1 = normal head/tail sheets */
 12    33 						/* 2 = brief head/tail sheets */
 12    34 						/* 3 to 10 RESERVED	*/
 12    35        2 banner_bars fixed bin,			/* 0 = normal overprinted separator bars */
 12    36 						/* 1 = single print line bars (no overprint) */
 12    37 						/* 2 = suppress the separator bars (no separator) */
 12    38        2 banner_indent fixed bin,			/* how far to indent the banner (future) */
 12    39        2 banner_line fixed bin,			/* what line to start the banner on (future) */
 12    40 
 12    41        2 paper_info,
 12    42          3 phys_page_length fixed bin,
 12    43          3 phys_line_length fixed bin,
 12    44          3 lines_per_inch fixed bin,
 12    45        2 channel_stops (256) bit (16) unal,		/* logical stops for slew to channel */
 12    46        2 prt_ctl_pad (10) fixed bin;			/* for future additions */
 12    47 
 12    48 /* constants for prt_ctl.banner_type */
 12    49 dcl  (NO_BANNERS init (0),
 12    50      NORMAL_BANNERS init (1),
 12    51      BRIEF_BANNERS init (2)) fixed bin int static options (constant);
 12    52 
 12    53 /* constants for prt_ctl.banner_bars */
 12    54 dcl  (NORMAL_BANNER_BARS init (0),
 12    55      SINGLE_BANNER_BARS init (1),
 12    56      NO_BANNER_BARS init (2)) fixed bin int static options (constant);
 12    57 
 12    58 /* END INCLUDE FILE ... prt_ctl.incl.pl1 */
     2170 
     2171  /* Begin include file ...... prt_order_info.incl.pl1 */
 13     2 /*	Created 3/15/77 by Noel I. Morris	*/
 13     3 
 13     4 dcl  orderp ptr;					/* pointer to order info structure */
 13     5 
 13     6 dcl 1 counts based (orderp) aligned,			/* structure used in "get_count"  order */
 13     7     2 line fixed bin,				/* line number */
 13     8     2 page_length fixed bin,				/* length of page */
 13     9     2 lmarg fixed bin,				/* left margin indentation */
 13    10     2 rmarg fixed bin,				/* line length */
 13    11     2 line_count fixed bin,				/* count of lines printed */
 13    12     2 page_count fixed bin;				/* count of pages printed */
 13    13 
 13    14 dcl 1 position_data based (orderp) aligned,		/* structure for "get_position" & "set_position" orders */
 13    15     2 line_number fixed bin (35),			/* current line on the page */
 13    16     2 page_number fixed bin (35),			/* current page number */
 13    17     2 total_lines fixed bin (35),			/* lines printed since reset */
 13    18     2 total_chars fixed bin (35),			/* chars processed since reset */
 13    19     2 pad(4) fixed bin;				/* for the future */
 13    20 
 13    21 dcl 1 page_labels based (orderp) aligned,		/* structure used in "page_labels" order */
 13    22     2 top_label char (136),				/* label for top of page */
 13    23     2 bottom_label char (136);			/* label for bottom of page */
 13    24 
 13    25 dcl  channel_stops (256) bit (16) based (orderp) unal;	/* structure used in "channel_stops" order */
 13    26 
 13    27 dcl 1 paper_info based (orderp) aligned,		/* structure used in "paper_info" order */
 13    28     2 phys_page_length fixed bin,			/* physical page length */
 13    29     2 phys_line_length fixed bin,			/* physical line length */
 13    30     2 lines_per_inch fixed bin;			/* lines per inch spacing */
 13    31 
 13    32 dcl  ret_error_count fixed bin based (orderp);		/* variable used for "get_error_count" order */
 13    33 
 13    34 /* End of include file ...... prt_order_info.incl.pl1 */
     2171 
     2172  /* BEGIN INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
 14     2 
 14     3 /* This is the message header used for standard system queue messages, namely:
 14     4*   IO daemon requests, absentee requests, retrieval requests.
 14     5**/
 14     6 
 14     7 /* Written by Jerry Whitmore, Spring 1978.
 14     8*   Modified by T. Casey, November 1978, to add values for state.
 14     9*   Modified by R. Kovalcik, June 1982, defer_until_process_terminataion
 14    10**/
 14    11 
 14    12 dcl 1 queue_msg_hdr based aligned,			/* standard header for all system queue messages */
 14    13     2 msg_time fixed bin (71),			/* date and time of request */
 14    14     2 hdr_version fixed bin,				/* version of this declaration */
 14    15     2 dirname char (168),				/* directory name */
 14    16     2 ename char (32),				/* entry name of file requested */
 14    17     2 message_type fixed bin,				/* message format descriptor   */
 14    18 						/* 0 = absentee request        */
 14    19 						/* 1 = print request           */
 14    20 						/* 2 = punch request           */
 14    21 						/* 3 = tape request            */
 14    22 						/* 4 = retrieval request       */
 14    23     2 bit_flags,
 14    24       3 delete_sw bit (1) unal,			/* delete file when done */
 14    25       3 notify bit (1) unal,				/* user wants to be notified */
 14    26       3 defer_until_process_termination bit (1) unal,	/* don't process request until process terminates */
 14    27       3 padding bit (33) unal,
 14    28     2 state fixed bin,				/* stage of processing after being queued:
 14    29*						   0 = initial unprocessed state, 1 = deferred,
 14    30*						   2 = in state transition, 3 = eligible, 4 = running,
 14    31*                                                               5 = bumped, 6 = deferred_until_process_termination */
 14    32     2 orig_queue fixed bin,				/* queue the request was submitted to */
 14    33     2 std_length fixed bin,				/* length of std msg for this type */
 14    34     2 dupt_lock bit (36) aligned,			/* lock word for defer until process termination */
 14    35     2 hdr_pad (3) fixed bin;
 14    36 
 14    37 dcl  queue_msg_hdr_version_1 fixed bin int static options (constant) init (1); /* current version of the header */
 14    38 
 14    39 /* Values for queue_msg_hdr.state */
 14    40 
 14    41 dcl  STATE_UNPROCESSED fixed bin int static options (constant) init (0);
 14    42 dcl  STATE_DEFERRED fixed bin int static options (constant) init (1);
 14    43 dcl  STATE_TRANSITION fixed bin int static options (constant) init (2);
 14    44 dcl  STATE_ELIGIBLE fixed bin int static options (constant) init (3);
 14    45 dcl  STATE_RUNNING fixed bin int static options (constant) init (4);
 14    46 dcl  STATE_BUMPED fixed bin int static options (constant) init (5);
 14    47 dcl  STATE_DUPT fixed bin int static options (constant) init (6);
 14    48 
 14    49 /* END INCLUDE FILE ... queue_msg_hdr.incl.pl1 */
     2172 
     2173  /* BEGIN INCLUDE FILE...request_descriptor.incl.pl1 */
 15     2 
 15     3 /* Descriptor associated with an I/O daemon request */
 15     4 /* Coded August 1973 by Robert S. Coren */
 15     5 /* Modified by J. C. Whitmore, 5/78, to extend driver_data to 7 words */
 15     6 /* Modified by C. Marker, 2/23/85, changed to use mseg_message_info */
 15     7 
 15     8 dcl  1 request_descriptor based aligned,
 15     9 	2 mseg_message_info_copy like mseg_message_info,
 15    10 	2 seq_id fixed bin(35),	/* sequential number assigned by coordinator */
 15    11 	2 q fixed bin,		/* priority queue in which request was submitted */
 15    12 	2 contd_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of continued request */
 15    13 	2 prev_seq_id fixed bin(35),	/* if nonzero, this is previous seq_id of restarted request */
 15    14 	2 dev_class_index fixed bin,	/* index of device_class entry */
 15    15 	2 spare_fb fixed bin (17) unal, /* save half a word for later */
 15    16 	2 charge_q fixed bin (17) unal, /* priority to use for charging */
 15    17 	2 time_done fixed bin(71),	/* clock time when request was completed */
 15    18 	2 prev_done fixed bin(18),	/* descriptor threaded ahead of this one in saved list */
 15    19 	2 next_done fixed bin(18),	/*      "        "     behind    "        "       "      */
 15    20 	2 driver_data bit(252),	/* driver maintained data */
 15    21 	2 flags,
 15    22 	   (3 continued,		/* unfinished by one driver and given to another */
 15    23 	    3 finished,
 15    24 	    3 restarted,
 15    25 	    3 cancelled,
 15    26 	    3 dont_delete,
 15    27 	    3 saved,		/* not to be freed */
 15    28 	    3 keep_in_queue,	/* keep request in queue */
 15    29 	    3 series_restart,	/* this request is part of restarted series */
 15    30 	    3 priority_request) bit (1) unal, /* this request was given extra priority */
 15    31 	    3 pad bit(27) unal,
 15    32 	2 next_pending fixed bin(18);	/* thread to next pending descriptor */
 15    33 
 15    34 /* END INCLUDE FILE...request_descriptor.incl.pl1 */
     2173 
     2174  /*  BEGIN  send_mail_info include file */
 16     2 
 16     3 dcl send_mail_info_version_2 fixed bin init(2);
 16     4 
 16     5 dcl 1 send_mail_info aligned,
 16     6      2 version fixed bin,  /* = 2 */
 16     7      2 sent_from char(32) aligned,
 16     8      2 switches,
 16     9       3 wakeup bit(1) unal,
 16    10       3 mbz1 bit(1) unal,
 16    11       3 always_add bit(1) unal,
 16    12       3 never_add bit(1) unal,
 16    13       3 notify bit(1) unal,
 16    14       3 acknowledge bit(1) unal,
 16    15       3 mbz bit(30) unal;
 16    16 
 16    17 /*  END  send_mail_info include file */
     2174 
     2175  /* BEGIN INCLUDE FILE ... system_forms_info.incl.pl1 */
 17     2 
 17     3 /****^  HISTORY COMMENTS:
 17     4*  1) change(88-02-26,Brunelle), approve(88-06-08,MCR7911),
 17     5*     audit(88-10-12,Wallman), install(88-10-28,MR12.2-1199):
 17     6*     Created.
 17     7*                                                   END HISTORY COMMENTS */
 17     8 
 17     9 /* format: style4 */
 17    10 
 17    11 /* input structure for call to iod_info_$evaluate_forms_info */
 17    12 
 17    13 dcl  evaluate_forms_info_input_ptr ptr;
 17    14 dcl  1 evaluate_forms_info_input aligned based (evaluate_forms_info_input_ptr),
 17    15        2 version char (8),
 17    16        2 ithp ptr,					/* ptr to io daemon tables */
 17    17        2 qgtep ptr,					/* request type entry ptr */
 17    18        2 idtep ptr,					/* major device entry ptr */
 17    19        2 mdtep ptr,					/* minor device entry ptr */
 17    20        2 max_forms_string_length fixed bin,		/* max allowed size of forms string */
 17    21        2 forms_string_length fixed bin,			/* # of chars in forms string */
 17    22        2 forms_string char (system_input_forms_string_length/* forms string to evaluate */
 17    23 	  refer (evaluate_forms_info_input.forms_string_length)),
 17    24        2 area_ptr ptr;				/* ptr to user area */
 17    25 dcl  system_input_forms_string_length fixed bin;
 17    26 dcl  EVALUATE_FORMS_INFO_INPUT_VERSION_1 char (8) int static options (constant) init ("EFII0001");
 17    27 
 17    28 
 17    29 /* output structure for call to iod_info_$evaluate_forms_info */
 17    30 
 17    31 dcl  evaluate_forms_info_output_ptr ptr;
 17    32 dcl  1 evaluate_forms_info_output aligned based (evaluate_forms_info_output_ptr),
 17    33        2 version char (8),
 17    34        2 lines_per_page fixed bin,
 17    35        2 chars_per_line fixed bin,
 17    36        2 lines_per_inch fixed bin,
 17    37        2 forms_length fixed bin,
 17    38        2 error_length fixed bin,
 17    39        2 escape_length fixed bin,
 17    40        2 special_length fixed bin,
 17    41        2 returned_forms char (system_returned_forms_length
 17    42 	  refer (evaluate_forms_info_output.forms_length)),
 17    43        2 error_string char (system_error_string_length
 17    44 	  refer (evaluate_forms_info_output.error_length)),
 17    45        2 escape_string char (system_escape_string_length
 17    46 	  refer (evaluate_forms_info_output.escape_length)),
 17    47        2 special_string char (system_special_string_length
 17    48 	  refer (evaluate_forms_info_output.special_length));
 17    49 
 17    50 dcl  (system_returned_forms_length, system_error_string_length,
 17    51      system_escape_string_length, system_special_string_length) fixed bin;
 17    52 
 17    53 dcl  EVALUATE_FORMS_INFO_OUTPUT_VERSION_1 char (8) int static options (constant) init ("EFIO0001");
 17    54 
 17    55 /* END INCLUDE FILE ... system_forms_info.incl.pl1 */
     2175 
     2176 
     2177      end do_prt_request_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    10/01/90  1529.0  do_prt_request_.pl1               >spec>install>1034>do_prt_request_.pl1
2159         1    02/12/85  1529.5  access_audit_user_info.incl.pl1   >ldd>include>access_audit_user_info.incl.pl1
2160         2    01/30/85  1623.9  access_audit_eventflags.incl.pl1  >ldd>include>access_audit_eventflags.incl.pl1
2161         3    11/09/88  0859.7  dprint_msg.incl.pl1               >ldd>include>dprint_msg.incl.pl1
2162         4    11/09/88  0859.7  driver_status.incl.pl1            >ldd>include>driver_status.incl.pl1
2163         5    11/09/88  0859.7  iod_constants.incl.pl1            >ldd>include>iod_constants.incl.pl1
2164         6    11/09/88  0859.7  iod_tables_hdr.incl.pl1           >ldd>include>iod_tables_hdr.incl.pl1
2165         7    11/09/88  0859.7  iodd_static.incl.pl1              >ldd>include>iodd_static.incl.pl1
2166         8    04/29/76  1204.2  kst_attributes.incl.pl1           >ldd>include>kst_attributes.incl.pl1
2167         9    01/10/85  2102.8  mseg_message_info.incl.pl1        >ldd>include>mseg_message_info.incl.pl1
2168        10    11/09/88  0859.7  output_request_data.incl.pl1      >ldd>include>output_request_data.incl.pl1
2169        11    09/28/78  1459.8  print_driver_data.incl.pl1        >ldd>include>print_driver_data.incl.pl1
2170        12    11/09/88  0859.7  prt_ctl.incl.pl1                  >ldd>include>prt_ctl.incl.pl1
2171        13    09/28/78  1459.8  prt_order_info.incl.pl1           >ldd>include>prt_order_info.incl.pl1
2172        14    08/31/82  1736.3  queue_msg_hdr.incl.pl1            >ldd>include>queue_msg_hdr.incl.pl1
2173        15    03/15/85  1053.1  request_descriptor.incl.pl1       >ldd>include>request_descriptor.incl.pl1
2174        16    04/27/78  1604.4  send_mail_info.incl.pl1           >ldd>include>send_mail_info.incl.pl1
2175        17    11/09/88  0859.7  system_forms_info.incl.pl1        >ldd>include>system_forms_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ATTACH_TYPE_IOM                        constant        fixed bin(17,0)          initial dcl 5-15 ref 2024
BAD_CHARS                       000002 constant        char(6)                  initial packed unaligned dcl 180 ref 407 407 408 408
                                                                                  409 409 410 410 795 795 795 795 828 828 828 828
                                                                                  1080 1080 1080 1080 1486 1486 1623 1623 1623 1623
                                                                                  1746 1746 1746 1746 1804 1804 1804 1804 1917 1917
                                                                                  1918 1918 1928 1928 1929 1929 2014 2014 2014 2014
                                                                                  2024 2024 2024 2024 2107 2107 2107 2107 2132 2132
                                                                                  2132 2132
FF                                     defined         char(1)                  packed unaligned dcl 178 set ref 795 795 828 828
                                                                                  1623 1623 1746 1746 1804 1804 2014 2014 2024 2024
                                                                                  2107 2107 2132 2132
NORMAL_BANNERS                         constant        fixed bin(17,0)          initial dcl 12-49 ref 2051
NORMAL_BANNER_BARS                     constant        fixed bin(17,0)          initial dcl 12-54 ref 701 2052
NO_BANNERS                             constant        fixed bin(17,0)          initial dcl 12-49 ref 2107 2107 2132 2132
NO_BANNER_BARS                         constant        fixed bin(17,0)          initial dcl 12-54 ref 2107 2132
PAPER_TYPE_CONTINUOUS                  constant        fixed bin(17,0)          initial dcl 5-26 ref 307
PAPER_TYPE_SINGLE                      constant        fixed bin(17,0)          initial dcl 5-26 ref 371
PRINT                                  constant        fixed bin(17,0)          initial dcl 158 ref 845 1551 1602
REQUEST                         001712 automatic       structure                level 1 dcl 10-69 set ref 342 1163 1163 1955 1955
                                                                                  1983 1983 2028 2028
SAMPLE                                 constant        fixed bin(17,0)          initial dcl 159 set ref 724* 1437 1504
SAVE                                   constant        fixed bin(17,0)          initial dcl 161 ref 559 843 1457 1551 1554 1602
SINGLE_BANNER_BARS                     constant        fixed bin(17,0)          initial dcl 12-54 ref 701
SKIP                            000155 constant        fixed bin(17,0)          initial dcl 160 set ref 1446 1534 1569 1610 1820*
VT                                     defined         char(1)                  packed unaligned dcl 177 set ref 1080* 1080*
a_code                                 parameter       fixed bin(35,0)          dcl 72 set ref 66 296* 1193*
a_iocbp                                parameter       pointer                  dcl 70 ref 66 295
a_page                                 parameter       varying char             dcl 1672 ref 1670 1683 1688 1695
a_pgn                                  parameter       fixed bin(24,0)          dcl 1673 set ref 1670 1684* 1703* 1706* 1709* 1711
                                                                                  1711*
a_stat_p                               parameter       pointer                  dcl 71 ref 66 294
access_audit_gate_$log_obj_ptr_user
                                000276 constant        entry                    external dcl 201 ref 1236
access_class                    000100 automatic       bit(72)                  dcl 76 in procedure "do_prt_request_" set ref 455*
                                                                                  460*
access_class                    002310 automatic       bit(72)                  dcl 1206 in procedure "check_labels" set ref 1242*
                                                                                  1252*
access_class                    002350 automatic       bit(72)                  dcl 1268 in procedure "check_user_access" set ref
                                                                                  1285* 1292*
access_class_string     101     001712 automatic       char(280)                level 2 dcl 10-69 set ref 463* 463
access_operations_$io_daemon_set_page_labels
                                000250 external static bit(36)                  dcl 185 set ref 1236*
acct_entry               60            based           entry variable           level 2 dcl 4-25 set ref 1163*
addr                                                   builtin function         dcl 279 ref 317 317 336 338 340 341 342 622 622 628
                                                                                  628 678 678 795 795 799 799 828 828 901 901 957
                                                                                  957 1082 1082 1124 1124 1150 1150 1163 1163 1236
                                                                                  1236 1439 1439 1479 1479 1492 1506 1506 1525 1525
                                                                                  1612 1612 1623 1623 1649 1649 1746 1746 1804 1804
                                                                                  1808 1808 1849 1849 1955 1955 1983 1983 2014 2014
                                                                                  2024 2024 2028 2028 2033 2033 2033 2033 2098 2098
                                                                                  2107 2107 2126 2126 2132 2132
aim_check_$equal                000300 constant        entry                    external dcl 202 ref 460 1252
aim_check_$greater              000302 constant        entry                    external dcl 203 ref 443
allow_write                     000032 internal static bit(1)                   level 3 packed packed unaligned dcl 250 set ref 322*
always_add               11(02) 002243 automatic       bit(1)                   level 3 packed packed unaligned dcl 16-5 set ref
                                                                                  398*
any_other                       000000 stack reference condition                dcl 286 ref 1107
arg                      23     001502 automatic       varying char(64)         array level 2 dcl 266 set ref 656 656 660* 689* 691*
                                                                                  736 764* 766*
arg_list                        001502 automatic       structure                level 1 dcl 266 set ref 628 628
attach_type             146            based           fixed bin(17,0)          level 2 dcl 7-17 ref 2024
attached                436            based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 327
                                                                                  1954
audit_event_flags                      based           structure                level 1 dcl 2-5
audit_flags              22     002313 automatic       bit(36)                  level 2 dcl 1215 set ref 1231*
audit_user_info                        based           structure                level 1 dcl 1-13
audit_user_info_version_1       000000 constant        char(8)                  initial packed unaligned dcl 1-23 ref 1224
auth                            000102 automatic       bit(72)                  dcl 77 set ref 443* 445* 447* 460*
auth_string                     000104 automatic       char(680)                packed unaligned dcl 78 set ref 447* 453 460* 463
authorization            14     002313 automatic       bit(72)                  level 2 dcl 1215 set ref 1228* 1246* 1252*
authorization_range      16     002313 automatic       bit(72)                  array level 2 dcl 1215 set ref 1229* 1230*
bad_chars                              defined         char(5)                  packed unaligned dcl 174 ref 407 408 409 410
banner_bars               2            based           fixed bin(17,0)          level 2 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_" ref 701 701 2107
                                                                                  2132
banner_bars               2     000035 internal static fixed bin(17,0)          level 2 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_" set ref 2052*
banner_indent             3     000035 internal static fixed bin(17,0)          level 2 dcl 264 set ref 2053*
banner_line               4     000035 internal static fixed bin(17,0)          level 2 dcl 264 set ref 2054*
banner_type               1            based           fixed bin(17,0)          level 2 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_" ref 2107 2107 2132
                                                                                  2132
banner_type               1     000035 internal static fixed bin(17,0)          level 2 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_" set ref 2051*
baseno                                                 builtin function         dcl 279 ref 317 317 1479 1479
bc                              002456 automatic       fixed bin(24,0)          dcl 1415 in procedure "output_file" set ref 1473*
                                                                                  1482
bc                              002444 automatic       fixed bin(24,0)          dcl 1320 in procedure "open_file" set ref 1328* 1334
                                                                                  1339 1350* 1376 1382 1384
binary                                                 builtin function         dcl 279 ref 317 317 1479 1479
bit                                                    builtin function         dcl 279 ref 1279 1391
bit_count               302     001712 automatic       fixed bin(24,0)          level 2 dcl 10-69 set ref 372* 1382* 1382
bit_flags                66            based           structure                level 3 dcl 3-20
bit_rate_est            132            based           fixed bin(35,0)          level 2 dcl 4-25 set ref 509 512 908 917*
both                            000147 constant        fixed bin(17,0)          initial dcl 151 set ref 432* 523* 546* 946* 1053*
                                                                                  1077* 1188* 1463* 1507* 1516* 1590* 1613*
bottom_label                           based           char                     level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "do_prt_request_" ref 1220 1928
bottom_label             42     001373 automatic       char(136)                level 2 in structure "pg_labels" dcl 261
                                                                                  in procedure "do_prt_request_" set ref 1913* 1934*
                                                                                  1936*
bottom_label_lth        110            based           fixed bin(17,0)          level 2 dcl 3-20 ref 1220 1928
center_bottom_label     102(06)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1932
center_top_label        102(05)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1921
channel                   2     000242 internal static fixed bin(71,0)          level 2 dcl 272 set ref 329* 1965* 1967* 1974*
channel_stops            10     000035 internal static bit(16)                  array level 2 packed packed unaligned dcl 264 set
                                                                                  ref 2060*
char                                                   builtin function         dcl 279 ref 463 1330 1455
char_count                      000356 automatic       fixed bin(24,0)          dcl 79 in procedure "do_prt_request_" set ref 475*
                                                                                  511 666* 909
char_count                             parameter       fixed bin(24,0)          dcl 1312 in procedure "open_file" set ref 1306 1326*
                                                                                  1384* 1384
char_pos                               based           char(1)                  array packed unaligned dcl 1425 set ref 1492
charge                  303     001712 automatic       float bin(27)            level 2 dcl 10-69 set ref 389* 593* 1166* 1172* 1174
charge_q                 37(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 15-8 ref 362
charge_queue            311     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 362* 432*
chars_done                      000357 automatic       fixed bin(24,0)          dcl 80 set ref 511* 512 909* 913
chars_per_line            3            based           fixed bin(17,0)          level 2 dcl 17-32 ref 1847
checkpoint                2            based           structure                level 2 dcl 11-9 set ref 489 1551*
chgsw                           000360 automatic       bit(1)                   packed unaligned dcl 81 set ref 297* 890* 893* 894*
                                                                                  989* 992* 999* 1020* 1161
ck                              001266 automatic       structure                level 1 dcl 254
ck_interval                     000361 automatic       fixed bin(17,0)          dcl 82 set ref 483* 484 1449 1562 1584
ck_mode                         000362 automatic       char(12)                 dcl 83 set ref 485* 1438 1453 1457 1459 1513
cleanup                         001610 stack reference condition                dcl 286 ref 347
clock_                          000304 constant        entry                    external dcl 204 ref 390 594 851 1144
cmd                       2     001502 automatic       varying char(64)         level 2 dcl 266 set ref 636 648 655 655 687 734 749
                                                                                  753
cmd_line                        000365 automatic       char(80)                 packed unaligned dcl 84 set ref 622 622 628 628 632*
                                                                                  751 751
code                                   parameter       fixed bin(35,0)          dcl 1997 in procedure "print_tail_banner" set ref
                                                                                  1995 2008* 2014* 2018* 2021* 2024* 2027* 2028*
code                                   parameter       fixed bin(35,0)          dcl 1313 in procedure "open_file" set ref 1306 1328*
                                                                                  1329 1336* 1342* 1343 1350* 1351 1362* 1363 1368*
                                                                                  1369 1377* 1386* 1387 1393*
code                                   parameter       fixed bin(35,0)          dcl 1207 in procedure "check_labels" set ref 1201
                                                                                  1218* 1242* 1243 1246* 1247 1248*
code                            002346 automatic       fixed bin(35,0)          dcl 1265 in procedure "check_user_access" set ref
                                                                                  1270* 1271 1272 1275 1285* 1286 1288
code                            002504 automatic       fixed bin(35,0)          dcl 1422 in procedure "output_file" set ref 1439*
                                                                                  1440 1442 1461* 1462* 1463 1463* 1494* 1496 1497
                                                                                  1498 1506* 1507 1507* 1515* 1516 1516* 1519* 1525*
                                                                                  1526 1527 1589* 1590 1590* 1612* 1613 1613* 1623*
code                                   parameter       fixed bin(35,0)          dcl 1065 in procedure "error_write" set ref 1063
                                                                                  1069 1069* 1081* 1082* 1083*
code                            002660 automatic       fixed bin(35,0)          dcl 1731 in procedure "skip_to_page" set ref 1738*
                                                                                  1739 1740 1746* 1747 1748 1752* 1801* 1802* 1804*
                                                                                  1806* 1808* 1809 1810 1823* 1824*
code                                   parameter       fixed bin(35,0)          dcl 1948 in procedure "print_head_banner" set ref
                                                                                  1946 1952* 1979* 1980* 1983* 1984 1988*
code                                   parameter       fixed bin(35,0)          dcl 1185 in procedure "driver_fatal_error" set ref
                                                                                  1182 1188* 1193
code                            000411 automatic       fixed bin(35,0)          dcl 85 in procedure "do_prt_request_" set ref 447*
                                                                                  448 455* 456 469* 470 475* 476 538* 539 560* 580*
                                                                                  601* 602 602* 622* 623 624* 628* 629 630 676* 678*
                                                                                  689* 690 703* 704* 705* 718* 719 720* 724* 725
                                                                                  726* 751* 752 752 753 764* 765 772* 773 774* 795*
                                                                                  799* 800 805* 810* 811 812* 828* 837* 838 839*
                                                                                  848* 865* 876 877 878* 886* 901* 902 925* 926 927*
                                                                                  944* 957* 958 972* 1011* 1022* 1048* 1150* 1849*
                                                                                  1850 1851* 1856* 1859* 2096* 2097* 2098* 2100*
                                                                                  2101* 2107* 2113* 2114* 2115 2116* 2122* 2126*
                                                                                  2127 2128* 2132*
code                            002534 automatic       fixed bin(35,0)          dcl 1642 in procedure "restart_request" set ref
                                                                                  1647* 1649* 1650
comp_dir                        002360 automatic       char(168)                dcl 1315 set ref 1362* 1368* 1370 1378
comp_name                       002432 automatic       char(32)                 dcl 1316 set ref 1362* 1368* 1370 1378
comp_no                   2     001266 automatic       fixed bin(17,0)          array level 4 in structure "ck" dcl 254 in procedure
                                                                                  "do_prt_request_" set ref 1794
comp_no                         002510 automatic       fixed bin(17,0)          level 2 in structure "temp" dcl 1428 in procedure
                                                                                  "output_file" set ref 1473* 1485 1535 1602 1627*
                                                                                  1627
comp_no                         001261 automatic       fixed bin(17,0)          level 2 in structure "current" dcl 252 in procedure
                                                                                  "do_prt_request_" set ref 494* 673* 1778* 1794*
cond                                   parameter       char                     packed unaligned dcl 2146 ref 2144 2148
contd_no                305     001712 automatic       fixed bin(35,0)          level 2 dcl 10-69 set ref 365* 592*
contd_seq_id             34            based           fixed bin(35,0)          level 2 dcl 15-8 ref 365
continue_to_signal_             000306 constant        entry                    external dcl 205 ref 1114
continued               304     001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 355* 378 381* 489 589*
continued                53            based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 15-8 in procedure
                                                                                  "do_prt_request_" ref 355
continuous_paper                000412 automatic       bit(1)                   packed unaligned dcl 86 set ref 307* 701 701 708 794
                                                                                  805 825 1745 1844 2011 2024 2093
control                 102            based           structure                level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "do_prt_request_"
control                         000413 automatic       bit(36)                  dcl 87 in procedure "do_prt_request_" set ref 575*
                                                                                  596* 622*
control_flags           304     001712 automatic       structure                level 2 dcl 10-69 set ref 353*
conversion                      001676 stack reference condition                dcl 286 ref 609 1694
convert                                                builtin function         dcl 279 ref 736 1695
convert_authorization_$from_string
                                000310 constant        entry                    external dcl 206 ref 455 1246
convert_authorization_$to_string
                                000312 constant        entry                    external dcl 207 ref 447
convert_ipc_code_               000314 constant        entry                    external dcl 208 ref 1971 2035
convert_status_code_            000316 constant        entry                    external dcl 209 ref 1069 1851 2116
copies                   65            based           fixed bin(17,0)          level 2 in structure "ordata" dcl 10-17 in procedure
                                                                                  "do_prt_request_" set ref 2156*
copies                   77            based           fixed bin(17,0)          level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "do_prt_request_" ref 376
copies                   65     001712 automatic       fixed bin(17,0)          level 2 in structure "REQUEST" dcl 10-69
                                                                                  in procedure "do_prt_request_" set ref 376* 383
                                                                                  384 546* 737 738* 808 888 1605 1658 1660* 2028
copies_charged            0(18)        based           fixed bin(17,0)          level 2 packed packed unaligned dcl 11-9 set ref 888
                                                                                  891* 891
copies_done                            based           fixed bin(17,0)          level 2 packed packed unaligned dcl 11-9 set ref
                                                                                  378* 381 383* 383 384 385 935* 935 1658
copies_left                     000414 automatic       fixed bin(17,0)          dcl 88 set ref 384* 432 432* 511 946
copy_no                  66     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 385* 546 546* 599 670*
                                                                                  742* 808 936* 936 1605 1658* 1660* 1982 2028 2107
                                                                                  2132
cpu_time                274     001712 automatic       fixed bin(71,0)          level 2 dcl 10-69 set ref 785* 1156*
cpu_time_and_paging_            000320 constant        entry                    external dcl 210 ref 850 1145
ctl_ev_chan             420            based           fixed bin(71,0)          level 3 dcl 7-17 ref 329
ctl_msg_sent                    000415 automatic       bit(1)                   packed unaligned dcl 89 set ref 1961* 1963* 1964
                                                                                  1970* 1977* 2031
ctl_output              370            based           char(32)                 level 3 dcl 7-17 set ref 1955*
ctl_term                344            based           structure                level 2 dcl 7-17
ctl_wait_list                   000242 internal static structure                level 1 dcl 272 set ref 2033 2033
cu_$level_get                   000322 constant        entry                    external dcl 211 ref 1221
current                         001261 automatic       structure                level 1 dcl 252 set ref 489* 502 1435 1550* 1551
                                                                                  1565 1782
daemon_again                    001624 stack reference condition                dcl 286 ref 563
daemon_again_slave              001632 stack reference condition                dcl 286 ref 568
daemon_cancel                   001654 stack reference condition                dcl 286 ref 553
daemon_defer                    001646 stack reference condition                dcl 286 ref 554
daemon_kill                     001640 stack reference condition                dcl 286 ref 552
daemon_save                     001662 stack reference condition                dcl 286 ref 555
date_time_                      000324 constant        entry                    external dcl 212 ref 391 595
date_time_start_request
                        264     001712 automatic       char(24)                 level 2 dcl 10-69 set ref 391* 595*
defer_time_limit        133            based           fixed bin(35,0)          level 2 dcl 4-25 ref 514 514
delete                  210     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 367* 369* 960 1003
delete_msg                      000416 automatic       char(32)                 packed unaligned dcl 90 set ref 1000* 1003* 1006*
                                                                                  1009*
delete_sw                66            based           bit(1)                   level 4 packed packed unaligned dcl 3-20 ref 367
desc_ptr                        000426 automatic       pointer                  dcl 91 set ref 338* 339 341 355 356 357 361 362 363
                                                                                  364 365 522 843 877 888 931 958 961 969 1055 1190
                                                                                  1191
descriptor              146            based           structure                level 2 dcl 4-25 set ref 338
dest                            000430 automatic       char(24)                 dcl 92 set ref 425* 426 426*
destination             130            based           char(24)                 level 2 dcl 3-20 set ref 409* 409 425
dev_ctl_ptr             130            based           pointer                  level 2 dcl 4-25 ref 335
dev_name_label           10            based           char(32)                 level 2 dcl 4-25 ref 359
dev_out_stream           72            based           char(32)                 level 2 dcl 4-25 ref 345
device_error                    000436 automatic       bit(1)                   packed unaligned dcl 93 set ref 898* 902* 904* 907
device_name             211     001712 automatic       char(32)                 level 2 dcl 10-69 set ref 359* 950*
dir                                    constant        fixed bin(17,0)          initial dcl 1318 ref 1334
dir_len                         002443 automatic       fixed bin(17,0)          dcl 1319 set ref 1352* 1362* 1370 1378
dirname                   3            based           char(168)                level 3 dcl 3-20 ref 403
divide                                                 builtin function         dcl 279 ref 512 910 913 1384 1482 1922 1922 1933
                                                                                  1933 2012
dmp                             001704 automatic       pointer                  dcl 3-18 set ref 340* 366 367 370 376 377 386 403
                                                                                  404 409 409 410 410 415 425 1220 1220 1246 1246
                                                                                  1864 1865 1872 1873 1885 1891 1893 1895 1897 1898
                                                                                  1902 1904 1917 1921 1928 1932
dont_delete              53(04)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref 958
                                                                                  961* 1055* 1190*
dpmp                            001712 automatic       pointer                  level 2 dcl 10-69 set ref 366*
dprint_msg                             based           structure                level 1 dcl 3-20
driver_data              44            based           bit(252)                 level 2 dcl 15-8 set ref 341
driver_data_p                   002236 automatic       pointer                  dcl 11-4 set ref 341* 378 381 383 383 384 385 489
                                                                                  489 882 888 891 891 935 935 1551 1658
driver_ptr              304            based           pointer                  level 2 dcl 7-17 ref 333
driver_status                          based           structure                level 1 dcl 4-25
driver_status_ptr               001706 automatic       pointer                  dcl 4-24 set ref 333* 334 335 338 340 345 359 360
                                                                                  443 445 509 512 514 514 908 917 1162 1163 1974
ec                                     parameter       fixed bin(35,0)          dcl 1266 in procedure "check_user_access" set ref
                                                                                  1258 1275* 1281* 1288* 1293* 1298*
ec                              003062 automatic       fixed bin(35,0)          dcl 1998 in procedure "print_tail_banner" set ref
                                                                                  2033* 2034 2035* 2036*
ec                              003052 automatic       fixed bin(35,0)          dcl 1949 in procedure "print_head_banner" set ref
                                                                                  1955* 1956 1957 1958* 1965* 1966 1971* 1972*
ec                                     parameter       fixed bin(35,0)          dcl 1674 in procedure "get_page_no" set ref 1670
                                                                                  1681* 1698*
ec                              000102 automatic       fixed bin(35,0)          dcl 1094 in procedure "notify_user" set ref 1114*
                                                                                  1124*
ec                                     parameter       fixed bin(35,0)          dcl 1413 in procedure "output_file" set ref 1409
                                                                                  1433* 1442* 1473* 1498* 1527* 1537* 1557* 1576*
                                                                                  1611*
ec                                     parameter       fixed bin(35,0)          dcl 1723 in procedure "skip_to_page" set ref 1720
                                                                                  1734* 1740* 1748* 1810* 1820*
ename                                  parameter       char                     dcl 1309 in procedure "open_file" set ref 1306 1328*
                                                                                  1342*
ename                                  parameter       char                     dcl 1208 in procedure "check_labels" set ref 1201
                                                                                  1242*
ename                           000437 automatic       char(32)                 dcl 94 in procedure "do_prt_request_" set ref 404*
                                                                                  405* 469* 475* 538*
ename                    55            based           char(32)                 level 3 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "do_prt_request_" ref 404
ename                                  parameter       char                     dcl 1264 in procedure "check_user_access" set ref
                                                                                  1258 1270* 1285*
ending_page                            parameter       fixed bin(24,0)          dcl 1412 set ref 1409 1448 1571 1574 1577* 1582
entry                     1     001266 automatic       structure                array level 2 dcl 254 set ref 501 505 1765
err_label                       000026 internal static label variable           dcl 172 set ref 349* 2149
err_mess                        000447 automatic       varying char(200)        dcl 95 set ref 439* 597* 720* 726* 774* 790* 878
                                                                                  921* 922* 1009* 1018* 1048* 1188* 1272* 1274*
                                                                                  1280* 1287* 1294* 1330* 1330 1344* 1352* 1364*
                                                                                  1370* 1370 1378* 1388* 1392* 1441* 1475* 1499*
                                                                                  1528* 1538* 1577* 1615* 1617* 1741* 1749* 1811*
err_msg                                parameter       char                     packed unaligned dcl 1186 set ref 1182 1188*
error                           000157 constant        fixed bin(17,0)          initial dcl 153 set ref 602* 720* 726* 774* 1188*
                                                                                  1463* 1507* 1516* 1590* 1613* 1958* 1972* 2036*
error_length              6            based           fixed bin(17,0)          level 2 dcl 17-32 ref 858 869 2098 2098
error_table_$action_not_performed
                                000252 external static fixed bin(35,0)          dcl 186 ref 1957
error_table_$ai_restricted      000254 external static fixed bin(35,0)          dcl 187 ref 1293
error_table_$dirseg             000256 external static fixed bin(35,0)          dcl 188 ref 1336
error_table_$eof_record         000260 external static fixed bin(35,0)          dcl 189 ref 1537 1611
error_table_$improper_data_format
                                000262 external static fixed bin(35,0)          dcl 190 ref 1377
error_table_$moderr             000264 external static fixed bin(35,0)          dcl 191 ref 1281 1393
error_table_$noarg              000266 external static fixed bin(35,0)          dcl 192 ref 630
error_table_$noentry            000270 external static fixed bin(35,0)          dcl 193 ref 1272
error_table_$out_of_bounds      000272 external static fixed bin(35,0)          dcl 194 ref 1576
error_table_$request_pending    000274 external static fixed bin(35,0)          dcl 195 ref 877 1497 1557
esc                     102(04)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1902
escape_length             7            based           fixed bin(17,0)          level 2 dcl 17-32 ref 858 869 2095 2098 2098 2098
escape_string                          based           char                     level 2 dcl 17-32 set ref 2098 2098
evaluate_forms_info_output             based           structure                level 1 dcl 17-32
evaluate_forms_info_output_ptr  002256 automatic       pointer                  dcl 17-31 set ref 334* 856 857 858 867 868 869 1845
                                                                                  1846 1847 1848 2094 2095 2098 2098 2098
event_info                      003064 automatic       structure                level 1 dcl 2001 set ref 2033 2033
explicit_deactivate_ok
                          0(05) 000032 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 250 in procedure "do_prt_request_" set ref
                                                                                  321*
explicit_deactivate_ok
                          1(14) 000032 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 250 in procedure "do_prt_request_" set ref
                                                                                  321*
factor                                 constant        float bin(27)            initial dcl 163 ref 914 914
fault_name                      000013 internal static char(32)                 dcl 169 set ref 995 997 2148*
fcbp                                   parameter       pointer                  dcl 1310 in procedure "open_file" set ref 1306 1342*
                                                                                  1350*
fcbp                            000532 automatic       pointer                  dcl 96 in procedure "do_prt_request_" set ref 343*
                                                                                  475* 1473* 2071 2075* 2078*
file_offset               4     001261 automatic       fixed bin(33,0)          level 2 in structure "current" dcl 252 in procedure
                                                                                  "do_prt_request_" set ref 496* 511 673* 846 1780*
                                                                                  1796*
file_offset               6     001266 automatic       fixed bin(33,0)          array level 4 in structure "ck" dcl 254 in procedure
                                                                                  "do_prt_request_" set ref 1796
file_offset               4     002510 automatic       fixed bin(33,0)          level 2 in structure "temp" dcl 1428 in procedure
                                                                                  "output_file" set ref 1532 1548* 1600* 1600
finished                 53(01)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  969*
first_call                      000012 internal static bit(1)                   initial packed unaligned dcl 168 set ref 309 325*
fixed                                                  builtin function         dcl 279 ref 914 1158 1159
flags                                  based           structure                level 2 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_"
flags                           000035 internal static structure                level 2 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_" set ref 2049*
flags                   310            based           structure                level 2 in structure "iodd_static" dcl 7-17
                                                                                  in procedure "do_prt_request_"
flags                    53            based           structure                level 2 in structure "request_descriptor" dcl 15-8
                                                                                  in procedure "do_prt_request_"
float                                                  builtin function         dcl 279 ref 523 525 533
force_ck_pt                     000534 automatic       bit(1)                   dcl 97 set ref 577* 712* 750* 834* 1536* 1575* 1619*
                                                                                  1754* 1758 1788 1815*
force_ctl_char            0(04)        based           bit(1)                   level 3 packed packed unaligned dcl 12-22 ref 1906
force_esc                 0(01)        based           bit(1)                   level 3 packed packed unaligned dcl 12-22 ref 1902
force_nep                              based           bit(1)                   level 3 packed packed unaligned dcl 12-22 ref 1885
force_nsep                0(05)        based           bit(1)                   level 3 packed packed unaligned dcl 12-22 ref 377
form_type               432            based           char(16)                 level 3 dcl 7-17 set ref 1955*
form_wait_time          114            based           fixed bin(71,0)          level 2 dcl 4-25 set ref 1974*
forms_length              5            based           fixed bin(17,0)          level 2 dcl 17-32 ref 858 869 2098 2098
forms_validation_ptr    116            based           pointer                  level 2 dcl 4-25 ref 334
forward                   1     001266 automatic       fixed bin(17,0)          array level 3 dcl 254 set ref 503* 505* 1564 1781
full_path                12     001712 automatic       char(168)                level 2 in structure "REQUEST" dcl 10-69
                                                                                  in procedure "do_prt_request_" set ref 407* 411*
                                                                                  525* 950* 962* 1072*
full_path                       000535 automatic       char(168)                dcl 98 in procedure "do_prt_request_" set ref 405*
                                                                                  407 408* 408 411 432* 439 666* 1330 1344
grant                     0(01) 002336 automatic       bit(1)                   level 2 packed packed unaligned dcl 1216 set ref
                                                                                  1234*
have_accounting          47(04)        based           bit(1)                   level 3 packed packed unaligned dcl 4-25 ref 1162
hbound                                                 builtin function         dcl 279 ref 501 505 1765
hcs_$fs_get_mode                000326 constant        entry                    external dcl 213 ref 1386
hcs_$fs_get_path_name           000330 constant        entry                    external dcl 214 ref 1362
hcs_$get_access_class           000332 constant        entry                    external dcl 215 ref 1242 1285
hcs_$get_user_effmode           000334 constant        entry                    external dcl 216 ref 1270
hcs_$status_minf                000336 constant        entry                    external dcl 217 ref 1328
head                            000607 automatic       char(64)                 dcl 99 set ref 415* 416 416* 416 418 418*
header                                 based           structure                level 2 dcl 3-20
header_done                     000627 automatic       bit(1)                   packed unaligned dcl 100 set ref 298* 937* 1042 1045
                                                                                  1050 1079 1984*
heading                 136            based           char                     level 2 dcl 3-20 set ref 410* 410 415
heading_lth             106            based           fixed bin(17,0)          level 2 dcl 3-20 ref 410 410 415 1220 1220 1246 1246
                                                                                  1917 1928
high_page                       002655 automatic       fixed bin(24,0)          dcl 1728 set ref 1762* 1768 1769* 1788
how                             000630 automatic       fixed bin(17,0)          dcl 101 in procedure "do_prt_request_" set ref 559*
                                                                                  843* 845* 865*
how                                    parameter       fixed bin(17,0)          dcl 1411 in procedure "output_file" ref 1409 1437
                                                                                  1446 1457 1504 1534 1551 1551 1554 1569 1602 1602
                                                                                  1610
i                               002653 automatic       fixed bin(17,0)          dcl 1726 in procedure "skip_to_page" set ref 1765*
                                                                                  1767 1770*
i                               000631 automatic       fixed bin(17,0)          dcl 102 in procedure "do_prt_request_" set ref 501*
                                                                                  502 503 503* 736* 736 737 737 742 826* 827 901 901
                                                                                  902 957 957 958
i                               002771 automatic       fixed bin(17,0)          dcl 1835 in procedure "set_modes_and_labels" set ref
                                                                                  1880* 1882 1882 1908* 1910 1910
i                               002643 automatic       fixed bin(17,0)          dcl 1645 in procedure "restart_request" set ref
                                                                                  1656* 1660*
ind                             002777 automatic       fixed bin(17,0)          dcl 1838 in procedure "set_modes_and_labels" set ref
                                                                                  1873* 1874 1878* 1922 1922 1933 1933
ind                             002656 automatic       fixed bin(17,0)          dcl 1729 in procedure "skip_to_page" set ref 1763*
                                                                                  1770* 1774 1792 1793 1794 1795 1796 1797
io_daemon_account_              000340 constant        entry                    external dcl 218 ref 1163
ioa_$rsnnl                      000342 constant        entry                    external dcl 219 ref 405 418 426 525 921 950 962
                                                                                  1009 1072 1080 1352 1538 1577 1615 1617 1656 1660
                                                                                  1852 2117
iocbp                           000632 automatic       pointer                  dcl 103 set ref 295* 560* 580* 676* 678* 703* 704*
                                                                                  705* 795* 799* 805* 828* 848* 859* 860* 870* 871*
                                                                                  886* 901* 944* 957* 972* 1081* 1082* 1083* 1150*
                                                                                  1439* 1461* 1462* 1494* 1506* 1515* 1519* 1525*
                                                                                  1589* 1612* 1623* 1647* 1649* 1738* 1746* 1752*
                                                                                  1801* 1802* 1804* 1806* 1808* 1823* 1824* 1849*
                                                                                  1859* 1979* 1980* 1983* 1988* 2014* 2018* 2021*
                                                                                  2024* 2027* 2028* 2096* 2097* 2098* 2100* 2101*
                                                                                  2107* 2113* 2114* 2126* 2132*
iodd_command_processor_         000344 constant        entry                    external dcl 220 ref 751
iodd_get_cmd_                   000346 constant        entry                    external dcl 221 ref 622
iodd_msg_                       000350 constant        entry                    external dcl 222 ref 432 523 533 546 602 612 618 632
                                                                                  637 638 639 640 642 643 644 650 660 666 668 670
                                                                                  673 677 679 682 691 720 726 738 745 755 766 774
                                                                                  781 946 1053 1077 1188 1463 1507 1516 1590 1613
                                                                                  1662 1958 1972 2036
iodd_parse_$args                000352 constant        entry                    external dcl 223 ref 858 869
iodd_parse_$command             000354 constant        entry                    external dcl 224 ref 628
iodd_static                            based           structure                level 1 dcl 7-17
iox_$control                    000356 constant        entry                    external dcl 225 ref 580 678 703 705 799 805 848 859
                                                                                  870 886 901 944 957 972 1150 1439 1461 1506 1519
                                                                                  1525 1612 1647 1649 1752 1801 1808 1823 1849 1859
                                                                                  1979 1980 1988 2018 2021 2027 2097 2100 2113 2126
iox_$modes                      000360 constant        entry                    external dcl 226 ref 560 676 860 871 1081 1083 1462
                                                                                  1515 1589 1738 1802 1806 1824 2096 2101 2114
iox_$put_chars                  000362 constant        entry                    external dcl 227 ref 795 828 1082 1494 1623 1746
                                                                                  1804 2014 2024 2098 2107 2132
ipc_$block                      000364 constant        entry                    external dcl 228 ref 2033
ipc_$drain_chn                  000366 constant        entry                    external dcl 229 ref 1965
ipc_ind                         000100 automatic       fixed bin(35,0)          dcl 1094 set ref 1096* 1111 1111* 1113* 1119* 1131
                                                                                  1131*
keep_in_queue            53(06)        based           bit(1)                   level 3 packed packed unaligned dcl 15-8 set ref
                                                                                  522* 1191*
kst_attributes                         based           structure                level 1 dcl 8-5
ksta                            000032 internal static structure                level 1 dcl 250 set ref 316* 317 317 1479 1479
l                               000634 automatic       fixed bin(24,0)          dcl 104 set ref 393* 394 405* 418* 421* 426* 426 426
                                                                                  426 428 430 453* 454 525* 527 527 921* 950* 952
                                                                                  952 962* 964 964 1009* 1072* 1074 1074 1080* 1082*
                                                                                  1538* 1577* 1615* 1617* 1852* 1853 1853 2117* 2119
                                                                                  2119
last                            001266 automatic       fixed bin(17,0)          level 2 dcl 254 set ref 300* 1562 1564 1566* 1781
                                                                                  1783* 1797*
last_error_count                000635 automatic       fixed bin(17,0)          dcl 105 set ref 305* 799 799 800* 898 902 955 958
len                             003042 automatic       fixed bin(17,0)          dcl 1840 set ref 1920* 1921 1922* 1922 1923 1931*
                                                                                  1932 1933* 1933 1934
length                                                 builtin function         dcl 279 ref 393 453 463 1330 1455 1486 1880 1908
                                                                                  1920 1931
level                           002312 automatic       fixed bin(17,0)          dcl 1209 set ref 1221* 1236*
lg_msg                          000636 automatic       char(100)                dcl 106 set ref 1068* 1069* 1072* 1077* 1080* 1851*
                                                                                  1852* 2116* 2117*
lg_sw                           000667 automatic       bit(1)                   dcl 107 set ref 656* 664* 668 672
line_count                3     001261 automatic       fixed bin(24,0)          level 2 in structure "current" dcl 252 in procedure
                                                                                  "do_prt_request_" set ref 493* 673* 1777* 1793*
line_count                5     001266 automatic       fixed bin(24,0)          array level 4 in structure "ck" dcl 254 in procedure
                                                                                  "do_prt_request_" set ref 1793
line_count                3     002510 automatic       fixed bin(24,0)          level 2 in structure "temp" dcl 1428 in procedure
                                                                                  "output_file" set ref 1546*
line_count              272     001712 automatic       fixed bin(24,0)          level 2 in structure "REQUEST" dcl 10-69
                                                                                  in procedure "do_prt_request_" set ref 373* 946*
                                                                                  1152*
line_lth                104            based           fixed bin(17,0)          level 2 dcl 3-20 ref 1864 1865
line_mode                       000670 automatic       char(32)                 packed unaligned dcl 108 set ref 1881* 1882* 2114*
                                                                                  2117*
line_nbrs               102(08)        based           bit(1)                   level 3 in structure "dprint_msg" packed packed
                                                                                  unaligned dcl 3-20 in procedure "do_prt_request_"
                                                                                  ref 370 1904
line_nbrs               304(07) 001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 370*
line_number                     001363 automatic       fixed bin(35,0)          level 2 dcl 260 set ref 679* 1147* 1153 1615 1617*
                                                                                  2012
lines_per_inch            4            based           fixed bin(17,0)          level 2 in structure "evaluate_forms_info_output"
                                                                                  dcl 17-32 in procedure "do_prt_request_" ref 1848
lines_per_inch            2     001477 automatic       fixed bin(17,0)          level 2 in structure "paper_info_data" dcl 262
                                                                                  in procedure "do_prt_request_" set ref 1848*
lines_per_inch            7     000035 internal static fixed bin(17,0)          level 3 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_" set ref 2058*
lines_per_inch            7            based           fixed bin(17,0)          level 3 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_" ref 2012
lines_per_page            2            based           fixed bin(17,0)          level 2 dcl 17-32 ref 1846
linkage_error                   001616 stack reference condition                dcl 286 ref 311 324 1101 1121
ll                              002776 automatic       fixed bin(17,0)          dcl 1837 set ref 1865* 1866 1870* 1921 1922 1932
                                                                                  1933
lmargin                 103            based           fixed bin(17,0)          level 2 dcl 3-20 ref 1872 1873
local_audit_eventflags          002336 automatic       structure                level 1 dcl 1216 set ref 1233* 1236 1236
local_audit_user_info           002313 automatic       structure                level 1 dcl 1215 set ref 1223* 1236 1236
log                             000147 constant        fixed bin(17,0)          initial dcl 151 set ref 432* 523* 533* 546* 946*
                                                                                  1053* 1077*
ltrim                                                  builtin function         dcl 279 ref 485 1451 1587 1867 1875 1899
mailname                        000700 automatic       char(32)                 dcl 109 set ref 394* 1124*
master                          000160 constant        fixed bin(17,0)          initial dcl 149 set ref 303 565 648 778 1958* 1972*
                                                                                  2036*
master_hold             310(06)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  778* 780
max_comp                               parameter       fixed bin(17,0)          dcl 1311 in procedure "open_file" set ref 1306 1339*
                                                                                  1340* 1348
max_comp                        000710 automatic       fixed bin(17,0)          dcl 110 in procedure "do_prt_request_" set ref 475*
                                                                                  666 1485 1535 1602 1605
max_el                          002457 automatic       fixed bin(24,0)          dcl 1416 set ref 1482* 1486* 1486 1489
max_tokens                      001502 automatic       fixed bin(17,0)          level 2 dcl 266 set ref 301*
message                 240            based           fixed bin(17,0)          level 2 in structure "driver_status" dcl 4-25
                                                                                  in procedure "do_prt_request_" set ref 340
message                                parameter       char                     dcl 1093 in procedure "notify_user" set ref 1091
                                                                                  1124*
message                                parameter       varying char             dcl 1066 in procedure "error_write" set ref 1063
                                                                                  1072* 1077* 1080*
min                                                    builtin function         dcl 279 ref 383 1658 1865
min_banner               55            based           bit(72)                  level 2 dcl 4-25 set ref 443* 445
mod                                                    builtin function         dcl 279 ref 795 826 1555 2009
mode                            002347 automatic       fixed bin(5,0)           dcl 1267 in procedure "check_user_access" set ref
                                                                                  1270* 1279
mode                            002445 automatic       fixed bin(5,0)           dcl 1321 in procedure "open_file" set ref 1386* 1391
modes                           002460 automatic       char(64)                 packed unaligned dcl 1417 set ref 1438* 1451* 1453*
                                                                                  1455* 1455 1455 1457* 1459* 1462* 1463* 1513*
                                                                                  1515* 1516* 1587* 1589* 1590*
mseg_message_info                      based           structure                level 1 dcl 9-9
mseg_message_info_ptr           001710 automatic       pointer                  dcl 9-7 set ref 339* 354 443 443 467 1124 1225 1226
                                                                                  1227 1228 1230 1231 1292
msf_manager_$close              000370 constant        entry                    external dcl 230 ref 2075
msf_manager_$get_ptr            000372 constant        entry                    external dcl 231 ref 1350 1473
msf_manager_$open               000374 constant        entry                    external dcl 232 ref 1342
msg                             000711 automatic       char(256)                dcl 111 set ref 418* 422* 426* 426 426 428* 430*
                                                                                  432* 517* 519* 525* 527 527 531* 533 533 533* 950*
                                                                                  952 952 962* 964 964 987* 995* 1009* 1072* 1074
                                                                                  1074 1080* 1082 1082 1852* 1853 1853 2117* 2119
                                                                                  2119
mult_ind                        002446 automatic       fixed bin(17,0)          dcl 1322 set ref 1348* 1350* 1352* 1356*
n                               002500 automatic       fixed bin(17,0)          dcl 1418 set ref 1448* 1449 1450 1555* 1556 1582*
                                                                                  1584 1586
n_sample_pages                  001011 automatic       fixed bin(17,0)          dcl 112 set ref 578* 700 708* 710* 729* 729 794 795
                                                                                  818*
n_tokens                  1     001502 automatic       fixed bin(17,0)          level 2 dcl 266 set ref 656 688 735 763
nel                             002501 automatic       fixed bin(24,0)          dcl 1419 set ref 1489* 1494* 1535 1595 1600
nelt                            002502 automatic       fixed bin(24,0)          dcl 1420 set ref 1532* 1535 1547 1595
nep                     102            based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1885
nep_mode_set                    001012 automatic       bit(1)                   packed unaligned dcl 113 set ref 1887* 1890* 1915
                                                                                  2011
new_clock                       001014 automatic       fixed bin(71,0)          dcl 114 set ref 1144* 1157
new_cpu                         001016 automatic       fixed bin(52,0)          dcl 115 set ref 1145* 1156
new_pp                          001020 automatic       fixed bin(17,0)          dcl 116 set ref 1145* 1159
new_rate                        001021 automatic       fixed bin(35,0)          dcl 117 set ref 911* 913* 914* 914 917
new_waits                       001022 automatic       fixed bin(35,0)          dcl 118 set ref 1145* 1158
next                            002503 automatic       fixed bin(17,0)          dcl 1421 in procedure "output_file" set ref 1564*
                                                                                  1565 1566
next                            002657 automatic       fixed bin(17,0)          dcl 1730 in procedure "skip_to_page" set ref 1781*
                                                                                  1782 1783
nl_vt_ff                               defined         char(3)                  packed unaligned dcl 175 ref 1486 1917 1928
nm                              002670 automatic       varying char(256)        dcl 1834 set ref 1863* 1868* 1876* 1876 1880 1881
                                                                                  1886* 1886 1891* 1891 1893* 1893 1895* 1895 1900*
                                                                                  1900 1902* 1902 1904* 1904 1906* 1906 1908 1909
no_accounting           314(10) 001712 automatic       bit(1)                   level 2 packed packed unaligned dcl 10-69 set ref
                                                                                  1169*
no_auto_print             0(02)        based           bit(1)                   level 3 packed packed unaligned dcl 12-22 ref 582
no_separator            304(06) 001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 377* 1982 2028 2107 2132
no_separator            102(07)        based           bit(1)                   level 3 in structure "dprint_msg" packed packed
                                                                                  unaligned dcl 3-20 in procedure "do_prt_request_"
                                                                                  ref 377
non_edited              102(02)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1893
normal                          000160 constant        fixed bin(17,0)          initial dcl 152 set ref 612* 618* 632* 637* 638*
                                                                                  639* 640* 642* 643* 644* 650* 660* 666* 668* 670*
                                                                                  673* 677* 679* 682* 691* 738* 745* 755* 766* 781*
                                                                                  1662*
notify                  304(03) 001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 386* 949 1040* 1040 1042 1074
notify                   66(01)        based           bit(1)                   level 4 in structure "dprint_msg" packed packed
                                                                                  unaligned dcl 3-20 in procedure "do_prt_request_"
                                                                                  ref 386
notify                                 parameter       bit(1)                   packed unaligned dcl 1038 in procedure "fatal_error"
                                                                                  ref 1036 1040
nt                              001023 automatic       fixed bin(24,0)          dcl 119 set ref 622* 628 628 751 751
null                                                   builtin function         dcl 279 ref 336 343 344 580 580 703 703 705 705 805
                                                                                  805 848 848 856 859 859 867 870 870 886 886 944
                                                                                  944 972 972 997 1236 1236 1461 1461 1467 1469 1474
                                                                                  1495 1519 1519 1607 1647 1647 1752 1752 1801 1801
                                                                                  1823 1823 1845 1859 1859 1979 1979 1980 1980 1988
                                                                                  1988 2018 2018 2021 2021 2027 2027 2069 2071 2072
                                                                                  2078 2094 2097 2097 2100 2100 2113 2113
number                          000242 internal static fixed bin(17,0)          level 2 dcl 272 set ref 328* 331* 1964 1968*
odd_page                        003063 automatic       bit(1)                   packed unaligned dcl 1999 set ref 2009* 2012 2015*
                                                                                  2024
offset                    3     001266 automatic       fixed bin(24,0)          array level 4 in structure "ck" dcl 254 in procedure
                                                                                  "do_prt_request_" set ref 1795
offset                    1     001261 automatic       fixed bin(24,0)          level 2 in structure "current" dcl 252 in procedure
                                                                                  "do_prt_request_" set ref 495* 673* 1779* 1795*
offset                    1     002510 automatic       fixed bin(24,0)          level 2 in structure "temp" dcl 1428 in procedure
                                                                                  "output_file" set ref 1489 1492 1547* 1547 1628*
old_clock                       001024 automatic       fixed bin(71,0)          dcl 120 set ref 851* 1157
old_cpu                         001026 automatic       fixed bin(52,0)          dcl 121 set ref 850* 1156
old_pp                          001030 automatic       fixed bin(17,0)          dcl 122 set ref 850* 1159
old_rate                        001031 automatic       fixed bin(35,0)          dcl 123 set ref 908* 911 914 914
old_waits                       001032 automatic       fixed bin(35,0)          dcl 124 set ref 850* 1158
omode                           001033 automatic       char(256)                packed unaligned dcl 125 set ref 676* 677* 1081*
                                                                                  1083* 1462* 1463* 1515* 1516* 1589* 1590* 1738*
                                                                                  1802* 1806* 1824* 2114* 2117*
ordata                                 based           structure                level 1 dcl 10-17
output_mode             221     001712 automatic       char(128)                level 2 dcl 10-69 set ref 387* 1738 1909* 1910*
page_count              273     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 374* 921* 946* 1153* 1155*
page_labels                            based           structure                level 1 dcl 13-21
page_lth                105            based           fixed bin(17,0)          level 2 dcl 3-20 ref 1897 1898
page_no                   2     001261 automatic       fixed bin(24,0)          level 2 in structure "current" dcl 252 in procedure
                                                                                  "do_prt_request_" set ref 492* 499 670* 695 770
                                                                                  791 1448 1562 1571 1574 1577* 1582 1650 1684 1703
                                                                                  1706 1758 1776* 1788 1788 1792* 1817
page_no                   2     002510 automatic       fixed bin(24,0)          level 2 in structure "temp" dcl 1428 in procedure
                                                                                  "output_file" set ref 1545* 1555
page_no                   4     001266 automatic       fixed bin(24,0)          array level 4 in structure "ck" dcl 254 in procedure
                                                                                  "do_prt_request_" set ref 1562 1767 1792
page_no                   4            based           fixed bin(24,0)          level 3 in structure "print_driver_data" dcl 11-9
                                                                                  in procedure "do_prt_request_" set ref 489 882*
page_number               1     001363 automatic       fixed bin(35,0)          level 2 dcl 260 set ref 679* 1149* 1153 1155 1538
                                                                                  1545 1615 1617* 1652 1776* 1792* 2009
page_waits              300     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 788* 1158*
paper_info                5            based           structure                level 2 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_"
paper_info                5     000035 internal static structure                level 2 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_"
paper_info                             based           structure                level 1 dcl 13-27 in procedure "do_prt_request_"
paper_info_data                 001477 automatic       structure                level 1 dcl 262 set ref 1849 1849
paper_not_aligned               001133 automatic       bit(1)                   dcl 126 set ref 576* 598* 835* 1745 1753*
paper_type              244            based           fixed bin(17,0)          level 2 dcl 7-17 ref 307 371
pg                              002654 automatic       fixed bin(24,0)          dcl 1727 set ref 1767* 1768 1768 1769
pg_count_msg                    002535 automatic       char(80)                 packed unaligned dcl 1643 set ref 1656* 1662*
pg_labels                       001373 automatic       structure                level 1 dcl 261 set ref 2126 2126
pgn                             000102 automatic       fixed bin(24,0)          dcl 1678 set ref 1695* 1695 1697 1703 1706 1709
phcs_$deactivate                000376 constant        entry                    external dcl 233 ref 1469 1605 2072
phcs_$set_kst_attributes        000400 constant        entry                    external dcl 234 ref 317 1479
phys_line_length          6            based           fixed bin(17,0)          level 3 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_" ref 1865 1870
phys_line_length          6     000035 internal static fixed bin(17,0)          level 3 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_" set ref 2056*
phys_line_length          1     001477 automatic       fixed bin(17,0)          level 2 in structure "paper_info_data" dcl 262
                                                                                  in procedure "do_prt_request_" set ref 1847*
phys_page_length          5     000035 internal static fixed bin(17,0)          level 3 in structure "static_ctl" dcl 264
                                                                                  in procedure "do_prt_request_" set ref 2057*
phys_page_length          5            based           fixed bin(17,0)          level 3 in structure "prt_ctl" dcl 12-22
                                                                                  in procedure "do_prt_request_" ref 2012
phys_page_length                001477 automatic       fixed bin(17,0)          level 2 in structure "paper_info_data" dcl 262
                                                                                  in procedure "do_prt_request_" set ref 1846*
pic                             001134 automatic       picture(12)              packed unaligned dcl 127 set ref 484* 485 1450* 1451
                                                                                  1586* 1587 1866* 1867 1874* 1875 1898* 1899
point                     2     001266 automatic       structure                array level 3 dcl 254 set ref 502* 1565* 1782*
position                        001363 automatic       structure                level 1 dcl 260 set ref 678 678 1150 1150 1525 1525
                                                                                  1612 1612 1649 1649 1808 1808
position_data                          based           structure                level 1 dcl 13-14
pre_pages               301     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 789* 1159*
prev_seq_id              35            based           fixed bin(35,0)          level 2 dcl 15-8 ref 364
price_per_n_lines       307     001712 automatic       float bin(27)            level 2 dcl 10-69 set ref 1166*
price_per_n_pages       312     001712 automatic       float bin(27)            level 2 dcl 10-69 set ref 1166*
print_driver_data                      based           structure                level 1 dcl 11-9
print_head_separator    234            based           entry variable           level 2 dcl 7-17 ref 704
print_head_sheet        230            based           entry variable           level 2 dcl 7-17 ref 1983
print_tail_sheet        240            based           entry variable           level 2 dcl 7-17 ref 2028
printing                        001137 automatic       bit(1)                   packed unaligned dcl 128 set ref 306* 558 853* 884*
priority_request         53(08)        based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 15-8 in procedure
                                                                                  "do_prt_request_" ref 357
priority_request        304(05) 001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 357* 432* 517
privileged                      000010 internal static bit(1)                   initial packed unaligned dcl 166 set ref 313* 1469
                                                                                  1479 1605 2072
probe                           000402 constant        entry                    external dcl 235 ref 651
process_id               13     002313 automatic       bit(36)                  level 2 dcl 1215 set ref 1227*
prt_ctl                                based           structure                level 1 dcl 12-22
prt_ctl_ptr                     002240 automatic       pointer                  dcl 12-20 set ref 335* 336 336* 377 582 701 701 704*
                                                                                  1865 1870 1885 1902 1906 1983* 2012 2012 2028*
                                                                                  2107 2107 2107 2132 2132 2132
punsw                   207     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 375*
q                        33            based           fixed bin(17,0)          level 2 dcl 15-8 ref 361
queue                    64     001712 automatic       fixed bin(17,0)          level 2 dcl 10-69 set ref 361* 432* 950*
queue_msg_hdr                          based           structure                level 1 dcl 14-12
quit_during_request     310(09)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref 907
                                                                                  1951* 2031
r1_ind                          000101 automatic       fixed bin(35,0)          dcl 1094 set ref 1096* 1109 1109* 1113* 1117* 1128
                                                                                  1128*
read_allowed_                   000404 constant        entry                    external dcl 236 ref 1292
real_time               276     001712 automatic       fixed bin(71,0)          level 2 dcl 10-69 set ref 787* 910 1157*
req_type_label                         based           char(32)                 level 2 dcl 4-25 ref 360
request_data_p                  000024 internal static pointer                  initial dcl 170 set ref 342* 2156
request_descriptor                     based           structure                level 1 dcl 15-8
request_in_progress     310(02)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  574* 970*
request_no               67     001712 automatic       fixed bin(35,0)          level 2 dcl 10-69 set ref 363* 432* 523* 533* 546*
                                                                                  592 666* 946* 950* 962* 1053* 1077* 1660*
request_type             71     001712 automatic       char(32)                 level 2 dcl 10-69 set ref 360* 399 432*
requestor                 2     001712 automatic       char(32)                 level 2 dcl 10-69 set ref 354* 393 394 432* 1270*
restart_msg                     002561 automatic       char(200)                packed unaligned dcl 1644 set ref 1660* 1662*
restart_no               70     001712 automatic       fixed bin(35,0)          level 2 dcl 10-69 set ref 364*
restart_source                  001140 automatic       fixed bin(17,0)          dcl 129 set ref 565* 570* 602* 976*
restarted               304(01) 001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 356* 378 489 519
restarted                53(02)        based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 15-8 in procedure
                                                                                  "do_prt_request_" ref 356
ring                     12     002313 automatic       fixed bin(3,0)           level 2 packed packed unsigned unaligned dcl 1215
                                                                                  set ref 1226*
rtrim                                                  builtin function         dcl 279 ref 393 453 995 1246 1246 1486 1867 1875
                                                                                  1899 1920 1931
save_position                   002515 automatic       structure                level 1 dcl 1430 set ref 1439 1439 1506 1506
saved                    53(05)        based           bit(1)                   level 3 in structure "request_descriptor" packed
                                                                                  packed unaligned dcl 15-8 in procedure
                                                                                  "do_prt_request_" ref 843 877 888 931
saved                   304(04) 001712 automatic       bit(1)                   level 3 in structure "REQUEST" packed packed
                                                                                  unaligned dcl 10-69 in procedure "do_prt_request_"
                                                                                  set ref 557* 920
seconds                         001141 automatic       fixed bin(17,0)          dcl 130 set ref 910* 911 913
seg_string                             based           char                     packed unaligned dcl 1426 ref 1486
segp                            001142 automatic       pointer                  dcl 131 set ref 343* 1350* 1356 1362* 1386* 1467*
                                                                                  1469 1469* 1473* 1474 1479 1479 1486 1491 1492
                                                                                  1605* 1607* 2072 2072* 2078*
segptr                                 parameter       pointer                  dcl 1211 in procedure "check_labels" set ref 1201
                                                                                  1236*
segptr                  306            based           pointer                  level 2 in structure "iodd_static" dcl 7-17
                                                                                  in procedure "do_prt_request_" set ref 997 1491*
                                                                                  1495* 2069*
send_mail_$access_class         000406 constant        entry                    external dcl 237 ref 1124
send_mail_info                  002243 automatic       structure                level 1 dcl 16-5 set ref 395* 1124 1124
send_mail_info_version_2        002242 automatic       fixed bin(17,0)          initial dcl 16-3 set ref 396 16-3*
sender_audit             31            based           bit(36)                  level 2 dcl 9-9 ref 1231
sender_authorization     25            based           bit(72)                  level 2 dcl 9-9 set ref 443* 443 1124* 1228 1292*
sender_id                13            based           char(32)                 level 2 packed packed unaligned dcl 9-9 ref 354 1225
sender_level             24            based           fixed bin(17,0)          level 2 dcl 9-9 ref 467 1226
sender_max_authorization
                         27            based           bit(72)                  level 2 dcl 9-9 ref 1230
sender_process_id        23            based           bit(36)                  level 2 dcl 9-9 ref 1227
sent_from                 1     002243 automatic       char(32)                 level 2 dcl 16-5 set ref 399*
separator               304(02) 001712 automatic       bit(1)                   level 3 packed packed unaligned dcl 10-69 set ref
                                                                                  358* 599* 711* 819* 2107 2132
seq_id                   32            based           fixed bin(35,0)          level 2 dcl 15-8 ref 363
set                             000032 internal static structure                level 2 packed packed unaligned dcl 250
set_page_labels                 001144 automatic       bit(1)                   packed unaligned dcl 132 set ref 299* 1888* 1919*
                                                                                  1930* 2018 2106 2132
short_msg                       001146 automatic       char(8)                  dcl 133 set ref 1068* 1069* 1851* 2116*
sign                            000100 automatic       char(1)                  packed unaligned dcl 1676 set ref 1688* 1690 1690
                                                                                  1703 1706
single                  102(01)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1891
single_sheet            304(08) 001712 automatic       bit(1)                   level 3 packed packed unaligned dcl 10-69 set ref
                                                                                  371*
size                            001670 stack reference condition                dcl 286 ref 616
slave                           000157 constant        fixed bin(17,0)          initial dcl 150 in procedure "do_prt_request_" set
                                                                                  ref 304 533* 570
slave                   312            based           structure                level 2 in structure "iodd_static" dcl 7-17
                                                                                  in procedure "do_prt_request_"
slave_hold              310(07)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 set ref
                                                                                  1959* 1969* 2037*
slave_output            322            based           char(32)                 level 3 dcl 7-17 ref 304
source                          001150 automatic       fixed bin(17,0)          dcl 134 in procedure "do_prt_request_" set ref 612*
                                                                                  618* 622* 632* 637* 638* 639* 640* 642* 643* 644*
                                                                                  648 650* 660* 666* 668* 670* 673* 677* 679* 682*
                                                                                  691* 720* 726* 738* 745* 751* 755* 766* 774* 778
                                                                                  781*
source                                 parameter       fixed bin(17,0)          dcl 1640 in procedure "restart_request" set ref 1636
                                                                                  1662*
space_ht_bs                            defined         char(3)                  packed unaligned dcl 176 ref 1918 1929
special_length           10            based           fixed bin(17,0)          level 2 dcl 17-32 ref 857 858 868 869
special_string                         based           char                     level 2 dcl 17-32 ref 858 869
stars                           022473 constant        char(40)                 initial dcl 164 set ref 1080* 1080*
start                           000101 automatic       fixed bin(17,0)          dcl 1677 set ref 1690* 1692* 1695
start_char_offset               001151 automatic       fixed bin(24,0)          dcl 135 set ref 846* 909
start_segp                      001152 automatic       pointer                  dcl 136 set ref 344* 538* 1356*
starting_page                   001154 automatic       fixed bin(24,0)          dcl 137 set ref 499* 546 546* 601* 689* 695* 718*
                                                                                  764* 770* 772* 791* 826 837* 938* 1650* 1652* 1654
                                                                                  1654* 1656*
starting_pg                            parameter       fixed bin(24,0)          dcl 1722 ref 1720 1736
stat_p                          000246 internal static pointer                  dcl 7-15 set ref 294* 304 307 317 317 327 329 333
                                                                                  371 574 648 704 778 780 907 970 997 1491 1495 1951
                                                                                  1954 1955 1955 1959 1969 1983 2024 2028 2031 2037
                                                                                  2069
static_ctl                      000035 internal static structure                level 1 dcl 264 set ref 336
status_flags             47            based           structure                level 2 dcl 4-25
stream                          001155 automatic       char(32)                 packed unaligned dcl 138 set ref 345*
string                                                 builtin function         dcl 279 set ref 316* 353* 2049* 2060*
substr                                                 builtin function         dcl 279 set ref 394 416 416 426 426 430* 527 527 628
                                                                                  628 751 751 952 952 964 964 1074 1074 1370 1378
                                                                                  1688 1695 1853 1853 1882* 1910* 1923* 1934* 2119
                                                                                  2119
switches                 11     002243 automatic       structure                level 2 dcl 16-5
sys_info$access_class_floor     000424 external static bit(72)                  dcl 1212 ref 1229
sys_priv                        000011 internal static bit(1)                   initial packed unaligned dcl 167 set ref 1098 1103*
system_privilege_$ipc_priv_off  000410 constant        entry                    external dcl 239 ref 1111 1131
system_privilege_$ipc_priv_on   000412 constant        entry                    external dcl 240 ref 1119
system_privilege_$ring1_priv_off
                                000414 constant        entry                    external dcl 241 ref 1109 1128
system_privilege_$ring1_priv_on 000416 constant        entry                    external dcl 242 ref 1117
target                          002652 automatic       fixed bin(24,0)          dcl 1725 set ref 1736* 1758 1768 1788 1817 1820*
tell_user                              constant        bit(1)                   initial packed unaligned dcl 154 set ref 449* 457*
                                                                                  471* 477* 540* 1013* 1024*
temp                            002510 automatic       structure                level 1 dcl 1428 set ref 1435* 1550
temp_label                      003000 automatic       char(136)                packed unaligned dcl 1839 set ref 1917* 1918 1920
                                                                                  1923 1925 1928* 1929 1931 1934 1936
terminal                        001165 automatic       char(32)                 array packed unaligned dcl 139 set ref 303* 304*
test_entry              310(01)        based           bit(1)                   level 3 packed packed unaligned dcl 7-17 ref 648
text_offset                            based           structure                level 1 packed packed unaligned dcl 6-45
time_est                        001205 automatic       fixed bin(17,0)          dcl 140 set ref 512* 514 523 525 533 533
time_start_request      262     001712 automatic       fixed bin(71,0)          level 2 dcl 10-69 set ref 390* 391* 594* 595*
timer_manager_$alarm_wakeup     000420 constant        entry                    external dcl 243 ref 1974
top_label                       001373 automatic       char(136)                level 2 in structure "pg_labels" dcl 261
                                                                                  in procedure "do_prt_request_" set ref 1913* 1923*
                                                                                  1925*
top_label                              based           char                     level 2 in structure "dprint_msg" dcl 3-20
                                                                                  in procedure "do_prt_request_" ref 1220 1246 1246
                                                                                  1917
top_label_lth           107            based           fixed bin(17,0)          level 2 dcl 3-20 ref 1220 1220 1246 1246 1917 1928
total_charge            306     001712 automatic       float bin(27)            level 2 dcl 10-69 set ref 388* 946* 950* 1174* 1174
total_chars               3     001363 automatic       fixed bin(35,0)          level 2 dcl 260 set ref 1532 1548 1780* 1796*
total_lines               2     001363 automatic       fixed bin(35,0)          level 2 dcl 260 set ref 679* 1148* 1152 1546 1777*
                                                                                  1793*
tpd                       1(12) 000032 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 250 in procedure "do_prt_request_" set ref
                                                                                  320*
tpd                       0(03) 000032 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 250 in procedure "do_prt_request_" set ref
                                                                                  320*
translate                                              builtin function         dcl 279 ref 407 408 409 410 1917 1928
truncate                102(03)        based           bit(1)                   level 3 packed packed unaligned dcl 3-20 ref 1895
tus                       0(02) 000032 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 250 in procedure "do_prt_request_" set ref
                                                                                  323*
tus                       1(11) 000032 internal static bit(1)                   level 3 in structure "ksta" packed packed unaligned
                                                                                  dcl 250 in procedure "do_prt_request_" set ref
                                                                                  323*
type                            002442 automatic       fixed bin(2,0)           dcl 1317 set ref 1328* 1334
unspec                                                 builtin function         dcl 279 set ref 395* 1223* 1233* 1236 1236
user_dir                               parameter       char                     dcl 1263 in procedure "check_user_access" set ref
                                                                                  1258 1270* 1285*
user_dir                        001206 automatic       char(168)                dcl 141 in procedure "do_prt_request_" set ref 403*
                                                                                  405* 405 469* 475* 538*
user_dir                               parameter       char                     dcl 1210 in procedure "check_labels" set ref 1201
                                                                                  1242*
user_dir                               parameter       char                     dcl 1308 in procedure "open_file" set ref 1306 1328*
                                                                                  1342*
user_id                   2     002313 automatic       char(32)                 level 2 dcl 1215 set ref 1225*
v                               002772 automatic       varying char(12)         dcl 1836 set ref 1867* 1868 1875* 1876 1899* 1900
val                             001260 automatic       fixed bin(17,0)          dcl 142 set ref 467* 1270*
value                     1(09) 000032 internal static structure                level 2 packed packed unaligned dcl 250
verify                                                 builtin function         dcl 279 ref 1918 1929
version                         002313 automatic       char(8)                  level 2 in structure "local_audit_user_info"
                                                                                  dcl 1215 in procedure "check_labels" set ref 1224*
version                         002243 automatic       fixed bin(17,0)          level 2 in structure "send_mail_info" dcl 16-5
                                                                                  in procedure "do_prt_request_" set ref 396*
wakeup                   11     002243 automatic       bit(1)                   level 3 packed packed unaligned dcl 16-5 set ref
                                                                                  397*
whoami                          000004 constant        char(32)                 initial packed unaligned dcl 148 set ref 602* 1188*
                                                                                  1463* 1507* 1516* 1590* 1613* 1958* 1972* 2036*
wp                              002506 automatic       pointer                  dcl 1424 set ref 1492* 1494*
write_control_form_             000422 constant        entry                    external dcl 244 ref 1955

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ATTACH_TYPE_DIAL                       internal static fixed bin(17,0)          initial dcl 5-15
ATTACH_TYPE_TTY                        internal static fixed bin(17,0)          initial dcl 5-15
ATTACH_TYPE_VARIABLE_LINE              internal static fixed bin(17,0)          initial dcl 5-15
BRIEF_BANNERS                          internal static fixed bin(17,0)          initial dcl 12-49
CTL_ATTACH_TYPE_DIAL                   internal static fixed bin(17,0)          initial dcl 5-21
CTL_ATTACH_TYPE_MC                     internal static fixed bin(17,0)          initial dcl 5-21
CTL_ATTACH_TYPE_TTY                    internal static fixed bin(17,0)          initial dcl 5-21
EVALUATE_FORMS_INFO_INPUT_VERSION_1    internal static char(8)                  initial packed unaligned dcl 17-26
EVALUATE_FORMS_INFO_OUTPUT_VERSION_1   internal static char(8)                  initial packed unaligned dcl 17-53
IODT_VERSION_5                         internal static char(8)                  initial packed unaligned dcl 6-49
MSEG_MESSAGE_INFO_V1                   internal static char(8)                  initial dcl 9-28
MSEG_READ_AFTER_SPECIFIED              internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_BEFORE_SPECIFIED             internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_DELETE                       internal static bit(36)                  initial dcl 9-38
MSEG_READ_FIRST                        internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_LAST                         internal static fixed bin(17,0)          initial dcl 9-30
MSEG_READ_OWN                          internal static bit(36)                  initial dcl 9-38
MSEG_READ_SPECIFIED                    internal static fixed bin(17,0)          initial dcl 9-30
PAPER_TYPE_DEFAULT                     internal static fixed bin(17,0)          initial dcl 5-26
STATE_BUMPED                           internal static fixed bin(17,0)          initial dcl 14-46
STATE_DEFERRED                         internal static fixed bin(17,0)          initial dcl 14-42
STATE_DUPT                             internal static fixed bin(17,0)          initial dcl 14-47
STATE_ELIGIBLE                         internal static fixed bin(17,0)          initial dcl 14-44
STATE_RUNNING                          internal static fixed bin(17,0)          initial dcl 14-45
STATE_TRANSITION                       internal static fixed bin(17,0)          initial dcl 14-43
STATE_UNPROCESSED                      internal static fixed bin(17,0)          initial dcl 14-41
audit_user_info_ptr                    automatic       pointer                  dcl 1-11
channel_stops                          based           bit(16)                  array packed unaligned dcl 13-25
counts                                 based           structure                level 1 dcl 13-6
dprint_msg_version_3                   internal static fixed bin(17,0)          initial dcl 3-62
dprint_msg_version_4                   internal static fixed bin(17,0)          initial dcl 3-62
dprint_msg_version_5                   internal static fixed bin(17,0)          initial dcl 3-62
evaluate_forms_info_input              based           structure                level 1 dcl 17-14
evaluate_forms_info_input_ptr          automatic       pointer                  dcl 17-13
forms_max_lth                          internal static fixed bin(17,0)          initial dcl 3-55
head_max_lth                           internal static fixed bin(17,0)          initial dcl 3-55
iod_tables_hdr                         based           structure                level 1 dcl 6-23
ithp                                   automatic       pointer                  dcl 6-22
kstap                                  automatic       pointer                  dcl 8-3
label_max_lth                          internal static fixed bin(17,0)          initial dcl 3-55
ordatap                                automatic       pointer                  dcl 10-67
orderp                                 automatic       pointer                  dcl 13-4
path_max_lth                           internal static fixed bin(17,0)          initial dcl 3-55
queue_msg_hdr_version_1                internal static fixed bin(17,0)          initial dcl 14-37
ret_error_count                        based           fixed bin(17,0)          dcl 13-32
sys_info$max_seg_size                  external static fixed bin(35,0)          dcl 238
system_error_string_length             automatic       fixed bin(17,0)          dcl 17-50
system_escape_string_length            automatic       fixed bin(17,0)          dcl 17-50
system_input_forms_string_length       automatic       fixed bin(17,0)          dcl 17-25
system_returned_forms_length           automatic       fixed bin(17,0)          dcl 17-50
system_special_string_length           automatic       fixed bin(17,0)          dcl 17-50
text_strings                           based           structure                level 1 dcl 6-39
text_strings_ptr                       automatic       pointer                  dcl 6-38

NAMES DECLARED BY EXPLICIT CONTEXT.
LOG_AUDIT_MESSAGE               012646 constant        label                    dcl 1221 ref 1249 1252
abort_request                   011222 constant        label                    dcl 992 ref 349
ask                             004621 constant        label                    dcl 609 ref 582 613 619 630 633 645 652 662 683 692
                                                                                  721 731 740 743 746 758 767 775 782
charge_for_work                 012331 constant        entry                    internal dcl 1140 ref 896 1045
check_labels                    012600 constant        entry                    internal dcl 1201 ref 538
check_reprint_position          011212 constant        label                    dcl 976 ref 566 571
check_user_access               013140 constant        entry                    internal dcl 1258 ref 469 1368
clean_out                       011015 constant        label                    dcl 955 ref 450 458 472 478 528 541 625 753 813 840
                                                                                  879 928 931 1015 1026 1857 2123 2129
clean_proc                      021417 constant        entry                    internal dcl 2067 ref 347 971
defer_request                   011354 constant        label                    dcl 1018 ref 554
do_prt_request_                 002206 constant        entry                    external dcl 66
driver_fatal_error              012506 constant        entry                    internal dcl 1182 ref 624 812 839 878 927 1856 2122
                                                                                  2128
end_of_comp                     015543 constant        label                    dcl 1602 ref 1597
error_during_request            011371 constant        entry                    external dcl 2144
error_write                     011532 constant        entry                    internal dcl 1063 ref 922 1048
fatal_error                     011432 constant        entry                    internal dcl 1036 ref 449 457 471 477 540 1013 1024
flush_request                   011215 constant        label                    dcl 987 ref 552 553
forward                         017125 constant        label                    dcl 1820 ref 1788
get_page_no                     016300 constant        entry                    internal dcl 1670 ref 689 764
init_static_ctl                 021371 constant        entry                    internal dcl 2047 ref 310
next_comp                       014471 constant        label                    dcl 1469 ref 1630
no_delete                       011303 constant        label                    dcl 1003 ref 990
notify_user                     012114 constant        entry                    internal dcl 1091 ref 527 952 964 1074 1853 2119
open_file                       013353 constant        entry                    internal dcl 1306 ref 475
output_file                     014126 constant        entry                    internal dcl 1409 ref 724 865 1820
pgn_err                         016406 constant        label                    dcl 1698 ref 1694
print_head_banner               020415 constant        entry                    internal dcl 1946 ref 810 1042
print_req                       007342 constant        label                    dcl 785 ref 584
print_tail_banner               021011 constant        entry                    internal dcl 1995 ref 925 1050
restart_request                 016030 constant        entry                    internal dcl 1636 ref 976
restart_this_request            004516 constant        label                    dcl 589 ref 981
revert_handler                  012245 constant        label                    dcl 1121 ref 1104
sample_done                     014666 constant        label                    dcl 1506 ref 1624
send_it                         012246 constant        label                    dcl 1124 ref 1098
set_modes_and_labels            017220 constant        entry                    internal dcl 1832 ref 544 757
set_up_page_labels              021467 constant        entry                    internal dcl 2084 ref 716 816
single_copy                     011417 constant        entry                    external dcl 2152
skip_to_page                    016443 constant        entry                    internal dcl 1720 ref 601 718 772 837
tough                           002344 constant        label                    dcl 324 ref 314
write_out                       014613 constant        label                    dcl 1489 ref 1595

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     23612       24240   22517       23622
Length     25330   22517       426        1053    1073         240

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
do_prt_request_                    2662 external procedure  is an external procedure.  
on unit on line 311                  64 on unit               
on unit on line 347                  64 on unit               
on unit on line 552                  64 on unit               
on unit on line 553                  64 on unit               
on unit on line 554                  64 on unit               
on unit on line 555                  86 on unit               
on unit on line 563                  64 on unit               
on unit on line 568                  64 on unit               
on unit on line 609                  98 on unit               
on unit on line 616                 100 on unit               
fatal_error                             internal procedure  shares stack frame of external procedure do_prt_request_.  
error_write                             internal procedure  shares stack frame of external procedure do_prt_request_.  
notify_user                         110 internal procedure  is called during a stack extension, and enables or reverts conditions.  
on unit on line 1101                 64 on unit               
on unit on line 1107                 68 on unit               
charge_for_work                         internal procedure  shares stack frame of external procedure do_prt_request_.  
driver_fatal_error                  108 internal procedure  is called during a stack extension.  
check_labels                            internal procedure  shares stack frame of external procedure do_prt_request_.  
check_user_access                       internal procedure  shares stack frame of external procedure do_prt_request_.  
open_file                               internal procedure  shares stack frame of external procedure do_prt_request_.  
output_file                             internal procedure  shares stack frame of external procedure do_prt_request_.  
restart_request                         internal procedure  shares stack frame of external procedure do_prt_request_.  
get_page_no                         234 internal procedure  enables or reverts conditions.  
on unit on line 1694                 64 on unit               
skip_to_page                            internal procedure  shares stack frame of external procedure do_prt_request_.  
set_modes_and_labels                    internal procedure  shares stack frame of external procedure do_prt_request_.  
print_head_banner                       internal procedure  shares stack frame of external procedure do_prt_request_.  
print_tail_banner                       internal procedure  shares stack frame of external procedure do_prt_request_.  
init_static_ctl                         internal procedure  shares stack frame of external procedure do_prt_request_.  
clean_proc                           74 internal procedure  is called by several nonquick procedures.  
set_up_page_labels                      internal procedure  shares stack frame of external procedure do_prt_request_.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 privileged                  do_prt_request_
000011 sys_priv                    do_prt_request_
000012 first_call                  do_prt_request_
000013 fault_name                  do_prt_request_
000024 request_data_p              do_prt_request_
000026 err_label                   do_prt_request_
000032 ksta                        do_prt_request_
000035 static_ctl                  do_prt_request_
000242 ctl_wait_list               do_prt_request_
000246 stat_p                      do_prt_request_

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
do_prt_request_          000100 access_class                do_prt_request_
                         000102 auth                        do_prt_request_
                         000104 auth_string                 do_prt_request_
                         000356 char_count                  do_prt_request_
                         000357 chars_done                  do_prt_request_
                         000360 chgsw                       do_prt_request_
                         000361 ck_interval                 do_prt_request_
                         000362 ck_mode                     do_prt_request_
                         000365 cmd_line                    do_prt_request_
                         000411 code                        do_prt_request_
                         000412 continuous_paper            do_prt_request_
                         000413 control                     do_prt_request_
                         000414 copies_left                 do_prt_request_
                         000415 ctl_msg_sent                do_prt_request_
                         000416 delete_msg                  do_prt_request_
                         000426 desc_ptr                    do_prt_request_
                         000430 dest                        do_prt_request_
                         000436 device_error                do_prt_request_
                         000437 ename                       do_prt_request_
                         000447 err_mess                    do_prt_request_
                         000532 fcbp                        do_prt_request_
                         000534 force_ck_pt                 do_prt_request_
                         000535 full_path                   do_prt_request_
                         000607 head                        do_prt_request_
                         000627 header_done                 do_prt_request_
                         000630 how                         do_prt_request_
                         000631 i                           do_prt_request_
                         000632 iocbp                       do_prt_request_
                         000634 l                           do_prt_request_
                         000635 last_error_count            do_prt_request_
                         000636 lg_msg                      do_prt_request_
                         000667 lg_sw                       do_prt_request_
                         000670 line_mode                   do_prt_request_
                         000700 mailname                    do_prt_request_
                         000710 max_comp                    do_prt_request_
                         000711 msg                         do_prt_request_
                         001011 n_sample_pages              do_prt_request_
                         001012 nep_mode_set                do_prt_request_
                         001014 new_clock                   do_prt_request_
                         001016 new_cpu                     do_prt_request_
                         001020 new_pp                      do_prt_request_
                         001021 new_rate                    do_prt_request_
                         001022 new_waits                   do_prt_request_
                         001023 nt                          do_prt_request_
                         001024 old_clock                   do_prt_request_
                         001026 old_cpu                     do_prt_request_
                         001030 old_pp                      do_prt_request_
                         001031 old_rate                    do_prt_request_
                         001032 old_waits                   do_prt_request_
                         001033 omode                       do_prt_request_
                         001133 paper_not_aligned           do_prt_request_
                         001134 pic                         do_prt_request_
                         001137 printing                    do_prt_request_
                         001140 restart_source              do_prt_request_
                         001141 seconds                     do_prt_request_
                         001142 segp                        do_prt_request_
                         001144 set_page_labels             do_prt_request_
                         001146 short_msg                   do_prt_request_
                         001150 source                      do_prt_request_
                         001151 start_char_offset           do_prt_request_
                         001152 start_segp                  do_prt_request_
                         001154 starting_page               do_prt_request_
                         001155 stream                      do_prt_request_
                         001165 terminal                    do_prt_request_
                         001205 time_est                    do_prt_request_
                         001206 user_dir                    do_prt_request_
                         001260 val                         do_prt_request_
                         001261 current                     do_prt_request_
                         001266 ck                          do_prt_request_
                         001363 position                    do_prt_request_
                         001373 pg_labels                   do_prt_request_
                         001477 paper_info_data             do_prt_request_
                         001502 arg_list                    do_prt_request_
                         001704 dmp                         do_prt_request_
                         001706 driver_status_ptr           do_prt_request_
                         001710 mseg_message_info_ptr       do_prt_request_
                         001712 REQUEST                     do_prt_request_
                         002236 driver_data_p               do_prt_request_
                         002240 prt_ctl_ptr                 do_prt_request_
                         002242 send_mail_info_version_2    do_prt_request_
                         002243 send_mail_info              do_prt_request_
                         002256 evaluate_forms_info_output_ptr
                                                            do_prt_request_
                         002310 access_class                check_labels
                         002312 level                       check_labels
                         002313 local_audit_user_info       check_labels
                         002336 local_audit_eventflags      check_labels
                         002346 code                        check_user_access
                         002347 mode                        check_user_access
                         002350 access_class                check_user_access
                         002360 comp_dir                    open_file
                         002432 comp_name                   open_file
                         002442 type                        open_file
                         002443 dir_len                     open_file
                         002444 bc                          open_file
                         002445 mode                        open_file
                         002446 mult_ind                    open_file
                         002456 bc                          output_file
                         002457 max_el                      output_file
                         002460 modes                       output_file
                         002500 n                           output_file
                         002501 nel                         output_file
                         002502 nelt                        output_file
                         002503 next                        output_file
                         002504 code                        output_file
                         002506 wp                          output_file
                         002510 temp                        output_file
                         002515 save_position               output_file
                         002534 code                        restart_request
                         002535 pg_count_msg                restart_request
                         002561 restart_msg                 restart_request
                         002643 i                           restart_request
                         002652 target                      skip_to_page
                         002653 i                           skip_to_page
                         002654 pg                          skip_to_page
                         002655 high_page                   skip_to_page
                         002656 ind                         skip_to_page
                         002657 next                        skip_to_page
                         002660 code                        skip_to_page
                         002670 nm                          set_modes_and_labels
                         002771 i                           set_modes_and_labels
                         002772 v                           set_modes_and_labels
                         002776 ll                          set_modes_and_labels
                         002777 ind                         set_modes_and_labels
                         003000 temp_label                  set_modes_and_labels
                         003042 len                         set_modes_and_labels
                         003052 ec                          print_head_banner
                         003062 ec                          print_tail_banner
                         003063 odd_page                    print_tail_banner
                         003064 event_info                  print_tail_banner
get_page_no              000100 sign                        get_page_no
                         000101 start                       get_page_no
                         000102 pgn                         get_page_no
notify_user              000100 ipc_ind                     notify_user
                         000101 r1_ind                      notify_user
                         000102 ec                          notify_user

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars
call_ent_var_desc   call_ent_var        call_ext_out_desc   call_ext_out        call_int_this_desc  call_int_this
call_int_other      return_mac          fl2_to_fx1          tra_ext_1           tra_ext_2           mdfx1
enable_op           shorten_stack       ext_entry           ext_entry_desc      int_entry           int_entry_desc
set_chars_eis       verify_eis          any_to_any_truncate_divide_fx3          translate_3         verify_for_rtrim

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
access_audit_gate_$log_obj_ptr_user                         aim_check_$equal              aim_check_$greater
clock_                        continue_to_signal_           convert_authorization_$from_string
convert_authorization_$to_string                            convert_ipc_code_             convert_status_code_
cpu_time_and_paging_          cu_$level_get                 date_time_                    hcs_$fs_get_mode
hcs_$fs_get_path_name         hcs_$get_access_class         hcs_$get_user_effmode         hcs_$status_minf
io_daemon_account_            ioa_$rsnnl                    iodd_command_processor_       iodd_get_cmd_
iodd_msg_                     iodd_parse_$args              iodd_parse_$command           iox_$control
iox_$modes                    iox_$put_chars                ipc_$block                    ipc_$drain_chn
msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open             phcs_$deactivate
phcs_$set_kst_attributes      probe                         read_allowed_                 send_mail_$access_class
system_privilege_$ipc_priv_off                              system_privilege_$ipc_priv_on
system_privilege_$ring1_priv_off                            system_privilege_$ring1_priv_on
timer_manager_$alarm_wakeup   write_control_form_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
access_operations_$io_daemon_set_page_labels                error_table_$action_not_performed
error_table_$ai_restricted    error_table_$dirseg           error_table_$eof_record
error_table_$improper_data_format                           error_table_$moderr           error_table_$noarg
error_table_$noentry          error_table_$out_of_bounds    error_table_$request_pending  sys_info$access_class_floor




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
16    3 002176        66 002202       294 002214       295 002221       296 002224       297 002225       298 002226
    299 002227       300 002230       301 002232       303 002234       304 002241       305 002246       306 002250
    307 002251       309 002255       310 002257       311 002260       313 002274       314 002275       316 002300
    317 002304       320 002325       321 002332       322 002336       323 002340       324 002344       325 002345
    327 002347       328 002353       329 002355       330 002357       331 002360       333 002361       334 002363
    335 002365       336 002367       338 002375       339 002377       340 002400       341 002402       342 002404
    343 002406       344 002411       345 002413       347 002417       349 002441       353 002445       354 002446
    355 002452       356 002457       357 002464       358 002471       359 002473       360 002477       361 002502
    362 002504       363 002510       364 002512       365 002514       366 002516       367 002520       369 002526
    370 002527       371 002534       372 002544       373 002545       374 002546       375 002547       376 002550
    377 002552       378 002566       381 002575       383 002603       384 002616       385 002624       386 002627
    387 002634       388 002637       389 002641       390 002642       391 002650       393 002665       394 002700
    395 002703       396 002706       397 002710       398 002712       399 002714       403 002717       404 002723
    405 002726       407 002774       408 003012       409 003030       410 003047       411 003066       415 003072
    416 003075       418 003105       421 003143       422 003145       425 003150       426 003154       428 003232
    430 003242       432 003245       439 003353       443 003360       445 003405       447 003411       448 003432
    449 003434       450 003436       453 003437       454 003451       455 003453       456 003500       457 003502
    458 003504       460 003505       463 003526       467 003531       469 003534       470 003537       471 003541
    472 003543       475 003544       476 003547       477 003551       478 003553       483 003554       484 003556
    485 003565       489 003616       492 003631       493 003633       494 003634       495 003635       496 003636
    499 003637       501 003641       502 003647       503 003655       504 003660       505 003662       509 003664
    511 003667       512 003675       514 003700       517 003712       519 003721       522 003730       523 003733
    525 004003       527 004043       528 004062       530 004064       531 004065       533 004070       538 004163
    539 004166       540 004170       541 004172       544 004173       546 004174       552 004254       553 004273
    554 004312       555 004331       557 004345       558 004350       559 004352       560 004354       562 004404
    563 004405       565 004421       566 004424       568 004427       570 004443       571 004446       574 004451
    575 004455       576 004457       577 004460       578 004462       580 004463       582 004512       584 004515
    589 004516       592 004520       593 004522       594 004524       595 004533       596 004550       597 004552
    598 004553       599 004555       601 004562       602 004564       609 004621       612 004635       613 004671
    616 004674       618 004710       619 004744       622 004747       623 005015       624 005017       625 005036
    628 005037       629 005071       630 005074       632 005077       633 005136       636 005137       637 005144
    638 005200       639 005234       640 005270       642 005324       643 005360       644 005414       645 005444
    648 005445       650 005462       651 005520       652 005525       655 005526       656 005540       660 005560
    662 005620       663 005621       664 005622       666 005623       668 005702       670 005743       672 006006
    673 006010       676 006062       677 006107       678 006152       679 006204       682 006252       683 006302
    687 006303       688 006310       689 006313       690 006333       691 006335       692 006400       694 006401
    695 006402       700 006404       701 006406       703 006417       704 006452       705 006503       708 006536
    710 006543       711 006545       712 006547       716 006551       718 006552       719 006554       720 006556
    721 006615       724 006616       725 006621       726 006623       729 006662       731 006663       734 006664
    735 006671       736 006674       737 006704       738 006711       740 006750       742 006751       743 006752
    745 006753       746 007007       749 007010       750 007015       751 007017       752 007054       753 007064
    755 007073       757 007127       758 007130       763 007131       764 007134       765 007154       766 007156
    767 007221       769 007222       770 007223       772 007225       773 007227       774 007231       775 007270
    778 007271       780 007301       781 007306       782 007341       785 007342       787 007344       788 007345
    789 007346       790 007347       791 007350       794 007352       795 007356       799 007404       800 007440
    805 007444       808 007502       810 007505       811 007507       812 007511       813 007530       816 007531
    818 007532       819 007533       825 007535       826 007537       827 007543       828 007544       834 007567
    835 007571       837 007572       838 007574       839 007576       840 007615       843 007616       845 007625
    846 007627       848 007631       850 007661       851 007674       853 007703       856 007705       857 007711
    858 007714       859 007775       860 010031       865 010061       867 010064       868 010070       869 010073
    870 010154       871 010211       876 010241       877 010243       878 010252       879 010276       881 010300
    882 010301       884 010303       886 010304       888 010334       890 010346       891 010350       892 010353
    893 010354       894 010356       896 010357       898 010360       901 010365       902 010421       904 010431
    907 010432       908 010441       909 010444       910 010447       911 010454       913 010461       914 010465
    917 010504       920 010506       921 010511       922 010540       925 010544       926 010546       927 010550
    928 010567       931 010570       935 010574       936 010602       937 010603       938 010604       940 010606
    944 010607       946 010637       949 010722       950 010725       952 010775       953 011014       955 011015
    957 011020       958 011054       960 011065       961 011070       962 011072       964 011126       965 011145
    969 011146       970 011151       971 011155       972 011161       974 011211       976 011212       981 011214
    987 011215       989 011220       990 011221       992 011222       995 011223       997 011263       999 011275
   1000 011277      1001 011302      1003 011303      1006 011311      1009 011314      1011 011350      1013 011351
   1015 011353      1018 011354      1020 011361      1022 011362      1024 011363      1026 011365      2144 011366
   2148 011405      2149 011414      2152 011416      2156 011425      2157 011431      1036 011432      1040 011434
   1042 011443      1045 011453      1048 011456      1050 011461      1053 011466      1055 011526      1057 011531
   1063 011532      1068 011543      1069 011550      1072 011574      1074 011641      1077 011663      1079 011736
   1080 011740      1081 012014      1082 012044      1083 012064      1085 012112      1091 012113      1096 012127
   1098 012132      1101 012134      1103 012150      1104 012151      1107 012154      1109 012170      1111 012201
   1113 012213      1114 012217      1115 012226      1117 012227      1119 012236      1121 012245      1124 012246
   1128 012306      1131 012317      1134 012330      1140 012331      1144 012332      1145 012341      1147 012354
   1148 012355      1149 012356      1150 012357      1152 012411      1153 012413      1155 012425      1156 012427
   1157 012432      1158 012435      1159 012443      1161 012446      1162 012450      1163 012454      1164 012467
   1166 012470      1169 012474      1171 012476      1172 012477      1174 012501      1176 012504      1182 012505
   1188 012521      1190 012565      1191 012571      1193 012573      1195 012577      1201 012600      1218 012616
   1220 012620      1221 012646      1223 012655      1224 012660      1225 012663      1226 012667      1227 012674
   1228 012676      1229 012702      1230 012710      1231 012714      1233 012716      1234 012717      1236 012721
   1239 013004      1242 013005      1243 013033      1246 013037      1247 013113      1248 013117      1249 013120
   1252 013121      1255 013137      1258 013140      1270 013156      1271 013215      1272 013217      1274 013224
   1275 013231      1276 013234      1279 013235      1280 013243      1281 013250      1282 013254      1285 013255
   1286 013304      1287 013306      1288 013313      1289 013316      1292 013317      1293 013336      1294 013342
   1295 013347      1298 013350      1300 013352      1306 013353      1326 013371      1328 013373      1329 013433
   1330 013436      1331 013460      1334 013462      1336 013470      1337 013473      1339 013474      1340 013477
   1342 013500      1343 013526      1344 013531      1345 013545      1348 013547      1350 013555      1351 013601
   1352 013604      1353 013633      1356 013634      1362 013640      1363 013671      1364 013674      1365 013701
   1368 013702      1369 013722      1370 013725      1373 014001      1376 014003      1377 014006      1378 014011
   1379 014053      1382 014055      1384 014056      1386 014060      1387 014073      1388 014076      1389 014103
   1391 014104      1392 014112      1393 014117      1394 014122      1396 014123      1405 014125      1409 014126
   1433 014130      1435 014131      1437 014134      1438 014137      1439 014152      1440 014205      1441 014207
   1442 014214      1443 014217      1445 014220      1446 014221      1448 014223      1449 014226      1450 014230
   1451 014237      1452 014270      1453 014272      1455 014275      1456 014310      1457 014312      1459 014330
   1461 014344      1462 014375      1463 014422      1467 014467      1469 014471      1473 014511      1474 014535
   1475 014541      1476 014546      1479 014547      1482 014573      1485 014576      1486 014601      1489 014613
   1491 014616      1492 014622      1494 014626      1495 014642      1496 014646      1497 014650      1498 014652
   1499 014654      1500 014661      1504 014662      1506 014666      1507 014721      1513 014756      1515 014771
   1516 015017      1519 015064      1521 015114      1525 015115      1526 015146      1527 015150      1528 015152
   1529 015157      1532 015160      1534 015166      1535 015172      1536 015200      1537 015202      1538 015205
   1540 015242      1545 015243      1546 015245      1547 015247      1548 015251      1550 015253      1551 015256
   1554 015267      1555 015272      1556 015276      1557 015300      1558 015303      1562 015304      1564 015313
   1565 015316      1566 015324      1569 015326      1571 015331      1574 015335      1575 015336      1576 015340
   1577 015343      1579 015374      1582 015375      1584 015400      1586 015402      1587 015411      1589 015442
   1590 015470      1595 015535      1597 015540      1600 015541      1602 015543      1605 015554      1607 015575
   1608 015577      1610 015600      1611 015602      1612 015605      1613 015636      1615 015676      1617 015740
   1619 015776      1620 016000      1623 016001      1624 016024      1627 016025      1628 016026      1630 016027
   1636 016030      1647 016032      1649 016064      1650 016116      1652 016123      1654 016131      1656 016135
   1658 016165      1660 016174      1662 016232      1664 016276      1670 016277      1681 016313      1683 016315
   1684 016323      1685 016326      1688 016327      1690 016332      1692 016341      1694 016343      1695 016362
   1697 016403      1698 016406      1700 016411      1703 016412      1706 016422      1709 016432      1711 016434
   1714 016442      1720 016443      1734 016445      1736 016446      1738 016450      1739 016500      1740 016502
   1741 016504      1742 016511      1745 016512      1746 016516      1747 016541      1748 016543      1749 016545
   1750 016552      1752 016553      1753 016603      1754 016604      1758 016606      1762 016614      1763 016615
   1765 016616      1767 016623      1768 016626      1769 016632      1770 016633      1772 016635      1774 016637
   1776 016641      1777 016645      1778 016647      1779 016650      1780 016651      1781 016653      1782 016657
   1783 016665      1785 016667      1788 016670      1792 016700      1793 016706      1794 016711      1795 016713
   1796 016715      1797 016720      1801 016722      1802 016752      1804 017001      1806 017024      1808 017053
   1809 017106      1810 017110      1811 017112      1812 017117      1815 017120      1817 017121      1820 017125
   1823 017140      1824 017170      1826 017217      1832 017220      1844 017221      1845 017223      1846 017227
   1847 017232      1848 017234      1849 017236      1850 017271      1851 017273      1852 017314      1853 017344
   1856 017363      1857 017403      1859 017404      1863 017434      1864 017435      1865 017441      1866 017446
   1867 017455      1868 017510      1869 017542      1870 017544      1872 017547      1873 017552      1874 017553
   1875 017562      1876 017615      1877 017661      1878 017663      1880 017664      1881 017666      1882 017672
   1885 017677      1886 017705      1887 017717      1888 017721      1889 017722      1890 017723      1891 017724
   1893 017741      1895 017756      1897 017773      1898 017776      1899 020005      1900 020040      1901 020104
   1902 020105      1904 020125      1906 020142      1908 020157      1909 020161      1910 020165      1913 020172
   1915 020200      1917 020202      1918 020225      1919 020240      1920 020242      1921 020254      1922 020261
   1923 020273      1924 020303      1925 020304      1928 020307      1929 020336      1930 020345      1931 020347
   1932 020361      1933 020366      1934 020400      1935 020410      1936 020411      1940 020414      1946 020415
   1951 020417      1952 020423      1954 020424      1955 020427      1956 020455      1957 020457      1958 020462
   1959 020514      1961 020520      1962 020521      1963 020522      1964 020524      1965 020532      1966 020542
   1967 020544      1968 020547      1969 020550      1970 020553      1971 020554      1972 020562      1973 020615
   1974 020616      1976 020634      1977 020635      1979 020636      1980 020667      1982 020723      1983 020731
   1984 020752      1988 020757      1989 021010      1995 021011      2008 021013      2009 021014      2011 021022
   2012 021026      2014 021040      2015 021064      2017 021065      2018 021066      2021 021123      2024 021154
   2027 021210      2028 021244      2031 021273      2033 021302      2034 021320      2035 021322      2036 021331
   2037 021364      2041 021370      2047 021371      2049 021372      2051 021374      2052 021376      2053 021400
   2054 021401      2056 021403      2057 021405      2058 021407      2060 021411      2062 021415      2067 021416
   2069 021424      2071 021427      2072 021433      2075 021452      2078 021462      2080 021466      2084 021467
   2093 021470      2094 021472      2095 021476      2096 021501      2097 021530      2098 021562      2100 021615
   2101 021650      2106 021677      2107 021701      2113 021747      2114 022001      2115 022026      2116 022030
   2117 022051      2119 022111      2122 022130      2123 022150      2126 022151      2127 022203      2128 022205
   2129 022224      2132 022225      2139 022276


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
