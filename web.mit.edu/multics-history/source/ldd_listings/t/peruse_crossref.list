	COMPILATION LISTING OF SEGMENT peruse_crossref
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 09/15/86  1153.2 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /* This program peruses a cross-reference output file, as generated by the
       12*   online crossreference program. It is used to print out entries from the
       13*   crossref in a relatively readable format.
       14*
       15*   Modification history:
       16*   08/13/80 W. Olin Sibert
       17*   03/04/81 E. N. Kittlitz - divers alterations.
       18*   04/22/81 E. N. Kittlitz - handle cref* error messages in CREF MSF.
       19*   Fix assumes that all messages are at end of MSF.
       20*   12/31/81 J. Spencer Love - fix search bug, fix long include file names
       21*   bug, minor improvements.
       22*   2/82 BIM for default cref path.
       23*   4 Apr 82, WOS: Modified for active function usage.
       24*   1984-08-26 BIM -brief_errors
       25*   1985-01-03, BIM: fixed leading _ names to work for include files.
       26**/
       27 
       28 
       29 /****^  HISTORY COMMENTS:
       30*  1) change(86-08-16,JSLove), approve(86-08-16,MCR7430),
       31*     audit(86-09-12,GDixon), install(86-09-15,MR12.0-1153):
       32*     Added support for synonyms in input file.  Added undocumented -debug
       33*     control argument.
       34*                                                   END HISTORY COMMENTS */
       35 
       36 
       37 /* format: style2 */
       38 
       39 pcref:
       40 peruse_crossref:
       41      procedure () options (variable);
       42 
       43 	dcl     alp		 pointer;
       44 	dcl     code		 fixed bin (35);
       45 	dcl     debug		 bit (3) aligned;
       46 	dcl     nargs		 fixed bin;
       47 	dcl     rs_ptr		 pointer;
       48 	dcl     rs_lth		 fixed bin (21);
       49 	dcl     return_string	 char (rs_lth) based (rs_ptr) varying;
       50 	dcl     complain		 variable entry options (variable);
       51 	dcl     active_function	 bit (1) aligned;
       52 	dcl     brief_sw		 bit (1) aligned;
       53 	dcl     brief_error_sw	 bit (1) aligned;
       54 	dcl     questionable_module	 bit (1) aligned;	/* GLOBAL for communication between process_entry and process_entrypoint. */
       55 
       56 	dcl     dname		 char (168);
       57 	dcl     ename		 char (32);
       58 	dcl     bitcount		 fixed bin (24);
       59 	dcl     fs_type		 fixed bin (2);
       60 	dcl     fcb_ptr		 pointer;
       61 
       62 	dcl     system_area_ptr	 pointer;
       63 	dcl     system_area		 area based (system_area_ptr);
       64 
       65 	dcl     first_entry		 fixed bin;
       66 	dcl     n_entries		 fixed bin;
       67 	dcl     entry_ptr		 pointer;
       68 	dcl     1 entry		 (n_entries) based (entry_ptr),
       69 		2 argno		 fixed bin,
       70 		2 name		 char (36) varying,
       71 		2 ep		 char (36) varying,
       72 		2 non_star_lth	 fixed bin,
       73 		2 include		 bit (1) aligned;
       74 
       75 	dcl     n_parts		 fixed bin;
       76 	dcl     1 part		 (64) aligned,	/* "parts" of the cref. Segments and last/first lines */
       77 		2 ptr		 pointer,		/* pointer to beginning of this part */
       78 		2 lth		 fixed bin (21),	/* length in characters */
       79 		2 first		 fixed bin (30),	/* index (from char 1 of part 1) of first char in this part */
       80 		2 last		 fixed bin (30),	/* index of last char in this part */
       81 		2 allocated	 bit (1) aligned;	/* whether this part was allocated, and hence must be freed */
       82 
       83 	dcl     active_fnc_err_	 entry options (variable);
       84 	dcl     check_star_name_$entry entry (char (*), fixed bin (35));
       85 	dcl     com_err_		 entry options (variable);
       86 	dcl     cu_$af_return_arg	 entry (fixed bin, pointer, fixed bin (21), fixed bin (35));
       87 	dcl     cu_$arg_list_ptr	 entry (pointer);
       88 	dcl     cu_$arg_ptr_rel	 entry (fixed bin, pointer, fixed bin (21), fixed bin (35), pointer);
       89 	dcl     expand_pathname_$add_suffix
       90 				 entry (character (*), character (*), character (*), character (*),
       91 				 fixed binary (35));
       92 	dcl     get_system_free_area_	 entry () returns (pointer);
       93 	dcl     hcs_$status_minf	 entry (char (*), char (*), fixed bin (1), fixed bin (2), fixed bin (24),
       94 				 fixed bin (35));
       95 	dcl     initiate_file_	 entry (character (*), character (*), bit (*), pointer, fixed binary (24),
       96 				 fixed binary (35));
       97 	dcl     terminate_file_	 entry (pointer, fixed binary (24), bit (*), fixed binary (35));
       98 	dcl     pathname_		 entry (character (*), character (*)) returns (character (168));
       99 	dcl     ioa_		 entry options (variable);
      100 	dcl     ioa_$nnl		 entry options (variable);
      101 	dcl     match_star_name_	 entry (char (*), char (*), fixed bin (35));
      102 	dcl     msf_manager_$close	 entry (pointer);
      103 	dcl     msf_manager_$get_ptr	 entry (pointer, fixed bin, bit (1) aligned, pointer, fixed bin (24),
      104 				 fixed bin (35));
      105 	dcl     msf_manager_$open	 entry (char (*), char (*), pointer, fixed bin (35));
      106 
      107 	dcl     (
      108 	        error_table_$badopt,
      109 	        error_table_$dirseg,
      110 	        error_table_$noarg,
      111 	        error_table_$not_act_fnc,
      112 	        error_table_$too_many_args
      113 	        )			 fixed bin (35) external static;
      114 
      115 	dcl     WHOAMI		 char (32) internal static options (constant) init ("peruse_crossref");
      116 	dcl     DEFAULT_CREF_PATH	 char (168) init (">library_dir_dir>crossref>total.crossref") internal
      117 				 static options (constant);
      118 	dcl     SUFFIX		 char (8) init ("crossref") internal static options (constant);
      119 	dcl     FIRST_CH		 char (63) aligned internal static options (constant)
      120 				 init ("_abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789");
      121 	dcl     DASH		 char (1) aligned internal static options (constant) init ("-");
      122 	dcl     SPACE		 char (1) aligned internal static options (constant) init (" ");
      123 	dcl     TWO_SPACES		 char (2) aligned internal static options (constant) init ("  ");
      124 	dcl     TAB		 char (1) aligned internal static options (constant) init ("	");
      125 	dcl     TWO_TABS		 char (2) aligned internal static options (constant)
      126 				 init ("		");
      127 	dcl     NEWLINE		 char (1) aligned internal static options (constant) init ("
      128 ");
      129 	dcl     WHITESPACE		 char (3) aligned internal static options (constant) init ("
      130 	 ");					/* NEWLINE, TAB, SPACE */
      131 
      132 	dcl     (
      133 	        LESS		 init (1),
      134 	        EQUAL		 init (2),
      135 	        GREATER		 init (3)
      136 	        )			 fixed bin internal static options (constant);
      137 
      138 	dcl     (
      139 	        EXACT		 init (1),
      140 	        PARTIAL		 init (2),
      141 	        MISS		 init (3)
      142 	        )			 fixed bin internal static options (constant);
      143 
      144 	dcl     (cleanup, logic_error) condition;
      145 
      146 	dcl     (addr, after, before, bit, copy, divide, index, length, ltrim, maxlength, min, null, reverse, rtrim,
      147 	        search, substr, unspec, verify)
      148 				 builtin;
      149 
      150 
  1     1 /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      151 
      152 
  2     1 /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  2     2 /* format: style2,^inddcls,idind32 */
  2     3 
  2     4 declare 1 terminate_file_switches	based,
  2     5 	2 truncate		bit (1) unaligned,
  2     6 	2 set_bc			bit (1) unaligned,
  2     7 	2 terminate		bit (1) unaligned,
  2     8 	2 force_write		bit (1) unaligned,
  2     9 	2 delete			bit (1) unaligned;
  2    10 
  2    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  2    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  2    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  2    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  2    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  2    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  2    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  2    18 
  2    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      153 
      154 
      155 	call cu_$af_return_arg (nargs, rs_ptr, rs_lth, code);
      156 
      157 	if (code = 0)
      158 	then do;
      159 		complain = active_fnc_err_;
      160 		return_string = "";
      161 		active_function = "1"b;
      162 	     end;
      163 	else if (code = error_table_$not_act_fnc)
      164 	then do;
      165 		complain = com_err_;
      166 		rs_ptr = null ();
      167 		active_function = "0"b;
      168 	     end;
      169 	else do;
      170 		call com_err_ (code, WHOAMI);
      171 		return;
      172 	     end;
      173 
      174 	call cu_$arg_list_ptr (alp);
      175 
      176 	system_area_ptr = get_system_free_area_ ();	/* sundry initializations, for cleanup etc. */
      177 	n_parts = 0;
      178 	part.ptr (1) = null ();
      179 	first_entry = 0;
      180 	n_entries = 0;
      181 	dname = "";
      182 	entry_ptr = null ();
      183 	fcb_ptr = null ();
      184 
      185 	on condition (cleanup) call clean_up ();
      186 
      187 	if nargs < 1
      188 	then do;
      189 USAGE:
      190 		call complain (error_table_$noarg, WHOAMI,
      191 		     "^/Usage:^-^a {crossref_pathname} entrypoint_name(s) {-control_args}", WHOAMI);
      192 
      193 MAIN_RETURN:
      194 		call clean_up ();
      195 		return;
      196 	     end;
      197 
      198 	call process_args ();
      199 
      200 	if n_entries = 0
      201 	then /* must have at least one entrypoint, natch */
      202 	     goto USAGE;
      203 
      204 	allocate entry in (system_area) set (entry_ptr);	/* allocate the info array */
      205 
      206 	call check_entries ();
      207 
      208 	call default_input_file ();
      209 
      210 	call hcs_$status_minf (dname, ename, 1b /* chase */, fs_type, bitcount, code);
      211 	if code ^= 0
      212 	then do;
      213 BAD_XREF:
      214 		call complain (code, WHOAMI, "^a", pathname_ (dname, ename));
      215 		goto MAIN_RETURN;
      216 	     end;
      217 
      218 	if fs_type = 1
      219 	then /* segment */
      220 	     call initiate_segment ();
      221 
      222 	else do;					/* must be an MSF */
      223 		if bitcount = 0
      224 		then do;				/* but it's NOT */
      225 			code = error_table_$dirseg;
      226 			goto BAD_XREF;
      227 		     end;
      228 
      229 		call initiate_msf ();
      230 	     end;
      231 
      232 	if (debug & "1"b) ^= ""b
      233 	then call print_parts ();
      234 
      235 	if (debug & "01"b) = ""b
      236 	then call print_matches ();
      237 
      238 	return;
      239 
      240 print_parts:
      241      proc ();
      242 
      243 /* Debugging procedure to list parts of cref file */
      244 
      245 	dcl     part_idx		 fixed bin;
      246 
      247 	do part_idx = 1 to n_parts;
      248 	     call ioa_ ("Part ^d: ^d chars @ ^p.", part_idx, part.lth (part_idx), part.ptr (part_idx));
      249 	end;
      250 
      251 	call ioa_ ("");
      252 
      253 	return;
      254      end print_parts;
      255 
      256 
      257 print_matches:
      258      proc ();
      259 
      260 /* procedure to print matches found in cref. */
      261 
      262 	dcl     line_start		 fixed bin (30);
      263 	dcl     line_ptr		 pointer;
      264 	dcl     line_lth		 fixed bin (21);
      265 	dcl     line		 char (line_lth) based (line_ptr);
      266 
      267 	dcl     match		 fixed bin;
      268 	dcl     entry_idx		 fixed bin;
      269 	dcl     search_name		 char (36) varying;
      270 	dcl     exact		 bit (1) aligned;
      271 	dcl     include		 bit (1) aligned;
      272 
      273 
      274 	do entry_idx = 1 to n_entries;
      275 	     search_name = substr (entry.name (entry_idx), 1, entry.non_star_lth (entry_idx));
      276 	     exact = (length (search_name) = length (entry.name (entry_idx)));
      277 	     include = entry.include (entry_idx);
      278 
      279 	     call find_line (search_name, include, exact, line_ptr, line_start, line_lth, match);
      280 
      281 	     if (debug & "001"b) ^= ""b
      282 	     then call ioa_ ("^[Exact^;Partial^;No^] match for ""^a"" in ^d char line at char ^d (^p):^/^a", match,
      283 		     entry.name (entry_idx), line_lth, line_start, line_ptr, line);
      284 
      285 	     call process_entry (entry_idx, line_start, line_ptr, line_lth);
      286 	end;
      287 
      288 	return;
      289      end print_matches;
      290 
      291 clean_up:
      292      proc ();
      293 
      294 /* cleanup procedure */
      295 
      296 	dcl     s1p		 pointer;
      297 	dcl     s1l		 fixed bin (21);
      298 	dcl     s1		 char (s1l) based (s1p);
      299 	dcl     part_idx		 fixed bin;
      300 
      301 	if entry_ptr ^= null ()
      302 	then free entry in (system_area);
      303 
      304 	if fcb_ptr = null ()
      305 	then do;					/* not an MSF to close */
      306 		if part.ptr (1) ^= null ()
      307 		then /* but there is a segment */
      308 		     call terminate_file_ (part.ptr (1), (0), TERM_FILE_TERM, (0));
      309 	     end;
      310 
      311 	else do;					/* otherwise, close the MSF */
      312 		call msf_manager_$close (fcb_ptr);
      313 		do part_idx = 2 to (n_parts - 1) by 2;	/* and free all the strings */
      314 		     s1p = part.ptr (part_idx);
      315 		     s1l = part.lth (part_idx);
      316 		     if part.allocated (part_idx)
      317 		     then free s1 in (system_area);
      318 		end;
      319 	     end;					/* of closing MSF */
      320 
      321 	return;
      322      end clean_up;
      323 
      324 process_args:
      325      proc ();
      326 
      327 /* Simple procedure to process arguments */
      328 
      329 	dcl     ap		 pointer;
      330 	dcl     al		 fixed bin (21);
      331 	dcl     arg		 char (al) based (ap);
      332 	dcl     argno		 fixed bin;
      333 
      334 	brief_sw, brief_error_sw = "0"b;
      335 	debug = ""b;
      336 	do argno = 1 to nargs;
      337 	     call cu_$arg_ptr_rel (argno, ap, al, (0), alp);
      338 
      339 	     if index (arg, "-") = 1
      340 	     then if (^active_function) & ((arg = "-brief") | (arg = "-bf"))
      341 		then brief_sw = "1"b;
      342 		else if (^active_function) & ((arg = "-long") | (arg = "-lg"))
      343 		then brief_sw = "0"b;
      344 		else if arg = "-brief_errors" | arg = "-bfe"
      345 		then brief_error_sw = "1"b;
      346 		else if arg = "-debug" | arg = "-db"
      347 		then do;
      348 			if argno = nargs
      349 			then do;
      350 				call complain (error_table_$noarg, WHOAMI,
      351 				     "^a must be followed by a debug bit mask.", arg);
      352 				goto MAIN_RETURN;
      353 			     end;
      354 			argno = argno + 1;
      355 			call cu_$arg_ptr_rel (argno, ap, al, (0), alp);
      356 			debug = bit (arg, 3);
      357 		     end;
      358 		else if arg = "-long_errors" | arg = "-lgfe"
      359 		then brief_error_sw = "0"b;
      360 		else if (arg = "-pathname") | (arg = "-pn")
      361 		then do;
      362 			if argno = nargs
      363 			then do;
      364 				call complain (error_table_$noarg, WHOAMI,
      365 				     "^a must be followed by a crossreference pathname.", arg);
      366 				goto MAIN_RETURN;
      367 			     end;
      368 			argno = argno + 1;
      369 			call cu_$arg_ptr_rel (argno, ap, al, (0), alp);
      370 			goto PATHNAME;
      371 		     end;
      372 
      373 		else do;
      374 			call complain (error_table_$badopt, WHOAMI, "^a", arg);
      375 			goto MAIN_RETURN;
      376 		     end;
      377 
      378 	     else if search (arg, "<>") > 0
      379 	     then
      380 PATHNAME:
      381 		do;				/* Looks Like a PATHNAME! */
      382 		     if dname ^= ""			/* Two PATHNAMES? */
      383 		     then do;
      384 			     call complain (error_table_$too_many_args, WHOAMI,
      385 				"Only one crossref pathname is allowed, but ^a appears to be a second pathname.",
      386 				arg);
      387 			     goto MAIN_RETURN;
      388 			end;
      389 
      390 		     call expand_pathname_$add_suffix (arg, SUFFIX, dname, ename, code);
      391 		     if code ^= 0
      392 		     then do;
      393 			     call complain (code, WHOAMI, "^a", arg);
      394 			     goto MAIN_RETURN;
      395 			end;
      396 		end;
      397 
      398 	     else do;				/* A SEARCH NAME (a search name) */
      399 		     if first_entry = 0
      400 		     then first_entry = argno;
      401 		     n_entries = n_entries + 1;	/* otherwise, remember that we've seen an entrypoint */
      402 		end;
      403 
      404 	end;					/* of loop through args */
      405 
      406 	return;
      407      end process_args;
      408 
      409 check_entries:
      410      proc ();
      411 
      412 /* This procedure is used to extract and validate the arguments from the command line
      413*   which specify things to be searched for. */
      414 
      415 	dcl     ap		 pointer;
      416 	dcl     al		 fixed bin (21);
      417 	dcl     arg		 char (al) based (ap);
      418 	dcl     argno		 fixed bin;
      419 
      420 	dcl     name		 char (36) varying;
      421 	dcl     ep		 char (36) varying;
      422 	dcl     i1		 fixed bin;
      423 	dcl     entry_idx		 fixed bin;
      424 
      425 	entry_idx = 0;
      426 	do argno = first_entry to nargs;
      427 	     call cu_$arg_ptr_rel (argno, ap, al, (0), alp);
      428 
      429 	     if index (arg, "-") ^= 1 & search (arg, "<>") = 0
      430 	     then do;				/* thats us */
      431 		     entry_idx = entry_idx + 1;	/* get to the next slot */
      432 		     entry.argno (entry_idx) = argno;
      433 		end;
      434 	end;
      435 
      436 	do entry_idx = 1 to n_entries;		/* validate the name portions */
      437 	     ep = "";
      438 	     call cu_$arg_ptr_rel (entry.argno (entry_idx), ap, al, (0), alp);
      439 
      440 	     name = before (arg, "$");		/* split it in pieces */
      441 	     ep = after (arg, "$");
      442 
      443 	     if index (arg, ".incl") = 0
      444 	     then entry.include (entry_idx) = "0"b;
      445 	     else do;
      446 		     entry.include (entry_idx) = "1"b;
      447 
      448 		     if length (name) <= 25 & substr (reverse (name), 1, 5) = "lcni."
      449 		     then name = name || ".*";
      450 
      451 		     if ep ^= ""
      452 		     then call bad_entry_format ("$ not allowed in include name.");
      453 		end;
      454 
      455 	     if length (name) > 32
      456 	     then call bad_entry_format ("Segment name too long.");
      457 	     if length (ep) > 256
      458 	     then call bad_entry_format ("Entrypoint name too long.");
      459 
      460 	     entry.name (entry_idx) = name;
      461 	     entry.ep (entry_idx) = ep;
      462 
      463 	     call check_star_name_$entry ((name), code);
      464 	     if code > 2
      465 	     then call bad_entry_format ("Invalid star name.");
      466 	     else if code = 2
      467 	     then call bad_entry_format ("Double star not allowed in segment name.");
      468 	     else if code = 1
      469 	     then do;				/* special stuff for hacking star names */
      470 		     i1 = search (name, "*?");	/* find first star-like char -- there is guaranteed to be one */
      471 		     if i1 = 1
      472 		     then /* too complicated to implement this time */
      473 			call bad_entry_format ("Star names may not begin with star.");
      474 		     entry.non_star_lth (entry_idx) = i1 - 1;
      475 						/* length of non-starred portion */
      476 		end;
      477 	     else entry.non_star_lth (entry_idx) = length (name);
      478 						/* otherwise, is whole thing */
      479 
      480 	     if length (ep) > 0
      481 	     then do;				/* validate entrypoint name, too */
      482 		     call check_star_name_$entry ((ep), code);
      483 		     if code > 2
      484 		     then call bad_entry_format ("Invalid star name.");
      485 		end;
      486 	end;					/* of validation loop */
      487 
      488 	return;					/* end of main code of check_entries */
      489 
      490 bad_entry_format:
      491      proc (P_message);
      492 
      493 	dcl     P_message		 char (*) parameter;
      494 
      495 	call cu_$arg_ptr_rel (entry.argno (entry_idx), ap, al, (0), alp);
      496 
      497 	call complain (0, WHOAMI, "Invalid search name ^a. ^a", arg, P_message);
      498 	goto MAIN_RETURN;
      499 
      500      end bad_entry_format;
      501 
      502      end check_entries;
      503 
      504 initiate_segment:
      505      proc ();
      506 
      507 /* This procedure is used to initiate a single segment if the xref is not an MSF;
      508*   it creates, effectively, information about a one component MSF. */
      509 
      510 	unspec (part (1)) = ""b;
      511 
      512 	call initiate_file_ (dname, ename, R_ACCESS, part.ptr (1), bitcount, code);
      513 	if code ^= 0
      514 	then goto BAD_XREF;
      515 
      516 	n_parts = 1;
      517 
      518 	part.lth (1) = divide (bitcount, 9, 21, 0);
      519 	part.first (1) = 1;				/* first and only component */
      520 	part.last (1) = part.lth (1);			/* last char */
      521 	part.allocated (1) = "0"b;			/* should be terminated, not freed */
      522 
      523 	return;
      524      end initiate_segment;
      525 
      526 initiate_msf:
      527      proc ();
      528 
      529 /* This procedure is used to initiate all the components of an MSF, and then create
      530*   extra "lines" between each component which contain all the characters after (but not
      531*   including) the last newline in component N, followed by all the characters up to and
      532*   including the first newline in component N+1. The starting addresses and lengths of
      533*   each component are then updated appropriately to compensate for the characters
      534*   thus extracted. */
      535 
      536 	dcl     (s1p, s2p, s3p)	 pointer;		/* assorted based strings */
      537 	dcl     (s1l, s2l, s3l)	 fixed bin (21);
      538 	dcl     s1		 char (s1l) based (s1p);
      539 	dcl     s2		 char (s2l) based (s2p);
      540 	dcl     s3		 char (s3l) based (s3p);
      541 
      542 	dcl     (i1, i2)		 fixed bin (30);
      543 	dcl     part_idx		 fixed bin;
      544 	dcl     component_idx	 fixed bin;
      545 
      546 
      547 	call msf_manager_$open (dname, ename, fcb_ptr, code);
      548 	if (fcb_ptr = null ()) | (code ^= 0)
      549 	then goto BAD_XREF;
      550 
      551 	part_idx = 1;				/* incremented by two each time through */
      552 	do component_idx = 0 by 1;
      553 	     unspec (part (part_idx)) = ""b;		/* initialize */
      554 	     unspec (part (part_idx + 1)) = ""b;
      555 	     part.ptr (part_idx + 1) = null ();
      556 
      557 	     call msf_manager_$get_ptr (fcb_ptr, component_idx, "0"b, part.ptr (part_idx), bitcount, code);
      558 	     if part.ptr (part_idx) = null ()
      559 	     then /* last one, probably */
      560 		goto MSF_INITIATED;
      561 
      562 	     part.lth (part_idx) = divide (bitcount, 9, 21, 0);
      563 	     n_parts = part_idx;
      564 	     part_idx = part_idx + 2;
      565 	end;
      566 
      567 MSF_INITIATED:
      568 	do part_idx = 1 to (n_parts - 2) by 2;		/* now, combine the end and beginning of each segment */
      569 	     s1p = part.ptr (part_idx);		/* into a bare line, so that each part contains only */
      570 	     s1l = part.lth (part_idx);		/* integral lines */
      571 	     i1 = length (s1) - index (reverse (s1), NEWLINE) + 2;
      572 						/* first char after last newline */
      573 
      574 	     s2p = part.ptr (part_idx + 2);		/* next segment */
      575 	     s2l = part.lth (part_idx + 2);
      576 	     i2 = index (s2, NEWLINE);		/* first newline */
      577 
      578 	     s3l = length (substr (s1, i1)) + length (substr (s2, 1, i2));
      579 						/* length of string to be allocated */
      580 	     allocate s3 in (system_area) set (s3p);	/* -- sum of lengths of line parts */
      581 
      582 	     substr (s3, 1, length (substr (s1, i1))) = substr (s1, i1);
      583 						/* and copy in the two pieces */
      584 	     substr (s3, 1 + length (substr (s1, i1))) = substr (s2, 1, i2);
      585 
      586 	     part.lth (part_idx) = part.lth (part_idx) - length (substr (s1, i1));
      587 						/* shorten it by amount removed */
      588 
      589 	     part.ptr (part_idx + 1) = addr (substr (s3, 1, 1));
      590 						/* remember location of line */
      591 	     part.lth (part_idx + 1) = length (s3);
      592 	     part.allocated (part_idx + 1) = "1"b;
      593 
      594 	     part.ptr (part_idx + 2) = addr (substr (s2, i2 + 1));
      595 						/* move the beginning up */
      596 	     part.lth (part_idx + 2) = length (substr (s2, i2 + 1));
      597 						/* and shorten it */
      598 	end;
      599 
      600 	part.first (1) = 1;				/* first char of part 1 is 1 */
      601 	do part_idx = 1 to n_parts - 1;		/* now, set the "first" char of each */
      602 	     part.first (part_idx + 1) = part.first (part_idx) + part.lth (part_idx);
      603 	end;
      604 
      605 	do part_idx = 1 to n_parts;			/* now set part.last for all the parts */
      606 	     part.last (part_idx) = part.first (part_idx) + part.lth (part_idx) - 1;
      607 	end;
      608 
      609 	return;
      610      end initiate_msf;
      611 
      612 locate_char:
      613      proc (P_idx, P_part_idx, P_part_offset);
      614 
      615 /* This procedure takes a character index (as counted from character one of
      616*   part one) and returns the index of the part which contains it and
      617*   an index into that part. */
      618 
      619 	dcl     (
      620 	        P_idx		 fixed bin (30),
      621 	        P_part_idx		 fixed bin,
      622 	        P_part_offset	 fixed bin (21)
      623 	        )			 parameter;
      624 
      625 	dcl     idx		 fixed bin;
      626 
      627 	do idx = 1 to n_parts;
      628 	     if P_idx >= part.first (idx)
      629 	     then if P_idx <= part.last (idx)
      630 		then do;				/* found it */
      631 			P_part_idx = idx;
      632 			P_part_offset = P_idx - part.first (idx) + 1;
      633 			return;
      634 		     end;
      635 	end;					/* of loop through parts */
      636 
      637 	P_part_idx = -1;				/* force a fault if we fall through */
      638 	P_part_offset = -1;
      639 
      640 	return;
      641      end locate_char;
      642 
      643 /* This procedure locates the beginning and end of the text line containing the
      644*   referenced character, and returns a pointer to its first character and the length
      645*   of the line. The line contains a trailing newline, unless the last line of the
      646*   crossreference lacks one and is returned. */
      647 
      648 locate_line:
      649      proc (P_idx, P_line_ptr, P_line_start, P_line_lth);
      650 
      651 	dcl     (
      652 	        P_idx		 fixed bin (30),
      653 	        P_line_ptr		 pointer,
      654 	        P_line_start	 fixed bin (30),
      655 	        P_line_lth		 fixed bin (21)
      656 	        )			 parameter;
      657 
      658 	dcl     part_ptr		 pointer;
      659 	dcl     part_lth		 fixed bin (21);
      660 	dcl     part		 char (part_lth) based (part_ptr);
      661 	dcl     part_idx		 fixed bin;
      662 	dcl     char_idx		 fixed bin (21);
      663 	dcl     first		 fixed bin (21);
      664 	dcl     lth		 fixed bin (21);
      665 
      666 	call locate_char (P_idx, part_idx, char_idx);
      667 
      668 	part_ptr = part.ptr (part_idx);
      669 	part_lth = part.lth (part_idx);
      670 
      671 	first = index (reverse (substr (part, 1, char_idx)), NEWLINE);
      672 	if first = 0
      673 	then /* no previous newline, start at char 1 */
      674 	     first = 1;
      675 	else first = char_idx - first + 2;
      676 
      677 	lth = index (substr (part, first), NEWLINE);
      678 	if lth = 0
      679 	then /* no trailing newline */
      680 	     P_line_lth = length (substr (part, first));
      681 	else P_line_lth = lth;			/* otherwise, include the newline */
      682 
      683 	P_line_start = part.first (part_idx) + first - 1; /* the index of the first char */
      684 	P_line_ptr = addr (substr (part, first, 1));
      685 
      686 	return;
      687      end locate_line;
      688 
      689 next_line:
      690      proc (P_old_line_start, P_old_line_lth, P_new_line_ptr, P_new_line_start, P_new_line_lth);
      691 
      692 /* This procedure takes the index of the first character in a line, and returns pointer, start,
      693*   and length for the next line in the file, or a null pointer if there is none. */
      694 
      695 	dcl     (
      696 	        P_old_line_start	 fixed bin (30),
      697 	        P_old_line_lth	 fixed bin (21),
      698 	        P_new_line_ptr	 pointer,
      699 	        P_new_line_start	 fixed bin (30),
      700 	        P_new_line_lth	 fixed bin (21)
      701 	        )			 parameter;
      702 
      703 	dcl     part_ptr		 pointer;
      704 	dcl     part_lth		 fixed bin (21);
      705 	dcl     part		 char (part_lth) based (part_ptr);
      706 	dcl     part_idx		 fixed bin;
      707 	dcl     char_idx		 fixed bin (21);
      708 	dcl     lth		 fixed bin (21);
      709 
      710 
      711 	call locate_char (P_old_line_start + P_old_line_lth, part_idx, char_idx);
      712 	if part_idx < 0
      713 	then goto NO_APPROPRIATE_LINE;
      714 
      715 	part_ptr = part.ptr (part_idx);
      716 	part_lth = part.lth (part_idx);
      717 
      718 	lth = index (substr (part, char_idx), NEWLINE);
      719 	if lth = 0
      720 	then /* no trailing newline */
      721 	     P_new_line_lth = length (substr (part, char_idx));
      722 	else P_new_line_lth = lth;			/* otherwise, include the newline */
      723 
      724 	goto RETURN_INDICES;
      725 
      726 
      727 prev_line:
      728      entry (P_old_line_start, P_old_line_lth, P_new_line_ptr, P_new_line_start, P_new_line_lth);
      729 
      730 	if P_old_line_start - 1 <= 0
      731 	then goto NO_APPROPRIATE_LINE;
      732 
      733 	call locate_line (P_old_line_start - 2, P_new_line_ptr, P_new_line_start, P_new_line_lth);
      734 
      735 	if "1"b
      736 	then return;
      737 
      738 	call locate_char (P_old_line_start - 2, part_idx, char_idx);
      739 	if part_idx < 0
      740 	then goto NO_APPROPRIATE_LINE;
      741 
      742 	part_ptr = part.ptr (part_idx);
      743 	part_lth = part.lth (part_idx);
      744 
      745 	lth = index (reverse (substr (part, 1, char_idx)), NEWLINE) + 1;
      746 	if lth = 1
      747 	then lth = char_idx + 1;
      748 	else char_idx = char_idx - lth + 3;
      749 
      750 	P_new_line_lth = lth;
      751 	goto RETURN_INDICES;
      752 
      753 
      754 RETURN_INDICES:
      755 	P_new_line_start = part.first (part_idx) + char_idx - 1;
      756 						/* the index of the first char */
      757 	P_new_line_ptr = addr (substr (part, char_idx, 1));
      758 
      759 	return;
      760 
      761 
      762 NO_APPROPRIATE_LINE:
      763 	P_new_line_ptr = null ();
      764 	P_new_line_start = -1;
      765 	P_new_line_lth = -1;
      766 	return;
      767 
      768      end next_line;
      769 
      770 /* This procedure finds the line which either starts with P_string, or the first
      771*   line after that in collating sequence. Collating sequence is strictly ASCII,
      772*   except that anything containing the string ".incl." collates after anything
      773*   that doesn't. The finding is done by binary search. */
      774 
      775 find_line:
      776      proc (P_string, P_include, P_exact, P_line_ptr, P_line_start, P_line_lth, P_matched);
      777 
      778 	dcl     (
      779 	        P_string		 char (36) varying,
      780 	        P_include		 bit (1) aligned,
      781 	        P_exact		 bit (1) aligned,
      782 	        P_line_start	 fixed bin (30),
      783 	        P_line_ptr		 pointer,
      784 	        P_line_lth		 fixed bin (21),
      785 	        P_matched		 fixed bin
      786 	        )			 parameter;
      787 
      788 	dcl     include		 bit (1) aligned;	/* whether P_string contains ".incl." */
      789 	dcl     str_lth		 fixed bin;
      790 	dcl     backward		 bit (1) aligned;	/* which direction are we scanning */
      791 
      792 	dcl     (lb, ub)		 fixed bin (30);	/* bounds for binary search */
      793 	dcl     try		 fixed bin (30);
      794 
      795 	dcl     (line_start, try_line_start)
      796 				 fixed bin (30);	/* line we work with */
      797 	dcl     (line_ptr, try_line_ptr)
      798 				 pointer;
      799 	dcl     (line_lth, try_line_lth)
      800 				 fixed bin (21);
      801 	dcl     line		 char (line_lth) based (line_ptr);
      802 
      803 	dcl     continue		 bit (1) aligned;
      804 	dcl     comparison		 fixed bin;
      805 	dcl     matched		 fixed bin;
      806 
      807 	dcl     last_char		 fixed bin (30);
      808 	dcl     first_char		 fixed bin (30);
      809 
      810 	include = P_include;
      811 	str_lth = length (P_string);
      812 
      813 	lb = 1;
      814 	ub = part.last (n_parts);
      815 
      816 ITERATE:
      817 	try = divide ((lb + ub), 2, 30, 0);		/* beginning of loop -- see goto at bottom of procedure */
      818 
      819 	call locate_line (try, line_ptr, line_start, line_lth);
      820 
      821 	try_line_ptr = line_ptr;			/* remember info about this line, in case we must search back */
      822 	try_line_start = line_start;
      823 	try_line_lth = line_lth;
      824 
      825 	do while (index (FIRST_CH, substr (line, 1, 1)) = 0);
      826 						/* stop looping at the first non-whitespace */
      827 	     call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
      828 	     if line_ptr = null ()
      829 	     then /* last line */
      830 		goto LOOK_BACK_INSTEAD;
      831 	end;					/* of finding next line with a name on it */
      832 
      833 	call compare_line (line, P_string, include, comparison, matched);
      834 
      835 	if comparison = EQUAL
      836 	then /* strings are more or less equal. Finish and return */
      837 	     goto EQUAL_MATCH;
      838 
      839 	last_char = line_start + line_lth - 1;		/* last char we have "looked" at */
      840 
      841 	if comparison = LESS
      842 	then do;					/* if LESS, then search backwards to the previous one */
      843 LOOK_BACK_INSTEAD:
      844 		line_ptr = try_line_ptr;		/* start from the line we ended up trying */
      845 		line_start = try_line_start;
      846 		line_lth = try_line_lth;
      847 
      848 		continue = "1"b;
      849 		do while (continue);		/* look at prev line, stop when we hit a good one */
      850 		     call prev_line (line_start, line_lth, line_ptr, line_start, line_lth);
      851 		     if line_ptr = null ()
      852 		     then /* first line */
      853 			goto FINISH_AND_RETURN;
      854 
      855 		     if index (FIRST_CH, substr (line, 1, 1)) ^= 0
      856 		     then continue = "0"b;		/* stop looping at the first non-whitespace */
      857 		end;				/* of finding next line with a name on it */
      858 
      859 		call compare_line (line, P_string, include, comparison, matched);
      860 						/* see what this line looks like */
      861 
      862 		if comparison = EQUAL
      863 		then goto EQUAL_MATCH;
      864 
      865 		first_char = line_start;		/* remember the index of the first char we look at */
      866 	     end;					/* of marching backward for "prev" comparison */
      867 
      868 	else first_char = try_line_start;		/* remember where we started looking */
      869 
      870 	if comparison = LESS
      871 	then /* reset the bounds */
      872 	     ub = first_char;
      873 	else lb = last_char;
      874 
      875 	if lb <= ub
      876 	then /* go around and try again */
      877 	     goto ITERATE;				/* Yes, I know it's an evil way to loop, but I think */
      878 	else goto FINISH_AND_RETURN;			/* it's actually somewhat clearer this way than it */
      879 						/* would have been with a do while loop */
      880 
      881 EQUAL_MATCH:
      882 	if "1"b
      883 	then do;					/* always scan backwards, just for laughs */
      884 		backward = "1"b;
      885 		continue = "1"b;
      886 
      887 EQUAL_MATCH_RESTART:
      888 		do while (continue);
      889 		     if backward
      890 		     then call prev_line (line_start, line_lth, line_ptr, line_start, line_lth);
      891 		     else call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
      892 		     if line_ptr = null ()
      893 		     then if ^backward
      894 			then signal condition (logic_error);
      895 			else do;
      896 				backward = "0"b;
      897 				goto EQUAL_MATCH_RESTART;
      898 			     end;
      899 
      900 		     if index (FIRST_CH, substr (line, 1, 1)) ^= 0
      901 		     then do;			/* see if this is a match */
      902 			     call compare_line (line, P_string, include, comparison, matched);
      903 			     if comparison ^= EQUAL
      904 			     then do;		/* stop scan in this direction */
      905 				     if backward
      906 				     then backward = "0"b;
      907 				     else if comparison = LESS
      908 				     then goto FINISH_AND_RETURN;
      909 				end;
      910 			     else if ^backward
      911 			     then /* really set, now */
      912 				if ^P_exact | (matched = EXACT)
      913 				then continue = "0"b;
      914 			end;
      915 
      916 		end;				/* of loop to find previous exact match */
      917 	     end;
      918 
      919 FINISH_AND_RETURN:
      920 	P_line_ptr = line_ptr;
      921 	P_line_start = line_start;
      922 	P_line_lth = line_lth;
      923 	P_matched = matched;
      924 
      925 	return;
      926      end find_line;
      927 
      928 /* This procedure compares P_string to the first token on P_line, setting P_comparison
      929*   and P_matching appropriately. It is used to determine what direction to search in next,
      930*   and also when to stop looping through lines. This is the procedure where the knowledge
      931*   of the special effects of ".incl." on the collating sequence is embodied. */
      932 
      933 compare_line:
      934      proc (P_line, P_string, P_include, P_comparison, P_matching);
      935 
      936 	dcl     (
      937 	        P_line		 char (*),
      938 	        P_string		 char (36) varying,
      939 	        P_include		 bit (1) aligned,
      940 	        P_comparison	 fixed bin,
      941 	        P_matching		 fixed bin
      942 	        )			 parameter;
      943 
      944 	dcl     token_lth		 fixed bin;
      945 	dcl     token_ptr		 pointer;
      946 	dcl     token		 char (token_lth) based (token_ptr);
      947 
      948 	dcl     test_lth		 fixed bin;
      949 
      950 	token_lth = search (P_line, WHITESPACE) - 1;	/* find the first token on the line */
      951 	token_ptr = addr (substr (P_line, 1, 1));
      952 	if token_lth < 0
      953 	then /* no trailing delimiter */
      954 	     token_lth = length (P_line);
      955 
      956 	P_matching = MISS;				/* likely this is the case; only set it otherwise if not */
      957 
      958 	if index (token, ".incl.") ^= 0
      959 	then do;					/* we have hit an include file line */
      960 		if ^P_include
      961 		then do;				/* but we are not searching for one, so punt */
      962 			P_comparison = LESS;
      963 			return;
      964 		     end;
      965 	     end;
      966 
      967 	else if substr (token, token_lth, 1) = ":"
      968 	then do;
      969 		P_comparison = LESS;		/* nasty error message at end of file */
      970 		return;
      971 	     end;
      972 
      973 	else do;					/* otherwise, check the opposite */
      974 		if P_include
      975 		then do;				/* include file always after than non-include */
      976 			P_comparison = GREATER;
      977 			return;
      978 		     end;
      979 	     end;
      980 
      981 	test_lth = min (length (token), length (P_string));
      982 
      983 	if substr (P_string, 1, test_lth) > substr (token, 1, test_lth)
      984 	then P_comparison = GREATER;
      985 
      986 	else if substr (P_string, 1, test_lth) < substr (token, 1, test_lth)
      987 	then P_comparison = LESS;
      988 
      989 	else if token_lth < length (P_string)
      990 	then /* short token is always greater than string */
      991 	     P_comparison = GREATER;
      992 
      993 	else do;					/* they compare equal */
      994 		if length (token) = length (P_string)
      995 		then /* if strings are identical */
      996 		     P_matching = EXACT;
      997 		else P_matching = PARTIAL;
      998 
      999 		P_comparison = EQUAL;
     1000 	     end;
     1001 
     1002 	return;
     1003      end compare_line;
     1004 
     1005 /* This procedure prints out formatted information for a single entry. It is given the
     1006*   location of the line containins the first reference to the entry. */
     1007 
     1008 process_entry:
     1009      proc (P_entry_idx, P_line_start, P_line_ptr, P_line_lth);
     1010 
     1011 	dcl     (
     1012 	        P_entry_idx		 fixed bin,
     1013 	        P_line_start	 fixed bin (30),
     1014 	        P_line_ptr		 pointer,
     1015 	        P_line_lth		 fixed bin (21)
     1016 	        )			 parameter;
     1017 
     1018 	dcl     line_start		 fixed bin (30);
     1019 	dcl     line_ptr		 pointer;
     1020 	dcl     line_lth		 fixed bin (21);
     1021 	dcl     line		 char (line_lth) based (line_ptr);
     1022 
     1023 	dcl     name_starname	 char (32);
     1024 	dcl     ep_starname		 char (32);
     1025 	dcl     name		 char (36) varying;
     1026 	dcl     ep		 char (36) varying;
     1027 
     1028 	dcl     n_entrypoints	 fixed bin (17);
     1029 	dcl     header_bumf		 char (64) varying;
     1030 	dcl     out_str		 char (1000) varying;
     1031 	dcl     include		 bit (1) aligned;
     1032 	dcl     comparison		 fixed bin (17);
     1033 	dcl     matched		 fixed bin (17);
     1034 	dcl     ep_scanning		 bit (1) aligned;
     1035 	dcl     exact_match		 bit (1) aligned;
     1036 	dcl     i1		 fixed bin (21);
     1037 	dcl     seg_name		 char (32);
     1038 	dcl     synonym		 bit (1) aligned;
     1039 	dcl     processing_synonym	 bit (1) aligned;
     1040 	dcl     syn_name		 char (32);
     1041 	dcl     saved_line_start	 fixed bin (30);
     1042 	dcl     saved_line_lth	 fixed bin (21);
     1043 	dcl     match		 fixed bin (17);
     1044 	dcl     len		 fixed bin (21);
     1045 	dcl     pos		 fixed bin (21);
     1046 
     1047 
     1048 	line_start = P_line_start;
     1049 	line_ptr = P_line_ptr;
     1050 	line_lth = P_line_lth;
     1051 
     1052 	n_entrypoints = 0;
     1053 	out_str = "";
     1054 	header_bumf = "FOO!";
     1055 	processing_synonym = "0"b;
     1056 
     1057 	name = substr (entry.name (P_entry_idx), 1, entry.non_star_lth (P_entry_idx));
     1058 	name_starname = entry.name (P_entry_idx);
     1059 	exact_match = (length (name) = length (entry.name (P_entry_idx)));
     1060 	include = entry.include (P_entry_idx);
     1061 	ep, ep_starname = entry.ep (P_entry_idx);
     1062 
     1063 /* set up to read the ----- bumf line */
     1064 
     1065 TRY_SYNONYM:
     1066 	call prev_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1067 	ep_scanning = "0"b;				/* no call to look at entrypoint lines yet */
     1068 
     1069 	do while (line_ptr ^= null ());		/* loop through the lines, looking for things to print */
     1070 
     1071 	     if index (FIRST_CH, substr (line, 1, 1)) ^= 0
     1072 	     then do;				/* extract segment name */
     1073 		     call compare_line (line, name, include, comparison, matched);
     1074 						/* is this line interesting? */
     1075 		     if comparison ^= EQUAL
     1076 		     then /* no longer equal */
     1077 			goto FINISHED;		/* the first of these comparisons will always be spurious */
     1078 		     else if (matched ^= EXACT) & exact_match
     1079 		     then /* we've run out of candidates, even */
     1080 			goto FINISHED;
     1081 
     1082 		     ep_scanning, questionable_module, synonym = "0"b;
     1083 		     i1 = search (line, WHITESPACE);
     1084 		     if i1 = 0
     1085 		     then seg_name = line;
     1086 		     else do;
     1087 			     seg_name = substr (line, 1, i1 - 1);
     1088 			     if index (substr (line, i1 + 1), "(?)") ^= 0
     1089 			     then questionable_module = "1"b;
     1090 			     else if index (substr (line, i1 + 1), "SEE:") ^= 0
     1091 			     then synonym = "1"b;
     1092 			end;
     1093 
     1094 		     if ^exact_match
     1095 		     then do;
     1096 			     call match_star_name_ (seg_name, name_starname, code);
     1097 			     if code ^= 0
     1098 			     then goto NEXT_LINE;	/* it doesn't match -- ignore it */
     1099 			end;
     1100 
     1101 		     if include
     1102 		     then call process_include ();	/* well, is it ? */
     1103 		     else if synonym
     1104 		     then do;
     1105 			     if processing_synonym
     1106 			     then do;
     1107 				     call complain (0, WHOAMI, "Nested synonym ^a.", name);
     1108 				     goto MAIN_RETURN;
     1109 				end;
     1110 			     saved_line_start = line_start;
     1111 			     saved_line_lth = line_lth;
     1112 			     syn_name = seg_name;
     1113 			     name, name_starname =
     1114 				ltrim (rtrim (after (substr (line, i1 + 1), ":"), WHITESPACE), WHITESPACE);
     1115 			     call find_line (name, "0"b, "1"b, line_ptr, line_start, line_lth, match);
     1116 			     if (debug & "001"b) ^= ""b
     1117 			     then call ioa_ ("^[Exact^;Partial^;No^] match for synonym ^a line[^d,^d]@^p:^/^a",
     1118 				     match, name, line_start, line_lth, line_ptr, line);
     1119 			     exact_match, processing_synonym = "1"b;
     1120 			     goto TRY_SYNONYM;
     1121 			end;
     1122 		     else do;
     1123 			     if processing_synonym
     1124 			     then seg_name = syn_name;
     1125 			     ep_scanning = "1"b;
     1126 NEXT_LINE:
     1127 			     call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1128 			end;			/* skip the segname line */
     1129 		end;
     1130 
     1131 	     else if ep_scanning & substr (line, 1, 1) = SPACE
     1132 	     then do;				/* see if it's an entrypoint name */
     1133 		     if index (FIRST_CH, substr (line, 2, 1)) ^= 0
     1134 		     then call process_entrypoint ();
     1135 		     else call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1136 		end;
     1137 
     1138 	     else do;
     1139 		     if ^include & (substr (line, 1, 1) = DASH)
     1140 		     then do;			/* must be dat ole debbil --- bumf line */
     1141 			     pos = index (line, "***** ") + 6;
     1142 			     if pos > 6
     1143 			     then do;
     1144 				     len = index (substr (line, pos), " *****") - 1;
     1145 				     if len > 0 then header_bumf = substr (line, pos, len);
     1146 				end;
     1147 			end;
     1148 		     call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1149 		end;
     1150 	end;					/* otherwise, just skip it */
     1151 
     1152 FINISHED:
     1153 	if processing_synonym
     1154 	then do;
     1155 		processing_synonym = "0"b;
     1156 		name = substr (entry.name (P_entry_idx), 1, entry.non_star_lth (P_entry_idx));
     1157 		name_starname = entry.name (P_entry_idx);
     1158 		exact_match = (length (name) = length (entry.name (P_entry_idx)));
     1159 		line_start = saved_line_start;
     1160 		line_lth = saved_line_lth;
     1161 		goto NEXT_LINE;
     1162 	     end;
     1163 
     1164 	if n_entrypoints = 0			/* found nothing there */
     1165 	then if ^brief_error_sw
     1166 	     then call complain (0, WHOAMI, "Not found: ^a^[$^a^]^/", name_starname, (ep_starname ^= ""), ep_starname);
     1167 	     else ;
     1168 	else if ^active_function
     1169 	then call ioa_$nnl ("^a", out_str);		/* all done */
     1170 
     1171 	return;					/* end of code for process_entry */
     1172 
     1173 process_entrypoint:
     1174      proc ();
     1175 
     1176 /* This procedure (internal to process_entry) collects information about a single entrypoint. */
     1177 
     1178 	dcl     (idx, jdx)		 fixed bin (21);
     1179 	dcl     ep_name		 char (32);
     1180 	dcl     caller_name		 char (32) varying;
     1181 
     1182 	dcl     first_on_line	 bit (1) aligned;
     1183 	dcl     questionable_entry	 bit (1) aligned;
     1184 	dcl     header_output	 bit (1) aligned;
     1185 	dcl     obj_name		 char (72) varying;
     1186 	dcl     line_size		 fixed bin (17);
     1187 	dcl     MAX_LINE_SIZE	 fixed bin internal static options (constant) init (72);
     1188 
     1189 
     1190 	idx = search (substr (line, 2), WHITESPACE);
     1191 	ep_name = substr (line, 2, idx - 1);		/* extract the entrypoint name */
     1192 	idx = 1 + idx;
     1193 
     1194 	if ep_starname ^= ""
     1195 	then do;					/* see if we should print this one */
     1196 		call match_star_name_ ((ep_name), ep_starname, code);
     1197 		if code ^= 0
     1198 		then do;				/* it doesn't match -- ignore it */
     1199 			call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1200 			return;			/* get to the beginning of the next line */
     1201 		     end;				/* and return to let it get inspected */
     1202 	     end;
     1203 
     1204 	questionable_entry = "0"b;
     1205 	jdx = index (substr (line, idx), "(?)");
     1206 	if jdx > 0
     1207 	then do;
     1208 		idx = idx + jdx + 3;
     1209 		questionable_entry = ^questionable_module;
     1210 	     end;
     1211 
     1212 	n_entrypoints = n_entrypoints + 1;
     1213 
     1214 	if (ep_name = seg_name)
     1215 	then /* figure out what to call this */
     1216 	     obj_name = rtrim (seg_name);
     1217 	else if (ep_name = "")
     1218 	then obj_name = rtrim (seg_name) || "$";
     1219 	else obj_name = rtrim (seg_name) || "$" || rtrim (ep_name);
     1220 
     1221 	line_size = MAX_LINE_SIZE + 1;		/* force "overflow" for first time through */
     1222 	header_output = "0"b;			/* whether we've commented on this entry yet */
     1223 
     1224 GET_NEXT_TOKEN:
     1225 	if ^active_function
     1226 	then /* If we're gonna be printing this, see if it's too big */
     1227 	     if (length (out_str) + 200 > maxlength (out_str))
     1228 	     then do;				/* time to flush the buffer */
     1229 		     call ioa_$nnl ("^a", out_str);
     1230 		     out_str = "";
     1231 		end;
     1232 
     1233 	if idx >= line_lth
     1234 	then do;					/* get the next line */
     1235 GET_TO_NEXT_LINE:
     1236 		call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1237 
     1238 		if (substr (line, 1, min (2, length (line))) ^= TWO_SPACES) & (substr (line, 1, 1) ^= TAB)
     1239 		then do;
     1240 			if active_function
     1241 			then return;		/* Not gonna say anything */
     1242 
     1243 			if ^header_output
     1244 			then do;			/* whether we have said anything about this entry */
     1245 				if brief_sw
     1246 				then return;
     1247 				out_str = out_str || "No references to ";
     1248 				out_str = out_str || obj_name;
     1249 				out_str = out_str || " (";
     1250 				out_str = out_str || header_bumf;
     1251 				out_str = out_str || ")";
     1252 			     end;
     1253 
     1254 			out_str = out_str || NEWLINE; /* finish it with two newlines */
     1255 			out_str = out_str || NEWLINE; /* watch cretinous pl1 concatenation implementation */
     1256 			return;			/* and return for the next entrypoint */
     1257 		     end;
     1258 
     1259 		idx = 1;				/* start at the beginning */
     1260 	     end;
     1261 
     1262 	jdx = verify (substr (line, idx), WHITESPACE);
     1263 	if jdx = 0
     1264 	then goto GET_TO_NEXT_LINE;
     1265 
     1266 	idx = idx + jdx - 1;			/* first non-white char */
     1267 	jdx = search (substr (line, idx), WHITESPACE) - 1;
     1268 	if jdx < 0
     1269 	then jdx = length (substr (line, idx));
     1270 
     1271 	caller_name = substr (line, idx, jdx);
     1272 
     1273 	if active_function
     1274 	then do;					/* Just add to the return string, and go back for more */
     1275 		if length (return_string) > 0
     1276 		then return_string = return_string || " ";
     1277 		return_string = return_string || caller_name;
     1278 		idx = idx + jdx;
     1279 		goto GET_NEXT_TOKEN;
     1280 	     end;
     1281 
     1282 	if line_size + 2 + length (caller_name) > MAX_LINE_SIZE
     1283 	then do;
     1284 		if ^header_output
     1285 		then do;
     1286 			out_str = out_str || "References to ";
     1287 			out_str = out_str || obj_name;
     1288 			out_str = out_str || ":  (";
     1289 			out_str = out_str || header_bumf;
     1290 			out_str = out_str || ")";
     1291 			if questionable_entry
     1292 			then out_str = out_str || " ** Not Found **";
     1293 			out_str = out_str || NEWLINE;
     1294 			out_str = out_str || copy (SPACE, 4);
     1295 
     1296 			header_output = "1"b;
     1297 		     end;
     1298 
     1299 		else do;
     1300 			out_str = out_str || ",";
     1301 			out_str = out_str || NEWLINE;
     1302 			out_str = out_str || copy (SPACE, 4);
     1303 		     end;
     1304 
     1305 		line_size = 4;
     1306 	     end;
     1307 
     1308 	else if ^first_on_line
     1309 	then do;
     1310 		out_str = out_str || ", ";
     1311 		line_size = line_size + 2;
     1312 	     end;
     1313 
     1314 	out_str = out_str || caller_name;
     1315 	line_size = line_size + length (caller_name);
     1316 	first_on_line = "0"b;
     1317 
     1318 	idx = idx + jdx;				/* get on to next token */
     1319 	goto GET_NEXT_TOKEN;
     1320 
     1321      end process_entrypoint;
     1322 
     1323 process_include:
     1324      proc ();
     1325 
     1326 /* This procedure (internal to process_entry) collects information about a single include file. */
     1327 
     1328 	dcl     (idx, jdx)		 fixed bin (21);
     1329 	dcl     caller_name		 char (32) varying;
     1330 	dcl     first_on_line	 bit (1) aligned;
     1331 	dcl     header_output	 bit (1) aligned;
     1332 	dcl     incl_name		 char (32) varying;
     1333 	dcl     incl_dtcm		 char (40) varying;
     1334 	dcl     line_size		 fixed bin (17);
     1335 	dcl     MAX_LINE_SIZE	 fixed bin internal static options (constant) init (72);
     1336 
     1337 
     1338 	n_entrypoints = n_entrypoints + 1;
     1339 	incl_name = rtrim (seg_name);
     1340 
     1341 	if index (line, "*****") = 0
     1342 	then call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1343 
     1344 	incl_dtcm = substr (line, index (line, "***** ") + 6);
     1345 	incl_dtcm = substr (incl_dtcm, 1, length (incl_dtcm) - 7);
     1346 
     1347 	idx = line_lth;				/* force next_line */
     1348 	line_size = MAX_LINE_SIZE + 1;		/* force "overflow" for first time through */
     1349 	header_output = "0"b;			/* whether we've commented on this entry yet */
     1350 
     1351 GET_NEXT_TOKEN:
     1352 	if ^active_function
     1353 	then /* If we're gonna be printing this, see if it's too big */
     1354 	     if (length (out_str) + 200 > maxlength (out_str))
     1355 	     then do;				/* time to flush the buffer */
     1356 		     call ioa_$nnl ("^a", out_str);
     1357 		     out_str = "";
     1358 		end;
     1359 
     1360 	if idx >= line_lth
     1361 	then do;					/* get the next line */
     1362 GET_TO_NEXT_LINE:
     1363 		call next_line (line_start, line_lth, line_ptr, line_start, line_lth);
     1364 
     1365 		if (substr (line, 1, 2) ^= TWO_TABS)
     1366 		then if header_output
     1367 		     then do;			/* whether we have said anything about this include incarnation */
     1368 			     if active_function
     1369 			     then return;		/* Not gonna say anything */
     1370 
     1371 			     out_str = out_str || NEWLINE;
     1372 						/* add one newline for now */
     1373 			     out_str = out_str || NEWLINE;
     1374 						/* and another for later */
     1375 			     return;		/* and return for the next entrypoint */
     1376 			end;
     1377 
     1378 		idx = 1;				/* start at the beginning */
     1379 	     end;
     1380 
     1381 	jdx = verify (substr (line, idx), WHITESPACE);
     1382 	if jdx = 0
     1383 	then goto GET_TO_NEXT_LINE;
     1384 
     1385 	idx = idx + jdx - 1;			/* first non-white char */
     1386 	jdx = search (substr (line, idx), WHITESPACE) - 1;
     1387 	if jdx < 0
     1388 	then jdx = length (substr (line, idx));
     1389 
     1390 	caller_name = substr (line, idx, jdx);
     1391 
     1392 	if active_function
     1393 	then do;					/* Just add to the return string, and go back for more */
     1394 		if length (return_string) > 0
     1395 		then return_string = return_string || " ";
     1396 		return_string = return_string || caller_name;
     1397 		idx = idx + jdx;
     1398 		header_output = "1"b;		/* Force above logic to terminate properly */
     1399 		goto GET_NEXT_TOKEN;
     1400 	     end;
     1401 
     1402 	if line_size + 2 + length (caller_name) > MAX_LINE_SIZE
     1403 	then do;
     1404 		if ^header_output
     1405 		then do;
     1406 			out_str = out_str || "References to ";
     1407 			out_str = out_str || incl_name;
     1408 			out_str = out_str || ":  (";
     1409 			out_str = out_str || incl_dtcm;
     1410 			out_str = out_str || ")";
     1411 			out_str = out_str || NEWLINE;
     1412 			out_str = out_str || copy (SPACE, 4);
     1413 
     1414 			header_output = "1"b;
     1415 		     end;
     1416 
     1417 		else do;
     1418 			out_str = out_str || ",";
     1419 			out_str = out_str || NEWLINE;
     1420 			out_str = out_str || copy (SPACE, 4);
     1421 		     end;
     1422 
     1423 		line_size = 4;
     1424 	     end;
     1425 
     1426 	else if ^first_on_line
     1427 	then do;
     1428 		out_str = out_str || ", ";
     1429 		line_size = line_size + 2;
     1430 	     end;
     1431 
     1432 	out_str = out_str || caller_name;
     1433 	line_size = line_size + length (caller_name);
     1434 	first_on_line = "0"b;
     1435 
     1436 	idx = idx + jdx;				/* get on to next token */
     1437 	goto GET_NEXT_TOKEN;
     1438 
     1439      end process_include;
     1440 
     1441      end process_entry;
     1442 
     1443 default_input_file:
     1444      procedure;
     1445 
     1446 	if dname ^= ""
     1447 	then return;
     1448 	ename = "";
     1449 
     1450 	call expand_pathname_$add_suffix (DEFAULT_CREF_PATH, SUFFIX, dname, ename, code);
     1451 	if code ^= 0
     1452 	then do;
     1453 		call complain (code, WHOAMI, "Bad default path ^a.", DEFAULT_CREF_PATH);
     1454 		goto MAIN_RETURN;
     1455 	     end;
     1456 
     1457      end default_input_file;
     1458 
     1459      end peruse_crossref;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    09/15/86  1153.2  peruse_crossref.pl1               >spec>install>1153>peruse_crossref.pl1
151          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
153          2    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
DASH                                   constant        char(1)                  initial dcl 121 ref 1139
DEFAULT_CREF_PATH               000024 constant        char(168)                initial unaligned dcl 116 set ref 1450* 1453*
EQUAL                                  constant        fixed bin(17,0)          initial dcl 132 ref 835 862 903 999 1075
EXACT                                  constant        fixed bin(17,0)          initial dcl 138 ref 910 994 1078
FIRST_CH                        000001 constant        char(63)                 initial dcl 119 ref 825 855 900 1071 1133
GREATER                                constant        fixed bin(17,0)          initial dcl 132 ref 976 983 989
LESS                                   constant        fixed bin(17,0)          initial dcl 132 ref 841 870 907 962 969 986
MAX_LINE_SIZE                          constant        fixed bin(17,0)          initial dcl 1335 in procedure "process_include" ref
                                                                                  1348 1402
MAX_LINE_SIZE                          constant        fixed bin(17,0)          initial dcl 1187 in procedure "process_entrypoint"
                                                                                  ref 1221 1282
MISS                                   constant        fixed bin(17,0)          initial dcl 138 ref 956
NEWLINE                         010370 constant        char(1)                  initial dcl 127 ref 571 576 671 677 718 745 1254
                                                                                  1255 1293 1301 1371 1373 1411 1419
PARTIAL                                constant        fixed bin(17,0)          initial dcl 138 ref 997
P_comparison                           parameter       fixed bin(17,0)          dcl 936 set ref 933 962* 969* 976* 983* 986* 989*
                                                                                  999*
P_entry_idx                            parameter       fixed bin(17,0)          dcl 1011 ref 1008 1057 1057 1058 1059 1060 1061 1156
                                                                                  1156 1157 1158
P_exact                                parameter       bit(1)                   dcl 778 ref 775 910
P_idx                                  parameter       fixed bin(30,0)          dcl 651 in procedure "locate_line" set ref 648 666*
P_idx                                  parameter       fixed bin(30,0)          dcl 619 in procedure "locate_char" ref 612 628 628
                                                                                  632
P_include                              parameter       bit(1)                   dcl 778 in procedure "find_line" ref 775 810
P_include                              parameter       bit(1)                   dcl 936 in procedure "compare_line" ref 933 960 974
P_line                                 parameter       char                     unaligned dcl 936 set ref 933 950 951 952
P_line_lth                             parameter       fixed bin(21,0)          dcl 778 in procedure "find_line" set ref 775 922*
P_line_lth                             parameter       fixed bin(21,0)          dcl 1011 in procedure "process_entry" ref 1008 1050
P_line_lth                             parameter       fixed bin(21,0)          dcl 651 in procedure "locate_line" set ref 648 678*
                                                                                  681*
P_line_ptr                             parameter       pointer                  dcl 1011 in procedure "process_entry" ref 1008 1049
P_line_ptr                             parameter       pointer                  dcl 778 in procedure "find_line" set ref 775 919*
P_line_ptr                             parameter       pointer                  dcl 651 in procedure "locate_line" set ref 648 684*
P_line_start                           parameter       fixed bin(30,0)          dcl 651 in procedure "locate_line" set ref 648 683*
P_line_start                           parameter       fixed bin(30,0)          dcl 778 in procedure "find_line" set ref 775 921*
P_line_start                           parameter       fixed bin(30,0)          dcl 1011 in procedure "process_entry" ref 1008 1048
P_matched                              parameter       fixed bin(17,0)          dcl 778 set ref 775 923*
P_matching                             parameter       fixed bin(17,0)          dcl 936 set ref 933 956* 994* 997*
P_message                              parameter       char                     unaligned dcl 493 set ref 490 497*
P_new_line_lth                         parameter       fixed bin(21,0)          dcl 695 set ref 689 719* 722* 727 733* 750* 765*
P_new_line_ptr                         parameter       pointer                  dcl 695 set ref 689 727 733* 757* 762*
P_new_line_start                       parameter       fixed bin(30,0)          dcl 695 set ref 689 727 733* 754* 764*
P_old_line_lth                         parameter       fixed bin(21,0)          dcl 695 ref 689 711 727
P_old_line_start                       parameter       fixed bin(30,0)          dcl 695 ref 689 711 727 730 733 738
P_part_idx                             parameter       fixed bin(17,0)          dcl 619 set ref 612 631* 637*
P_part_offset                          parameter       fixed bin(21,0)          dcl 619 set ref 612 632* 638*
P_string                               parameter       varying char(36)         dcl 936 in procedure "compare_line" ref 933 981 983
                                                                                  986 989 994
P_string                               parameter       varying char(36)         dcl 778 in procedure "find_line" set ref 775 811
                                                                                  833* 859* 902*
R_ACCESS                        000162 constant        bit(3)                   initial unaligned dcl 1-11 set ref 512*
SPACE                                  constant        char(1)                  initial dcl 122 ref 1131 1294 1302 1412 1420
SUFFIX                          000022 constant        char(8)                  initial unaligned dcl 118 set ref 390* 1450*
TAB                             010372 constant        char(1)                  initial dcl 124 ref 1238
TERM_FILE_TERM                  000145 constant        bit(3)                   initial unaligned dcl 2-14 set ref 306*
TWO_SPACES                      010373 constant        char(2)                  initial dcl 123 ref 1238
TWO_TABS                        010371 constant        char(2)                  initial dcl 125 ref 1365
WHITESPACE                      000000 constant        char(3)                  initial dcl 129 ref 950 1083 1113 1113 1190 1262
                                                                                  1267 1381 1386
WHOAMI                          000076 constant        char(32)                 initial unaligned dcl 115 set ref 170* 189* 189*
                                                                                  213* 350* 364* 374* 384* 393* 497* 1107* 1164*
                                                                                  1453*
active_fnc_err_                 000010 constant        entry                    external dcl 83 ref 159
active_function                 000116 automatic       bit(1)                   dcl 51 set ref 161* 167* 339 342 1168 1224 1240 1273
                                                                                  1351 1368 1392
addr                                                   builtin function         dcl 146 ref 589 594 684 757 951
after                                                  builtin function         dcl 146 ref 441 1113
al                              001114 automatic       fixed bin(21,0)          dcl 416 in procedure "check_entries" set ref 427*
                                                                                  429 429 438* 440 441 443 495* 497 497
al                              001100 automatic       fixed bin(21,0)          dcl 330 in procedure "process_args" set ref 337* 339
                                                                                  339 339 342 342 344 344 346 346 350 350 355* 356
                                                                                  358 358 360 360 364 364 369* 374 374 378 384 384
                                                                                  390 390 393 393
allocated                 5     000220 automatic       bit(1)                   array level 2 dcl 76 set ref 316 521* 592*
alp                             000100 automatic       pointer                  dcl 43 set ref 174* 337* 355* 369* 427* 438* 495*
ap                              001076 automatic       pointer                  dcl 329 in procedure "process_args" set ref 337* 339
                                                                                  339 339 342 342 344 344 346 346 350 355* 356 358
                                                                                  358 360 360 364 369* 374 378 384 390 393
ap                              001112 automatic       pointer                  dcl 415 in procedure "check_entries" set ref 427*
                                                                                  429 429 438* 440 441 443 495* 497
arg                                    based           char                     unaligned dcl 331 in procedure "process_args" set
                                                                                  ref 339 339 339 342 342 344 344 346 346 350* 356
                                                                                  358 358 360 360 364* 374* 378 384* 390* 393*
arg                                    based           char                     unaligned dcl 417 in procedure "check_entries" set
                                                                                  ref 429 429 440 441 443 497*
argno                           001101 automatic       fixed bin(17,0)          dcl 332 in procedure "process_args" set ref 336*
                                                                                  337* 348 354* 354 355* 362 368* 368 369* 399*
argno                                  based           fixed bin(17,0)          array level 2 in structure "entry" dcl 68
                                                                                  in procedure "peruse_crossref" set ref 432* 438*
                                                                                  495*
argno                           001115 automatic       fixed bin(17,0)          dcl 418 in procedure "check_entries" set ref 426*
                                                                                  427* 432*
backward                        001262 automatic       bit(1)                   dcl 790 set ref 884* 889 892 896* 905 905* 910
before                                                 builtin function         dcl 146 ref 440
bit                                                    builtin function         dcl 146 ref 356
bitcount                        000204 automatic       fixed bin(24,0)          dcl 58 set ref 210* 223 512* 518 557* 562
brief_error_sw                  000120 automatic       bit(1)                   dcl 53 set ref 334* 344* 358* 1164
brief_sw                        000117 automatic       bit(1)                   dcl 52 set ref 334* 339* 342* 1245
caller_name                     002100 automatic       varying char(32)         dcl 1180 in procedure "process_entrypoint" set ref
                                                                                  1271* 1277 1282 1314 1315
caller_name                     002150 automatic       varying char(32)         dcl 1329 in procedure "process_include" set ref
                                                                                  1390* 1396 1402 1432 1433
char_idx                        001232 automatic       fixed bin(21,0)          dcl 662 in procedure "locate_line" set ref 666* 671
                                                                                  675
char_idx                        001250 automatic       fixed bin(21,0)          dcl 707 in procedure "next_line" set ref 711* 718
                                                                                  719 738* 745 746 748* 748 754 757
check_star_name_$entry          000012 constant        entry                    external dcl 84 ref 463 482
cleanup                         001020 stack reference condition                dcl 144 ref 185
code                            000102 automatic       fixed bin(35,0)          dcl 44 set ref 155* 157 163 170* 210* 211 213* 225*
                                                                                  390* 391 393* 463* 464 466 468 482* 483 512* 513
                                                                                  547* 548 557* 1096* 1097 1196* 1197 1450* 1451
                                                                                  1453*
com_err_                        000014 constant        entry                    external dcl 85 ref 165 170
comparison                      001277 automatic       fixed bin(17,0)          dcl 804 in procedure "find_line" set ref 833* 835
                                                                                  841 859* 862 870 902* 903 907
comparison                      002023 automatic       fixed bin(17,0)          dcl 1032 in procedure "process_entry" set ref 1073*
                                                                                  1075
complain                        000112 automatic       entry variable           dcl 50 set ref 159* 165* 189 213 350 364 374 384 393
                                                                                  497 1107 1164 1453
component_idx                   001204 automatic       fixed bin(17,0)          dcl 544 set ref 552* 557*
continue                        001276 automatic       bit(1)                   dcl 803 set ref 848* 849 855* 885* 887 910*
copy                                                   builtin function         dcl 146 ref 1294 1302 1412 1420
cu_$af_return_arg               000016 constant        entry                    external dcl 86 ref 155
cu_$arg_list_ptr                000020 constant        entry                    external dcl 87 ref 174
cu_$arg_ptr_rel                 000022 constant        entry                    external dcl 88 ref 337 355 369 427 438 495
debug                           000103 automatic       bit(3)                   dcl 45 set ref 232 235 281 335* 356* 1116
divide                                                 builtin function         dcl 146 ref 518 562 816
dname                           000122 automatic       char(168)                unaligned dcl 56 set ref 181* 210* 213* 213* 382
                                                                                  390* 512* 547* 1446 1450*
ename                           000174 automatic       char(32)                 unaligned dcl 57 set ref 210* 213* 213* 390* 512*
                                                                                  547* 1448* 1450*
entry                                  based           structure                array level 1 unaligned dcl 68 set ref 204 301
entry_idx                       001052 automatic       fixed bin(17,0)          dcl 268 in procedure "print_matches" set ref 274*
                                                                                  275 275 276 277 281 285*
entry_idx                       001143 automatic       fixed bin(17,0)          dcl 423 in procedure "check_entries" set ref 425*
                                                                                  431* 431 432 436* 438 443 446 460 461 474 477* 495
entry_ptr                       000214 automatic       pointer                  dcl 67 set ref 182* 204* 275 275 276 277 281 301 301
                                                                                  432 438 443 446 460 461 474 477 495 1057 1057 1058
                                                                                  1059 1060 1061 1156 1156 1157 1158
ep                              001130 automatic       varying char(36)         dcl 421 in procedure "check_entries" set ref 437*
                                                                                  441* 451 457 461 480 482
ep                       13            based           varying char(36)         array level 2 in structure "entry" dcl 68
                                                                                  in procedure "peruse_crossref" set ref 461* 1061
ep                              001373 automatic       varying char(36)         dcl 1026 in procedure "process_entry" set ref 1061*
ep_name                         002070 automatic       char(32)                 unaligned dcl 1179 set ref 1191* 1196 1214 1217 1219
ep_scanning                     002025 automatic       bit(1)                   dcl 1034 set ref 1067* 1082* 1125* 1131
ep_starname                     001351 automatic       char(32)                 unaligned dcl 1024 set ref 1061* 1164 1164* 1194
                                                                                  1196*
error_table_$badopt             000054 external static fixed bin(35,0)          dcl 107 set ref 374*
error_table_$dirseg             000056 external static fixed bin(35,0)          dcl 107 ref 225
error_table_$noarg              000060 external static fixed bin(35,0)          dcl 107 set ref 189* 350* 364*
error_table_$not_act_fnc        000062 external static fixed bin(35,0)          dcl 107 ref 163
error_table_$too_many_args      000064 external static fixed bin(35,0)          dcl 107 set ref 384*
exact                           001065 automatic       bit(1)                   dcl 270 set ref 276* 279*
exact_match                     002026 automatic       bit(1)                   dcl 1035 set ref 1059* 1078 1094 1119* 1158*
expand_pathname_$add_suffix     000024 constant        entry                    external dcl 89 ref 390 1450
fcb_ptr                         000206 automatic       pointer                  dcl 60 set ref 183* 304 312* 547* 548 557*
first                     3     000220 automatic       fixed bin(30,0)          array level 2 in structure "part" dcl 76
                                                                                  in procedure "peruse_crossref" set ref 519* 600*
                                                                                  602* 602 606 628 632 683 754
first                           001233 automatic       fixed bin(21,0)          dcl 663 in procedure "locate_line" set ref 671* 672
                                                                                  672* 675* 675 677 678 683 684
first_char                      001302 automatic       fixed bin(30,0)          dcl 808 set ref 865* 868* 870
first_entry                     000212 automatic       fixed bin(17,0)          dcl 65 set ref 179* 399 399* 426
first_on_line                   002161 automatic       bit(1)                   dcl 1330 in procedure "process_include" set ref 1426
                                                                                  1434*
first_on_line                   002111 automatic       bit(1)                   dcl 1182 in procedure "process_entrypoint" set ref
                                                                                  1308 1316*
fs_type                         000205 automatic       fixed bin(2,0)           dcl 59 set ref 210* 218
get_system_free_area_           000026 constant        entry                    external dcl 92 ref 176
hcs_$status_minf                000030 constant        entry                    external dcl 93 ref 210
header_bumf                     001406 automatic       varying char(64)         dcl 1029 set ref 1054* 1145* 1250 1289
header_output                   002162 automatic       bit(1)                   dcl 1331 in procedure "process_include" set ref
                                                                                  1349* 1365 1398* 1404 1414*
header_output                   002113 automatic       bit(1)                   dcl 1184 in procedure "process_entrypoint" set ref
                                                                                  1222* 1243 1284 1296*
i1                              001201 automatic       fixed bin(30,0)          dcl 542 in procedure "initiate_msf" set ref 571* 578
                                                                                  582 582 584 586
i1                              001142 automatic       fixed bin(17,0)          dcl 422 in procedure "check_entries" set ref 470*
                                                                                  471 474
i1                              002027 automatic       fixed bin(21,0)          dcl 1036 in procedure "process_entry" set ref 1083*
                                                                                  1084 1087 1088 1090 1113
i2                              001202 automatic       fixed bin(30,0)          dcl 542 set ref 576* 578 584 594 596
idx                             002066 automatic       fixed bin(21,0)          dcl 1178 in procedure "process_entrypoint" set ref
                                                                                  1190* 1191 1192* 1192 1205 1208* 1208 1233 1259*
                                                                                  1262 1266* 1266 1267 1268 1271 1278* 1278 1318*
                                                                                  1318
idx                             001216 automatic       fixed bin(17,0)          dcl 625 in procedure "locate_char" set ref 627* 628
                                                                                  628 631 632*
idx                             002146 automatic       fixed bin(21,0)          dcl 1328 in procedure "process_include" set ref
                                                                                  1347* 1360 1378* 1381 1385* 1385 1386 1387 1390
                                                                                  1397* 1397 1436* 1436
incl_dtcm                       002174 automatic       varying char(40)         dcl 1333 set ref 1344* 1345* 1345 1345 1409
incl_name                       002163 automatic       varying char(32)         dcl 1332 set ref 1339* 1407
include                         001260 automatic       bit(1)                   dcl 788 in procedure "find_line" set ref 810* 833*
                                                                                  859* 902*
include                         001066 automatic       bit(1)                   dcl 271 in procedure "print_matches" set ref 277*
                                                                                  279*
include                         002022 automatic       bit(1)                   dcl 1031 in procedure "process_entry" set ref 1060*
                                                                                  1073* 1101 1139
include                  26            based           bit(1)                   array level 2 in structure "entry" dcl 68
                                                                                  in procedure "peruse_crossref" set ref 277 443*
                                                                                  446* 1060
index                                                  builtin function         dcl 146 ref 339 429 443 571 576 671 677 718 745 825
                                                                                  855 900 958 1071 1088 1090 1133 1141 1144 1205
                                                                                  1341 1344
initiate_file_                  000032 constant        entry                    external dcl 95 ref 512
ioa_                            000040 constant        entry                    external dcl 99 ref 248 251 281 1116
ioa_$nnl                        000042 constant        entry                    external dcl 100 ref 1168 1229 1356
jdx                             002067 automatic       fixed bin(21,0)          dcl 1178 in procedure "process_entrypoint" set ref
                                                                                  1205* 1206 1208 1262* 1263 1266 1267* 1268 1268*
                                                                                  1271 1278 1318
jdx                             002147 automatic       fixed bin(21,0)          dcl 1328 in procedure "process_include" set ref
                                                                                  1381* 1382 1385 1386* 1387 1387* 1390 1397 1436
last                      4     000220 automatic       fixed bin(30,0)          array level 2 dcl 76 set ref 520* 606* 628 814
last_char                       001301 automatic       fixed bin(30,0)          dcl 807 set ref 839* 873
lb                              001263 automatic       fixed bin(30,0)          dcl 792 set ref 813* 816 873* 875
len                             002055 automatic       fixed bin(21,0)          dcl 1044 set ref 1144* 1145 1145
length                                                 builtin function         dcl 146 ref 276 276 448 455 457 477 480 571 578 578
                                                                                  582 584 586 591 596 678 719 811 952 981 981 989
                                                                                  994 994 1059 1059 1158 1158 1224 1238 1268 1275
                                                                                  1282 1315 1345 1351 1387 1394 1402 1433
line                                   based           char                     unaligned dcl 265 in procedure "print_matches" set
                                                                                  ref 281*
line                                   based           char                     unaligned dcl 801 in procedure "find_line" set ref
                                                                                  825 833* 855 859* 900 902*
line                                   based           char                     unaligned dcl 1021 in procedure "process_entry" set
                                                                                  ref 1071 1073* 1083 1084 1087 1088 1090 1113 1116*
                                                                                  1131 1133 1139 1141 1144 1145 1190 1191 1205 1238
                                                                                  1238 1238 1262 1267 1268 1271 1341 1344 1344 1365
                                                                                  1381 1386 1387 1390
line_lth                        001274 automatic       fixed bin(21,0)          dcl 799 in procedure "find_line" set ref 819* 823
                                                                                  825 827* 827* 833 833 839 846* 850* 850* 855 859
                                                                                  859 889* 889* 891* 891* 900 902 902 922
line_lth                        001340 automatic       fixed bin(21,0)          dcl 1020 in procedure "process_entry" set ref 1050*
                                                                                  1065* 1065* 1071 1073 1073 1083 1084 1087 1088
                                                                                  1090 1111 1113 1115* 1116* 1116 1116 1126* 1126*
                                                                                  1131 1133 1135* 1135* 1139 1141 1144 1145 1148*
                                                                                  1148* 1160* 1190 1191 1199* 1199* 1205 1233 1235*
                                                                                  1235* 1238 1238 1238 1262 1267 1268 1271 1341
                                                                                  1341* 1341* 1344 1344 1347 1360 1362* 1362* 1365
                                                                                  1381 1386 1387 1390
line_lth                        001050 automatic       fixed bin(21,0)          dcl 264 in procedure "print_matches" set ref 279*
                                                                                  281* 281 281 285*
line_ptr                        001336 automatic       pointer                  dcl 1019 in procedure "process_entry" set ref 1049*
                                                                                  1065* 1069 1071 1073 1083 1084 1087 1088 1090 1113
                                                                                  1115* 1116* 1116 1126* 1131 1133 1135* 1139 1141
                                                                                  1144 1145 1148* 1190 1191 1199* 1205 1235* 1238
                                                                                  1238 1238 1262 1267 1268 1271 1341 1341* 1344 1344
                                                                                  1362* 1365 1381 1386 1387 1390
line_ptr                        001046 automatic       pointer                  dcl 263 in procedure "print_matches" set ref 279*
                                                                                  281* 281 285*
line_ptr                        001270 automatic       pointer                  dcl 797 in procedure "find_line" set ref 819* 821
                                                                                  825 827* 828 833 843* 850* 851 855 859 889* 891*
                                                                                  892 900 902 919
line_size                       002207 automatic       fixed bin(17,0)          dcl 1334 in procedure "process_include" set ref
                                                                                  1348* 1402 1423* 1429* 1429 1433* 1433
line_size                       002137 automatic       fixed bin(17,0)          dcl 1186 in procedure "process_entrypoint" set ref
                                                                                  1221* 1282 1305* 1311* 1311 1315* 1315
line_start                      001266 automatic       fixed bin(30,0)          dcl 795 in procedure "find_line" set ref 819* 822
                                                                                  827* 827* 839 845* 850* 850* 865 889* 889* 891*
                                                                                  891* 921
line_start                      001044 automatic       fixed bin(30,0)          dcl 262 in procedure "print_matches" set ref 279*
                                                                                  281* 285*
line_start                      001334 automatic       fixed bin(30,0)          dcl 1018 in procedure "process_entry" set ref 1048*
                                                                                  1065* 1065* 1110 1115* 1116* 1126* 1126* 1135*
                                                                                  1135* 1148* 1148* 1159* 1199* 1199* 1235* 1235*
                                                                                  1341* 1341* 1362* 1362*
logic_error                     000000 stack reference condition                dcl 144 ref 892
lth                       2     000220 automatic       fixed bin(21,0)          array level 2 in structure "part" dcl 76
                                                                                  in procedure "peruse_crossref" set ref 248* 315
                                                                                  518* 520 562* 570 575 586* 586 591* 596* 602 606
                                                                                  669 716 743
lth                             001251 automatic       fixed bin(21,0)          dcl 708 in procedure "next_line" set ref 718* 719
                                                                                  722 745* 746 746* 748 750
lth                             001234 automatic       fixed bin(21,0)          dcl 664 in procedure "locate_line" set ref 677* 678
                                                                                  681
ltrim                                                  builtin function         dcl 146 ref 1113
match                           002054 automatic       fixed bin(17,0)          dcl 1043 in procedure "process_entry" set ref 1115*
                                                                                  1116*
match                           001051 automatic       fixed bin(17,0)          dcl 267 in procedure "print_matches" set ref 279*
                                                                                  281*
match_star_name_                000044 constant        entry                    external dcl 101 ref 1096 1196
matched                         001300 automatic       fixed bin(17,0)          dcl 805 in procedure "find_line" set ref 833* 859*
                                                                                  902* 910 923
matched                         002024 automatic       fixed bin(17,0)          dcl 1033 in procedure "process_entry" set ref 1073*
                                                                                  1078
maxlength                                              builtin function         dcl 146 ref 1224 1351
min                                                    builtin function         dcl 146 ref 981 1238
msf_manager_$close              000046 constant        entry                    external dcl 102 ref 312
msf_manager_$get_ptr            000050 constant        entry                    external dcl 103 ref 557
msf_manager_$open               000052 constant        entry                    external dcl 105 ref 547
n_entries                       000213 automatic       fixed bin(17,0)          dcl 66 set ref 180* 200 204 274 301 401* 401 436
n_entrypoints                   001405 automatic       fixed bin(17,0)          dcl 1028 set ref 1052* 1164 1212* 1212 1338* 1338
n_parts                         000216 automatic       fixed bin(17,0)          dcl 75 set ref 177* 247 313 516* 563* 567 601 605
                                                                                  627 814
name                            001116 automatic       varying char(36)         dcl 420 in procedure "check_entries" set ref 440*
                                                                                  448 448 448* 448 455 460 463 470 477
name                            001361 automatic       varying char(36)         dcl 1025 in procedure "process_entry" set ref 1057*
                                                                                  1059 1073* 1107* 1113* 1115* 1116* 1156* 1158
name                      1            based           varying char(36)         array level 2 in structure "entry" dcl 68
                                                                                  in procedure "peruse_crossref" set ref 275 276
                                                                                  281* 460* 1057 1058 1059 1156 1157 1158
name_starname                   001341 automatic       char(32)                 unaligned dcl 1023 set ref 1058* 1096* 1113* 1157*
                                                                                  1164*
nargs                           000104 automatic       fixed bin(17,0)          dcl 46 set ref 155* 187 336 348 362 426
non_star_lth             25            based           fixed bin(17,0)          array level 2 dcl 68 set ref 275 474* 477* 1057 1156
null                                                   builtin function         dcl 146 ref 166 178 182 183 301 304 306 548 555 558
                                                                                  762 828 851 892 1069
obj_name                        002114 automatic       varying char(72)         dcl 1185 set ref 1214* 1217* 1219* 1248 1287
out_str                         001427 automatic       varying char(1000)       dcl 1030 set ref 1053* 1168* 1224 1224 1229* 1230*
                                                                                  1247* 1247 1248* 1248 1249* 1249 1250* 1250 1251*
                                                                                  1251 1254* 1254 1255* 1255 1286* 1286 1287* 1287
                                                                                  1288* 1288 1289* 1289 1290* 1290 1291* 1291 1293*
                                                                                  1293 1294* 1294 1300* 1300 1301* 1301 1302* 1302
                                                                                  1310* 1310 1314* 1314 1351 1351 1356* 1357* 1371*
                                                                                  1371 1373* 1373 1406* 1406 1407* 1407 1408* 1408
                                                                                  1409* 1409 1410* 1410 1411* 1411 1412* 1412 1418*
                                                                                  1418 1419* 1419 1420* 1420 1428* 1428 1432* 1432
part                                   based           char                     unaligned dcl 660 in procedure "locate_line" set ref
                                                                                  671 677 678 684
part                                   based           char                     unaligned dcl 705 in procedure "next_line" set ref
                                                                                  718 719 745 757
part                            000220 automatic       structure                array level 1 dcl 76 in procedure "peruse_crossref"
                                                                                  set ref 510* 553* 554*
part_idx                        000103 automatic       fixed bin(17,0)          dcl 299 in procedure "clean_up" set ref 313* 314 315
                                                                                  316*
part_idx                        001247 automatic       fixed bin(17,0)          dcl 706 in procedure "next_line" set ref 711* 712
                                                                                  715 716 738* 739 742 743 754
part_idx                        001034 automatic       fixed bin(17,0)          dcl 245 in procedure "print_parts" set ref 247* 248*
                                                                                  248 248*
part_idx                        001231 automatic       fixed bin(17,0)          dcl 661 in procedure "locate_line" set ref 666* 668
                                                                                  669 683
part_idx                        001203 automatic       fixed bin(17,0)          dcl 543 in procedure "initiate_msf" set ref 551* 553
                                                                                  554 555 557 558 562 563 564* 564 567* 569 570 574
                                                                                  575 586 586 589 591 592 594 596* 601* 602 602 602*
                                                                                  605* 606 606 606*
part_lth                        001230 automatic       fixed bin(21,0)          dcl 659 in procedure "locate_line" set ref 669* 671
                                                                                  677 678 684
part_lth                        001246 automatic       fixed bin(21,0)          dcl 704 in procedure "next_line" set ref 716* 718
                                                                                  719 743* 745 757
part_ptr                        001226 automatic       pointer                  dcl 658 in procedure "locate_line" set ref 668* 671
                                                                                  677 678 684
part_ptr                        001244 automatic       pointer                  dcl 703 in procedure "next_line" set ref 715* 718
                                                                                  719 742* 745 757
pathname_                       000036 constant        entry                    external dcl 98 ref 213 213
pos                             002056 automatic       fixed bin(21,0)          dcl 1045 set ref 1141* 1142 1144 1145
processing_synonym              002041 automatic       bit(1)                   dcl 1039 set ref 1055* 1105 1119* 1123 1152 1155*
ptr                             000220 automatic       pointer                  array level 2 dcl 76 set ref 178* 248* 306 306* 314
                                                                                  512* 555* 557* 558 569 574 589* 594* 668 715 742
questionable_entry              002112 automatic       bit(1)                   dcl 1183 set ref 1204* 1209* 1291
questionable_module             000121 automatic       bit(1)                   dcl 54 set ref 1082* 1088* 1209
return_string                          based           varying char             dcl 49 set ref 160* 1275 1275* 1275 1277* 1277 1394
                                                                                  1394* 1394 1396* 1396
reverse                                                builtin function         dcl 146 ref 448 571 671 745
rs_lth                          000110 automatic       fixed bin(21,0)          dcl 48 set ref 155* 160 1275 1277 1394 1396
rs_ptr                          000106 automatic       pointer                  dcl 47 set ref 155* 160 166* 1275 1275 1275 1277
                                                                                  1277 1394 1394 1394 1396 1396
rtrim                                                  builtin function         dcl 146 ref 1113 1214 1217 1219 1219 1339
s1                                     based           char                     unaligned dcl 538 in procedure "initiate_msf" ref
                                                                                  571 571 578 582 582 584 586
s1                                     based           char                     unaligned dcl 298 in procedure "clean_up" ref 316
s1l                             001176 automatic       fixed bin(21,0)          dcl 537 in procedure "initiate_msf" set ref 570* 571
                                                                                  571 578 582 582 584 586
s1l                             000102 automatic       fixed bin(21,0)          dcl 297 in procedure "clean_up" set ref 315* 316 316
s1p                             001170 automatic       pointer                  dcl 536 in procedure "initiate_msf" set ref 569* 571
                                                                                  571 578 582 582 584 586
s1p                             000100 automatic       pointer                  dcl 296 in procedure "clean_up" set ref 314* 316
s2                                     based           char                     unaligned dcl 539 set ref 576 578 584 594 596
s2l                             001177 automatic       fixed bin(21,0)          dcl 537 set ref 575* 576 578 584 594 596
s2p                             001172 automatic       pointer                  dcl 536 set ref 574* 576 578 584 594 596
s3                                     based           char                     unaligned dcl 540 set ref 580 582* 584* 589 591
s3l                             001200 automatic       fixed bin(21,0)          dcl 537 set ref 578* 580 580 582 584 589 591
s3p                             001174 automatic       pointer                  dcl 536 set ref 580* 582 584 589 591
saved_line_lth                  002053 automatic       fixed bin(21,0)          dcl 1042 set ref 1111* 1160
saved_line_start                002052 automatic       fixed bin(30,0)          dcl 1041 set ref 1110* 1159
search                                                 builtin function         dcl 146 ref 378 429 470 950 1083 1190 1267 1386
search_name                     001053 automatic       varying char(36)         dcl 269 set ref 275* 276 279*
seg_name                        002030 automatic       char(32)                 unaligned dcl 1037 set ref 1084* 1087* 1096* 1112
                                                                                  1123* 1214 1214 1217 1219 1339
str_lth                         001261 automatic       fixed bin(17,0)          dcl 789 set ref 811*
substr                                                 builtin function         dcl 146 set ref 275 448 578 578 582* 582 582 584*
                                                                                  584 584 586 589 594 596 671 677 678 684 718 719
                                                                                  745 757 825 855 900 951 967 983 983 986 986 1057
                                                                                  1071 1087 1088 1090 1113 1131 1133 1139 1144 1145
                                                                                  1156 1190 1191 1205 1238 1238 1262 1267 1268 1271
                                                                                  1344 1345 1365 1381 1386 1387 1390
syn_name                        002042 automatic       char(32)                 unaligned dcl 1040 set ref 1112* 1123
synonym                         002040 automatic       bit(1)                   dcl 1038 set ref 1082* 1090* 1103
system_area                            based           area(1024)               dcl 63 ref 204 301 316 580
system_area_ptr                 000210 automatic       pointer                  dcl 62 set ref 176* 204 301 316 580
terminate_file_                 000034 constant        entry                    external dcl 97 ref 306
test_lth                        001324 automatic       fixed bin(17,0)          dcl 948 set ref 981* 983 983 986 986
token                                  based           char                     unaligned dcl 946 ref 958 967 981 983 986 994
token_lth                       001320 automatic       fixed bin(17,0)          dcl 944 set ref 950* 952 952* 958 967 967 981 983
                                                                                  986 989 994
token_ptr                       001322 automatic       pointer                  dcl 945 set ref 951* 958 967 981 983 986 994
try                             001265 automatic       fixed bin(30,0)          dcl 793 set ref 816* 819*
try_line_lth                    001275 automatic       fixed bin(21,0)          dcl 799 set ref 823* 846
try_line_ptr                    001272 automatic       pointer                  dcl 797 set ref 821* 843
try_line_start                  001267 automatic       fixed bin(30,0)          dcl 795 set ref 822* 845 868
ub                              001264 automatic       fixed bin(30,0)          dcl 792 set ref 814* 816 870* 875
unspec                                                 builtin function         dcl 146 set ref 510* 553* 554*
verify                                                 builtin function         dcl 146 ref 1262 1381

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
A_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
REW_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SA_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial unaligned dcl 2-12
TERM_FILE_DELETE                       internal static bit(5)                   initial unaligned dcl 2-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial unaligned dcl 2-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial unaligned dcl 2-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial unaligned dcl 2-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial unaligned dcl 2-15
W_ACCESS                               internal static bit(3)                   initial unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
terminate_file_switches                based           structure                level 1 packed unaligned dcl 2-4

NAMES DECLARED BY EXPLICIT CONTEXT.
BAD_XREF                        001001 constant        label                    dcl 213 ref 226 513 548
EQUAL_MATCH                     004125 constant        label                    dcl 881 ref 835 862
EQUAL_MATCH_RESTART             004130 constant        label                    dcl 887 ref 897
FINISHED                        005247 constant        label                    dcl 1152 ref 1075 1078
FINISH_AND_RETURN               004247 constant        label                    dcl 919 ref 851 878 907
GET_NEXT_TOKEN                  005663 constant        label                    dcl 1224 in procedure "process_entrypoint" ref 1279
                                                                                  1319
GET_NEXT_TOKEN                  006471 constant        label                    dcl 1351 in procedure "process_include" ref 1399
                                                                                  1437
GET_TO_NEXT_LINE                005714 constant        label                    dcl 1235 in procedure "process_entrypoint" ref 1263
GET_TO_NEXT_LINE                006522 constant        label                    dcl 1362 in procedure "process_include" ref 1382
ITERATE                         003707 constant        label                    dcl 816 ref 875
LOOK_BACK_INSTEAD               004012 constant        label                    dcl 843 ref 828
MAIN_RETURN                     000720 constant        label                    dcl 193 ref 215 352 366 375 387 394 498 1108 1454
MSF_INITIATED                   003141 constant        label                    dcl 567 ref 558
NEXT_LINE                       005147 constant        label                    dcl 1126 ref 1097 1161
NO_APPROPRIATE_LINE             003661 constant        label                    dcl 762 ref 712 730 739
PATHNAME                        002013 constant        label                    dcl 378 ref 370
RETURN_INDICES                  003645 constant        label                    dcl 754 ref 724 751
TRY_SYNONYM                     004511 constant        label                    dcl 1065 ref 1120
USAGE                           000671 constant        label                    dcl 189 ref 200
bad_entry_format                002647 constant        entry                    internal dcl 490 ref 451 455 457 464 466 471 483
check_entries                   002154 constant        entry                    internal dcl 409 ref 206
clean_up                        001300 constant        entry                    internal dcl 291 ref 185 193
compare_line                    004261 constant        entry                    internal dcl 933 ref 833 859 902 1073
default_input_file              007101 constant        entry                    internal dcl 1443 ref 208
find_line                       003671 constant        entry                    internal dcl 775 ref 279 1115
initiate_msf                    003023 constant        entry                    internal dcl 526 ref 229
initiate_segment                002745 constant        entry                    internal dcl 504 ref 218
locate_char                     003336 constant        entry                    internal dcl 612 ref 666 711 738
locate_line                     003377 constant        entry                    internal dcl 648 ref 733 819
next_line                       003504 constant        entry                    internal dcl 689 ref 827 891 1126 1135 1148 1199
                                                                                  1235 1341 1362
pcref                           000531 constant        entry                    external dcl 39
peruse_crossref                 000522 constant        entry                    external dcl 39
prev_line                       003552 constant        entry                    internal dcl 727 ref 850 889 1065
print_matches                   001153 constant        entry                    internal dcl 257 ref 235
print_parts                     001075 constant        entry                    internal dcl 240 ref 232
process_args                    001421 constant        entry                    internal dcl 324 ref 198
process_entry                   004413 constant        entry                    internal dcl 1008 ref 285
process_entrypoint              005404 constant        entry                    internal dcl 1173 ref 1133
process_include                 006377 constant        entry                    internal dcl 1323 ref 1101

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     10712       11000   10404       10722
Length     11260   10404        66         244     306           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
peruse_crossref                    1868 external procedure  is an external procedure.  
on unit on line 185                  64 on unit               
print_parts                             internal procedure  shares stack frame of external procedure peruse_crossref.  
print_matches                           internal procedure  shares stack frame of external procedure peruse_crossref.  
clean_up                             90 internal procedure  is called by several nonquick procedures.  
process_args                            internal procedure  shares stack frame of external procedure peruse_crossref.  
check_entries                           internal procedure  shares stack frame of external procedure peruse_crossref.  
bad_entry_format                        internal procedure  shares stack frame of external procedure peruse_crossref.  
initiate_segment                        internal procedure  shares stack frame of external procedure peruse_crossref.  
initiate_msf                            internal procedure  shares stack frame of external procedure peruse_crossref.  
locate_char                             internal procedure  shares stack frame of external procedure peruse_crossref.  
locate_line                             internal procedure  shares stack frame of external procedure peruse_crossref.  
next_line                               internal procedure  shares stack frame of external procedure peruse_crossref.  
find_line                               internal procedure  shares stack frame of external procedure peruse_crossref.  
compare_line                            internal procedure  shares stack frame of external procedure peruse_crossref.  
process_entry                           internal procedure  shares stack frame of external procedure peruse_crossref.  
process_entrypoint                      internal procedure  shares stack frame of external procedure peruse_crossref.  
process_include                         internal procedure  shares stack frame of external procedure peruse_crossref.  
default_input_file                      internal procedure  shares stack frame of external procedure peruse_crossref.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
clean_up                 000100 s1p                         clean_up
                         000102 s1l                         clean_up
                         000103 part_idx                    clean_up
peruse_crossref          000100 alp                         peruse_crossref
                         000102 code                        peruse_crossref
                         000103 debug                       peruse_crossref
                         000104 nargs                       peruse_crossref
                         000106 rs_ptr                      peruse_crossref
                         000110 rs_lth                      peruse_crossref
                         000112 complain                    peruse_crossref
                         000116 active_function             peruse_crossref
                         000117 brief_sw                    peruse_crossref
                         000120 brief_error_sw              peruse_crossref
                         000121 questionable_module         peruse_crossref
                         000122 dname                       peruse_crossref
                         000174 ename                       peruse_crossref
                         000204 bitcount                    peruse_crossref
                         000205 fs_type                     peruse_crossref
                         000206 fcb_ptr                     peruse_crossref
                         000210 system_area_ptr             peruse_crossref
                         000212 first_entry                 peruse_crossref
                         000213 n_entries                   peruse_crossref
                         000214 entry_ptr                   peruse_crossref
                         000216 n_parts                     peruse_crossref
                         000220 part                        peruse_crossref
                         001034 part_idx                    print_parts
                         001044 line_start                  print_matches
                         001046 line_ptr                    print_matches
                         001050 line_lth                    print_matches
                         001051 match                       print_matches
                         001052 entry_idx                   print_matches
                         001053 search_name                 print_matches
                         001065 exact                       print_matches
                         001066 include                     print_matches
                         001076 ap                          process_args
                         001100 al                          process_args
                         001101 argno                       process_args
                         001112 ap                          check_entries
                         001114 al                          check_entries
                         001115 argno                       check_entries
                         001116 name                        check_entries
                         001130 ep                          check_entries
                         001142 i1                          check_entries
                         001143 entry_idx                   check_entries
                         001170 s1p                         initiate_msf
                         001172 s2p                         initiate_msf
                         001174 s3p                         initiate_msf
                         001176 s1l                         initiate_msf
                         001177 s2l                         initiate_msf
                         001200 s3l                         initiate_msf
                         001201 i1                          initiate_msf
                         001202 i2                          initiate_msf
                         001203 part_idx                    initiate_msf
                         001204 component_idx               initiate_msf
                         001216 idx                         locate_char
                         001226 part_ptr                    locate_line
                         001230 part_lth                    locate_line
                         001231 part_idx                    locate_line
                         001232 char_idx                    locate_line
                         001233 first                       locate_line
                         001234 lth                         locate_line
                         001244 part_ptr                    next_line
                         001246 part_lth                    next_line
                         001247 part_idx                    next_line
                         001250 char_idx                    next_line
                         001251 lth                         next_line
                         001260 include                     find_line
                         001261 str_lth                     find_line
                         001262 backward                    find_line
                         001263 lb                          find_line
                         001264 ub                          find_line
                         001265 try                         find_line
                         001266 line_start                  find_line
                         001267 try_line_start              find_line
                         001270 line_ptr                    find_line
                         001272 try_line_ptr                find_line
                         001274 line_lth                    find_line
                         001275 try_line_lth                find_line
                         001276 continue                    find_line
                         001277 comparison                  find_line
                         001300 matched                     find_line
                         001301 last_char                   find_line
                         001302 first_char                  find_line
                         001320 token_lth                   compare_line
                         001322 token_ptr                   compare_line
                         001324 test_lth                    compare_line
                         001334 line_start                  process_entry
                         001336 line_ptr                    process_entry
                         001340 line_lth                    process_entry
                         001341 name_starname               process_entry
                         001351 ep_starname                 process_entry
                         001361 name                        process_entry
                         001373 ep                          process_entry
                         001405 n_entrypoints               process_entry
                         001406 header_bumf                 process_entry
                         001427 out_str                     process_entry
                         002022 include                     process_entry
                         002023 comparison                  process_entry
                         002024 matched                     process_entry
                         002025 ep_scanning                 process_entry
                         002026 exact_match                 process_entry
                         002027 i1                          process_entry
                         002030 seg_name                    process_entry
                         002040 synonym                     process_entry
                         002041 processing_synonym          process_entry
                         002042 syn_name                    process_entry
                         002052 saved_line_start            process_entry
                         002053 saved_line_lth              process_entry
                         002054 match                       process_entry
                         002055 len                         process_entry
                         002056 pos                         process_entry
                         002066 idx                         process_entrypoint
                         002067 jdx                         process_entrypoint
                         002070 ep_name                     process_entrypoint
                         002100 caller_name                 process_entrypoint
                         002111 first_on_line               process_entrypoint
                         002112 questionable_entry          process_entrypoint
                         002113 header_output               process_entrypoint
                         002114 obj_name                    process_entrypoint
                         002137 line_size                   process_entrypoint
                         002146 idx                         process_include
                         002147 jdx                         process_include
                         002150 caller_name                 process_include
                         002161 first_on_line               process_include
                         002162 header_output               process_include
                         002163 incl_name                   process_include
                         002174 incl_dtcm                   process_include
                         002207 line_size                   process_include

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ent_var_desc   call_ext_out_desc
call_ext_out        call_int_this       call_int_other      return_mac          signal_op           enable_op
shorten_stack       ext_entry           int_entry           reverse_cs          set_chars_eis       index_chars_eis
any_to_any_truncate_op_alloc_           op_freen_

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
active_fnc_err_               check_star_name_$entry        com_err_                      cu_$af_return_arg
cu_$arg_list_ptr              cu_$arg_ptr_rel               expand_pathname_$add_suffix   get_system_free_area_
hcs_$status_minf              initiate_file_                ioa_                          ioa_$nnl
match_star_name_              msf_manager_$close            msf_manager_$get_ptr          msf_manager_$open
pathname_                     terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$badopt           error_table_$dirseg           error_table_$noarg            error_table_$not_act_fnc
error_table_$too_many_args




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     39 000521       155 000536       157 000552       159 000554       160 000561       161 000562       162 000564
    163 000565       165 000570       166 000574       167 000576       168 000577       170 000600       171 000614
    174 000615       176 000623       177 000632       178 000633       179 000635       180 000636       181 000637
    182 000642       183 000643       185 000644       187 000666       189 000671       193 000720       195 000724
    198 000725       200 000726       204 000730       206 000736       208 000737       210 000740       211 000777
    213 001001       215 001047       218 001050       223 001055       225 001057       226 001062       229 001063
    232 001064       235 001070       238 001074       240 001075       247 001076       248 001105       249 001137
    251 001141       253 001152       257 001153       274 001154       275 001163       276 001203       277 001207
    279 001211       281 001213       285 001272       286 001274       288 001276       291 001277       301 001305
    304 001316       306 001323       309 001356       312 001357       313 001366       314 001377       315 001403
    316 001407       318 001415       321 001420       324 001421       334 001422       335 001424       336 001425
    337 001435       339 001455       342 001511       344 001526       346 001542       348 001552       350 001555
    352 001610       354 001611       355 001612       356 001632       357 001642       358 001643       360 001655
    362 001665       364 001670       366 001723       368 001724       369 001725       370 001745       374 001746
    375 001777       376 002000       378 002001       382 002013       384 002017       387 002052       390 002053
    391 002107       393 002111       394 002142       396 002143       399 002144       401 002150       404 002151
    406 002153       409 002154       425 002155       426 002156       427 002165       429 002205       431 002233
    432 002234       434 002242       436 002244       437 002253       438 002254       440 002277       441 002315
    443 002337       446 002352       448 002356       451 002406       455 002422       457 002433       460 002444
    461 002456       463 002464       464 002512       466 002530       468 002540       470 002542       471 002555
    474 002565       476 002574       477 002575       480 002601       482 002603       483 002627       486 002644
    488 002646       490 002647       495 002660       497 002703       498 002744       504 002745       510 002746
    512 002751       513 003006       516 003010       518 003012       519 003015       520 003017       521 003021
    523 003022       526 003023       547 003024       548 003051       551 003057       552 003061       553 003062
    554 003070       555 003074       557 003077       558 003123       562 003130       563 003133       564 003135
    565 003137       567 003141       569 003151       570 003154       571 003157       574 003174       575 003176
    576 003200       578 003211       580 003221       582 003231       584 003237       586 003252       589 003255
    591 003256       592 003260       594 003262       596 003266       598 003271       600 003274       601 003276
    602 003307       603 003314       605 003316       606 003325       607 003333       609 003335       612 003336
    627 003340       628 003347       631 003360       632 003362       633 003366       635 003367       637 003371
    638 003374       640 003376       648 003377       666 003401       668 003413       669 003417       671 003422
    672 003434       675 003440       677 003444       678 003462       681 003470       683 003472       684 003477
    686 003503       689 003504       711 003506       712 003513       715 003515       716 003520       718 003522
    719 003541       722 003547       724 003551       727 003552       730 003554       733 003560       735 003577
    738 003600       739 003606       742 003610       743 003613       745 003615       746 003627       748 003635
    750 003641       751 003644       754 003645       757 003653       759 003660       762 003661       764 003664
    765 003666       766 003670       775 003671       810 003673       811 003676       813 003701       814 003703
    816 003707       819 003713       821 003715       822 003717       823 003721       825 003723       827 003736
    828 003740       831 003744       833 003745       835 004000       839 004003       841 004007       843 004012
    845 004014       846 004016       848 004020       849 004022       850 004024       851 004026       855 004032
    857 004045       859 004046       862 004101       865 004104       866 004106       868 004107       870 004111
    873 004117       875 004121       878 004124       884 004125       885 004127       887 004130       889 004132
    891 004137       892 004141       896 004153       897 004154       900 004155       902 004167       903 004222
    905 004225       907 004231       909 004233       910 004234       916 004246       919 004247       921 004252
    922 004254       923 004256       925 004260       933 004261       950 004272       951 004305       952 004307
    956 004312       958 004314       960 004322       962 004325       963 004327       965 004330       967 004331
    969 004337       970 004341       974 004342       976 004345       977 004347       981 004350       983 004357
    986 004370       989 004374       994 004402       997 004406       999 004410      1002 004412      1008 004413
   1048 004415      1049 004417      1050 004422      1052 004424      1053 004425      1054 004426      1055 004432
   1057 004433      1058 004454      1059 004461      1060 004465      1061 004467      1065 004511      1067 004514
   1069 004515      1071 004522      1073 004537      1075 004571      1078 004574      1082 004601      1083 004604
   1084 004620      1087 004625      1088 004631      1090 004647      1094 004662      1096 004664      1097 004704
   1101 004706      1103 004713      1105 004715      1107 004717      1108 004747      1110 004750      1111 004752
   1112 004754      1113 004757      1115 005053      1116 005062      1119 005134      1120 005137      1123 005140
   1125 005145      1126 005147      1129 005151      1131 005152      1133 005157      1135 005172      1136 005174
   1139 005175      1141 005203      1142 005213      1144 005215      1145 005233      1148 005244      1150 005246
   1152 005247      1155 005251      1156 005252      1157 005274      1158 005301      1159 005305      1160 005307
   1161 005311      1164 005312      1167 005361      1168 005362      1171 005403      1173 005404      1190 005405
   1191 005422      1192 005426      1194 005427      1196 005433      1197 005457      1199 005461      1200 005463
   1204 005464      1205 005465      1206 005504      1208 005505      1209 005510      1212 005513      1214 005514
   1217 005541      1219 005600      1221 005657      1222 005662      1224 005663      1229 005671      1230 005710
   1233 005711      1235 005714      1238 005716      1240 005733      1243 005736      1245 005740      1247 005743
   1248 005755      1249 005767      1250 006001      1251 006013      1254 006022      1255 006031      1256 006040
   1259 006041      1262 006043      1263 006063      1266 006064      1267 006067      1268 006105      1271 006111
   1273 006120      1275 006122      1277 006134      1278 006147      1279 006151      1282 006152      1284 006157
   1286 006161      1287 006173      1288 006205      1289 006217      1290 006231      1291 006240      1293 006254
   1294 006263      1296 006300      1297 006302      1300 006303      1301 006312      1302 006321      1305 006336
   1306 006340      1308 006341      1310 006343      1311 006355      1314 006357      1315 006371      1316 006373
   1318 006374      1319 006376      1323 006377      1338 006400      1339 006401      1341 006421      1344 006432
   1345 006456      1347 006464      1348 006466      1349 006470      1351 006471      1356 006477      1357 006516
   1360 006517      1362 006522      1365 006524      1368 006533      1371 006536      1373 006545      1375 006554
   1378 006555      1381 006557      1382 006577      1385 006600      1386 006603      1387 006621      1390 006625
   1392 006634      1394 006636      1396 006650      1397 006663      1398 006665      1399 006667      1402 006670
   1404 006675      1406 006677      1407 006711      1408 006723      1409 006735      1410 006747      1411 006756
   1412 006765      1414 007002      1415 007004      1418 007005      1419 007014      1420 007023      1423 007040
   1424 007042      1426 007043      1428 007045      1429 007057      1432 007061      1433 007073      1434 007075
   1436 007076      1437 007100      1443 007101      1446 007102      1448 007107      1450 007112      1451 007142
   1453 007144      1454 007173      1457 007174


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
