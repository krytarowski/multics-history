	COMPILATION LISTING OF SEGMENT bk_output
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/30/87  1121.9 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(86-01-01,GWMay), approve(), audit(), install():
       14*     old history comments.
       15*     Coded February 1969, R C Daley.
       16*     25 March 1970, R H Campbell.
       17*     9/77 by Noel I. Morris to use tape_mult_.
       18*     11/9/77 by Steve Herbst
       19*     Changed to call command_query_ for tape labels 02/28/80 S. Herbst
       20*     17 October 1980 by G. Palter to use preattached switches if requested.
       21*     Fixed to retry correctly after open fails 06/02/81 S. Herbst
       22*     84Feb01 by Art Beattie to allow longer tape labels to be used.
       23*     1984-03-25, BIM: Use async mode in tape_mult_
       24*     9 May 1985 by G. Palter to not try error_count/unmounts for preattached
       25*     switches.
       26*  2) change(86-06-05,GWMay), approve(86-07-07,MCR7445), audit(86-11-20,GDixon),
       27*     install(86-11-21,MR12.0-1223):
       28*     Moved call for "error_count" tally out of the write loop in wrbufout. The
       29*     result will be that the tape will continue to spin until the entire buffer
       30*     is emptied rather that synchonizing after each write. This should improve
       31*     dump time.
       32*     MCR7320 - added a command loop so that the operator may enter a new tape
       33*     label id after a bad mount.  This way if the wrong tape gets mounted, the
       34*     operator can deny the mount and give a correct tape id without stopping
       35*     the dump.
       36*                                                   END HISTORY COMMENTS */
       37 
       38 
       39 /* format: style2,idind30,indcomtxt */
       40 
       41 bk_output:
       42      procedure;
       43 
       44 	dcl     uptr		        ptr;	/* ptr to user seg, or junk if we get a fault */
       45 	dcl     temp		        fixed bin,	/* Temporary storage. */
       46 	        code		        fixed bin (35),
       47 	        attach_descrip	        char (168),
       48 	        buffer		        pointer,	/* Pointer to output line buffer. */
       49 	        line		        character (132);
       50 						/* Output line buffer. */
       51 
       52 	dcl     answer		        char (64) aligned varying;
       53 
       54 	dcl     (primary_dump_tape, secondary_dump_tape)
       55 				        static character (64),
       56 						/* Tape labels. */
       57 	        (iocbp1, iocbp2)	        ptr static,
       58 	        mounted		        static bit (1) initial (""b),
       59 						/* Flag to show tape mounted. */
       60 	        two_tapes		        bit (1) static,
       61 	        blanks		        char (4) static init (""),
       62 						/* To reset tape label */
       63 	        s			        character (1) static;
       64 						/* To make comments plural. */
       65 
       66 	dcl     1 header		        static,	/* Backup logical record header */
       67 		2 zz1		        character (32) initial (" z z z z z z z z z z z z z z z z"),
       68 		2 english		        character (56)
       69 				        initial ("This is the beginning of a backup logical record."),
       70 		2 zz2		        character (32) initial (" z z z z z z z z z z z z z z z z"),
       71 		2 hdrcnt		        fixed binary,
       72 		2 segcnt		        fixed binary;
       73 
       74 	dcl     end_of_tape_encountered       static options (constant) char (24) initial ("End of tape encountered.");
       75 
       76 	declare parse_tape_reel_name_	        entry (char (*), char (*)),
       77 	        backup_map_$error_line        entry options (variable),
       78 	        backup_map_$fs_error_line     entry (fixed bin (35), char (*), char (*), char (*)),
       79 	        (
       80 	        backup_map_$on_line,
       81 	        backup_map_$tapes
       82 	        )			        entry (pointer, fixed binary);
       83 
  1     1 /* --------------- BEGIN include file iox_dcls.incl.pl1 --------------- */
  1     2 
  1     3 /* Written 05/04/78 by C. D. Tavares */
  1     4 /* Fixed declaration of iox_$find_iocb_n 05/07/80 by R. Holmstedt */
  1     5 /* Modified 5/83 by S. Krupp to add declarations for:  iox_$open_file,
  1     6*     iox_$close_file, iox_$detach and iox_$attach_loud entries. */
  1     7 
  1     8 dcl  iox_$attach_name entry (char (*), pointer, char (*), pointer, fixed bin (35)),
  1     9      iox_$attach_ptr entry (pointer, char (*), pointer, fixed bin (35)),
  1    10      iox_$close entry (pointer, fixed bin (35)),
  1    11      iox_$control entry (pointer, char (*), pointer, fixed bin (35)),
  1    12      iox_$delete_record entry (pointer, fixed bin (35)),
  1    13      iox_$destroy_iocb entry (pointer, fixed bin (35)),
  1    14      iox_$detach_iocb entry (pointer, fixed bin (35)),
  1    15      iox_$err_not_attached entry options (variable),
  1    16      iox_$err_not_closed entry options (variable),
  1    17      iox_$err_no_operation entry options (variable),
  1    18      iox_$err_not_open entry options (variable),
  1    19      iox_$find_iocb entry (char (*), pointer, fixed bin (35)),
  1    20      iox_$find_iocb_n entry (fixed bin, ptr, fixed bin(35)),
  1    21      iox_$get_chars entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    22      iox_$get_line entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    23      iox_$look_iocb entry (char (*), pointer, fixed bin (35)),
  1    24      iox_$modes entry (pointer, char (*), char (*), fixed bin (35)),
  1    25      iox_$move_attach entry (pointer, pointer, fixed bin (35)),
  1    26      iox_$open entry (pointer, fixed bin, bit (1) aligned, fixed bin (35)),
  1    27      iox_$position entry (pointer, fixed bin, fixed bin (21), fixed bin (35)),
  1    28      iox_$propagate entry (pointer),
  1    29      iox_$put_chars entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    30      iox_$read_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    31      iox_$read_length entry (pointer, fixed bin (21), fixed bin (35)),
  1    32      iox_$read_record entry (pointer, pointer, fixed bin (21), fixed bin (21), fixed bin (35)),
  1    33      iox_$rewrite_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    34      iox_$seek_key entry (pointer, char (256) varying, fixed bin (21), fixed bin (35)),
  1    35      iox_$write_record entry (pointer, pointer, fixed bin (21), fixed bin (35)),
  1    36      iox_$open_file entry(ptr, fixed bin, char(*), bit(1) aligned, fixed bin(35)),
  1    37      iox_$close_file entry(ptr, char(*), fixed bin(35)),
  1    38      iox_$detach entry(ptr, char(*), fixed bin(35)),
  1    39      iox_$attach_loud entry(ptr, char(*), ptr, fixed bin(35));
  1    40 
  1    41 dcl (iox_$user_output,
  1    42      iox_$user_input,
  1    43      iox_$user_io,
  1    44      iox_$error_output) external static pointer;
  1    45 
  1    46 /* ---------------- END include file iox_dcls.incl.pl1 ---------------- */
       84 
       85 
       86 	dcl     command_query_	        entry options (variable);
       87 	dcl     ioa_$rsnnl		        entry options (variable);
       88 
       89 	dcl     error_table_$action_not_performed
       90 				        fixed bin (35) ext static,
       91 	        error_table_$dev_nt_assnd     fixed bin (35) ext static,
       92 	        error_table_$device_end       fixed bin (35) ext static;
       93 
       94 
       95 	dcl     (addr, addrel, divide, length, min, null, mod, rtrim, unspec)
       96 				        builtin;
       97 
  2     1 /*	BEGIN INCLUDE FILE query_info.incl.pl1		TAC June 1, 1973 */
  2     2 /*        Renamed to query_info.incl.pl1 and cp_escape_control added, 08/10/78 WOS */
  2     3 /*	version number changed to 4, 08/10/78 WOS */
  2     4 /* Version 5 adds explanation_(ptr len) 05/08/81 S. Herbst */
  2     5 /* Version 6 adds literal_sw, prompt_after_explanation switch 12/15/82 S. Herbst */
  2     6 
  2     7 dcl 1 query_info aligned,				/* argument structure for command_query_ call */
  2     8     2 version fixed bin,				/* version of this structure - must be set, see below */
  2     9     2 switches aligned,                                     /* various bit switch values */
  2    10       3 yes_or_no_sw bit (1) unaligned init ("0"b),		/* not a yes-or-no question, by default */
  2    11       3 suppress_name_sw bit (1) unaligned init ("0"b),	/* do not suppress command name */
  2    12       3 cp_escape_control bit (2) unaligned init ("00"b),   /* obey static default value */
  2    13                                                             /* "01" -> invalid, "10" -> don't allow, "11" -> allow */
  2    14       3 suppress_spacing bit (1) unaligned init ("0"b),     /* whether to print extra spacing */
  2    15       3 literal_sw bit (1) unaligned init ("0"b),		/* ON => do not strip leading/trailing white space */
  2    16       3 prompt_after_explanation bit (1) unaligned init ("0"b),  /* ON => repeat question after explanation */
  2    17       3 padding bit (29) unaligned init (""b),		/* pads it out to t word */
  2    18     2 status_code fixed bin (35) init (0),		/* query not prompted by any error, by default */
  2    19     2 query_code fixed bin (35) init (0),		/* currently has no meaning */
  2    20 
  2    21 /*  Limit of data defined for version 2 */
  2    22 
  2    23     2 question_iocbp ptr init (null ()),		/* IO switch to write question */
  2    24     2 answer_iocbp ptr init (null ()),			/* IO switch to read answer */
  2    25     2 repeat_time fixed bin (71) init (0),		/* repeat question every N seconds if no answer */
  2    26 						/* minimum of 30 seconds required for repeat */
  2    27 						/* otherwise, no repeat will occur */
  2    28 /* Limit of data defined for version 4 */
  2    29 
  2    30     2 explanation_ptr ptr init (null ()),		/* explanation of question to be printed if */
  2    31     2 explanation_len fixed bin (21) init (0);		/* user answers "?" (disabled if ptr=null or len=0) */
  2    32 
  2    33 dcl  query_info_version_3 fixed bin int static options (constant) init (3);
  2    34 dcl  query_info_version_4 fixed bin int static options (constant) init (4);
  2    35 dcl  query_info_version_5 fixed bin int static options (constant) init (5);
  2    36 dcl  query_info_version_6 fixed bin int static options (constant) init (6); /* the current version number */
  2    37 
  2    38 /*	END INCLUDE FILE query_info.incl.pl1 */
       98 
       99 
  3     1 /* Begin include file ..... iox_modes.incl.pl1 */
  3     2 
  3     3 /* Written by C. D. Tavares, 03/17/75 */
  3     4 /* Updated 10/31/77 by CDT to include short iox mode strings */
  3     5 
  3     6 dcl  iox_modes (13) char (24) int static options (constant) aligned initial
  3     7     ("stream_input", "stream_output", "stream_input_output",
  3     8      "sequential_input", "sequential_output", "sequential_input_output", "sequential_update",
  3     9      "keyed_sequential_input", "keyed_sequential_output", "keyed_sequential_update",
  3    10      "direct_input", "direct_output", "direct_update");
  3    11 
  3    12 dcl  short_iox_modes (13) char (4) int static options (constant) aligned initial
  3    13     ("si", "so", "sio", "sqi", "sqo", "sqio", "squ", "ksqi", "ksqo", "ksqu", "di", "do", "du");
  3    14 
  3    15 dcl (Stream_input initial (1),
  3    16      Stream_output initial (2),
  3    17      Stream_input_output initial (3),
  3    18      Sequential_input initial (4),
  3    19      Sequential_output initial (5),
  3    20      Sequential_input_output initial (6),
  3    21      Sequential_update initial (7),
  3    22      Keyed_sequential_input initial (8),
  3    23      Keyed_sequential_output initial (9),
  3    24      Keyed_sequential_update initial (10),
  3    25      Direct_input initial (11),
  3    26      Direct_output initial (12),
  3    27      Direct_update initial (13)) fixed bin int static options (constant);
  3    28 
  3    29 /* End include file ..... iox_modes.incl.pl1 */
      100 
      101 
  4     1 /* BEGIN INCLUDE FILE ... bk_ss_.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(87-03-03,GWMay), approve(87-03-03,MCR7627), audit(87-03-13,Farley),
  4     6*     install(87-03-30,MR12.1-1018):
  4     7*     added a writing_map switch to indicate when the dump map is being written.
  4     8*                                                   END HISTORY COMMENTS */
  4     9 
  4    10 
  4    11 /* Modified: July 1982 by G. Palter to add data for true AIM support in IMFT */
  4    12 /* Modified: August 1983 by Robert Coren to add minimum access class */
  4    13 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  4    14 
  4    15 /* Hierarchy dumper/reloader static data */
  4    16 
  4    17 dcl (bk_ss_$allow_dir_overwrite bit (1) aligned,		/* ON => allow reloaded seg to overwrite dir */
  4    18      bk_ss_$areap pointer,				/* pointer to list dir area */
  4    19      bk_ss_$brief_mapsw bit (1) aligned,		/* no form-feed for each control file entry */
  4    20      bk_ss_$caller_handles_conditions bit (1) aligned,	/* ON => caller has an any_other handler (for IMFT Daemon) */
  4    21      bk_ss_$control_name char(168),			/* control file path for dumping */
  4    22      bk_ss_$control_ptr pointer,			/* Ptr to control structure for sub entries */
  4    23      bk_ss_$cross_retrievesw bit (1) aligned,		/* ON => cross-retrieving this entry */
  4    24      bk_ss_$data_iocb pointer,			/* IOCB for dumping/reloading if bk_ss_$preattached */
  4    25      bk_ss_$date fixed binary (52),			/* dump all modified since this date */
  4    26      bk_ss_$datesw bit (1) aligned,			/* Flags presence of a date input */
  4    27      bk_ss_$debugsw bit (1) aligned,			/* Flag to prevent calls to hphcs_ */
  4    28      bk_ss_$dir_trim bit (1) aligned,			/* Flag to allow deletion of directories */
  4    29      bk_ss_$dprint_destination char (24),		/* for start_dump and reload, -ds for dprinting maps */
  4    30      bk_ss_$dprint_destination_setsw bit (1) aligned,
  4    31      bk_ss_$dprint_heading char (64),			/* for start_dump and reload, -he for dprinting maps */
  4    32      bk_ss_$dprint_heading_setsw bit (1) aligned,
  4    33      bk_ss_$dprint_queue fixed bin,			/* Queue number for dprinting maps and error files */
  4    34      bk_ss_$dprint_request_type char (24),		/* for start_dump and reload, -rqt for dprinting maps */
  4    35      bk_ss_$dprint_request_type_setsw bit (1) aligned,
  4    36      bk_ss_$dprintsw bit (1) aligned,			/* Whether to dprint maps for start_dump and reload */
  4    37      bk_ss_$dtdsw bit (1) aligned,			/* Flag to check if modified since last dumped */
  4    38      bk_ss_$ename char(32) aligned,			/* Branch entry to dump */
  4    39      bk_ss_$err_label label,				/* Place to go to attempt error recovery */
  4    40      bk_ss_$err_onlinesw bit(1) aligned,		/* Flag error output to be online, default to a file */
  4    41      bk_ss_$error fixed binary,			/* Code for location from which signal expected */
  4    42      bk_ss_$holdsw bit(1) aligned,			/* controls dismounting of tape for dumper */
  4    43      bk_ss_$hp pointer,				/* Pointer to preamble header */
  4    44      bk_ss_$ignore_dates bit (1) aligned,		/* Flag to skip check if have older info on tape */
  4    45      bk_ss_$mapsw bit (1) aligned,			/* Flag map output */
  4    46      bk_ss_$myname char(16),				/* Name by which backup was called */
  4    47      bk_ss_$namesw bit (1) aligned,			/* Flag to dump named branch only */
  4    48      bk_ss_$no_contin bit (1) aligned,			/* Flag to end dump after catchup dump. */
  4    49      bk_ss_$no_output bit (1) aligned,			/* Flag test run or dbugging dumper.  No tape output.*/
  4    50      bk_ss_$no_primary bit (1) aligned,			/* Flag saying do not use primary pathnames */
  4    51      bk_ss_$no_reload bit (1) aligned,			/* Flag debuging reloader.  Do not write in hierarchy. */
  4    52      bk_ss_$no_setlvid bit (1) aligned,			/* Flag to surpress setting of sons lvid on reload */
  4    53      bk_ss_$ntapes fixed bin,				/* number of tape copies for dumper */
  4    54      bk_ss_$onlysw bit (1) aligned,			/* ON => disable hiearchy sweep (dumping) or stop when all
  4    55*						   requests satisfied (loading) */
  4    56      bk_ss_$operator char(32),			/* operator name */
  4    57      bk_ss_$path_index fixed bin,			/* index of entry in backup_control structure */
  4    58      bk_ss_$pathsw bit(1) aligned,			/* starting directory path given to dumper */
  4    59      bk_ss_$preattached bit(1) aligned,			/* ON => caller has setup I/O switch for dumping/reloading */
  4    60      bk_ss_$pvsw  bit(1) aligned,			/* Flag to enable physical volume recovery */
  4    61      bk_ss_$pvname char(32) aligned,			/* Physical volume name */
  4    62      bk_ss_$qchecksw bit(1) aligned,			/* Flag to prevent suspension of quota checking */
  4    63      bk_ss_$quotasw bit(1) aligned,			/* Flag to allow quota setting */
  4    64      bk_ss_$restart_dumpsw bit(1) aligned,		/* restarting complete or catchup from given point */
  4    65      bk_ss_$restart_path char(168) aligned,		/* where to restart complete or catchup dump */
  4    66      bk_ss_$restart_plen fixed bin,			/* length of restart pathname */
  4    67      bk_ss_$retrieval_index fixed bin,			/* Index of entry in bk_retrieve's structure */
  4    68      bk_ss_$retrievesw bit (1) aligned,			/* Flags retrieval */
  4    69      bk_ss_$rlen fixed bin,				/* Length if current restart dir for recursion */
  4    70      bk_ss_$rname char(168),				/* retrieval file name */
  4    71      bk_ss_$rsize fixed bin,				/* length of retrieval file name */
  4    72      bk_ss_$save_path char(168),			/* starting directory for dump */
  4    73      bk_ss_$save_plen fixed bin,			/* length of starting directory name */
  4    74      bk_ss_$save_time fixed bin(52),			/* date, time of start of dump */
  4    75      bk_ss_$segptr pointer,
  4    76      bk_ss_$set_dtd bit (1) aligned,			/* ON to always set dtd when dumping, OFF never */
  4    77      bk_ss_$set_dtd_explicit bit (1) aligned,		/* ON to follow bk_ss_$set_dtd, OFF usual algorithm */
  4    78      bk_ss_$sp pointer,
  4    79      bk_ss_$sub_entry bit(1) aligned,			/* ON for backup_dump_ and backup_load_ */
  4    80      bk_ss_$sub_entry_errfile bit(1) aligned,		/* ON => backup_dump_ and backup_load_ should create error files */
  4    81      bk_ss_$tapesw bit(1) aligned,			/* Flag to indicate tape output */
  4    82      bk_ss_$trimsw bit(1) aligned,			/* Flag to trim directories on reload */
  4    83      bk_ss_$volume_set_name char (32),			/* For future arg -volume_set_name */
  4    84      bk_ss_$wakeup_interval fixed bin(52),		/* interval between wakeups of dumper in micro secs. */
  4    85      bk_ss_$wasnt_known bit(1) aligned,			/* Flag for segment termination */
  4    86      bk_ss_$enforce_max_access_class bit (1) aligned,	/* ON => don't dump anything above give access class */
  4    87      bk_ss_$maximum_access_class bit (72) aligned,	/* the access class to enforce on all branches */
  4    88      bk_ss_$enforce_min_access_class bit (1) aligned,	/* ON => don't dump anything below give access class */
  4    89      bk_ss_$minimum_access_class bit (72) aligned,	/* the minimum access class to enforce on all branches */
  4    90      bk_ss_$dont_dump_upgraded_dirs bit (1) aligned,	/* ON => don't dump any directory above given access class */
  4    91      bk_ss_$maximum_dir_access_class bit (72) aligned,	/* the access class to enforce on directories */
  4    92      bk_ss_$check_effective_access bit (1) aligned,	/* ON => don't dump branches given user can't access */
  4    93      bk_ss_$upgrade_to_user_auth bit (1) aligned,		/* ON => set access class of branch being dumped to user's authorization */
  4    94      bk_ss_$user_id character (32) unaligned,		/* the user's Person.Project.tag */
  4    95      bk_ss_$user_authorization bit (72) aligned,		/* the user's process authorization */
  4    96      bk_ss_$user_ring fixed binary,			/* the user's ring of execution */
  4    97      bk_ss_$restore_access_class bit (1) aligned,		/* ON => restore access class even when debugging */
  4    98      bk_ss_$enforce_minimum_ring bit (1) aligned,		/* ON => don't give anything lower ring bracket */
  4    99      bk_ss_$minimum_ring fixed binary,			/* the minimum ring bracket to be used */
  4   100      bk_ss_$translate_access_class bit (1) aligned,	/* ON => translate access classes read from tape */
  4   101      bk_ss_$source_attributes_ptr pointer,		/* -> source system's AIM attributes */
  4   102      bk_ss_$target_attributes_ptr pointer,		/* -> target system's AIM attributes */
  4   103      bk_ss_$writing_map bit (1) aligned)                    /* ON => in backup_map$try_write */
  4   104 	external static;
  4   105 
  4   106 /* END INCLUDE FILE ... bk_ss_.incl.pl1 */
      102 
      103 
  5     1 /* BEGIN INCLUDE FILE ... backup_control.incl.pl1 */
  5     2 /* Modified: July 1982 by G. Palter to add features for proper support of AIM in IMFT (version 4) */
  5     3 /* Modified: August 1983 by Robert Coren to add minimum access class enforcement */
  5     4 /* Modified: November 1983 by Robert Coren to add "upgrade_to_user_auth" flag */
  5     5 
  5     6 /* Hierarchy dumper/reloader subroutine control structure */
  5     7 
  5     8 dcl 1 backup_control aligned based (backup_control_ptr),
  5     9     2 header,					/* allows people to use like (!) */
  5    10       3 version character (8) unaligned,
  5    11       3 tape_entry entry (character (*)) variable,	/* returns next tape label */
  5    12       3 data_iocb pointer,				/* -> I/O switch to use for dumping/loading if preattached */
  5    13       3 maximum_access_class bit (72) aligned,		/* maximum access class for anything to be dumped */
  5    14       3 minimum_access_class bit (72) aligned,		/* minimum access class for anything to be dumped */
  5    15       3 maximum_dir_access_class bit (72) aligned,	/* no directory above this access class is dumped */
  5    16       3 user_for_access_check,			/* data required to validate user's access */
  5    17         4 id character (32) unaligned,			/* Person.Project.tag */
  5    18         4 authorization bit (72),			/* the user's process authorization */
  5    19         4 ring fixed binary,				/* the user's ring o execution */
  5    20       3 minimum_ring fixed binary,			/* no ring bracket is set below this value */
  5    21       3 aim_translations,				/* data required to translate AIM attributes on the tape */
  5    22         4 source_attributes_ptr pointer,
  5    23         4 target_attributes_ptr pointer,
  5    24       3 options aligned,
  5    25         4 map_sw  bit(1) unaligned,			/* ON to write map segment */
  5    26         4 debug_sw bit (1) unaligned,			/* ON to check quotas and not trim subtrees */
  5    27         4 no_reload_sw bit (1) unaligned,		/* ON to not load for backup_load_ */
  5    28         4 hold_sw bit (1) unaligned,			/* ON to not demount tape afterwards */
  5    29         4 preattached bit (1) unaligned,		/* ON => perform loading/dumping to supplied I/O switch */
  5    30         4 error_file bit (1) unaligned,			/* ON => generate an error file anyway */
  5    31         4 first bit (1) unaligned,			/* ON => for reload, stop after all requests satisfied */
  5    32         4 caller_handles_conditions bit (1) unaligned,	/* ON => caller of backup_dump_ handles faults */
  5    33         4 allow_dir_overwrite bit (1) unaligned,		/* ON => allow reloaded seg to overwrite a dir */
  5    34         4 enforce_max_access_class bit (1) unaligned,	/* ON => do not dump anything above given access class */
  5    35         4 dont_dump_upgraded_dirs bit (1) unaligned,	/* ON => do not dump directories above given access class */
  5    36         4 check_effective_access bit (1) unaligned,	/* ON => do not dump branches specified user can't touch */
  5    37         4 restore_access_class bit (1) unaligned,		/* ON => restore AIM attributes even in debug mode */
  5    38         4 enforce_minimum_ring bit (1) unaligned,		/* ON => do not give anything ring bracket below minimum */
  5    39         4 translate_access_class bit (1) unaligned,	/* ON => translate access classes read from tape */
  5    40         4 enforce_min_access_class bit (1) unaligned,	/* ON => do not dump anything below given access class */
  5    41         4 upgrade_to_user_auth bit (1) unaligned,		/* ON => set access class of branch being dumped to user's authorization */
  5    42         4 pad bit (19) unaligned,
  5    43       3 request_count fixed binary,			/* # of entries to load or dump */
  5    44     2 requests (backup_control_request_count refer (backup_control.request_count)),
  5    45       3 path character (168) unaligned,			/* pathname of object to be dumped/loaded */
  5    46       3 new_path character (168) unaligned,		/* pathname for object when reloading if not same as above */
  5    47       3 switches aligned,
  5    48         4 no_primary_sw bit (1) unaligned,		/* do not use primary pathname */
  5    49         4 trim_sw bit (1) unaligned,			/* trim target directories */
  5    50         4 pad bit (34) unaligned,
  5    51       3 found bit(1) aligned,				/* ON => found on tape by backup_load_ (output) */
  5    52       3 loaded bit (1) aligned,			/* ON => loaded by backup_load_ (output) */
  5    53       3 status_code fixed binary (35),			/* ON => per-entry status code (output) */
  5    54       3 error_name character (65) unaligned;		/* ON => some information about what happened (output) */
  5    55 
  5    56 dcl  backup_control_ptr pointer;
  5    57 
  5    58 dcl backup_control_request_count fixed binary;		/* for allocations */
  5    59 
  5    60 dcl BACKUP_CONTROL_VERSION_5 character (8) static options (constant) initial ("hbc_0005");
  5    61 
  5    62 /* END INCLUDE FILE ... backup_control.incl.pl1 */
      104 
      105 
      106 output_init:
      107      entry (ntapes, wstat);				/* entry to initialize backup output procedure */
      108 	dcl     ntapes		        fixed bin;	/* 1 or 2 tapes */
      109 
      110 	if bk_ss_$no_output
      111 	then do;					/* No output */
      112 		wstat = 0;			/* Error code to zero */
      113 		go to exit;			/* Quit */
      114 	     end;
      115 
      116 	buffer = addr (line);			/* Set up pointer to output line buffer. */
      117 	if bk_ss_$preattached
      118 	then do;					/* caller has requested we use a specific I/O switch */
      119 		mounted = "1"b;			/* make sure I/O gets done */
      120 		two_tapes = "0"b;			/* act as if only a single tape is being made */
      121 		s = " ";
      122 		iocbp1 = bk_ss_$data_iocb;
      123 		wstat = 0;
      124 	     end;
      125 	else if mounted
      126 	then wstat = 0;				/* reset status code */
      127 	else do;					/* Mount a new set of tapes. */
      128 		if ntapes > 1 & ^bk_ss_$sub_entry
      129 		then do;				/* Decide how many tapes to use. */
      130 			two_tapes = "1"b;		/* Use two. */
      131 			s = "s";			/* Make comments plural. */
      132 		     end;
      133 		else if ntapes = 1
      134 		then do;
      135 			two_tapes = ""b;		/* Use one. */
      136 			s = " ";			/* Make comments singular. */
      137 		     end;
      138 		call mount (wstat);			/* mount first dump tape(s) */
      139 	     end;
      140 	if bk_ss_$mapsw
      141 	then /* Are we writing a map? */
      142 	     if wstat = 0
      143 	     then do;				/* Yes, did we succeed in attaching the tape(s)? */
      144 		     if two_tapes
      145 		     then /* Are we writing two tapes? */
      146 			call ioa_$rsnnl ("Primary tape label: ^a, secondary tape label: ^a.", line, temp,
      147 			     primary_dump_tape, secondary_dump_tape);
      148 		     else call ioa_$rsnnl ("Tape label: ^a.", line, temp, primary_dump_tape);
      149 		     call backup_map_$tapes (buffer, temp);
      150 						/* Write the comment in the map. */
      151 		end;
      152 	go to exit;
      153 
      154 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      155 
      156 output_finish:
      157      entry;					/* to terminate backup dump */
      158 
      159 	if bk_ss_$no_output
      160 	then go to exit;				/* No output so quit. */
      161 
      162 	buffer = addr (line);			/* Set up pointer to output line buffer. */
      163 	if bk_ss_$preattached
      164 	then ;					/* nothing to do here */
      165 	else if bk_ss_$holdsw
      166 	then do;
      167 		call iox_$control (iocbp1, "error_count", addr (temp), code);
      168 		if code ^= 0
      169 		then do;				/* All OK? */
      170 flush_error:
      171 			call backup_map_$fs_error_line (code, "bk_output", "", "");
      172 unmo:
      173 			call unmount;		/* Unmount the tape anyway. */
      174 		     end;
      175 		if mounted
      176 		then if two_tapes
      177 		     then do;			/* Is the other tape mounted? */
      178 			     call iox_$control (iocbp2, "error_count", addr (temp), code);
      179 			     if code ^= 0
      180 			     then go to flush_error;	/* OK? */
      181 			end;
      182 	     end;
      183 	else call unmount;				/* unmount any reel(s) still mounted */
      184 	go to exit;
      185 
      186 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      187 
      188 wr_tape:
      189      entry (lblptr, lblcnt, segptr, segcnt, wstat);	/* to write next backup record on tape */
      190 
      191 	dcl     lblptr		        pointer,	/* pointer to preamble area */
      192 	        lblcnt		        fixed binary,
      193 						/* length of preamble in words */
      194 	        segptr		        pointer,	/* pointer to segment (if any) */
      195 	        segcnt		        fixed binary,
      196 						/* length of segment (if any) in words */
      197 	        wstat		        fixed bin (35);
      198 						/* status code (returned) */
      199 
      200 	uptr = segptr;				/* copy this arg so we can mung it if err */
      201 	if bk_ss_$no_output
      202 	then do;					/* No output */
      203 		wstat = 0;			/* Zero error code */
      204 		go to exit;
      205 	     end;
      206 
      207 	if ^mounted
      208 	then do;
      209 		wstat = error_table_$dev_nt_assnd;
      210 		go to exit;
      211 	     end;
      212 	wstat = 0;
      213 	buffer = addr (line);			/* Set up pointer to output line buffer. */
      214 	header.hdrcnt = lblcnt;			/* pick up preamble length */
      215 	header.segcnt = segcnt;			/* and segment length */
      216 retry:
      217 	call wrout (addr (header), 32);		/* write out backup logical record header */
      218 	if code = error_table_$device_end
      219 	then go to enderr;				/* Check end of reel */
      220 	if code ^= 0
      221 	then go to tsterr;
      222 	temp = header.hdrcnt + 32 + 255;		/* adjust to write preamble thru next higher block */
      223 	temp = temp - mod (temp, 256) - 32;		/* 32 words are already written. */
      224 	call wrout (lblptr, temp);			/* write out preamble thru next higher 256-word block */
      225 	if code = error_table_$device_end
      226 	then go to enderr;				/* Check end of reel */
      227 	if code ^= 0
      228 	then go to tsterr;
      229 	if header.segcnt > 0
      230 	then do;					/* Is there any segment to write? */
      231 		temp = header.segcnt;
      232 		call wrbufout (uptr, temp);		/* write out segment thru next higher 256-word block */
      233 		if code = error_table_$device_end
      234 		then go to enderr;			/* Check end of reel */
      235 		if code ^= 0
      236 		then go to tsterr;
      237 	     end;
      238 exit:
      239 	return;					/* exit to caller */
      240 enderr:
      241 	call backup_map_$on_line (addr (end_of_tape_encountered), length (end_of_tape_encountered));
      242 	go to unm;				/* Go get new reel */
      243 tsterr:
      244 	call backup_map_$fs_error_line (code, "bk_output", "", "");
      245 
      246 unm:
      247 	if bk_ss_$preattached
      248 	then do;					/* preattached => not using tapes => can't unmount anything */
      249 		wstat = code;
      250 		go to exit;
      251 	     end;
      252 
      253 	call unmount;				/* unmount current tape(s) */
      254 	call output_init (-1, wstat);			/* mount next reel(s) */
      255 	if wstat = 0
      256 	then go to retry;
      257 	go to exit;				/* go to exit to caller on operator message */
      258 
      259 get_label:
      260      procedure (type, label, Squit_the_dump);		/* Procedure to read label typed on console. */
      261 	dcl     type		        character (*),
      262 						/* Type of tape (primary or secondary). */
      263 	        label		        character (64),
      264 						/* The label. */
      265 	        Squit_the_dump	        bit (1) aligned;
      266 
      267 
      268 	Squit_the_dump = "0"b;
      269 	unspec (query_info) = "0"b;
      270 	query_info.version = query_info_version_4;
      271 	query_info.suppress_name_sw = "1"b;
      272 	query_info.question_iocbp, query_info.answer_iocbp = null;
      273 	call command_query_ (addr (query_info), answer, bk_ss_$myname, "Type ^a dump tape label:", type);
      274 	label = answer;
      275 
      276 	if label = "quit" | label = "q"
      277 	then Squit_the_dump = "1"b;
      278 
      279 	else do;
      280 		if ^bk_ss_$debugsw
      281 		then /* caller wants privilege */
      282 		     label = rtrim (label) || ",sys";
      283 	     end;
      284 	return;
      285      end get_label;
      286 
      287 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      288 
      289 mount:
      290      procedure (mount_status);			/* internal procedure to mount first or next reel(s) */
      291 	dcl     mount_status	        fixed bin (35);
      292 	dcl     Squit_the_dump	        bit (1) aligned;
      293 
      294 	mount_status = 0;
      295 	mounted = "0"b;
      296 	Squit_the_dump = "0"b;
      297 	iocbp1, iocbp2 = null;
      298 
      299 	do while (^mounted & ^Squit_the_dump);
      300 	     if bk_ss_$sub_entry
      301 	     then /* get first tape label from tape_entry */
      302 		call bk_ss_$control_ptr -> backup_control.tape_entry (primary_dump_tape);
      303 	     else /* else read it from the terminal */
      304 		call get_label ("primary", primary_dump_tape, Squit_the_dump);
      305 
      306 	     call mount_tape (Squit_the_dump, iocbp1, "bk_output_1", primary_dump_tape, mount_status);
      307 	end;					/* Do we need another tape? */
      308 	if two_tapes & mounted & mount_status = 0
      309 	then do;
      310 		mounted = "0"b;
      311 		do while (^mounted & ^Squit_the_dump);
      312 		     call get_label ("secondary", secondary_dump_tape, Squit_the_dump);
      313 
      314 		     call mount_tape (Squit_the_dump, iocbp2, "bk_output_2", secondary_dump_tape, mount_status);
      315 		end;
      316 	     end;
      317 	return;
      318 
      319 
      320 mount_tape:
      321      proc (Squit, Piocb, switch_name, tape_id, code);
      322 
      323 	dcl     Squit		        bit (1) aligned,
      324 	        Piocb		        ptr,
      325 	        switch_name		        char (11),
      326 	        tape_id		        char (64),
      327 	        code		        fixed bin (35);
      328 
      329 	code = 0;
      330 
      331 	if Squit
      332 	then do;
      333 		code = error_table_$action_not_performed;
      334 		call backup_map_$error_line (code, "bk_output", "Aborted tape mount.");
      335 		if iocbp1 ^= null
      336 		then do;
      337 			call iox_$close (iocbp1, (0));
      338 			call iox_$detach_iocb (iocbp1, (0));
      339 		     end;
      340 		return;
      341 	     end;
      342 
      343 	call parse_tape_reel_name_ (tape_id, attach_descrip);
      344 	call iox_$attach_name (switch_name, Piocb, "tape_mult_ " || attach_descrip || " -write", null (), code);
      345 						/* null refptr to use user-supplied tape_mult_ */
      346 	if code ^= 0
      347 	then call backup_map_$fs_error_line (code, "bk_output", tape_id, "");
      348 	else do;
      349 		call iox_$open (Piocb, Stream_output, "0"b, code);
      350 		if code = 0
      351 		then mounted = "1"b;
      352 		else do;
      353 			call backup_map_$fs_error_line (code, "bk_output", tape_id, "");
      354 			code = 0;
      355 			call iox_$detach_iocb (Piocb, code);
      356 			if code ^= 0
      357 			then call backup_map_$fs_error_line (code, "bk_output", tape_id, "");
      358 		     end;
      359 	     end;
      360 	if code = 0
      361 	then call iox_$modes (Piocb, "async", (""), (0));
      362 
      363 	return;
      364      end mount_tape;
      365      end mount;
      366 
      367 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      368 
      369 wrbufout:
      370      proc (wrptr, wrcnt);				/* internal proc to write user seg to tape */
      371 	dcl     wrptr		        ptr;
      372 	dcl     wrcnt		        fixed bin;
      373 	dcl     ttbuf		        (words_to_write) fixed bin (35) aligned based;
      374 	dcl     zzbuf		        (1024) fixed bin (35) aligned based;
      375 	dcl     xptr		        ptr;
      376 	dcl     words_to_go		        fixed bin;
      377 	dcl     words_to_write	        fixed bin;
      378 	dcl     save_err_label	        label;
      379 	dcl     EC		        fixed bin (35);
      380 						/* control order puts count of errors here */
      381 
      382 	save_err_label = bk_ss_$err_label;		/* remember err recovery location */
      383 	bk_ss_$err_label = wbo_clean;			/* and set up to recover here */
      384 
      385 	words_to_go = wrcnt;
      386 wbo_retry:					/* come here from wbo_clean */
      387 	xptr = wrptr;
      388 	do while (words_to_go > 0);
      389 
      390 	     words_to_write = min (1024, words_to_go);	/* one page at most */
      391 						/* then copy a page of users seg */
      392 	     if wrptr ^= bk_ss_$sp
      393 	     then do;				/* if not already recovering from an error */
      394 		     if words_to_write ^= 1024
      395 		     then /* if not copying whole page */
      396 			unspec (bk_ss_$sp -> zzbuf) = ""b;
      397 						/* clear the buffer */
      398 		     bk_ss_$error = 9;		/* then copy the user's page */
      399 		     bk_ss_$sp -> ttbuf = xptr -> ttbuf;/* if fault then will go to wbo_clean */
      400 		     bk_ss_$error = 0;		/* make faults fatal again */
      401 		end;
      402 
      403 	     words_to_write = 256 * divide (words_to_write + 255, 256, 17, 0);
      404 						/* write mod 256 */
      405 	     call iox_$put_chars (iocbp1, bk_ss_$sp, words_to_write * 4, code);
      406 	     if two_tapes & code = 0			/* two_tapes is only true when not preattached */
      407 	     then call iox_$put_chars (iocbp2, bk_ss_$sp, words_to_write * 4, code);
      408 	     if code ^= 0
      409 	     then go to wbo_ret;
      410 
      411 	     xptr = addrel (xptr, words_to_write);	/* step thru user's seg */
      412 	     words_to_go = words_to_go - words_to_write;	/* account for stuff just written */
      413 	end;
      414 
      415 wbo_ret:
      416 	if ^bk_ss_$preattached & (code = 0)		/* preattached => not using tapes => no error_count order */
      417 	then do;
      418 		call iox_$control (iocbp1, "error_count", addr (EC), code);
      419 
      420 		if two_tapes & code = 0
      421 		then call iox_$control (iocbp2, "error_count", addr (EC), code);
      422 	     end;
      423 
      424 	bk_ss_$err_label = save_err_label;		/* restore error recovery location */
      425 	return;					/* and return */
      426 
      427 wbo_clean:					/* This handles faults taken on user's seg */
      428 	unspec (bk_ss_$sp -> zzbuf) = ""b;		/* clear it */
      429 	wrptr = bk_ss_$sp;				/* Forget user seg, set flag thatwr're recovering */
      430 	bk_ss_$err_label = save_err_label;		/* We are no longer interested in faults */
      431 
      432 	go to wbo_retry;				/* Go write zeroes onto tape as needed */
      433 
      434      end wrbufout;
      435 
      436 /* -------------------------------------------------------- */
      437 
      438 wrout:
      439      procedure (wrptr, wrcnt);			/* internal procedure to write on current tape(s) */
      440 	dcl     wrptr		        pointer,	/* write workspace pointer */
      441 	        wrcnt		        fixed binary;
      442 						/* no. of words to write */
      443 	call iox_$put_chars (iocbp1, wrptr, wrcnt * 4, code);
      444 	if two_tapes
      445 	then if code = 0
      446 	     then /* Even if two don't bother if previous in error. */
      447 		call iox_$put_chars (iocbp2, wrptr, wrcnt * 4, code);
      448 						/* Write second tape. */
      449      end wrout;
      450 
      451 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */
      452 
      453 unmount:
      454      procedure;					/* internal procedure to unmount current reel(s) */
      455 	if ^mounted
      456 	then return;
      457 
      458 	call iox_$close (iocbp1, code);
      459 	if code ^= 0
      460 	then call backup_map_$fs_error_line (code, "bk_output", primary_dump_tape, "");
      461 	call iox_$detach_iocb (iocbp1, code);
      462 	if code ^= 0
      463 	then call backup_map_$fs_error_line (code, "bk_output", primary_dump_tape, "");
      464 	if two_tapes
      465 	then do;					/* Is another tape attached? */
      466 		call iox_$close (iocbp2, code);
      467 		if code ^= 0
      468 		then /* Give error comment if close not OK. */
      469 		     call backup_map_$fs_error_line (code, "bk_output", secondary_dump_tape, "");
      470 		call iox_$detach_iocb (iocbp2, code);
      471 		if code ^= 0
      472 		then /* Give error comment if detach not OK. */
      473 		     call backup_map_$fs_error_line (code, "bk_output", secondary_dump_tape, "");
      474 	     end;
      475 	call backup_map_$tapes (addr (blanks), 4);	/* Reset label info in map header */
      476 	mounted = "0"b;
      477 	iocbp1, iocbp2 = null;
      478 
      479      end unmount;
      480      end bk_output;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/30/87  1054.1  bk_output.pl1                     >special_ldd>install>MR12.1-1018>bk_output.pl1
84           1    05/23/83  0916.6  iox_dcls.incl.pl1                 >ldd>include>iox_dcls.incl.pl1
98           2    03/11/83  1204.3  query_info.incl.pl1               >ldd>include>query_info.incl.pl1
100          3    02/02/78  1229.7  iox_modes.incl.pl1                >ldd>include>iox_modes.incl.pl1
102          4    03/30/87  1052.4  bk_ss_.incl.pl1                   >special_ldd>install>MR12.1-1018>bk_ss_.incl.pl1
104          5    11/21/83  1219.2  backup_control.incl.pl1           >ldd>include>backup_control.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
EC                              000324 automatic       fixed bin(35,0)          dcl 379 set ref 418 418 420 420
Piocb                                  parameter       pointer                  dcl 323 set ref 320 344* 349* 355* 360*
Squit                                  parameter       bit(1)                   dcl 323 ref 320 331
Squit_the_dump                  000276 automatic       bit(1)                   dcl 292 in procedure "mount" set ref 296* 299 303*
                                                                                  306* 311 312* 314*
Squit_the_dump                         parameter       bit(1)                   dcl 261 in procedure "get_label" set ref 259 268*
                                                                                  276*
Stream_output                   000033 constant        fixed bin(17,0)          initial dcl 3-15 set ref 349*
addr                                                   builtin function         dcl 95 ref 116 162 167 167 178 178 213 216 216 240
                                                                                  240 273 273 418 418 420 420 475 475
addrel                                                 builtin function         dcl 95 ref 411
answer                          000221 automatic       varying char(64)         dcl 52 set ref 273* 274
answer_iocbp              6     000242 automatic       pointer                  initial level 2 dcl 2-7 set ref 2-7* 272*
attach_descrip                  000104 automatic       char(168)                unaligned dcl 45 set ref 343* 344
backup_control                         based           structure                level 1 dcl 5-8
backup_map_$error_line          000122 constant        entry                    external dcl 76 ref 334
backup_map_$fs_error_line       000124 constant        entry                    external dcl 76 ref 170 243 346 353 356 459 462 467
                                                                                  471
backup_map_$on_line             000126 constant        entry                    external dcl 76 ref 240
backup_map_$tapes               000130 constant        entry                    external dcl 76 ref 149 475
bk_ss_$control_ptr              000162 external static pointer                  dcl 4-17 ref 300
bk_ss_$data_iocb                000164 external static pointer                  dcl 4-17 ref 122
bk_ss_$debugsw                  000166 external static bit(1)                   dcl 4-17 ref 280
bk_ss_$err_label                000170 external static label variable           dcl 4-17 set ref 382 383* 424* 430*
bk_ss_$error                    000172 external static fixed bin(17,0)          dcl 4-17 set ref 398* 400*
bk_ss_$holdsw                   000174 external static bit(1)                   dcl 4-17 ref 165
bk_ss_$mapsw                    000176 external static bit(1)                   dcl 4-17 ref 140
bk_ss_$myname                   000200 external static char(16)                 unaligned dcl 4-17 set ref 273*
bk_ss_$no_output                000202 external static bit(1)                   dcl 4-17 ref 110 159 201
bk_ss_$preattached              000204 external static bit(1)                   dcl 4-17 ref 117 163 246 415
bk_ss_$sp                       000206 external static pointer                  dcl 4-17 set ref 392 394 399 405* 406* 427 429
bk_ss_$sub_entry                000210 external static bit(1)                   dcl 4-17 ref 128 300
blanks                          000056 internal static char(4)                  initial unaligned dcl 54 set ref 475 475
buffer                          000156 automatic       pointer                  dcl 45 set ref 116* 149* 162* 213*
code                            000103 automatic       fixed bin(35,0)          dcl 45 in procedure "bk_output" set ref 167* 168
                                                                                  170* 178* 179 218 220 225 227 233 235 243* 249
                                                                                  405* 406 406* 408 415 418* 420 420* 443* 444 444*
                                                                                  458* 459 459* 461* 462 462* 466* 467 467* 470* 471
                                                                                  471*
code                                   parameter       fixed bin(35,0)          dcl 323 in procedure "mount_tape" set ref 320 329*
                                                                                  333* 334* 344* 346 346* 349* 350 353* 354* 355*
                                                                                  356 356* 360
command_query_                  000150 constant        entry                    external dcl 86 ref 273
cp_escape_control         1(02) 000242 automatic       bit(2)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
divide                                                 builtin function         dcl 95 ref 403
end_of_tape_encountered         000000 constant        char(24)                 initial unaligned dcl 74 set ref 240 240 240 240
error_table_$action_not_performed
                                000154 external static fixed bin(35,0)          dcl 89 ref 333
error_table_$dev_nt_assnd       000156 external static fixed bin(35,0)          dcl 89 ref 209
error_table_$device_end         000160 external static fixed bin(35,0)          dcl 89 ref 218 225 233
explanation_len          14     000242 automatic       fixed bin(21,0)          initial level 2 dcl 2-7 set ref 2-7*
explanation_ptr          12     000242 automatic       pointer                  initial level 2 dcl 2-7 set ref 2-7*
hdrcnt                   36     000060 internal static fixed bin(17,0)          level 2 dcl 66 set ref 214* 222
header                                 based           structure                level 2 in structure "backup_control" dcl 5-8
                                                                                  in procedure "bk_output"
header                          000060 internal static structure                level 1 unaligned dcl 66 in procedure "bk_output"
                                                                                  set ref 216 216
ioa_$rsnnl                      000152 constant        entry                    external dcl 87 ref 144 148
iocbp1                          000050 internal static pointer                  dcl 54 set ref 122* 167* 297* 306* 335 337* 338*
                                                                                  405* 418* 443* 458* 461* 477*
iocbp2                          000052 internal static pointer                  dcl 54 set ref 178* 297* 314* 406* 420* 444* 466*
                                                                                  470* 477*
iox_$attach_name                000132 constant        entry                    external dcl 1-8 ref 344
iox_$close                      000134 constant        entry                    external dcl 1-8 ref 337 458 466
iox_$control                    000136 constant        entry                    external dcl 1-8 ref 167 178 418 420
iox_$detach_iocb                000140 constant        entry                    external dcl 1-8 ref 338 355 461 470
iox_$modes                      000142 constant        entry                    external dcl 1-8 ref 360
iox_$open                       000144 constant        entry                    external dcl 1-8 ref 349
iox_$put_chars                  000146 constant        entry                    external dcl 1-8 ref 405 406 443 444
label                                  parameter       char(64)                 unaligned dcl 261 set ref 259 274* 276 276 280* 280
lblcnt                                 parameter       fixed bin(17,0)          dcl 191 ref 188 214
lblptr                                 parameter       pointer                  dcl 191 set ref 188 224*
length                                                 builtin function         dcl 95 ref 240 240
line                            000160 automatic       char(132)                unaligned dcl 45 set ref 116 144* 148* 162 213
literal_sw                1(05) 000242 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
min                                                    builtin function         dcl 95 ref 390
mod                                                    builtin function         dcl 95 ref 223
mount_status                           parameter       fixed bin(35,0)          dcl 291 set ref 289 294* 306* 308 314*
mounted                         000054 internal static bit(1)                   initial unaligned dcl 54 set ref 119* 125 175 207
                                                                                  295* 299 308 310* 311 350* 455 476*
ntapes                                 parameter       fixed bin(17,0)          dcl 108 ref 106 128 133
null                                                   builtin function         dcl 95 ref 2-7 2-7 2-7 272 297 335 344 344 477
padding                   1(07) 000242 automatic       bit(29)                  initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
parse_tape_reel_name_           000120 constant        entry                    external dcl 76 ref 343
primary_dump_tape               000010 internal static char(64)                 unaligned dcl 54 set ref 144* 148* 300* 303* 306*
                                                                                  459* 462*
prompt_after_explanation
                          1(06) 000242 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
query_code                3     000242 automatic       fixed bin(35,0)          initial level 2 dcl 2-7 set ref 2-7*
query_info                      000242 automatic       structure                level 1 dcl 2-7 set ref 269* 273 273
query_info_version_4                   constant        fixed bin(17,0)          initial dcl 2-34 ref 270
question_iocbp            4     000242 automatic       pointer                  initial level 2 dcl 2-7 set ref 2-7* 272*
repeat_time              10     000242 automatic       fixed bin(71,0)          initial level 2 dcl 2-7 set ref 2-7*
rtrim                                                  builtin function         dcl 95 ref 280
s                               000057 internal static char(1)                  unaligned dcl 54 set ref 121* 131* 136*
save_err_label                  000320 automatic       label variable           dcl 378 set ref 382* 424 430
secondary_dump_tape             000030 internal static char(64)                 unaligned dcl 54 set ref 144* 312* 314* 467* 471*
segcnt                                 parameter       fixed bin(17,0)          dcl 191 in procedure "bk_output" ref 188 215
segcnt                   37     000060 internal static fixed bin(17,0)          level 2 in structure "header" dcl 66 in procedure
                                                                                  "bk_output" set ref 215* 229 231
segptr                                 parameter       pointer                  dcl 191 ref 188 200
status_code               2     000242 automatic       fixed bin(35,0)          initial level 2 dcl 2-7 set ref 2-7*
suppress_name_sw          1(01) 000242 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7* 271*
suppress_spacing          1(04) 000242 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
switch_name                            parameter       char(11)                 unaligned dcl 323 set ref 320 344*
switches                  1     000242 automatic       structure                level 2 dcl 2-7
tape_entry                2            based           entry variable           level 3 dcl 5-8 ref 300
tape_id                                parameter       char(64)                 unaligned dcl 323 set ref 320 343* 346* 353* 356*
temp                            000102 automatic       fixed bin(17,0)          dcl 45 set ref 144* 148* 149* 167 167 178 178 222*
                                                                                  223* 223 223 224* 231* 232*
ttbuf                                  based           fixed bin(35,0)          array dcl 373 set ref 399* 399
two_tapes                       000055 internal static bit(1)                   unaligned dcl 54 set ref 120* 130* 135* 144 175 308
                                                                                  406 420 444 464
type                                   parameter       char                     unaligned dcl 261 set ref 259 273*
unspec                                                 builtin function         dcl 95 set ref 269* 394* 427*
uptr                            000100 automatic       pointer                  dcl 44 set ref 200* 232*
version                         000242 automatic       fixed bin(17,0)          level 2 dcl 2-7 set ref 270*
words_to_go                     000316 automatic       fixed bin(17,0)          dcl 376 set ref 385* 388 390 412* 412
words_to_write                  000317 automatic       fixed bin(17,0)          dcl 377 set ref 390* 394 399 403* 403 405 406 411
                                                                                  412
wrcnt                                  parameter       fixed bin(17,0)          dcl 372 in procedure "wrbufout" ref 369 385
wrcnt                                  parameter       fixed bin(17,0)          dcl 440 in procedure "wrout" ref 438 443 444
wrptr                                  parameter       pointer                  dcl 440 in procedure "wrout" set ref 438 443* 444*
wrptr                                  parameter       pointer                  dcl 371 in procedure "wrbufout" set ref 369 386 392
                                                                                  429*
wstat                                  parameter       fixed bin(35,0)          dcl 191 set ref 106 112* 123* 125* 138* 140 188 203*
                                                                                  209* 212* 249* 254* 255
xptr                            000314 automatic       pointer                  dcl 375 set ref 386* 399 411* 411
yes_or_no_sw              1     000242 automatic       bit(1)                   initial level 3 packed unaligned dcl 2-7 set ref
                                                                                  2-7*
zzbuf                                  based           fixed bin(35,0)          array dcl 374 set ref 394* 427*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
BACKUP_CONTROL_VERSION_5               internal static char(8)                  initial unaligned dcl 5-60
Direct_input                           internal static fixed bin(17,0)          initial dcl 3-15
Direct_output                          internal static fixed bin(17,0)          initial dcl 3-15
Direct_update                          internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_input                 internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_output                internal static fixed bin(17,0)          initial dcl 3-15
Keyed_sequential_update                internal static fixed bin(17,0)          initial dcl 3-15
Sequential_input                       internal static fixed bin(17,0)          initial dcl 3-15
Sequential_input_output                internal static fixed bin(17,0)          initial dcl 3-15
Sequential_output                      internal static fixed bin(17,0)          initial dcl 3-15
Sequential_update                      internal static fixed bin(17,0)          initial dcl 3-15
Stream_input                           internal static fixed bin(17,0)          initial dcl 3-15
Stream_input_output                    internal static fixed bin(17,0)          initial dcl 3-15
backup_control_ptr                     automatic       pointer                  dcl 5-56
backup_control_request_count           automatic       fixed bin(17,0)          dcl 5-58
bk_ss_$allow_dir_overwrite             external static bit(1)                   dcl 4-17
bk_ss_$areap                           external static pointer                  dcl 4-17
bk_ss_$brief_mapsw                     external static bit(1)                   dcl 4-17
bk_ss_$caller_handles_conditions       external static bit(1)                   dcl 4-17
bk_ss_$check_effective_access          external static bit(1)                   dcl 4-17
bk_ss_$control_name                    external static char(168)                unaligned dcl 4-17
bk_ss_$cross_retrievesw                external static bit(1)                   dcl 4-17
bk_ss_$date                            external static fixed bin(52,0)          dcl 4-17
bk_ss_$datesw                          external static bit(1)                   dcl 4-17
bk_ss_$dir_trim                        external static bit(1)                   dcl 4-17
bk_ss_$dont_dump_upgraded_dirs         external static bit(1)                   dcl 4-17
bk_ss_$dprint_destination              external static char(24)                 unaligned dcl 4-17
bk_ss_$dprint_destination_setsw        external static bit(1)                   dcl 4-17
bk_ss_$dprint_heading                  external static char(64)                 unaligned dcl 4-17
bk_ss_$dprint_heading_setsw            external static bit(1)                   dcl 4-17
bk_ss_$dprint_queue                    external static fixed bin(17,0)          dcl 4-17
bk_ss_$dprint_request_type             external static char(24)                 unaligned dcl 4-17
bk_ss_$dprint_request_type_setsw       external static bit(1)                   dcl 4-17
bk_ss_$dprintsw                        external static bit(1)                   dcl 4-17
bk_ss_$dtdsw                           external static bit(1)                   dcl 4-17
bk_ss_$ename                           external static char(32)                 dcl 4-17
bk_ss_$enforce_max_access_class        external static bit(1)                   dcl 4-17
bk_ss_$enforce_min_access_class        external static bit(1)                   dcl 4-17
bk_ss_$enforce_minimum_ring            external static bit(1)                   dcl 4-17
bk_ss_$err_onlinesw                    external static bit(1)                   dcl 4-17
bk_ss_$hp                              external static pointer                  dcl 4-17
bk_ss_$ignore_dates                    external static bit(1)                   dcl 4-17
bk_ss_$maximum_access_class            external static bit(72)                  dcl 4-17
bk_ss_$maximum_dir_access_class        external static bit(72)                  dcl 4-17
bk_ss_$minimum_access_class            external static bit(72)                  dcl 4-17
bk_ss_$minimum_ring                    external static fixed bin(17,0)          dcl 4-17
bk_ss_$namesw                          external static bit(1)                   dcl 4-17
bk_ss_$no_contin                       external static bit(1)                   dcl 4-17
bk_ss_$no_primary                      external static bit(1)                   dcl 4-17
bk_ss_$no_reload                       external static bit(1)                   dcl 4-17
bk_ss_$no_setlvid                      external static bit(1)                   dcl 4-17
bk_ss_$ntapes                          external static fixed bin(17,0)          dcl 4-17
bk_ss_$onlysw                          external static bit(1)                   dcl 4-17
bk_ss_$operator                        external static char(32)                 unaligned dcl 4-17
bk_ss_$path_index                      external static fixed bin(17,0)          dcl 4-17
bk_ss_$pathsw                          external static bit(1)                   dcl 4-17
bk_ss_$pvname                          external static char(32)                 dcl 4-17
bk_ss_$pvsw                            external static bit(1)                   dcl 4-17
bk_ss_$qchecksw                        external static bit(1)                   dcl 4-17
bk_ss_$quotasw                         external static bit(1)                   dcl 4-17
bk_ss_$restart_dumpsw                  external static bit(1)                   dcl 4-17
bk_ss_$restart_path                    external static char(168)                dcl 4-17
bk_ss_$restart_plen                    external static fixed bin(17,0)          dcl 4-17
bk_ss_$restore_access_class            external static bit(1)                   dcl 4-17
bk_ss_$retrieval_index                 external static fixed bin(17,0)          dcl 4-17
bk_ss_$retrievesw                      external static bit(1)                   dcl 4-17
bk_ss_$rlen                            external static fixed bin(17,0)          dcl 4-17
bk_ss_$rname                           external static char(168)                unaligned dcl 4-17
bk_ss_$rsize                           external static fixed bin(17,0)          dcl 4-17
bk_ss_$save_path                       external static char(168)                unaligned dcl 4-17
bk_ss_$save_plen                       external static fixed bin(17,0)          dcl 4-17
bk_ss_$save_time                       external static fixed bin(52,0)          dcl 4-17
bk_ss_$segptr                          external static pointer                  dcl 4-17
bk_ss_$set_dtd                         external static bit(1)                   dcl 4-17
bk_ss_$set_dtd_explicit                external static bit(1)                   dcl 4-17
bk_ss_$source_attributes_ptr           external static pointer                  dcl 4-17
bk_ss_$sub_entry_errfile               external static bit(1)                   dcl 4-17
bk_ss_$tapesw                          external static bit(1)                   dcl 4-17
bk_ss_$target_attributes_ptr           external static pointer                  dcl 4-17
bk_ss_$translate_access_class          external static bit(1)                   dcl 4-17
bk_ss_$trimsw                          external static bit(1)                   dcl 4-17
bk_ss_$upgrade_to_user_auth            external static bit(1)                   dcl 4-17
bk_ss_$user_authorization              external static bit(72)                  dcl 4-17
bk_ss_$user_id                         external static char(32)                 unaligned dcl 4-17
bk_ss_$user_ring                       external static fixed bin(17,0)          dcl 4-17
bk_ss_$volume_set_name                 external static char(32)                 unaligned dcl 4-17
bk_ss_$wakeup_interval                 external static fixed bin(52,0)          dcl 4-17
bk_ss_$wasnt_known                     external static bit(1)                   dcl 4-17
bk_ss_$writing_map                     external static bit(1)                   dcl 4-17
iox_$attach_loud                000000 constant        entry                    external dcl 1-8
iox_$attach_ptr                 000000 constant        entry                    external dcl 1-8
iox_$close_file                 000000 constant        entry                    external dcl 1-8
iox_$delete_record              000000 constant        entry                    external dcl 1-8
iox_$destroy_iocb               000000 constant        entry                    external dcl 1-8
iox_$detach                     000000 constant        entry                    external dcl 1-8
iox_$err_no_operation           000000 constant        entry                    external dcl 1-8
iox_$err_not_attached           000000 constant        entry                    external dcl 1-8
iox_$err_not_closed             000000 constant        entry                    external dcl 1-8
iox_$err_not_open               000000 constant        entry                    external dcl 1-8
iox_$error_output                      external static pointer                  dcl 1-41
iox_$find_iocb                  000000 constant        entry                    external dcl 1-8
iox_$find_iocb_n                000000 constant        entry                    external dcl 1-8
iox_$get_chars                  000000 constant        entry                    external dcl 1-8
iox_$get_line                   000000 constant        entry                    external dcl 1-8
iox_$look_iocb                  000000 constant        entry                    external dcl 1-8
iox_$move_attach                000000 constant        entry                    external dcl 1-8
iox_$open_file                  000000 constant        entry                    external dcl 1-8
iox_$position                   000000 constant        entry                    external dcl 1-8
iox_$propagate                  000000 constant        entry                    external dcl 1-8
iox_$read_key                   000000 constant        entry                    external dcl 1-8
iox_$read_length                000000 constant        entry                    external dcl 1-8
iox_$read_record                000000 constant        entry                    external dcl 1-8
iox_$rewrite_record             000000 constant        entry                    external dcl 1-8
iox_$seek_key                   000000 constant        entry                    external dcl 1-8
iox_$user_input                        external static pointer                  dcl 1-41
iox_$user_io                           external static pointer                  dcl 1-41
iox_$user_output                       external static pointer                  dcl 1-41
iox_$write_record               000000 constant        entry                    external dcl 1-8
iox_modes                              internal static char(24)                 initial array dcl 3-6
query_info_version_3                   internal static fixed bin(17,0)          initial dcl 2-33
query_info_version_5                   internal static fixed bin(17,0)          initial dcl 2-35
query_info_version_6                   internal static fixed bin(17,0)          initial dcl 2-36
short_iox_modes                        internal static char(4)                  initial array dcl 3-12

NAMES DECLARED BY EXPLICIT CONTEXT.
bk_output                       000162 constant        entry                    external dcl 41
enderr                          000666 constant        label                    dcl 240 ref 218 225 233
exit                            000665 constant        label                    dcl 238 ref 113 152 159 184 204 210 250 257
flush_error                     000444 constant        label                    dcl 170 ref 179
get_label                       000756 constant        entry                    internal dcl 259 ref 303 312
mount                           001116 constant        entry                    internal dcl 289 ref 138
mount_tape                      001315 constant        entry                    internal dcl 320 ref 306 314
output_finish                   000370 constant        entry                    external dcl 156
output_init                     000175 constant        entry                    external dcl 106 ref 254
retry                           000604 constant        label                    dcl 216 ref 255
tsterr                          000703 constant        label                    dcl 243 ref 220 227 235
unm                             000732 constant        label                    dcl 246 ref 242
unmo                            000474 constant        label                    dcl 172
unmount                         002257 constant        entry                    internal dcl 453 ref 172 183 253
wbo_clean                       002167 constant        label                    dcl 427 ref 383
wbo_ret                         002062 constant        label                    dcl 415 ref 408
wbo_retry                       001735 constant        label                    dcl 386 ref 432
wr_tape                         000546 constant        entry                    external dcl 188
wrbufout                        001717 constant        entry                    internal dcl 369 ref 232
wrout                           002206 constant        entry                    internal dcl 438 ref 216 224

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3110        3322    2554        3120
Length      3720    2554       212         362     334         110

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
bk_output                           498 external procedure  is an external procedure.  
get_label                               internal procedure  shares stack frame of external procedure bk_output.  
mount                                   internal procedure  shares stack frame of external procedure bk_output.  
mount_tape                              internal procedure  shares stack frame of external procedure bk_output.  
wrbufout                                internal procedure  shares stack frame of external procedure bk_output.  
wrout                                   internal procedure  shares stack frame of external procedure bk_output.  
unmount                                 internal procedure  shares stack frame of external procedure bk_output.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 primary_dump_tape           bk_output
000030 secondary_dump_tape         bk_output
000050 iocbp1                      bk_output
000052 iocbp2                      bk_output
000054 mounted                     bk_output
000055 two_tapes                   bk_output
000056 blanks                      bk_output
000057 s                           bk_output
000060 header                      bk_output

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
bk_output                000100 uptr                        bk_output
                         000102 temp                        bk_output
                         000103 code                        bk_output
                         000104 attach_descrip              bk_output
                         000156 buffer                      bk_output
                         000160 line                        bk_output
                         000221 answer                      bk_output
                         000242 query_info                  bk_output
                         000276 Squit_the_dump              mount
                         000314 xptr                        wrbufout
                         000316 words_to_go                 wrbufout
                         000317 words_to_write              wrbufout
                         000320 save_err_label              wrbufout
                         000324 EC                          wrbufout

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ent_var_desc   call_ext_in         call_ext_out_desc   call_ext_out        return_mac
mdfx1               shorten_stack       ext_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
backup_map_$error_line        backup_map_$fs_error_line     backup_map_$on_line           backup_map_$tapes
command_query_                ioa_$rsnnl                    iox_$attach_name              iox_$close
iox_$control                  iox_$detach_iocb              iox_$modes                    iox_$open
iox_$put_chars                parse_tape_reel_name_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
bk_ss_$control_ptr            bk_ss_$data_iocb              bk_ss_$debugsw                bk_ss_$err_label
bk_ss_$error                  bk_ss_$holdsw                 bk_ss_$mapsw                  bk_ss_$myname
bk_ss_$no_output              bk_ss_$preattached            bk_ss_$sp                     bk_ss_$sub_entry
error_table_$action_not_performed                           error_table_$dev_nt_assnd     error_table_$device_end




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
 2    7 000127        41 000161       106 000170       110 000206       112 000211       113 000212       116 000213
    117 000215       119 000217       120 000221       121 000222       122 000224       123 000227       124 000230
    125 000231       128 000235       130 000243       131 000245       132 000247       133 000250       135 000252
    136 000253       138 000255       140 000263       144 000270       148 000325       149 000355       152 000366
    156 000367       159 000376       162 000401       163 000403       165 000406       167 000410       168 000442
    170 000444       172 000474       175 000475       178 000502       179 000534       182 000536       183 000537
    184 000540       188 000541       200 000557       201 000563       203 000566       204 000567       207 000570
    209 000572       210 000574       212 000575       213 000576       214 000600       215 000602       216 000604
    218 000613       220 000617       222 000621       223 000624       224 000633       225 000644       227 000650
    229 000652       231 000654       232 000655       233 000657       235 000663       238 000665       240 000666
    242 000702       243 000703       246 000732       249 000735       250 000737       253 000740       254 000741
    255 000753       257 000755       259 000756       268 000767       269 000771       270 000774       271 000776
    272 001000       273 001003       274 001042       276 001050       280 001063       283 001114       284 001115
    289 001116       294 001120       295 001121       296 001123       297 001124       299 001127       300 001136
    303 001153       306 001175       307 001222       308 001223       310 001232       311 001233       312 001242
    314 001266       315 001313       317 001314       320 001315       329 001317       331 001320       333 001323
    334 001326       335 001360       337 001365       338 001376       340 001410       343 001411       344 001426
    346 001477       349 001535       350 001554       353 001563       354 001614       355 001616       356 001627
    360 001663       363 001716       369 001717       382 001721       383 001727       385 001732       386 001735
    388 001741       390 001744       392 001750       394 001756       398 001767       399 001771       400 002001
    403 002002       405 002007       406 002026       408 002051       411 002053       412 002057       413 002061
    415 002062       418 002067       420 002121       424 002160       425 002166       427 002167       429 002176
    430 002200       432 002205       438 002206       443 002210       444 002231       449 002256       453 002257
    455 002260       458 002264       459 002274       461 002327       462 002340       464 002373       466 002376
    467 002406       470 002441       471 002452       475 002505       476 002522       477 002524       479 002527


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
