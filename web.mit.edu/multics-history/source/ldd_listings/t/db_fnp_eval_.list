	COMPILATION LISTING OF SEGMENT db_fnp_eval_
	Compiled by: Multics PL/I Compiler, Release 27d, of October 11, 1982
	Compiled at: Honeywell LISD Phoenix, System M
	Compiled on: 11/15/82  1617.2 mst Mon
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /* DB_FNP_EVAL_ - Procedure to evaluate expressions intended to be fnp addresses */
       12 
       13 /* Written February 1977 by Larry Johnson */
       14 /* Modified January 1977 by Larry Johnson to accept 'string' as machine instruction format */
       15 /* Modified January 1981 by Robert Coren to evaluate symbols in channel metering areas */
       16 
       17 db_fnp_eval_: proc (arg_corep, arg_fnp, arg_expr, arg_expr_infop, arg_caller, arg_result, arg_code);
       18 
       19 /* Parameters */
       20 
       21 dcl  arg_corep ptr;					/* Pointer to segment containg core image */
       22 dcl  arg_fnp fixed bin;				/* Number of running fnp */
       23 dcl  arg_expr char (*);				/* The expression to evaluate */
       24 dcl  arg_expr_infop ptr;				/* Optional pointer to supplementary information */
       25 dcl  arg_caller char (*);				/* Caller name to go in error messages */
       26 dcl  arg_result fixed bin;				/* The answer */
       27 dcl  arg_code fixed bin (35);
       28 
       29 /* Automatic */
       30 
       31 dcl  corep ptr;
       32 dcl  fnp fixed bin;
       33 dcl  result fixed bin;
       34 dcl  code fixed bin (35);
       35 dcl  ntoken fixed bin;				/* Number of tokens */
       36 dcl  exprp ptr;					/* Pointer to unparsed part of expression */
       37 dcl  exprl fixed bin;				/* Length of unparsed part */
       38 dcl  expr char (exprl) based (exprp);			/* The unparsed part of expression */
       39 dcl  tstart fixed bin;				/* Starting token in sub-expression */
       40 dcl  tend fixed bin;				/* Last token in sub-expression */
       41 dcl  tcur fixed bin;				/* Current token */
       42 dcl  n_ind fixed bin;				/* Count of indirects in expression */
       43 dcl  n_mult fixed bin;				/* Count of multiplies and divides */
       44 dcl  n_add fixed bin;				/* Count of adds and subtracts */
       45 
       46 dcl 1 auto_expr_info like expr_info;
       47 dcl 1 token_list aligned,
       48     2 entry (255) unal,
       49       3 token like token;
       50 
       51 
       52 /* Definition of a token */
       53 
       54 dcl  tokenp ptr;
       55 
       56 dcl 1 token unaligned based (tokenp),
       57     2 prev fixed bin (8),				/* Backwards pointer */
       58     2 next fixed bin (8),				/* Forwards pointer */
       59     2 type fixed bin (8),				/* Kind of token */
       60     2 sub fixed bin (8),				/* Sub-type, for some tokens */
       61     2 val fixed bin (35);
       62 
       63 /* Values for token.type */
       64 
       65 dcl (start_token init (0),				/* Start of expression */
       66      leftp_token init (1),				/* Left parenthesis */
       67      rightp_token init (2),				/* Right parenthesis */
       68      mult_token init (3),				/* Multiply (sub=1), or divide (sub=2) */
       69      add_token init (4),				/* Add (sub=1), or subtract (sub=2) */
       70      ind_token init (5),				/* Indirect thru fnp word */
       71      sym_token init (6),				/* Symbol or constant */
       72      end_token init (7))				/* End of expression */
       73      fixed bin int static options (constant);
       74 
       75 /* External stuff */
       76 
       77 dcl  ioa_ entry options (variable);
       78 dcl  ioa_$general_rs entry (ptr, fixed bin, fixed bin, char (*), fixed bin, bit (1) aligned, bit (1) aligned);
       79 dcl  com_err_ entry options (variable);
       80 dcl  db_fnp_memory_$fetch entry (ptr, fixed bin, fixed bin, fixed bin, ptr, fixed bin (35));
       81 dcl  cu_$arg_list_ptr entry (ptr);
       82 dcl  cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       83 dcl  cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
       84 dcl  db_fnp_sym_util_$lookup entry (char (*), ptr);
       85 dcl  db_fnp_sym_util_$lookup_user entry (ptr, char (*), ptr);
       86 dcl  db_fnp_opblock_util_$lookup entry (char (*), bit (18), fixed bin (35));
       87 dcl  db_fnp_util_$lookup_module entry (ptr, fixed bin, char (*), fixed bin, fixed bin (35));
       88 dcl  db_fnp_edit_inst_$assemble entry (ptr, fixed bin, char (*), ptr, bit (18), fixed bin (35));
       89 
       90 dcl  error_table_$bad_arg ext fixed bin (35);
       91 
       92 dcl (addr, divide, hbound, index, length, null, search, string, substr, unspec, verify) builtin;
       93 
       94 /* Initialization */
       95 
       96 	corep = arg_corep;
       97 	fnp = arg_fnp;
       98 	exprp = addr (arg_expr);
       99 	exprl = length (arg_expr);
      100 	expr_infop = arg_expr_infop;
      101 	if expr_infop = null then do;			/* If no structure, setup dummy */
      102 	     expr_infop = addr (auto_expr_info);
      103 	     string (expr_info.flags) = "0"b;
      104 	     expr_info.user_tablep = null;
      105 	end;
      106 	expr_info.type = type_oct;
      107 	expr_info.len = 1;
      108 
      109 
      110 /* Now evaluate the expression */
      111 
      112 	code = 0;
      113 
      114 	if substr (expr, 1, 1) = "'" then do;		/* Special machine instruction format */
      115 	     call eval_inst;
      116 	     go to eval_return;
      117 	end;
      118 
      119 	call parse_expr;
      120 
      121 	call eval_expr;
      122 
      123 eval_return:
      124 	arg_result = result;
      125 	arg_code = 0;
      126 	return;
      127 
      128 error_return:					/* If error */
      129 	arg_result = 0;
      130 	arg_code = code;
      131 	return;
      132 
      133 /* Procedure to parse the expression */
      134 
      135 parse_expr: proc;
      136 
      137 dcl  nparen fixed bin;				/* For paren level counting */
      138 dcl  i fixed bin;
      139 
      140 	     ntoken = 0;
      141 	     call new_token (start_token);		/* First, start of expr token */
      142 
      143 	     nparen = 0;
      144 
      145 
      146 
      147 	     do while (exprl > 0);			/* Loop until end */
      148 
      149 		i = index ("()*/+|-,", substr (expr, 1, 1)); /* Check for special character */
      150 		if i = 0 then do;			/* Must be symbol */
      151 		     if sym_or_rightp_or_ind () then go to bad_char;
      152 		     call parse_sym;
      153 		     go to next_token;
      154 		end;
      155 		else go to parse_op (i);		/* Branch, depending on character */
      156 
      157 parse_op (1):					/* Left paren */
      158 		if sym_or_rightp_or_ind () then go to bad_char;
      159 		call new_token (leftp_token);
      160 		nparen = nparen + 1;
      161 		call adv (1);
      162 		go to next_token;
      163 
      164 parse_op (2):					/* Right paren */
      165 		if token.type = start_token | mult_or_add () then go to bad_char;
      166 		if nparen ^> 0 then do;
      167 		     if exprl = length (arg_expr) then go to bad_char;
      168 		     else call err ("Too many "")"".");
      169 		end;
      170 		call new_token (rightp_token);
      171 		nparen = nparen - 1;
      172 		call adv (1);
      173 		go to next_token;
      174 
      175 parse_op (3):					/* "*" - may be multiply or reference to loc counter */
      176 		if sym_or_rightp_or_ind () then do;	/* Multiply */
      177 		     call new_token (mult_token);
      178 		     token.sub = 1;
      179 		end;
      180 		else do;				/* Reference to location counter */
      181 		     if ^expr_info.star_known then call err ("Value of ""*"" is not known.");;
      182 		     call new_token (sym_token);
      183 		     token.val = expr_info.star_addr;
      184 		end;
      185 		call adv (1);
      186 		go to next_token;
      187 
      188 parse_op (4):					/* Divide */
      189 		if start_or_leftp () | mult_or_add () then go to bad_char;
      190 		call new_token (mult_token);
      191 		token.sub = 2;
      192 		call adv (1);
      193 		go to next_token;
      194 
      195 parse_op (5):					/* Add */
      196 parse_op (6):					/* Add, alternate form ("|") */
      197 parse_op (7):					/* Subtract */
      198 		if start_or_leftp () then call new_token (sym_token); /* Unary, treat as 0+ or 0- */
      199 		else if mult_or_add () then go to bad_char;
      200 		call new_token (add_token);
      201 		if substr (expr, 1, 1) = "-" then token.sub = 2;
      202 		else token.sub = 1;
      203 		call adv (1);
      204 		go to next_token;
      205 
      206 parse_op (8):					/* Comma, must be start of ",*" */
      207 		if (exprl < 2) | ((exprl >= 2) & substr (expr, 2, 1) ^= "*") then
      208 		     call err ("Missing ""*"" after "","".");
      209 		if start_or_leftp () | mult_or_add () then go to bad_char;
      210 		call new_token (ind_token);
      211 		call adv (2);
      212 		go to next_token;
      213 
      214 next_token:
      215 	     end;
      216 
      217 	     if nparen ^= 0 then call err ("Parens do not balance."); /* Must balance in end */
      218 
      219 	     if mult_or_add () then call err ("Expression ends badly.");
      220 
      221 	     call new_token (end_token);
      222 	     return;
      223 
      224 	end parse_expr;
      225 
      226 /* Procedure to parse a constant or a symbol name */
      227 
      228 parse_sym: proc;
      229 
      230 dcl  val fixed bin (35);
      231 dcl  bval bit (36) aligned based (addr (val));
      232 dcl (i, j) fixed bin;
      233 dcl  dec_sw bit (1) init ("0"b);
      234 dcl  opval bit (18);
      235 dcl  tib_meter fixed bin;
      236 dcl  tib_page_base fixed bin;
      237 dcl  meter_orig fixed bin (18) unsigned unaligned;
      238 
      239 	     i = verify (expr, "0123456789");		/* Try constant first */
      240 	     if i ^= 1 then do;			/* It is a constant */
      241 		if i = 0 then i = length (expr);	/* Rest of expr is a constant */
      242 		else i = i - 1;
      243 		if i < length (expr) then if substr (expr, i+1, 1) = "." then dec_sw = "1"b; /* Decimal constant */
      244 		if dec_sw then do;
      245 		     val = cv_dec_check_ (substr (expr, 1, i), code);
      246 		     if code ^= 0 then do;
      247 			code = 0;
      248 			call err ("Invalid decimal integer: ""^a"".", substr (expr, 1, i));
      249 		     end;
      250 		     if val < -262144 | val > 262143 then
      251 			call err ("Decimal integer not in range -262144 to 262143: ^a", substr (expr, 1, i));
      252 		     call adv (i+1);
      253 		end;
      254 		else do;				/* Octal number */
      255 		     val = cv_oct_check_ (substr (expr, 1, i), code);
      256 		     if code ^= 0 then do;
      257 			code = 0;
      258 			call err ("Invalid octal integer: ""^a"".", substr (expr, 1, i));
      259 		     end;
      260 		     if substr (bval, 1, 18) ^= "0"b & substr (bval, 1, 18) ^= "777777"b3 then
      261 			call err ("Octal integer not in range -400000 to 377777: ^a", substr (expr, 1, i));
      262 		     call adv (i);
      263 		end;
      264 		if val > 0 then if substr (bval, 19, 1) then /* Really negative */
      265 			substr (bval, 1, 18) = "777777"b3;
      266 		call new_token (sym_token);		/* Set up token for symbol */
      267 		token.val = val;
      268 		return;
      269 	     end;
      270 
      271 /* Symbol must be a name */
      272 
      273 	     i = search (expr, "()*/+|-,");		/* Look for end */
      274 	     if i = 1 then go to bad_char;
      275 	     if i = 0 then i = length (expr);
      276 	     else i = i - 1;
      277 
      278 	     call db_fnp_util_$lookup_module (corep, fnp, substr (expr, 1, i), j, code);
      279 	     if code = 0 then do;
      280 		call new_token (sym_token);
      281 		token.val = j;
      282 		call adv (i);
      283 		return;
      284 	     end;
      285 
      286 	     call db_fnp_opblock_util_$lookup (substr (expr, 1, i), opval, code);
      287 	     if code = 0 then do;
      288 		call new_token (sym_token);
      289 		unspec (token.val) = "777777"b3 || opval;
      290 		call adv (i);
      291 		return;
      292 	     end;
      293 
      294 	     call db_fnp_edit_inst_$assemble (corep, fnp, substr (expr, 1, i), expr_infop, opval, code);
      295 						/* May symbol is a machine opcode mneumonic */
      296 	     if code = 0 then do;
      297 		call new_token (sym_token);
      298 		if substr (opval, 1, 1) then unspec (token.val) = "777777"b3 || opval;
      299 		else unspec (token.val) = "000000"b3 || opval;
      300 		call adv (i);
      301 		return;
      302 	     end;
      303 
      304 	     call db_fnp_sym_util_$lookup_user (expr_info.user_tablep, substr (expr, 1, i), symp);
      305 	     if symp = null then do;
      306 		call db_fnp_sym_util_$lookup (substr (expr, 1, i), symp);
      307 		if symp = null then do;
      308 		     code = 0;
      309 		     call err ("Invalid symbol: ""^a"".", substr (expr, 1, i));
      310 		end;
      311 	     end;
      312 
      313 	     code = 0;
      314 	     call new_token (sym_token);
      315 	     token.val = sym.value;
      316 	     if sym.reloc = reloc_tib then		/* Must add in tib */
      317 		if ^expr_info.tib_known then call err ("Illegal use of ""^a"". Address of TIB not known.",
      318 		     substr (expr, 1, i));
      319 		else token.val = token.val + expr_info.tib_addr;
      320 	     else if sym.reloc = reloc_hwcm then
      321 		if ^expr_info.hwcm_known then call err ("Illegal use of ""^a"". Address of HWCM not known.",
      322 		     substr (expr, 1, i));
      323 		else token.val = token.val + expr_info.hwcm_addr;
      324 	     else if sym.reloc = reloc_sfcm then
      325 		if ^expr_info.sfcm_known then call err ("Illegal use of ""^a"". Address of SFCM not known.",
      326 		     substr (expr, 1, i));
      327 		else token.val = token.val + expr_info.sfcm_addr;
      328 	     else if sym.reloc = reloc_meters then	/* add in value of t.metr */
      329 		if ^expr_info.tib_known then call err ("Illegal use of ""^a"". Address of TIB not known.",
      330 		     substr (expr, 1, i));
      331 		else do;
      332 		     call db_fnp_eval_ (corep, fnp, "t.metr", expr_infop, arg_caller, tib_meter, code); /* get value of t.metr */
      333 		     if code ^= 0
      334 		     then do;
      335 			arg_code = code;
      336 			return;
      337 		     end;
      338 
      339 		     tib_page_base = 256*(divide (expr_info.tib_addr, 256, 17, 0)); /* allow for possible virtual address */
      340 		     tib_meter = tib_page_base + mod (tib_meter,256);
      341 
      342 		     call db_fnp_memory_$fetch (corep, fnp, tib_meter, 1, addr (meter_orig), code);
      343 		     if code ^= 0
      344 		     then do;
      345 			arg_code = code;
      346 			return;
      347 		     end;
      348 
      349 		     meter_orig = tib_page_base + mod (meter_orig, 256); /* make sure we have abs. address */
      350 		     token.val = token.val + meter_orig;
      351 		end;
      352 
      353 	     expr_info.type = sym.type;
      354 	     expr_info.len = sym.len;
      355 	     call adv (i);
      356 	     return;
      357 
      358 	end parse_sym;
      359 
      360 /* Procedures which to some comon tests on the previous token */
      361 
      362 mult_or_add: proc returns (bit (1));
      363 
      364 	     return (token.type = mult_token | token.type = add_token);
      365 
      366 	end mult_or_add;
      367 
      368 start_or_leftp: proc returns (bit (1));
      369 
      370 	     return (token.type = start_token | token.type = leftp_token);
      371 
      372 	end start_or_leftp;
      373 
      374 sym_or_rightp_or_ind: proc returns (bit (1));
      375 
      376 	     return (token.type = sym_token | token.type = rightp_token | token.type = ind_token);
      377 
      378 	end sym_or_rightp_or_ind;
      379 
      380 /* Procedure to create a new token and trhread it in */
      381 
      382 new_token: proc (type);
      383 
      384 dcl  type fixed bin;				/* Type of new token */
      385 
      386 	     if ntoken = hbound (token_list.entry, 1) then call err ("Expression too long.");
      387 	     if ntoken > 0 then token.next = ntoken + 1;	/* Set pointer in prev token */
      388 	     ntoken = ntoken + 1;
      389 	     tokenp = addr (token_list.entry (ntoken));
      390 	     token.prev = ntoken - 1;
      391 	     token.next = 0;
      392 	     token.type = type;
      393 	     token.sub = 0;
      394 	     token.val = 0;
      395 	     return;
      396 
      397 	end new_token;
      398 
      399 /* Procedure to advance pointer in expression */
      400 
      401 adv:	proc (n);
      402 
      403 dcl  n fixed bin;					/* Amount to move */
      404 
      405 	     exprp = substraddr (expr, n+1);		/* Adjust pointer */
      406 	     exprl = exprl - n;			/* Adjust length */
      407 	     return;
      408 
      409 	end adv;
      410 
      411 /* Procedure to evaluate the expression by scanning the list of tokens */
      412 /* The procedure is to find the inner most expression, evaluate it, and
      413*   continue. At the end, there should only be 3 tokens left: the start, the end,
      414*   and one symbol token containing the final value */
      415 
      416 eval_expr: proc;
      417 
      418 	     do while (ntoken > 3);
      419 		call find_sub_expr;			/* Find some inner expression to work on */
      420 		call eval_sub_expr;			/* And reduce it to a value */
      421 	     end;
      422 
      423 	     tokenp = addr (token_list.entry (1));	/* Pointer to start token */
      424 	     tokenp = addr (token_list.entry (token.next)); /* Second token, containing the value */
      425 	     result = token.val;			/* Get the answer */
      426 	     return;
      427 
      428 	end eval_expr;
      429 
      430 
      431 /* Procedure to locate an inner expression to evaluate. This will be either
      432*   a part of the expression delimited by parens, or, if no parens left, the
      433*   entire expression. */
      434 /* The following variables are set for future use:
      435*   tstart - the first token in the expression found
      436*   tend - the last
      437*   n_ind - the number of indirection tokens between tstart and tend
      438*   n_mult - likewise for mult tokens
      439*   n_add - likewise for add tokens */
      440 
      441 find_sub_expr: proc;
      442 
      443 	     n_ind, n_mult, n_add = 0;
      444 	     tstart, tcur = 1;
      445 	     tokenp = addr (token_list.entry (tstart));
      446 
      447 	     do while ((token.type ^= rightp_token) & (token.type ^= end_token));
      448 		if token.type = leftp_token then do;
      449 		     tstart = tcur;			/* Maybe expression will start here */
      450 		     n_ind, n_mult, n_add = 0;	/* Must reset counters for inner level */
      451 		end;
      452 		else if token.type = ind_token then n_ind = n_ind + 1;
      453 		else if token.type = mult_token then n_mult = n_mult + 1;
      454 		else if token.type = add_token then n_add = n_add + 1;
      455 		tcur = token.next;			/* On to next one */
      456 		tokenp = addr (token_list.entry (tcur));
      457 	     end;
      458 	     tend = tcur;
      459 
      460 	end find_sub_expr;
      461 
      462 /* Procedure to evaluate sub-expression once it has been isolated. */
      463 /* The sub-expression is repeatedly scanned for mult tokens, add tokens, and
      464*   ind tokens, in that order.  Repeated scans are necessary because
      465*   indirect ops must be done before mult or add ops after them, and vice versa */
      466 
      467 eval_sub_expr: proc;
      468 
      469 	     do while ((n_ind + n_mult + n_add) > 0);
      470 		if n_mult > 0 then call eval_op (mult_token, n_mult);
      471 		if n_add > 0 then call eval_op (add_token, n_add);
      472 		if n_ind > 0 then call eval_ind;
      473 	     end;
      474 
      475 	     call del_token (tstart);			/* Delete parens one expression is evaluated */
      476 	     call del_token (tend);
      477 	     return;
      478 
      479 	end eval_sub_expr;
      480 
      481 /* This procedure scans looking for either mult tokens or add tokens to be
      482*   evaluated. As many are evaluated as possible. The scan stops with either a
      483*   an ind token, or exhausting the count of tokens being handled. */
      484 
      485 eval_op:	proc (token_type, token_cnt);
      486 
      487 dcl  token_type fixed bin;				/* The kind of token being evaluated, mult or add */
      488 dcl  token_cnt fixed bin;				/* Number still unevaluated in sub-expression */
      489 
      490 	     tcur = tstart;
      491 	     tokenp = addr (token_list.entry (tcur));
      492 	     do while ((token.type ^= ind_token) & (token_cnt > 0));
      493 		if token.type = token_type then do;	/* Got one */
      494 		     call compute_op;		/* Go do the arithmetic */
      495 		     token_cnt = token_cnt - 1;
      496 		end;
      497 		tcur = token.next;
      498 		tokenp = addr (token_list.entry (tcur));
      499 	     end;
      500 	     return;				/* Every thing possible is done */
      501 
      502 	end eval_op;
      503 
      504 /* Procedure called to evalue a mult or add token. Once the arithmetic is done,
      505*   the value is stored in the first sym token. the operator token and the second
      506*   symbol token are deleted. This procedure is called with tcur as the operator
      507*   token being evaluated */
      508 
      509 compute_op: proc;
      510 
      511 dcl (del1, del2) fixed bin;				/* The two tokens to be deleted */
      512 dcl (val1, val2) fixed bin (35);			/* Values of the two symbols */
      513 dcl  p ptr;
      514 
      515 	     del1 = tcur;				/* The operator token will be deleted */
      516 	     del2 = token.next;			/* As well as the second operand */
      517 	     p = addr (token_list.entry (token.next));	/* Pointter to second symbol token */
      518 	     val2 = p -> token.val;
      519 	     p = addr (token_list.entry (token.prev));	/* Pointer to the first symbol */
      520 	     val1 = p -> token.val;
      521 	     if token.type = add_token then do;		/* Add or subtract */
      522 		if token.sub = 1 then val1 = val1 + val2;
      523 		else val1 = val1 - val2;
      524 	     end;
      525 	     else do;				/* Multiply or divide */
      526 		if token.sub = 1 then val1 = val1 * val2;
      527 		else do;
      528 		     if val2 = 0 then call err ("Division by zero.");
      529 		     else val1 = divide (val1, val2, 35, 0);
      530 		end;
      531 	     end;
      532 
      533 	     tcur = token.prev;			/* Make first operand the current token */
      534 	     tokenp = addr (token_list.entry (tcur));
      535 	     token.val = val1;			/* Save answer */
      536 	     expr_info.type = type_oct;
      537 	     expr_info.len = 1;
      538 	     call del_token (del1);			/* Delete operator */
      539 	     call del_token (del2);			/* And the sedond operand */
      540 	     return;
      541 
      542 	end compute_op;
      543 
      544 /* Procedure to scan for and evalute indirections. The will do as many
      545*   indirections as specified, but will not scan past an add or mult token */
      546 
      547 eval_ind:	proc;
      548 
      549 dcl  bitval bit (36);
      550 dcl 1 word_buf aligned,
      551     2 val bit (18) unal,
      552     2 pad bit (18) unal;
      553 
      554 	     tcur = tstart;
      555 	     tokenp = addr (token_list.entry (tcur));
      556 	     do while (^mult_or_add () & (n_ind > 0));
      557 		if token.type = ind_token then do;	/* Found one */
      558 		     tcur = token.prev;		/* Back up to look at token with address */
      559 		     tokenp = addr (token_list.entry (tcur));
      560 		     call db_fnp_memory_$fetch (corep, fnp, (token.val), 1, addr (word_buf), code);
      561 		     if code ^= 0 then call err ("Unable to read FNP memory location ^o to do indrection.", token.val);
      562 		     substr (bitval, 19) = word_buf.val; /* Put in right half of word */
      563 		     if substr (word_buf.val, 1, 1) = "0"b then substr (bitval, 1, 18) = "0"b; /* Propagate sign */
      564 		     else substr (bitval, 1, 18) = "777777"b3;
      565 		     unspec (token.val) = bitval;
      566 		     n_ind = n_ind - 1;
      567 		     expr_info.type = type_oct;
      568 		     expr_info.len = 1;
      569 		     call del_token ((token.next));	/* Delete ind token */
      570 		end;
      571 		tcur = token.next;
      572 		tokenp = addr (token_list.entry (tcur));
      573 	     end;
      574 
      575 	end eval_ind;
      576 
      577 /* Procedure to delete a token by untreading it from the list */
      578 
      579 del_token: proc (n);
      580 
      581 dcl  n fixed bin;					/* The token to go */
      582 dcl (next, prev) fixed bin;
      583 dcl  p ptr;
      584 
      585 	     p = addr (token_list.entry (n));
      586 	     prev = p -> token.prev;
      587 	     next = p -> token.next;
      588 	     if (prev = 0) | (next = 0) then return;	/* Ndver delete start or end */
      589 
      590 	     p = addr (token_list.entry (prev));
      591 	     p -> token.next = next;
      592 	     p = addr (token_list.entry (next));
      593 	     p -> token.prev = prev;
      594 	     ntoken = ntoken - 1;
      595 	     return;
      596 
      597 	end del_token;
      598 
      599 /* Handle an expression in single-quuotes (') as a machine instruction */
      600 
      601 eval_inst: proc;
      602 
      603 dcl (i, j) fixed bin;
      604 dcl  inst bit (18);
      605 dcl  fb35 fixed bin (35);
      606 
      607 	     i = 1;				/* Starting index to assemble */
      608 	     j = length (expr);			/* Length to assemble */
      609 	     if substr (expr, 1, 1) = "'" then do;	/* Strip leading quote */
      610 		i = 2;
      611 		j = j-1;
      612 	     end;
      613 	     if substr (expr, length (expr), 1) = "'" then j = j-1; /* Strip trailing quote */
      614 	     call db_fnp_edit_inst_$assemble (corep, fnp, substr (expr, i, j), expr_infop, inst, code);
      615 	     if code ^= 0 then do;
      616 		if arg_caller ^= "" then call com_err_ (0, arg_caller, "Invalid machine instruction: ^a");
      617 		else call ioa_ ("Invalid machine instruction: ^a", expr);
      618 		go to error_return;
      619 	     end;
      620 	     if substr (inst, 1, 1) then unspec (fb35) = "777777"b3 || inst; /* If negative number */
      621 	     else fb35 = bin (inst);
      622 	     result = fb35;
      623 	     return;
      624 
      625 	end eval_inst;
      626 
      627 /* Error routines */
      628 
      629 bad_char:
      630 	if exprl < length (arg_expr) then call err ("""^a"" after ""^a"" is invalid.",
      631 	     substr (expr, 1, 1), substr (arg_expr, 1, length (arg_expr) - exprl));
      632 	else call err ("""^a"" at beginning is invalid.", substr (expr, 1, 1));
      633 
      634 
      635 /* General error subroutine */
      636 
      637 err:	proc options (variable);
      638 
      639 dcl  s char (256);
      640 dcl  p ptr;
      641 
      642 	     call cu_$arg_list_ptr (p);
      643 	     call ioa_$general_rs (p, 1, 2, s, (0), "1"b, "0"b);
      644 	     if code ^= 0 | arg_caller ^= "" then
      645 		call com_err_ (code, arg_caller, "Invalid expression: ""^a"". ^a", arg_expr, s);
      646 	     else call ioa_ ("Invalid expression: ""^a"". ^a", arg_expr, s);
      647 	     if code = 0 then code = error_table_$bad_arg;
      648 	     go to error_return;
      649 
      650 	end err;
      651 
      652 /* Simulate substraddr builtin temporarily */
      653 
      654 substraddr: proc (c, n) returns (ptr);
      655 
      656 dcl  c char (*);
      657 dcl  n fixed bin;
      658 dcl  ca (n) char (1) unal based (addr (c));
      659 
      660 	     return (addr (ca (n)));
      661 
      662 	end substraddr;
      663 
  1     1 /* Begin include file ..... debug_fnp_data.incl.pl1 */
  1     2 
  1     3 /* Describes various structures used by the debug_fnp command */
  1     4 
  1     5 /* Written February 1977 by Larry Johnson */
  1     6 
  1     7 /* Structures describing a symbol table used by the debug_fnp command,
  1     8*   to find values for common FNP symbols. */
  1     9 
  1    10 dcl  db_fnp_symbols_$db_fnp_symbols_ ext;
  1    11 
  1    12 dcl  symbol_tablep ptr;
  1    13 
  1    14 dcl 1 symbol_table aligned based (symbol_tablep),
  1    15     2 cnt fixed bin,				/* Number of entries */
  1    16     2 maxcnt fixed bin,				/* Max count */
  1    17     2 entry (symbol_table.cnt) unal,
  1    18       3 one_symbol like sym unal;
  1    19 
  1    20 dcl  symp ptr;					/* Pointer to one symbol */
  1    21 
  1    22 dcl 1 sym unal based (symp),
  1    23     2 name char (6),
  1    24     2 value fixed bin (17),
  1    25     2 len fixed bin (17),				/* Number of words */
  1    26     2 reloc fixed bin (17),
  1    27     2 type fixed bin (17),
  1    28     2 flag_mem char (6),				/* If non blank, name of word in which this is a flag */
  1    29     2 explain bit (18),				/* Offset to explanation for symbol */
  1    30     2 pad bit (18);
  1    31 
  1    32 dcl  exptextp ptr;
  1    33 
  1    34 dcl 1 exptext aligned based (exptextp),			/* Symbol explanation entry */
  1    35     2 len fixed bin (8) unal,
  1    36     2 data char (exptext.len) unal;
  1    37 
  1    38 /* Values for sym.reloc, which is relocation required to find the symbol */
  1    39 
  1    40 dcl (reloc_abs init (0),				/* Value is absolute */
  1    41      reloc_tib init (1),				/* Value is relative to current tib addr */
  1    42      reloc_hwcm init (2),				/* Value is relative to current hwcm */
  1    43      reloc_sfcm init (3),				/* Value is relative to software comm region */
  1    44      reloc_meters init (4))				/* Value is relative to tib meters */
  1    45      int static options (constant);
  1    46 
  1    47 /* Values for sym.type, which is the mode to be used in displaying symbol */
  1    48 
  1    49 dcl (type_oct init (0),				/* Octal, default for most symbols */
  1    50      type_char init (1),				/* Ascii characters */
  1    51      type_addr init (2),				/* Address to be converted to mod|offset */
  1    52      type_clock init (3),				/* Multics clock value */
  1    53      type_inst init (4),				/* Machine instruction */
  1    54      type_op init (5),				/* Interpreter opblock format */
  1    55      type_dec init (6),				/* Decimal */
  1    56      type_bit init (7),				/* In bits */
  1    57      type_ebcdic init (8))				/* 8-bit ebcdic characters */
  1    58      int static options (constant);
  1    59 
  1    60 dcl  long_type_names (0:8) char (12) int static options (constant) init (
  1    61      "octal", "character", "address", "clock", "instruction", "opblock", "decimal", "bit", "ebcdic");
  1    62 dcl  short_type_names (0:8) char (4) int static options (constant) init (
  1    63      "oct", "ch", "addr", "ck", "inst", "op", "dec", "bit", "ebc");
  1    64 
  1    65 
  1    66 /* Structure of suplmental data used in evaluating expressions */
  1    67 
  1    68 dcl  expr_infop ptr;
  1    69 
  1    70 dcl 1 expr_info aligned based (expr_infop),
  1    71     2 flags,
  1    72       3 star_known bit (1) unal,			/* Value of "*" is known */
  1    73       3 tib_known bit (1) unal,			/* TIB addresses may be used */
  1    74       3 hwcm_known bit (1) unal,			/* HWCM address may be used */
  1    75       3 sfcm_known bit (1) unal,			/* SFCM address may be used */
  1    76       3 pad bit (32) unal,
  1    77     2 star_addr fixed bin,				/* Value of "*" */
  1    78     2 tib_addr fixed bin,				/* Address of TIB */
  1    79     2 hwcm_addr fixed bin,				/* Address of HWCM */
  1    80     2 sfcm_addr fixed bin,				/* Address of SFCM */
  1    81     2 type fixed bin,				/* Expression type (mode for printing) */
  1    82     2 len fixed bin,				/* Implied length of expression */
  1    83     2 user_tablep ptr;				/* Pointer to a user symbol table */
  1    84 
  1    85 
  1    86 /* Structure of opcode table of machine instructions */
  1    87 
  1    88 dcl  db_fnp_opcodes_$ ext;
  1    89 
  1    90 dcl  optablep ptr;
  1    91 
  1    92 dcl 1 optable aligned based (optablep),
  1    93     2 cnt fixed bin,
  1    94     2 entry (optable.cnt) unal,
  1    95       3 one_op like op;
  1    96 
  1    97 dcl  opp ptr;
  1    98 
  1    99 dcl 1 op unal based (opp),
  1   100     2 name char (6),				/* The mneumonic */
  1   101     2 code bit (12),				/* The  opcode */
  1   102     2 mask bit (12),				/* Mask that says where the opcode is */
  1   103     2 type fixed bin (11),				/* Type of display required */
  1   104     2 pad bit (18);
  1   105 
  1   106 /* Values for op.type are:
  1   107*   0 - storage reference
  1   108*   1 - non-storage reference (immediate),
  1   109*   2 - non-storage reference (iacxn only),
  1   110*   3 - non-storage reference (shifts),
  1   111*   4 - non-storage reference (no operands) */
  1   112 
  1   113 
  1   114 /* Stuctures used while parsing commands into operands */
  1   115 
  1   116 dcl  cmd_infop ptr;
  1   117 
  1   118 dcl 1 cmd_info aligned based (cmd_infop),
  1   119     2 inbuf char (256),				/* For reading lines */
  1   120     2 opbuf char (256),				/* Used for operand in undoubling quotes */
  1   121     2 commandp ptr,					/* Address of unparsed part of command */
  1   122     2 commandl fixed bin,				/* Length of unparsed part */
  1   123     2 operandp ptr,					/* Address of current operand */
  1   124     2 operandl fixed bin,				/* And its length */
  1   125     2 error bit (1),				/* Set if error parsing operand */
  1   126     2 endline bit (1),				/* Set if no more operands on line */
  1   127     2 opstring bit (1),				/* Set if operand was unquoted string */
  1   128     2 flush bit (1),				/* If set, rest of input line will be ignored */
  1   129     2 envp ptr;					/* Pointer to the debug_fnp environment structure */
  1   130 
  1   131 dcl  command char (cmd_info.commandl) based (cmd_info.commandp);
  1   132 dcl  operand char (cmd_info.operandl) based (cmd_info.operandp);
  1   133 
  1   134 /* The following structure describes the current debug_fnp environment. */
  1   135 /* It specifies whether we are working on a dump, fnp, core image, etc. */
  1   136 
  1   137 dcl  envp ptr;
  1   138 
  1   139 dcl 1 env aligned based (envp),
  1   140     2 corep ptr,					/* Ptr to current dump or core-image. Null means live FNP */
  1   141     2 fnp fixed bin,				/* Current fnp number */
  1   142     2 dump_dir char (168) unal,			/* Directory where dumps are found */
  1   143     2 dir char (168) unal,				/* Directory for current dump or core image */
  1   144     2 ename char (32) unal,				/* Ename for current dump or core image */
  1   145     2 tty_name char (32),				/* Name of current channel */
  1   146     2 segp ptr,					/* Pointer to base of current segment */
  1   147     2 flags unal,
  1   148       3 fnps_configured bit (8),			/* Says which FNP's appear in config deck */
  1   149       3 fnp_sw bit (1),				/* 1 if currently working on fnp */
  1   150       3 image_sw bit (1),				/* 1 if currently working on a core-image */
  1   151       3 dump_sw bit (1),				/* 1 if current working on a dump */
  1   152       3 fdump_sw bit (1),				/* 1 if current dump is a fdump */
  1   153       3 pad bit (24),
  1   154     2 dump_time fixed bin (71);			/* Clock time dump occured */
  1   155 
  1   156 /* Structure of data defining table of interpreter opblock names */
  1   157 
  1   158 dcl  db_fnp_opblocks_$ ext;
  1   159 
  1   160 dcl  opblock_tablep ptr;
  1   161 
  1   162 dcl 1 opblock_table aligned based (opblock_tablep),
  1   163     2 cnt fixed bin,
  1   164     2 name (0:opblock_table.cnt) char (6) unal;
  1   165 
  1   166 /* End include file ..... debug_fnp_data.incl.pl1 */
      664 
      665 
      666      end db_fnp_eval_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/15/82  1502.0  db_fnp_eval_.pl1                  >dumps>old>recomp>db_fnp_eval_.pl1
664          1    06/19/81  2115.0  debug_fnp_data.incl.pl1           >ldd>include>debug_fnp_data.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
add_token                              constant        fixed bin(17,0)          initial dcl 65 set ref 200* 364 454 471* 521
addr                                                   builtin function         dcl 92 ref 98 102 260 260 264 264 342 342 389 423
                                                                                  424 445 456 491 498 517 519 534 555 559 560 560
                                                                                  572 585 590 592 660 660
arg_caller                             parameter       char                     unaligned dcl 25 set ref 17 332* 616 616* 644 644*
arg_code                               parameter       fixed bin(35,0)          dcl 27 set ref 17 125* 130* 335* 345*
arg_corep                              parameter       pointer                  dcl 21 ref 17 96
arg_expr                               parameter       char                     unaligned dcl 23 set ref 17 98 99 167 629 629 629
                                                                                  629 629 644* 646*
arg_expr_infop                         parameter       pointer                  dcl 24 ref 17 100
arg_fnp                                parameter       fixed bin(17,0)          dcl 22 ref 17 97
arg_result                             parameter       fixed bin(17,0)          dcl 26 set ref 17 123* 128*
auto_expr_info                  000120 automatic       structure                level 1 unaligned dcl 46 set ref 102
bitval                          001274 automatic       bit(36)                  unaligned dcl 549 set ref 562* 563* 564* 565
bval                                   based           bit(36)                  dcl 231 set ref 260 260 264 264*
c                                      parameter       char                     unaligned dcl 656 set ref 654 660
ca                                     based           char(1)                  array unaligned dcl 658 set ref 660
code                            000104 automatic       fixed bin(35,0)          dcl 34 set ref 112* 130 245* 246 247* 255* 256 257*
                                                                                  278* 279 286* 287 294* 296 308* 313* 332* 333 335
                                                                                  342* 343 345 560* 561 614* 615 644 644* 647 647*
com_err_                        000014 constant        entry                    external dcl 79 ref 616 644
corep                           000100 automatic       pointer                  dcl 31 set ref 96* 278* 294* 332* 342* 560* 614*
cu_$arg_list_ptr                000020 constant        entry                    external dcl 81 ref 642
cv_dec_check_                   000024 constant        entry                    external dcl 83 ref 245
cv_oct_check_                   000022 constant        entry                    external dcl 82 ref 255
db_fnp_edit_inst_$assemble      000036 constant        entry                    external dcl 88 ref 294 614
db_fnp_memory_$fetch            000016 constant        entry                    external dcl 80 ref 342 560
db_fnp_opblock_util_$lookup     000032 constant        entry                    external dcl 86 ref 286
db_fnp_sym_util_$lookup         000026 constant        entry                    external dcl 84 ref 306
db_fnp_sym_util_$lookup_user    000030 constant        entry                    external dcl 85 ref 304
db_fnp_util_$lookup_module      000034 constant        entry                    external dcl 87 ref 278
dec_sw                          001157 automatic       bit(1)                   initial unaligned dcl 233 set ref 233* 243* 244
del1                            001260 automatic       fixed bin(17,0)          dcl 511 set ref 515* 538*
del2                            001261 automatic       fixed bin(17,0)          dcl 511 set ref 516* 539*
divide                                                 builtin function         dcl 92 ref 339 529
end_token                              constant        fixed bin(17,0)          initial dcl 65 set ref 221* 447
entry                           000132 automatic       structure                array level 2 packed unaligned dcl 47 set ref 386
                                                                                  389 423 424 445 456 491 498 517 519 534 555 559
                                                                                  572 585 590 592
error_table_$bad_arg            000040 external static fixed bin(35,0)          dcl 90 ref 647
expr                                   based           char                     unaligned dcl 38 set ref 114 149 201 206 239 241 243
                                                                                  243 245 245 248 248 250 250 255 255 258 258 260
                                                                                  260 273 275 278 278 286 286 294 294 304 304 306
                                                                                  306 309 309 316 316 320 320 324 324 328 328 405*
                                                                                  608 609 613 613 614 614 617* 629 629 632 632
expr_info                              based           structure                level 1 dcl 1-70
expr_infop                      001134 automatic       pointer                  dcl 1-68 set ref 100* 101 102* 103 104 106 107 181
                                                                                  183 294* 304 316 319 320 323 324 327 328 332* 339
                                                                                  353 354 536 537 567 568 614*
exprl                           000110 automatic       fixed bin(17,0)          dcl 37 set ref 99* 114 147 149 167 201 206 206 206
                                                                                  239 241 243 243 245 245 248 248 250 250 255 255
                                                                                  258 258 260 260 273 275 278 278 286 286 294 294
                                                                                  304 304 306 306 309 309 316 316 320 320 324 324
                                                                                  328 328 405 405 406* 406 608 609 613 613 614 614
                                                                                  617 617 629 629 629 629 629 632 632
exprp                           000106 automatic       pointer                  dcl 36 set ref 98* 114 149 201 206 239 241 243 243
                                                                                  245 245 248 248 250 250 255 255 258 258 260 260
                                                                                  273 275 278 278 286 286 294 294 304 304 306 306
                                                                                  309 309 316 316 320 320 324 324 328 328 405* 405
                                                                                  608 609 613 613 614 614 617 629 629 632 632
fb35                            001321 automatic       fixed bin(35,0)          dcl 605 set ref 620* 621* 622
flags                                  based           structure                level 2 dcl 1-70 set ref 103*
fnp                             000102 automatic       fixed bin(17,0)          dcl 32 set ref 97* 278* 294* 332* 342* 560* 614*
hbound                                                 builtin function         dcl 92 ref 386
hwcm_addr                 3            based           fixed bin(17,0)          level 2 dcl 1-70 ref 323
hwcm_known                0(02)        based           bit(1)                   level 3 packed unaligned dcl 1-70 set ref 320
i                               001155 automatic       fixed bin(17,0)          dcl 232 in procedure "parse_sym" set ref 239* 240
                                                                                  241 241* 242* 242 243 243 245 245 248 248 250 250
                                                                                  252 255 255 258 258 260 260 262* 273* 274 275 275*
                                                                                  276* 276 278 278 282* 286 286 290* 294 294 300*
                                                                                  304 304 306 306 309 309 316 316 320 320 324 324
                                                                                  328 328 355*
i                               001145 automatic       fixed bin(17,0)          dcl 138 in procedure "parse_expr" set ref 149* 150
                                                                                  150
i                               001316 automatic       fixed bin(17,0)          dcl 603 in procedure "eval_inst" set ref 607* 610*
                                                                                  614 614
ind_token                              constant        fixed bin(17,0)          initial dcl 65 set ref 210* 376 452 492 557
index                                                  builtin function         dcl 92 ref 149
inst                            001320 automatic       bit(18)                  unaligned dcl 604 set ref 614* 620 620 621
ioa_                            000010 constant        entry                    external dcl 77 ref 617 646
ioa_$general_rs                 000012 constant        entry                    external dcl 78 ref 643
j                               001317 automatic       fixed bin(17,0)          dcl 603 in procedure "eval_inst" set ref 608* 611*
                                                                                  611 613* 613 614 614
j                               001156 automatic       fixed bin(17,0)          dcl 232 in procedure "parse_sym" set ref 278* 281
leftp_token                            constant        fixed bin(17,0)          initial dcl 65 set ref 159* 370 448
len                       6            based           fixed bin(17,0)          level 2 in structure "expr_info" dcl 1-70
                                                                                  in procedure "db_fnp_eval_" set ref 107* 354* 537*
                                                                                  568*
len                       2            based           fixed bin(17,0)          level 2 in structure "sym" packed unaligned dcl 1-22
                                                                                  in procedure "db_fnp_eval_" ref 354
length                                                 builtin function         dcl 92 ref 99 167 241 243 275 608 613 629 629 629
meter_orig                      001163 automatic       fixed bin(18,0)          unsigned unaligned dcl 237 set ref 342 342 349* 349
                                                                                  350
mult_token                             constant        fixed bin(17,0)          initial dcl 65 set ref 177* 190* 364 453 470*
n                                      parameter       fixed bin(17,0)          dcl 403 in procedure "adv" ref 401 405 406
n                                      parameter       fixed bin(17,0)          dcl 657 in procedure "substraddr" ref 654 660
n                                      parameter       fixed bin(17,0)          dcl 581 in procedure "del_token" ref 579 585
n_add                           000116 automatic       fixed bin(17,0)          dcl 44 set ref 443* 450* 454* 454 469 471 471*
n_ind                           000114 automatic       fixed bin(17,0)          dcl 42 set ref 443* 450* 452* 452 469 472 556 566*
                                                                                  566
n_mult                          000115 automatic       fixed bin(17,0)          dcl 43 set ref 443* 450* 453* 453 469 470 470*
next                            001304 automatic       fixed bin(17,0)          dcl 582 in procedure "del_token" set ref 587* 588
                                                                                  591 592
next                      0(09)        based           fixed bin(8,0)           level 2 in structure "token" packed unaligned dcl 56
                                                                                  in procedure "db_fnp_eval_" set ref 387* 391* 424
                                                                                  455 497 516 517 569 571 587 591*
nparen                          001144 automatic       fixed bin(17,0)          dcl 137 set ref 143* 160* 160 166 171* 171 217
ntoken                          000105 automatic       fixed bin(17,0)          dcl 35 set ref 140* 386 387 387 388* 388 389 390 418
                                                                                  594* 594
null                                                   builtin function         dcl 92 ref 101 104 305 307
op                                     based           structure                level 1 packed unaligned dcl 1-99
opval                           001160 automatic       bit(18)                  unaligned dcl 234 set ref 286* 289 294* 298 298 299
p                               001306 automatic       pointer                  dcl 583 in procedure "del_token" set ref 585* 586
                                                                                  587 590* 591 592* 593
p                               001264 automatic       pointer                  dcl 513 in procedure "compute_op" set ref 517* 518
                                                                                  519* 520
p                               000200 automatic       pointer                  dcl 640 in procedure "err" set ref 642* 643*
prev                                   based           fixed bin(8,0)           level 2 in structure "token" packed unaligned dcl 56
                                                                                  in procedure "db_fnp_eval_" set ref 390* 519 533
                                                                                  558 586 593*
prev                            001305 automatic       fixed bin(17,0)          dcl 582 in procedure "del_token" set ref 586* 588
                                                                                  590 593
reloc                     2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-22 ref 316 320 324
                                                                                  328
reloc_hwcm                             constant        fixed bin(17,0)          initial dcl 1-40 ref 320
reloc_meters                           constant        fixed bin(17,0)          initial dcl 1-40 ref 328
reloc_sfcm                             constant        fixed bin(17,0)          initial dcl 1-40 ref 324
reloc_tib                              constant        fixed bin(17,0)          initial dcl 1-40 ref 316
result                          000103 automatic       fixed bin(17,0)          dcl 33 set ref 123 425* 622*
rightp_token                           constant        fixed bin(17,0)          initial dcl 65 set ref 170* 376 447
s                               000100 automatic       char(256)                unaligned dcl 639 set ref 643* 644* 646*
search                                                 builtin function         dcl 92 ref 273
sfcm_addr                 4            based           fixed bin(17,0)          level 2 dcl 1-70 ref 327
sfcm_known                0(03)        based           bit(1)                   level 3 packed unaligned dcl 1-70 set ref 324
star_addr                 1            based           fixed bin(17,0)          level 2 dcl 1-70 ref 183
star_known                             based           bit(1)                   level 3 packed unaligned dcl 1-70 set ref 181
start_token                            constant        fixed bin(17,0)          initial dcl 65 set ref 141* 164 370
string                                                 builtin function         dcl 92 set ref 103*
sub                       0(27)        based           fixed bin(8,0)           level 2 packed unaligned dcl 56 set ref 178* 191*
                                                                                  201* 202* 393* 522 526
substr                                                 builtin function         dcl 92 set ref 114 149 201 206 243 245 245 248 248
                                                                                  250 250 255 255 258 258 260 260 260 260 264 264*
                                                                                  278 278 286 286 294 294 298 304 304 306 306 309
                                                                                  309 316 316 320 320 324 324 328 328 562* 563 563*
                                                                                  564* 609 613 614 614 620 629 629 629 629 632 632
sym                                    based           structure                level 1 packed unaligned dcl 1-22
sym_token                              constant        fixed bin(17,0)          initial dcl 65 set ref 182* 195* 266* 280* 288* 297*
                                                                                  314* 376
symp                            001132 automatic       pointer                  dcl 1-20 set ref 304* 305 306* 307 315 316 320 324
                                                                                  328 353 354
tcur                            000113 automatic       fixed bin(17,0)          dcl 41 set ref 444* 449 455* 456 458 490* 491 497*
                                                                                  498 515 533* 534 554* 555 558* 559 571* 572
tend                            000112 automatic       fixed bin(17,0)          dcl 40 set ref 458* 476*
tib_addr                  2            based           fixed bin(17,0)          level 2 dcl 1-70 ref 319 339
tib_known                 0(01)        based           bit(1)                   level 3 packed unaligned dcl 1-70 set ref 316 328
tib_meter                       001161 automatic       fixed bin(17,0)          dcl 235 set ref 332* 340* 340 342*
tib_page_base                   001162 automatic       fixed bin(17,0)          dcl 236 set ref 339* 340 349
token                                  based           structure                level 1 packed unaligned dcl 56
token_cnt                              parameter       fixed bin(17,0)          dcl 488 set ref 485 492 495* 495
token_list                      000132 automatic       structure                level 1 dcl 47
token_type                             parameter       fixed bin(17,0)          dcl 487 ref 485 493
tokenp                          001130 automatic       pointer                  dcl 54 set ref 164 178 183 191 201 202 267 281 289
                                                                                  298 299 315 319 319 323 323 327 327 350 350 364
                                                                                  364 370 370 376 376 376 387 389* 390 391 392 393
                                                                                  394 423* 424* 424 425 445* 447 447 448 452 453 454
                                                                                  455 456* 491* 492 493 497 498* 516 517 519 521 522
                                                                                  526 533 534* 535 555* 557 558 559* 560 561 565 569
                                                                                  571 572*
tstart                          000111 automatic       fixed bin(17,0)          dcl 39 set ref 444* 445 449* 475* 490 554
type                      3            based           fixed bin(17,0)          level 2 in structure "sym" packed unaligned dcl 1-22
                                                                                  in procedure "db_fnp_eval_" ref 353
type                      5            based           fixed bin(17,0)          level 2 in structure "expr_info" dcl 1-70
                                                                                  in procedure "db_fnp_eval_" set ref 106* 353* 536*
                                                                                  567*
type                      0(18)        based           fixed bin(8,0)           level 2 in structure "token" packed unaligned dcl 56
                                                                                  in procedure "db_fnp_eval_" set ref 164 364 364
                                                                                  370 370 376 376 376 392* 447 447 448 452 453 454
                                                                                  492 493 521 557
type                                   parameter       fixed bin(17,0)          dcl 384 in procedure "new_token" ref 382 392
type_oct                               constant        fixed bin(17,0)          initial dcl 1-49 ref 106 536 567
unspec                                                 builtin function         dcl 92 set ref 289* 298* 299* 565* 620*
user_tablep              10            based           pointer                  level 2 dcl 1-70 set ref 104* 304*
val                       1            based           fixed bin(35,0)          level 2 in structure "token" packed unaligned dcl 56
                                                                                  in procedure "db_fnp_eval_" set ref 183* 267* 281*
                                                                                  289* 298* 299* 315* 319* 319 323* 323 327* 327
                                                                                  350* 350 394* 425 518 520 535* 560 561* 565*
val                             001275 automatic       bit(18)                  level 2 in structure "word_buf" packed unaligned
                                                                                  dcl 550 in procedure "eval_ind" set ref 562 563
val                             001154 automatic       fixed bin(35,0)          dcl 230 in procedure "parse_sym" set ref 245* 250
                                                                                  250 255* 260 260 264 264 264 267
val1                            001262 automatic       fixed bin(35,0)          dcl 512 set ref 520* 522* 522 523* 523 526* 526 529*
                                                                                  529 535
val2                            001263 automatic       fixed bin(35,0)          dcl 512 set ref 518* 522 523 526 528 529
value                     1(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 1-22 ref 315
verify                                                 builtin function         dcl 92 ref 239
word_buf                        001275 automatic       structure                level 1 dcl 550 set ref 560 560

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
cmd_info                               based           structure                level 1 dcl 1-118
cmd_infop                              automatic       pointer                  dcl 1-116
command                                based           char                     unaligned dcl 1-131
db_fnp_opblocks_$                      external static fixed bin(17,0)          dcl 1-158
db_fnp_opcodes_$                       external static fixed bin(17,0)          dcl 1-88
db_fnp_symbols_$db_fnp_symbols_        external static fixed bin(17,0)          dcl 1-10
env                                    based           structure                level 1 dcl 1-139
envp                                   automatic       pointer                  dcl 1-137
exptext                                based           structure                level 1 dcl 1-34
exptextp                               automatic       pointer                  dcl 1-32
long_type_names                        internal static char(12)                 initial array unaligned dcl 1-60
opblock_table                          based           structure                level 1 dcl 1-162
opblock_tablep                         automatic       pointer                  dcl 1-160
operand                                based           char                     unaligned dcl 1-132
opp                                    automatic       pointer                  dcl 1-97
optable                                based           structure                level 1 dcl 1-92
optablep                               automatic       pointer                  dcl 1-90
reloc_abs                              internal static fixed bin(17,0)          initial dcl 1-40
short_type_names                       internal static char(4)                  initial array unaligned dcl 1-62
symbol_table                           based           structure                level 1 dcl 1-14
symbol_tablep                          automatic       pointer                  dcl 1-12
type_addr                              internal static fixed bin(17,0)          initial dcl 1-49
type_bit                               internal static fixed bin(17,0)          initial dcl 1-49
type_char                              internal static fixed bin(17,0)          initial dcl 1-49
type_clock                             internal static fixed bin(17,0)          initial dcl 1-49
type_dec                               internal static fixed bin(17,0)          initial dcl 1-49
type_ebcdic                            internal static fixed bin(17,0)          initial dcl 1-49
type_inst                              internal static fixed bin(17,0)          initial dcl 1-49
type_op                                internal static fixed bin(17,0)          initial dcl 1-49

NAMES DECLARED BY EXPLICIT CONTEXT.
adv                             002703 constant        entry                    internal dcl 401 ref 161 172 185 192 203 211 252 262
                                                                                  282 290 300 355
bad_char                        000441 constant        label                    dcl 629 ref 151 157 164 167 188 199 209 274
compute_op                      003150 constant        entry                    internal dcl 509 ref 494
db_fnp_eval_                    000342 constant        entry                    external dcl 17 ref 332
del_token                       003520 constant        entry                    internal dcl 579 ref 475 476 538 539 569
err                             003774 constant        entry                    internal dcl 637 ref 168 181 206 217 219 248 250 258
                                                                                  260 309 316 320 324 328 386 528 561 629 632
error_return                    000434 constant        label                    dcl 128 ref 618 648
eval_expr                       002737 constant        entry                    internal dcl 416 ref 121
eval_ind                        003330 constant        entry                    internal dcl 547 ref 472
eval_inst                       003576 constant        entry                    internal dcl 601 ref 115
eval_op                         003102 constant        entry                    internal dcl 485 ref 470 471
eval_return                     000427 constant        label                    dcl 123 ref 116
eval_sub_expr                   003054 constant        entry                    internal dcl 467 ref 420
find_sub_expr                   002767 constant        entry                    internal dcl 441 ref 419
mult_or_add                     002512 constant        entry                    internal dcl 362 ref 164 188 199 209 219 556
new_token                       002612 constant        entry                    internal dcl 382 ref 141 159 170 177 182 190 195 200
                                                                                  210 221 266 280 288 297 314
next_token                      001064 constant        label                    dcl 214 ref 153 162 173 186 193 204 212
parse_expr                      000536 constant        entry                    internal dcl 135 ref 119
parse_op                        000000 constant        label                    array(8) dcl 157 ref 150
parse_sym                       001124 constant        entry                    internal dcl 228 ref 152
start_or_leftp                  002536 constant        entry                    internal dcl 368 ref 188 195 209
substraddr                      004165 constant        entry                    internal dcl 654 ref 405
sym_or_rightp_or_ind            002562 constant        entry                    internal dcl 374 ref 151 157 175

NAMES DECLARED BY CONTEXT OR IMPLICATION.
bin                                                    builtin function         ref 621
mod                                                    builtin function         ref 340 349

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5140        5202    4737        5150
Length      5414    4737        42         176     201           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
db_fnp_eval_                       1032 external procedure  is an external procedure.  
parse_expr                              internal procedure  shares stack frame of external procedure db_fnp_eval_.  
parse_sym                               internal procedure  shares stack frame of external procedure db_fnp_eval_.  
mult_or_add                             internal procedure  shares stack frame of external procedure db_fnp_eval_.  
start_or_leftp                          internal procedure  shares stack frame of external procedure db_fnp_eval_.  
sym_or_rightp_or_ind                    internal procedure  shares stack frame of external procedure db_fnp_eval_.  
new_token                               internal procedure  shares stack frame of external procedure db_fnp_eval_.  
adv                                     internal procedure  shares stack frame of external procedure db_fnp_eval_.  
eval_expr                               internal procedure  shares stack frame of external procedure db_fnp_eval_.  
find_sub_expr                           internal procedure  shares stack frame of external procedure db_fnp_eval_.  
eval_sub_expr                           internal procedure  shares stack frame of external procedure db_fnp_eval_.  
eval_op                                 internal procedure  shares stack frame of external procedure db_fnp_eval_.  
compute_op                              internal procedure  shares stack frame of external procedure db_fnp_eval_.  
eval_ind                                internal procedure  shares stack frame of external procedure db_fnp_eval_.  
del_token                               internal procedure  shares stack frame of external procedure db_fnp_eval_.  
eval_inst                               internal procedure  shares stack frame of external procedure db_fnp_eval_.  
err                                 192 internal procedure  is called during a stack extension, and is declared options(variable).  
substraddr                              internal procedure  shares stack frame of external procedure db_fnp_eval_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
db_fnp_eval_             000100 corep                       db_fnp_eval_
                         000102 fnp                         db_fnp_eval_
                         000103 result                      db_fnp_eval_
                         000104 code                        db_fnp_eval_
                         000105 ntoken                      db_fnp_eval_
                         000106 exprp                       db_fnp_eval_
                         000110 exprl                       db_fnp_eval_
                         000111 tstart                      db_fnp_eval_
                         000112 tend                        db_fnp_eval_
                         000113 tcur                        db_fnp_eval_
                         000114 n_ind                       db_fnp_eval_
                         000115 n_mult                      db_fnp_eval_
                         000116 n_add                       db_fnp_eval_
                         000120 auto_expr_info              db_fnp_eval_
                         000132 token_list                  db_fnp_eval_
                         001130 tokenp                      db_fnp_eval_
                         001132 symp                        db_fnp_eval_
                         001134 expr_infop                  db_fnp_eval_
                         001144 nparen                      parse_expr
                         001145 i                           parse_expr
                         001154 val                         parse_sym
                         001155 i                           parse_sym
                         001156 j                           parse_sym
                         001157 dec_sw                      parse_sym
                         001160 opval                       parse_sym
                         001161 tib_meter                   parse_sym
                         001162 tib_page_base               parse_sym
                         001163 meter_orig                  parse_sym
                         001260 del1                        compute_op
                         001261 del2                        compute_op
                         001262 val1                        compute_op
                         001263 val2                        compute_op
                         001264 p                           compute_op
                         001274 bitval                      eval_ind
                         001275 word_buf                    eval_ind
                         001304 next                        del_token
                         001305 prev                        del_token
                         001306 p                           del_token
                         001316 i                           eval_inst
                         001317 j                           eval_inst
                         001320 inst                        eval_inst
                         001321 fb35                        eval_inst
err                      000100 s                           err
                         000200 p                           err

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_cs            call_ext_in_desc    call_ext_out_desc   call_ext_out
call_int_this_desc  return              tra_ext             mod_fx1             shorten_stack       ext_entry_desc
int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_list_ptr              cv_dec_check_                 cv_oct_check_
db_fnp_edit_inst_$assemble    db_fnp_memory_$fetch          db_fnp_opblock_util_$lookup   db_fnp_sym_util_$lookup
db_fnp_sym_util_$lookup_user  db_fnp_util_$lookup_module    ioa_                          ioa_$general_rs

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     17 000334        96 000362        97 000366        98 000370        99 000372       100 000374       101 000377
    102 000403       103 000405       104 000406       106 000410       107 000413       112 000415       114 000416
    115 000423       116 000424       119 000425       121 000426       123 000427       125 000432       126 000433
    128 000434       130 000436       131 000440       629 000441       632 000510       666 000535       135 000536
    140 000537       141 000540       143 000542       147 000543       149 000545       150 000557       151 000561
    152 000566       153 000567       157 000570       159 000575       160 000577       161 000600       162 000604
    164 000605       166 000623       167 000625       168 000630       170 000646       171 000650       172 000652
    173 000656       175 000657       177 000664       178 000666       179 000672       181 000673       182 000711
    183 000713       185 000722       186 000726       188 000727       190 000742       191 000744       192 000750
    193 000754       195 000755       199 000765       200 000772       201 000774       202 001006       203 001012
    204 001016       206 001017       209 001042       210 001055       211 001057       212 001063       217 001064
    219 001101       221 001121       222 001123       228 001124       233 001125       239 001126       240 001142
    241 001144       242 001151       243 001153       244 001164       245 001166       246 001214       247 001217
    248 001220       249 001247       250 001250       252 001304       253 001312       255 001313       256 001341
    257 001344       258 001345       259 001374       260 001375       262 001431       264 001434       266 001445
    267 001447       268 001455       273 001456       274 001470       275 001472       276 001477       278 001501
    279 001540       280 001543       281 001545       282 001553       283 001555       286 001556       287 001607
    288 001612       289 001614       290 001625       291 001627       294 001630       296 001674       297 001677
    298 001701       299 001716       300 001726       301 001730       304 001731       305 001762       306 001767
    307 002014       308 002021       309 002022       310 002051       313 002052       314 002053       315 002055
    316 002070       319 002141       320 002153       323 002210       324 002222       327 002257       328 002271
    331 002326       332 002327       333 002371       335 002373       336 002375       339 002376       340 002403
    342 002410       343 002435       345 002437       346 002441       349 002442       350 002451       353 002471
    354 002501       355 002507       356 002511       362 002512       364 002514       368 002536       370 002540
    374 002562       376 002564       382 002612       386 002614       387 002635       388 002646       389 002647
    390 002653       391 002662       392 002665       393 002674       394 002677       395 002702       401 002703
    405 002705       406 002733       407 002736       416 002737       418 002740       419 002743       420 002744
    421 002745       423 002746       424 002750       425 002760       426 002766       441 002767       443 002770
    444 002773       445 002776       447 003001       448 003014       449 003016       450 003020       451 003023
    452 003024       453 003030       454 003034       455 003037       456 003045       457 003050       458 003051
    460 003053       467 003054       469 003055       470 003061       471 003065       472 003071       473 003074
    475 003075       476 003077       477 003101       485 003102       490 003104       491 003106       492 003111
    493 003125       494 003130       495 003131       497 003134       498 003143       499 003146       500 003147
    509 003150       515 003151       516 003153       517 003162       518 003165       519 003173       520 003203
    521 003211       522 003220       523 003234       524 003242       526 003243       528 003256       529 003274
    533 003277       534 003306       535 003311       536 003316       537 003321       538 003323       539 003325
    540 003327       547 003330       554 003331       555 003333       556 003336       557 003350       558 003360
    559 003366       560 003371       561 003424       562 003446       563 003451       564 003457       565 003461
    566 003465       567 003467       568 003472       569 003474       571 003504       572 003513       573 003516
    575 003517       579 003520       585 003522       586 003526       587 003534       588 003542       590 003547
    591 003553       592 003561       593 003565       594 003573       595 003575       601 003576       607 003577
    608 003601       609 003603       610 003610       611 003612       613 003614       614 003623       615 003667
    616 003672       617 003730       618 003753       620 003754       621 003765       622 003770       623 003772
    637 003773       642 004001       643 004007       644 004056       646 004127       647 004154       648 004162
    654 004165       660 004176


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
