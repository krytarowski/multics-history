	COMPILATION LISTING OF SEGMENT amu_print_text_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/28/87  0928.6 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1983 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 /****^  HISTORY COMMENTS:
       15*  1) change(85-05-13,Farley), approve(85-05-13,MCR7242),
       16*     audit(85-05-13,Fawcett), install(86-02-19,MR12.0-1019):
       17*     Added EIS Indirect Descriptors.
       18*  2) change(87-07-17,Parisek), approve(87-07-17,MCR7746),
       19*     audit(87-07-17,Fawcett), install(87-07-28,MR12.1-1049):
       20*     Modified to conform to coding standards.
       21*                                                   END HISTORY COMMENTS */
       22 
       23 
       24 /* Program to display output text produced by pl/1 and Fortran.  A reduced version of
       25*   display_text.  Numbers in the disassembled instruction are decimal.  The offset and
       26*   the instruction as it apears in core are in octal.
       27*
       28*  The numbers are really in octal, despite comment.  Modified by JRDavis 19 Mar 80
       29*  to not call binoct (which was transfer vector to pl1 compiler lang_util_ MCR 4422
       30*  Modified for amu by Rich Fawcett Feb 83 to add real_offset entry
       31*  Modified April 1985 by Paul Farley to add EIS Indirect Descriptors.
       32**/
       33 
       34 amu_print_text_: proc (t_pt, arg_number, output_switch);
       35 
       36 dcl  t_pt ptr,					/* points at text base */
       37      arg_number fixed bin,				/* max. no. of words to print */
       38      output_switch char (*) aligned,			/* switch name for printing disassembled line */
       39      arg_offset fixed bin (18),			/* real offset to be printed instead of t_pt */
       40      arg_string char (*) var;				/* output.  Contains formatted instruction */
       41 
       42 
       43 dcl  number fixed bin;				/* no. of words to print */
       44 dcl  desc_type fixed bin;				/* descriptor type: 0 = alpha, 1 = bit, 2 = numeric */
       45 dcl  comment char (50) var;
       46 dcl  op_name char (32) aligned;
       47 dcl (p, pt) ptr,
       48     (no_to_print, j, k, m, op_index, irand, nrands, ndesc) fixed bin,
       49     (fract_offset, offset, scale) fixed bin (18),
       50     (double, eis, eis_desc, need_comma, ext_base, has_ic, decimal, ind_desc) bit (1),
       51      ht char (1) int static aligned init ("	"),		/* tab */
       52      htht char (2) int static aligned init ("		"),	/* two tabs */
       53      cstring char (12),
       54      op_code char (5),
       55      tag char (3),
       56      line char (256),
       57      buff char (12) varying,
       58      pl1_operators_$operator_table fixed bin ext;
       59 
       60 dcl  repeat_inst bit (1);				/* ON for rpd, rpt, rpl */
       61 dcl  print_instr bit (1);				/* 1= print instr;	  0= return formatted string */
       62 dcl  real_offset_entry bit (1) unal;			/* ON if instruction ptr is different from text location */
       63 dcl  real_offset fixed bin (18);			/* used with $format, $offset entries */
       64 dcl  ioa_$ioa_stream ext entry options (variable);
       65 dcl  ioa_$rsnnl ext entry options (variable);
       66 dcl  find_operator_name_ entry (char (*) aligned, ptr, char (32) aligned);
       67 
       68 dcl (addr, addrel, fixed, length, ptr, rel, rtrim, string, substr) builtin;
       69 
       70 dcl 1 op_mnemonic_$op_mnemonic (0:1023) ext static aligned,
       71     2 opcode char (6) unal,
       72     2 dtype fixed bin (2) unal,			/* 0 = alpha, 1 = bit, 2 = numeric */
       73     2 num_desc fixed bin (5) unal,
       74     2 num_words fixed bin (8) unal;
       75 
       76 dcl  digit (0:9) char (1) aligned int static
       77      init ("0", "1", "2", "3", "4", "5", "6", "7", "8", "9");
       78 
       79 dcl  base (0:7) char (4) aligned int static
       80      init ("pr0|", "pr1|", "pr2|", "pr3|", "pr4|", "pr5|", "pr6|", "pr7|");
       81 
       82 dcl  modifier (0:63) char (3) aligned int static
       83      init (" ", "au", "qu", "du", "ic", "al", "ql", "dl",
       84      "0", "1", "2", "3", "4", "5", "6", "7",
       85      "*", "au*", "qu*", "...", "ic*", "al*", "ql*", "...",
       86      "0*", "1*", "2*", "3*", "4*", "5*", "6*", "7*",
       87      "f", "itp", "...", "its", "sd", "scr", "f2", "f3",
       88      "ci", "i", "sc", "ad", "di", "dic", "id", "idc",
       89      "*n", "*au", "*qu", "*du", "*ic", "*al", "*ql", "*dl",
       90      "*0", "*1", "*2", "*3", "*4", "*5", "*6", "*7");
       91 
       92 dcl  word (0:1) bit (36) aligned based (p);
       93 
       94 dcl 1 instruction based (p) aligned,
       95     2 base unaligned bit (3),
       96     2 offset unaligned bit (15),
       97     2 op_code unaligned bit (10),
       98     2 inhibit unaligned bit (1),
       99     2 ext_base unaligned bit (1),
      100     2 tag unaligned bit (6);
      101 
      102 dcl 1 half based (p) aligned,
      103     2 left unaligned bit (18),
      104     2 right unaligned bit (18);
      105 
      106 dcl 1 mod_factor aligned,
      107     2 ext_base bit (1) unal,
      108     2 length_in_reg bit (1) unal,
      109     2 indirect_descriptor bit (1) unal,
      110     2 tag bit (4) unal;
      111 
      112 dcl  mf (3) fixed bin (6) int static init (30, 12, 3);	/* location of modification factor fields in EIS inst */
      113 
      114 dcl (ebase, len_reg, idesc, ic) (3) bit (1) aligned;
      115 dcl  desc_word char (8) varying;
      116 
      117 dcl  desc_op (0:3) char (8) varying int static init ("desc9a", "descb", "desc9fl", "desc9ls");
      118 
      119 dcl  eis_modifier (0:15) char (3) aligned int static
      120      init ("n", "au", "qu", "du", "ic", "al", "ql", "...",
      121      "x0", "x1", "x2", "x3", "x4", "x5", "x6", "x7");
      122 
      123 dcl  bool_word (0:15) char (6) aligned int static varying
      124      init ("clear", "and", "andnot", "move", "", "", "xor", "or",
      125      "", "", "", "", "invert", "", "nand", "set");
      126 
      127 dcl 1 descriptor based aligned,			/* EIS descriptor */
      128     2 address bit (18) unal,
      129     2 char bit (2) unal,
      130     2 bit bit (4) unal,
      131     2 length bit (12) unal;
      132 
      133 /*  */
      134 
      135 	number = arg_number;
      136 	print_instr = "1"b;
      137 	real_offset_entry = "0"b;
      138 	p = t_pt;
      139 
      140 begin:	substr (line, 11, 3) = "   ";
      141 	eis = "0"b;
      142 	irand = 0;
      143 
      144 	do no_to_print = 1 to number;
      145 
      146 	     comment = "";
      147 	     tag = "   ";
      148 	     substr (line, 7, 2) = "  ";
      149 	     cstring = binoct (p -> word (0));
      150 
      151 	     if eis then op_index = 0;
      152 
      153 	     else do;
      154 		op_index = fixed (p -> instruction.op_code, 10);
      155 		op_code = rtrim(opcode (op_index));
      156 	     end;
      157 
      158 	     if num_words (op_index) > 1 then call eis_instruction;
      159 
      160 	     else do;
      161 		has_ic, double, repeat_inst = "0"b;
      162 
      163 		eis_desc = eis & (ind_desc | desc_word ^= "arg");
      164 		if eis_desc then call eis_descriptor;
      165 
      166 		else do;
      167 		     substr (line, 13, 2) = "  ";
      168 		     substr (line, 15, 6) = substr (cstring, 2, 5);
      169 		     substr (line, 21, 5) = substr (cstring, 7, 4);
      170 		     substr (line, 26, 8) = substr (cstring, 11, 2) || ht || op_code;
      171 		     k = 34;
      172 
      173 		     ext_base = p -> instruction.ext_base;
      174 
      175 		     if op_code = "rpd  " | op_code = "rpt  " | op_code = "rpl  " then do;
      176 			repeat_inst = "1"b;
      177 			call ioa_$rsnnl ("^d", tag, j, fixed (p -> instruction.tag, 6));
      178 			offset = fixed (substr (p -> half.left, 1, 8), 8);
      179 			substr (line, 14, 1) = rtrim(cstring);
      180 			call ioa_$rsnnl ("	^d", buff, j, offset);
      181 			substr (line, k, j) = buff;
      182 			k = k + j;
      183 		     end;
      184 
      185 		     else do;
      186 			if num_desc (op_index) ^= 0 then
      187 			     tag = substr (binoct ((p -> instruction.tag)), 1, 2);
      188 
      189 			else do;
      190 			     if p -> instruction.tag then tag = modifier (fixed (p -> instruction.tag, 6));
      191 			     double = substr (op_code, 1, 2) = "df" | substr (op_code, 3, 2) = "aq" | substr (op_code, 4, 2) = "aq";
      192 			     has_ic = p -> instruction.tag = "000100"b; /* IC */
      193 			end;
      194 			call address;
      195 		     end;
      196 
      197 		     call set_tag;
      198 		end;
      199 
      200 /* Print data referred to by self relative address: (tab) (tab) data offset = contents */
      201 
      202 		if has_ic then do;
      203 		     if real_offset_entry then pt = ptr (p, real_offset + offset - irand);
      204 		     else pt = addrel (p, offset-irand);
      205 		     substr (line, k, 8) = htht || binoct (rel (pt));
      206 		     k = k + 8;
      207 
      208 		     if substr (op_code, 1, 1) ^= "t" then do;
      209 			comment = " = " || binoct (pt -> word (0));
      210 			if double then comment = comment || " " || binoct (pt -> word (1));
      211 		     end;
      212 		end;
      213 
      214 		else if ext_base & (p -> instruction.base = "000"b) then do; /* info for pr0 only */
      215 
      216 		     if op_code = "xec  " then do;
      217 			pt = addrel (addr (pl1_operators_$operator_table), offset);
      218 			op_index = fixed (pt -> instruction.op_code, 10);
      219 			if num_words (op_index) > 1 then do;
      220 
      221 /* we are executing an EIS instruction in pl1_operators_ */
      222 
      223 			     call init_eis;
      224 
      225 			     do j = 1 to ndesc;
      226 				ebase (j) = "1"b;
      227 				len_reg (j) = ^ decimal;
      228 				ic (j) = "0"b;
      229 			     end;
      230 			end;
      231 		     end;
      232 
      233 		     if tag ^= " " then do;
      234 			call find_operator_name_ ("pl1_operators_", p, op_name);
      235 			if op_name ^= " " then do;
      236 			     substr (line, k, 34) = htht || op_name;
      237 			     k = k + 34;
      238 			end;
      239 
      240 		     end;
      241 		end;
      242 		if ^eis_desc & ^repeat_inst & p -> instruction.inhibit then comment = comment || " interrupt inhibit";
      243 
      244 	     end;
      245 
      246 	     if comment ^= "" then do;
      247 		j = length (comment);
      248 		substr (line, k, j) = comment;
      249 		k = k + j;
      250 	     end;
      251 
      252 	     if print_instr then call ioa_$ioa_stream (output_switch, "^6o ^a", fixed (rel (p), 17), substr (line, 11, k-11));
      253 
      254 	     else do;				/* return string for one line only */
      255 		j = k - 11;			/* save length of strjng */
      256 		k = 1;
      257 		call bin_to_oct (real_offset);
      258 		arg_string = substr (line, 1, k-1) || substr (line, 11, j);
      259 		return;
      260 	     end;
      261 
      262 	     if eis
      263 	     then do;
      264 		irand = irand + 1;
      265 		if irand > nrands then do;
      266 		     eis = "0"b;
      267 		     irand = 0;
      268 		end;
      269 		else if irand > ndesc
      270 		then op_code, desc_word = "arg";
      271 	     end;
      272 
      273 	     p = addrel (p, 1);
      274 	end;
      275 
      276 	return;
      277 
      278 
      279 /*  */
      280 /*  Entry point to return a formatted string with the disassembled instruction.  The
      281*   real offset is returned in the string.  */
      282 
      283 amu_print_text_$real_offset: entry (t_pt, arg_string, arg_offset);
      284 
      285 
      286 	p = t_pt;
      287 	real_offset = arg_offset;
      288 	number = 1;				/* process one word only */
      289 	print_instr = "0"b;				/* return string instead */
      290 	real_offset_entry = "1"b;
      291 	go to begin;
      292 
      293 amu_print_text_$format: entry (t_pt, arg_string);
      294 
      295 	number = 1;
      296 	p = t_pt;
      297 	real_offset = fixed (rel (p), 18);
      298 	print_instr = "0"b;
      299 	real_offset_entry = "0"b;
      300 	go to begin;
      301 
      302 bin_to_oct: proc (number);
      303 
      304 dcl (m, number) fixed bin (18);
      305 
      306 	     call ioa_$rsnnl ("^o", buff, m, number);
      307 	     substr (line, k, m) = buff;
      308 	     k = k + m;
      309 
      310 	end bin_to_oct;
      311 
      312 
      313 init_eis:	proc;
      314 
      315 	     eis = "1"b;
      316 	     nrands = num_words (op_index) - 1;
      317 	     ndesc = num_desc (op_index);
      318 	     decimal = dtype (op_index) = 2;
      319 	     desc_word = desc_op (dtype (op_index));
      320 	     desc_type = dtype (op_index);
      321 	     irand = 0;
      322 
      323 	end init_eis;
      324 
      325 /*  */
      326 eis_instruction: proc;
      327 
      328 	     call init_eis;
      329 
      330 	     substr (line, 13, 4) = substr (cstring, 1, 3);
      331 	     substr (line, 17, 4) = substr (cstring, 4, 3);
      332 	     substr (line, 21, 4) = substr (cstring, 7, 3);
      333 	     substr (line, 25, 3) = substr (cstring, 10, 3);
      334 
      335 	     substr (line, 28, 1) = ht;
      336 	     substr (line, 29, 5) = op_code;
      337 	     substr (line, 34, 1) = ht;
      338 
      339 	     k = 35;
      340 
      341 	     do j = 1 to ndesc;
      342 		string (mod_factor) = substr (p -> word (0), mf (j), 7);
      343 		ebase (j) = mod_factor.ext_base;
      344 		len_reg (j) = mod_factor.length_in_reg;
      345 		idesc (j) = mod_factor.indirect_descriptor;
      346 
      347 		substr (line, k, 1) = "(";
      348 		k = k + 1;
      349 		need_comma = "0"b;
      350 
      351 		if ebase (j) then do;
      352 		     substr (line, k, 2) = "pr";
      353 		     k = k + 2;
      354 		     need_comma = "1"b;
      355 		end;
      356 
      357 		if len_reg (j) then do;
      358 		     if need_comma then do;
      359 			substr (line, k, 1) = ",";
      360 			k = k + 1;
      361 		     end;
      362 		     substr (line, k, 2) = "rl";
      363 		     k = k + 2;
      364 		     need_comma = "1"b;
      365 		end;
      366 
      367 		if idesc (j) then do;
      368 		     if need_comma then do;
      369 			substr (line, k, 1) = ",";
      370 			k = k + 1;
      371 		     end;
      372 		     substr (line, k, 2) = "id";
      373 		     k = k + 2;
      374 		     need_comma = "1"b;
      375 		end;
      376 
      377 		if mod_factor.tag then do;
      378 		     if need_comma then do;
      379 			substr (line, k, 1) = ",";
      380 			k = k + 1;
      381 		     end;
      382 		     ic (j) = mod_factor.tag = "0100"b; /* IC */
      383 		     substr (line, k, 2) = eis_modifier (fixed (mod_factor.tag, 4));
      384 		     k = k + 2;
      385 		end;
      386 		else ic (j) = "0"b;
      387 
      388 		substr (line, k, 2) = "),";
      389 		k = k + 2;
      390 	     end;
      391 
      392 
      393 	     if substr (p -> word (0), 10, 1) then do;
      394 		substr (line, k, 12) = "enablefault,";
      395 		k = k + 12;
      396 	     end;
      397 
      398 	     if desc_word = "desc9a"
      399 	     then if ndesc < 3 then do;
      400 		     if substr (op_code, 1, 2) ^= "sc"
      401 		     then substr (line, k, 5) = "fill(";
      402 		     else substr (line, k, 5) = "mask(";
      403 		     k = k + 5;
      404 		     substr (line, k, 3) = substr (cstring, 1, 3);
      405 		     k = k + 3;
      406 		     substr (line, k, 1) = ")";
      407 		     k = k + 1;
      408 		end;
      409 		else k = k - 1;
      410 	     else if desc_word = "descb" then do;
      411 		substr (line, k, 7) = "fill(" || digit (fixed (substr (p -> word (0), 1, 1), 1)) || ")"; /* fill(N) */
      412 		k = k + 7;
      413 
      414 		if op_code ^= "cmpb " then do;
      415 		     substr (line, k, 6) = ",bool(";
      416 		     k = k + 6;
      417 		     j = fixed (substr (p -> word (0), 6, 4), 4);
      418 		     m = length (bool_word (j));
      419 		     if m > 0 then do;
      420 			substr (line, k, m) = bool_word (j);
      421 			k = k + m;
      422 		     end;
      423 		     else do;
      424 			substr (line, k, 1) = digit (fixed (substr (p -> word (0), 6, 1), 1));
      425 			substr (line, k+1, 1) = digit (fixed (substr (p -> word (0), 7, 3), 3));
      426 			k = k + 2;
      427 		     end;
      428 		     substr (line, k, 1) = ")";
      429 		     k = k + 1;
      430 		end;
      431 	     end;
      432 	     else if substr (p -> word (0), 11, 1) then do;
      433 		substr (line, k, 5) = "round";
      434 		k = k + 5;
      435 	     end;
      436 	     else k = k - 1;
      437 
      438 	     return;
      439 
      440 	end eis_instruction;
      441 
      442 /*  */
      443 
      444 eis_descriptor: proc;
      445 
      446 dcl  len fixed bin (18);
      447 dcl  type fixed bin;				/* descriptor type */
      448 
      449 dcl 1 n_desc aligned based (p),
      450     2 y bit (18) unal,				/* address field */
      451     2 CN bit (3) unal,				/* character position */
      452     2 TN bit (1) unal,				/* type 0 = 9bit; 1 = 4 bit */
      453     2 S bit (2) unal,				/* sign type 0 = fl, 1 = ls, 2 = ts, 3 = ns */
      454     2 SF bit (6) unal,				/* scale factor */
      455     2 N bit (6) unal;				/* length */
      456 
      457 dcl 1 b_desc aligned based (p),			/* bit descriptor */
      458     2 y bit (18) unal,				/* address field */
      459     2 c bit (2) unal,				/* 9 bit offset */
      460     2 b bit (4) unal,				/* bit offset */
      461     2 N bit (12) unal;				/* length */
      462 
      463 dcl 1 a_desc aligned based (p),			/* alpha-numeric descriptor */
      464     2 y bit (18) unal,				/* address field */
      465     2 CN bit (3) unal,				/* character offset */
      466     2 TA bit (2) unal,
      467     2 pad bit (1) unal,				/* always zero */
      468     2 N bit (12) unal;				/* length */
      469 
      470 dcl  table_n_S (0:3) char (2) int static init ("fl", "ls", "ts", "ns");
      471 dcl  table_a_TA (0:3) char (1) int static init ("9", "6", "4", "?");
      472 
      473 	     ind_desc = idesc (irand);
      474 	     if ind_desc then do;
      475 		call ind_descriptor;
      476 		return;
      477 	     end;
      478 
      479 	     substr (line, 13, 2) = "  ";
      480 	     substr (line, 15, 6) = substr (cstring, 2, 5);
      481 	     substr (line, 21, 3) = substr (cstring, 7, 2);
      482 	     substr (line, 24, 4) = substr (cstring, 9, 4);
      483 	     substr (line, 28, 1) = ht;
      484 
      485 	     ext_base = ebase (irand);
      486 	     has_ic = ic (irand);
      487 
      488 	     type = desc_type;
      489 	     if op_code = "btd" & irand = 1 then type = 0;
      490 	     else if op_code = "dtb"  | op_code = "mvne" then if irand > 1 then type = 0;
      491 
      492 	     if type = 0 then do;			/*  alpha-nummeric descriptor */
      493 		desc_word = "desc" || table_a_TA (fixed (a_desc.TA, 2)) || "a";
      494 		if a_desc.TA = "00"b then fract_offset = fixed (substr (a_desc.CN, 1, 2), 2);
      495 		else fract_offset = fixed (a_desc.CN, 3);
      496 		len = fixed (a_desc.N, 12);
      497 	     end;
      498 
      499 	     else if type = 1 then do;		/* bit descriptor */
      500 		desc_word = "descb";
      501 		len = fixed (b_desc.N, 12);
      502 		fract_offset = fixed (b_desc.c, 2) * 9 + fixed (b_desc.b, 4);
      503 	     end;
      504 
      505 	     else do;				/* numeric descriptor */
      506 		if n_desc.TN then do;
      507 		     desc_word = "desc4";
      508 		     fract_offset = fixed (n_desc.CN,3);
      509 		end;
      510 		else do;
      511 		     desc_word = "desc9";
      512 		     fract_offset = fixed (substr (n_desc.CN, 1, 2), 2);
      513 		end;
      514 		desc_word = desc_word || table_n_S (fixed (n_desc.S, 2));
      515 		len = fixed (n_desc.N, 6);
      516 
      517 		if n_desc.S then do;		/*  for S = 00 there is no scale factor */
      518 		     scale = fixed (n_desc.SF, 6);
      519 		     if scale > 32 then scale = scale - 64;
      520 		end;
      521 	     end;
      522 
      523 /*  desc_word   address(fract_offset),tag,length,scale   */
      524 
      525 	     k = length (desc_word);
      526 	     substr (line, 29, k) = desc_word;
      527 	     k = k + 29;
      528 	     call address;
      529 
      530 	     if fract_offset ^= 0 then do;
      531 		call ioa_$rsnnl ("(^d)", buff, j, fract_offset);
      532 		substr (line, k, j) = buff;
      533 		k = k + j;
      534 	     end;
      535 
      536 	     if len_reg (irand) then do;		/* print register which contains length */
      537 		tag = eis_modifier (fixed (substr (p -> descriptor.length, 9, 4), 4));
      538 		call set_tag;
      539 	     end;
      540 
      541 	     else do;				/* print length as given */
      542 		substr (line, k, 1) = ",";
      543 		k = k + 1;
      544 		call bin_to_oct (len);
      545 	     end;
      546 
      547 	     if type = 2 then if n_desc.S then do;	/* scale factor for numeric only */
      548 		     substr (line, k, 1) = ",";
      549 		     k = k+1;
      550 		     call bin_to_oct (scale);
      551 		end;
      552 
      553 	     return;
      554 
      555 	end eis_descriptor;
      556 
      557 /*  */
      558 
      559 ind_descriptor: proc;
      560 
      561 dcl 1 i_desc aligned based (p),			/* indirect descriptor */
      562     2 y bit (18) unal,				/* address field */
      563     2 pad bit (11) unal,				/* always zero */
      564     2 extbase bit (1) unal,				/* PR mod */
      565     2 pad1 bit (2) unal,				/* always zero */
      566     2 tag bit (4) unal;				/* reg mod */
      567 
      568 
      569 	     substr (line, 13, 2) = "  ";
      570 	     substr (line, 15, 6) = substr (cstring, 2, 5);
      571 	     substr (line, 21, 5) = substr (cstring, 7, 4);
      572 	     substr (line, 26, 2) = substr (cstring, 11, 2);
      573 	     substr (line, 28, 1) = ht;
      574 
      575 	     ext_base = i_desc.extbase;
      576 	     has_ic = (i_desc.tag = "0100"b);
      577 	     desc_word = "arg";
      578 
      579 	     k = length (desc_word);
      580 	     substr (line, 29, k) = desc_word;
      581 	     k = k + 29;
      582 	     call address;
      583 
      584 	     if i_desc.tag then do;
      585 		substr (line, k, 3) = "," || eis_modifier (fixed (i_desc.tag, 4));
      586 		k = k + 3;
      587 	     end;
      588 	     return;
      589 	end ind_descriptor;
      590 
      591 /*  */
      592 
      593 /* This procedure disassembles the address portion.  It adds: tab [prN|] offset
      594*   It also sets the first octal digit so a blank will separate the register from the rest of the address field.
      595*
      596*   cstring	     The octal representation of the word.
      597*
      598*   ext_base	     ON if the address uses a register.
      599**/
      600 
      601 address:	proc;
      602 
      603 	     substr (line, k, 1) = ht;
      604 	     k = k + 1;
      605 
      606 	     if ext_base then do;
      607 		substr (line, k, 4) = base (fixed (p -> instruction.base, 3));
      608 		offset = fixed (p -> instruction.offset, 15);
      609 		if offset > 16384 then offset = offset - 32768;
      610 		k = k+4;
      611 		substr (line, 13, 1) = rtrim(cstring);
      612 	     end;
      613 
      614 	     else do;
      615 		offset = fixed (p -> half.left, 18);
      616 		if offset > 131072 then if tag ^= "du " & tag ^= "dl " then offset = offset - 262144; /* 2's comp */
      617 		substr (line, 14, 1) = rtrim(cstring);
      618 	     end;
      619 
      620 
      621 	     call bin_to_oct (offset);
      622 
      623 	end address;
      624 
      625 
      626 /*  This procedure sets the tag in the instruction line. */
      627 
      628 set_tag:	proc;
      629 
      630 	     if tag ^= " " then do;
      631 		substr (line, k, 4) = "," || tag;
      632 		k = k + 2;
      633 		if substr (line, k, 1) ^= " " then k = k + 1;
      634 		if substr (line, k, 1) ^= " " then k = k + 1;
      635 	     end;
      636 
      637 	     return;
      638 	end set_tag;
      639 
      640 binoct: proc (bits) returns (char (12) aligned);
      641         dcl bits bit (*) aligned parameter;
      642         dcl c12 char (12) aligned;
      643 
      644         call ioa_$rsnnl ("^12.3b", c12, (0), bits);
      645         return (c12);
      646 end binoct;
      647      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/28/87  0928.6  amu_print_text_.pl1               >spec>install>MR12.1-1049>amu_print_text_.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CN                        0(18)        based           bit(3)                   level 2 in structure "a_desc" packed unaligned
                                                                                  dcl 463 in procedure "eis_descriptor" ref 494 495
CN                        0(18)        based           bit(3)                   level 2 in structure "n_desc" packed unaligned
                                                                                  dcl 449 in procedure "eis_descriptor" ref 508 512
N                         0(24)        based           bit(12)                  level 2 in structure "b_desc" packed unaligned
                                                                                  dcl 457 in procedure "eis_descriptor" ref 501
N                         0(24)        based           bit(12)                  level 2 in structure "a_desc" packed unaligned
                                                                                  dcl 463 in procedure "eis_descriptor" ref 496
N                         0(30)        based           bit(6)                   level 2 in structure "n_desc" packed unaligned
                                                                                  dcl 449 in procedure "eis_descriptor" ref 515
S                         0(22)        based           bit(2)                   level 2 packed unaligned dcl 449 ref 514 517 547
SF                        0(24)        based           bit(6)                   level 2 packed unaligned dcl 449 ref 518
TA                        0(21)        based           bit(2)                   level 2 packed unaligned dcl 463 ref 493 494
TN                        0(21)        based           bit(1)                   level 2 packed unaligned dcl 449 ref 506
a_desc                                 based           structure                level 1 dcl 463
addr                                                   builtin function         dcl 68 ref 217
addrel                                                 builtin function         dcl 68 ref 204 217 273
arg_number                             parameter       fixed bin(17,0)          dcl 36 ref 34 135
arg_offset                             parameter       fixed bin(18,0)          dcl 36 ref 283 287
arg_string                             parameter       varying char             dcl 36 set ref 258* 283 293
b                         0(20)        based           bit(4)                   level 2 packed unaligned dcl 457 ref 502
b_desc                                 based           structure                level 1 dcl 457
base                            000223 constant        char(4)                  initial array dcl 79 in procedure "amu_print_text_"
                                                                                  ref 607
base                                   based           bit(3)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 94 in procedure "amu_print_text_" ref 214 607
bits                                   parameter       bit                      dcl 641 set ref 640 644*
bool_word                       000004 constant        varying char(6)          initial array dcl 123 ref 418 420
buff                            000265 automatic       varying char(12)         dcl 47 set ref 180* 181 306* 307 531* 532
c                         0(18)        based           bit(2)                   level 2 packed unaligned dcl 457 ref 502
c12                             000406 automatic       char(12)                 dcl 642 set ref 644* 645
comment                         000102 automatic       varying char(50)         dcl 45 set ref 146* 209* 210* 210 242* 242 246 247
                                                                                  248
cstring                         000157 automatic       char(12)                 unaligned dcl 47 set ref 149* 168 169 170 179 330
                                                                                  331 332 333 404 480 481 482 570 571 572 611 617
decimal                         000155 automatic       bit(1)                   unaligned dcl 47 set ref 227 318*
desc_op                         000104 constant        varying char(8)          initial array dcl 117 ref 319
desc_type                       000101 automatic       fixed bin(17,0)          dcl 44 set ref 320* 488
desc_word                       000312 automatic       varying char(8)          dcl 115 set ref 163 269* 319* 398 410 493* 500* 507*
                                                                                  511* 514* 514 525 526 577* 579 580
descriptor                             based           structure                level 1 dcl 127
digit                           000233 constant        char(1)                  initial array dcl 76 ref 411 424 425
double                          000147 automatic       bit(1)                   unaligned dcl 47 set ref 161* 191* 210
dtype                     1(18) 000020 external static fixed bin(2,0)           array level 2 packed unaligned dcl 70 ref 318 319
                                                                                  320
ebase                           000276 automatic       bit(1)                   array dcl 114 set ref 226* 343* 351 485
eis                             000150 automatic       bit(1)                   unaligned dcl 47 set ref 141* 151 163 262 266* 315*
eis_desc                        000151 automatic       bit(1)                   unaligned dcl 47 set ref 163* 164 242
eis_modifier                    000064 constant        char(3)                  initial array dcl 119 ref 383 537 585
ext_base                        000153 automatic       bit(1)                   unaligned dcl 47 in procedure "amu_print_text_" set
                                                                                  ref 173* 214 485* 575* 606
ext_base                  0(29)        based           bit(1)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 94 in procedure "amu_print_text_" ref 173
ext_base                        000275 automatic       bit(1)                   level 2 in structure "mod_factor" packed unaligned
                                                                                  dcl 106 in procedure "amu_print_text_" set ref 343
extbase                   0(29)        based           bit(1)                   level 2 packed unaligned dcl 561 ref 575
find_operator_name_             000016 constant        entry                    external dcl 66 ref 234
fixed                                                  builtin function         dcl 68 ref 154 177 177 178 190 218 252 252 297 383
                                                                                  411 417 424 425 493 494 495 496 501 502 502 508
                                                                                  512 514 515 518 537 585 607 608 615
fract_offset                    000144 automatic       fixed bin(18,0)          dcl 47 set ref 494* 495* 502* 508* 512* 530 531*
half                                   based           structure                level 1 dcl 102
has_ic                          000154 automatic       bit(1)                   unaligned dcl 47 set ref 161* 192* 202 486* 576*
ht                                     constant        char(1)                  initial dcl 47 ref 170 335 337 483 573 603
htht                            003266 constant        char(2)                  initial dcl 47 ref 205 236
i_desc                                 based           structure                level 1 dcl 561
ic                              000307 automatic       bit(1)                   array dcl 114 set ref 228* 382* 386* 486
idesc                           000304 automatic       bit(1)                   array dcl 114 set ref 345* 367 473
ind_desc                        000156 automatic       bit(1)                   unaligned dcl 47 set ref 163 473* 474
indirect_descriptor       0(02) 000275 automatic       bit(1)                   level 2 packed unaligned dcl 106 set ref 345
inhibit                   0(28)        based           bit(1)                   level 2 packed unaligned dcl 94 ref 242
instruction                            based           structure                level 1 dcl 94
ioa_$ioa_stream                 000012 constant        entry                    external dcl 64 ref 252
ioa_$rsnnl                      000014 constant        entry                    external dcl 65 ref 177 180 306 531 644
irand                           000141 automatic       fixed bin(17,0)          dcl 47 set ref 142* 203 204 264* 264 265 267* 269
                                                                                  321* 473 485 486 489 490 536
j                               000135 automatic       fixed bin(17,0)          dcl 47 set ref 177* 180* 181 182 225* 226 227 228*
                                                                                  247* 248 249 255* 258 341* 342 343 344 345 351 357
                                                                                  367 382 386* 417* 418 420 531* 532 533
k                               000136 automatic       fixed bin(17,0)          dcl 47 set ref 171* 181 182* 182 205 206* 206 236
                                                                                  237* 237 248 249* 249 252 252 255 256* 258 307
                                                                                  308* 308 339* 347 348* 348 352 353* 353 359 360*
                                                                                  360 362 363* 363 369 370* 370 372 373* 373 379
                                                                                  380* 380 383 384* 384 388 389* 389 394 395* 395
                                                                                  400 402 403* 403 404 405* 405 406 407* 407 409*
                                                                                  409 411 412* 412 415 416* 416 420 421* 421 424 425
                                                                                  426* 426 428 429* 429 433 434* 434 436* 436 525*
                                                                                  526 527* 527 532 533* 533 542 543* 543 548 549*
                                                                                  549 579* 580 581* 581 585 586* 586 603 604* 604
                                                                                  607 610* 610 631 632* 632 633 633* 633 634 634*
                                                                                  634
left                                   based           bit(18)                  level 2 packed unaligned dcl 102 ref 178 615
len                             000354 automatic       fixed bin(18,0)          dcl 446 set ref 496* 501* 515* 544*
len_reg                         000301 automatic       bit(1)                   array dcl 114 set ref 227* 344* 357 536
length                                                 builtin function         dcl 68 in procedure "amu_print_text_" ref 247 418
                                                                                  525 579
length                    0(24)        based           bit(12)                  level 2 in structure "descriptor" packed unaligned
                                                                                  dcl 127 in procedure "amu_print_text_" ref 537
length_in_reg             0(01) 000275 automatic       bit(1)                   level 2 packed unaligned dcl 106 set ref 344
line                            000165 automatic       char(256)                unaligned dcl 47 set ref 140* 148* 167* 168* 169*
                                                                                  170* 179* 181* 205* 236* 248* 252 252 258 258 307*
                                                                                  330* 331* 332* 333* 335* 336* 337* 347* 352* 359*
                                                                                  362* 369* 372* 379* 383* 388* 394* 400* 402* 404*
                                                                                  406* 411* 415* 420* 424* 425* 428* 433* 479* 480*
                                                                                  481* 482* 483* 526* 532* 542* 548* 569* 570* 571*
                                                                                  572* 573* 580* 585* 603* 607* 611* 617* 631* 633
                                                                                  634
m                               000137 automatic       fixed bin(17,0)          dcl 47 in procedure "amu_print_text_" set ref 418*
                                                                                  419 420 421
m                               000326 automatic       fixed bin(18,0)          dcl 304 in procedure "bin_to_oct" set ref 306* 307
                                                                                  308
mf                              000120 constant        fixed bin(6,0)           initial array dcl 112 ref 342
mod_factor                      000275 automatic       structure                level 1 dcl 106 set ref 342*
modifier                        000123 constant        char(3)                  initial array dcl 82 ref 190
n_desc                                 based           structure                level 1 dcl 449
ndesc                           000143 automatic       fixed bin(17,0)          dcl 47 set ref 225 269 317* 341 398
need_comma                      000152 automatic       bit(1)                   unaligned dcl 47 set ref 349* 354* 358 364* 368 374*
                                                                                  378
no_to_print                     000134 automatic       fixed bin(17,0)          dcl 47 set ref 144*
nrands                          000142 automatic       fixed bin(17,0)          dcl 47 set ref 265 316*
num_desc                  1(21) 000020 external static fixed bin(5,0)           array level 2 packed unaligned dcl 70 ref 186 317
num_words                 1(27) 000020 external static fixed bin(8,0)           array level 2 packed unaligned dcl 70 ref 158 219
                                                                                  316
number                                 parameter       fixed bin(18,0)          dcl 304 in procedure "bin_to_oct" set ref 302 306*
number                          000100 automatic       fixed bin(17,0)          dcl 43 in procedure "amu_print_text_" set ref 135*
                                                                                  144 288* 295*
offset                          000145 automatic       fixed bin(18,0)          dcl 47 in procedure "amu_print_text_" set ref 178*
                                                                                  180* 203 204 217 608* 609 609* 609 615* 616 616*
                                                                                  616 621*
offset                    0(03)        based           bit(15)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 94 in procedure "amu_print_text_" ref 608
op_code                         000162 automatic       char(5)                  unaligned dcl 47 in procedure "amu_print_text_" set
                                                                                  ref 155* 170 175 175 175 191 191 191 208 216 269*
                                                                                  336 400 414 489 490 490
op_code                   0(18)        based           bit(10)                  level 2 in structure "instruction" packed unaligned
                                                                                  dcl 94 in procedure "amu_print_text_" ref 154 218
op_index                        000140 automatic       fixed bin(17,0)          dcl 47 set ref 151* 154* 155 158 186 218* 219 316
                                                                                  317 318 319 320
op_mnemonic_$op_mnemonic        000020 external static structure                array level 1 dcl 70
op_name                         000120 automatic       char(32)                 dcl 46 set ref 234* 235 236
opcode                          000020 external static char(6)                  array level 2 packed unaligned dcl 70 ref 155
output_switch                          parameter       char                     dcl 36 set ref 34 252*
p                               000130 automatic       pointer                  dcl 47 set ref 138* 149 154 173 177 177 178 186 190
                                                                                  190 192 203 204 214 234* 242 252 252 273* 273 286*
                                                                                  296* 297 342 393 411 417 424 425 432 493 494 494
                                                                                  495 496 501 502 502 506 508 512 514 515 517 518
                                                                                  537 547 575 576 584 585 607 608 615
pl1_operators_$operator_table   000010 external static fixed bin(17,0)          dcl 47 set ref 217
print_instr                     000272 automatic       bit(1)                   unaligned dcl 61 set ref 136* 252 289* 298*
pt                              000132 automatic       pointer                  dcl 47 set ref 203* 204* 205 205 209 210 217* 218
ptr                                                    builtin function         dcl 68 ref 203
real_offset                     000274 automatic       fixed bin(18,0)          dcl 63 set ref 203 257* 287* 297*
real_offset_entry               000273 automatic       bit(1)                   unaligned dcl 62 set ref 137* 203 290* 299*
rel                                                    builtin function         dcl 68 ref 205 205 252 252 297
repeat_inst                     000271 automatic       bit(1)                   unaligned dcl 60 set ref 161* 176* 242
rtrim                                                  builtin function         dcl 68 ref 155 179 611 617
scale                           000146 automatic       fixed bin(18,0)          dcl 47 set ref 518* 519 519* 519 550*
string                                                 builtin function         dcl 68 set ref 342*
substr                                                 builtin function         dcl 68 set ref 140* 148* 167* 168* 168 169* 169 170*
                                                                                  170 178 179* 181* 186 191 191 191 205* 208 236*
                                                                                  248* 252 252 258 258 307* 330* 330 331* 331 332*
                                                                                  332 333* 333 335* 336* 337* 342 347* 352* 359*
                                                                                  362* 369* 372* 379* 383* 388* 393 394* 400 400*
                                                                                  402* 404* 404 406* 411* 411 415* 417 420* 424* 424
                                                                                  425* 425 428* 432 433* 479* 480* 480 481* 481 482*
                                                                                  482 483* 494 512 526* 532* 537 542* 548* 569* 570*
                                                                                  570 571* 571 572* 572 573* 580* 585* 603* 607*
                                                                                  611* 617* 631* 633 634
t_pt                                   parameter       pointer                  dcl 36 ref 34 138 283 286 293 296
table_a_TA                      000000 constant        char(1)                  initial array unaligned dcl 471 ref 493
table_n_S                       000002 constant        char(2)                  initial array unaligned dcl 470 ref 514
tag                       0(03) 000275 automatic       bit(4)                   level 2 in structure "mod_factor" packed unaligned
                                                                                  dcl 106 in procedure "amu_print_text_" set ref 377
                                                                                  382 383
tag                       0(30)        based           bit(6)                   level 2 in structure "instruction" packed unaligned
                                                                                  dcl 94 in procedure "amu_print_text_" ref 177 177
                                                                                  186 190 190 192
tag                             000164 automatic       char(3)                  unaligned dcl 47 in procedure "amu_print_text_" set
                                                                                  ref 147* 177* 186* 190* 233 537* 616 616 630 631
tag                       0(32)        based           bit(4)                   level 2 in structure "i_desc" packed unaligned
                                                                                  dcl 561 in procedure "ind_descriptor" ref 576 584
                                                                                  585
type                            000355 automatic       fixed bin(17,0)          dcl 447 set ref 488* 489* 490* 492 499 547
word                                   based           bit(36)                  array dcl 92 set ref 149* 209* 210* 342 393 411 417
                                                                                  424 425 432

NAMES DECLARED BY EXPLICIT CONTEXT.
address                         003001 constant        entry                    internal dcl 601 ref 194 528 582
amu_print_text_                 000364 constant        entry                    external dcl 34
amu_print_text_$format          001544 constant        entry                    external dcl 293
amu_print_text_$real_offset     001511 constant        entry                    external dcl 283
begin                           000410 constant        label                    dcl 140 ref 291 300
bin_to_oct                      001573 constant        entry                    internal dcl 302 ref 257 544 550 621
binoct                          003144 constant        entry                    internal dcl 640 ref 149 186 205 209 210
eis_descriptor                  002323 constant        entry                    internal dcl 444 ref 164
eis_instruction                 001701 constant        entry                    internal dcl 326 ref 158
ind_descriptor                  002706 constant        entry                    internal dcl 559 ref 475
init_eis                        001635 constant        entry                    internal dcl 313 ref 223 328
set_tag                         003103 constant        entry                    internal dcl 628 ref 197 538

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3432        3454    3274        3442
Length      3654    3274        22         164     135           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
amu_print_text_                     382 external procedure  is an external procedure.  
bin_to_oct                              internal procedure  shares stack frame of external procedure amu_print_text_.  
init_eis                                internal procedure  shares stack frame of external procedure amu_print_text_.  
eis_instruction                         internal procedure  shares stack frame of external procedure amu_print_text_.  
eis_descriptor                          internal procedure  shares stack frame of external procedure amu_print_text_.  
ind_descriptor                          internal procedure  shares stack frame of external procedure amu_print_text_.  
address                                 internal procedure  shares stack frame of external procedure amu_print_text_.  
set_tag                                 internal procedure  shares stack frame of external procedure amu_print_text_.  
binoct                                  internal procedure  shares stack frame of external procedure amu_print_text_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
amu_print_text_          000100 number                      amu_print_text_
                         000101 desc_type                   amu_print_text_
                         000102 comment                     amu_print_text_
                         000120 op_name                     amu_print_text_
                         000130 p                           amu_print_text_
                         000132 pt                          amu_print_text_
                         000134 no_to_print                 amu_print_text_
                         000135 j                           amu_print_text_
                         000136 k                           amu_print_text_
                         000137 m                           amu_print_text_
                         000140 op_index                    amu_print_text_
                         000141 irand                       amu_print_text_
                         000142 nrands                      amu_print_text_
                         000143 ndesc                       amu_print_text_
                         000144 fract_offset                amu_print_text_
                         000145 offset                      amu_print_text_
                         000146 scale                       amu_print_text_
                         000147 double                      amu_print_text_
                         000150 eis                         amu_print_text_
                         000151 eis_desc                    amu_print_text_
                         000152 need_comma                  amu_print_text_
                         000153 ext_base                    amu_print_text_
                         000154 has_ic                      amu_print_text_
                         000155 decimal                     amu_print_text_
                         000156 ind_desc                    amu_print_text_
                         000157 cstring                     amu_print_text_
                         000162 op_code                     amu_print_text_
                         000164 tag                         amu_print_text_
                         000165 line                        amu_print_text_
                         000265 buff                        amu_print_text_
                         000271 repeat_inst                 amu_print_text_
                         000272 print_instr                 amu_print_text_
                         000273 real_offset_entry           amu_print_text_
                         000274 real_offset                 amu_print_text_
                         000275 mod_factor                  amu_print_text_
                         000276 ebase                       amu_print_text_
                         000301 len_reg                     amu_print_text_
                         000304 idesc                       amu_print_text_
                         000307 ic                          amu_print_text_
                         000312 desc_word                   amu_print_text_
                         000326 m                           bin_to_oct
                         000354 len                         eis_descriptor
                         000355 type                        eis_descriptor
                         000406 c12                         binoct

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ne_as             alloc_char_temp     cat_realloc_chars   call_ext_out_desc   return_mac
shorten_stack       ext_entry_desc

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
find_operator_name_           ioa_$ioa_stream               ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
op_mnemonic_$op_mnemonic      pl1_operators_$operator_table




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     34 000360       135 000377       136 000402       137 000404       138 000405       140 000410       141 000413
    142 000414       144 000415       146 000425       147 000426       148 000430       149 000432       151 000453
    154 000457       155 000463       158 000511       161 000525       163 000530       164 000540       167 000543
    168 000545       169 000554       170 000562       171 000577       173 000601       175 000605       176 000614
    177 000616       178 000647       179 000652       180 000666       181 000715       182 000723       183 000725
    186 000726       190 000747       191 000756       192 001000       194 001004       197 001005       202 001006
    203 001010       204 001021       205 001026       206 001047       208 001052       209 001056       210 001106
    211 001161       212 001162       214 001163       216 001170       217 001173       218 001201       219 001205
    223 001214       225 001216       226 001225       227 001227       228 001232       229 001233       233 001235
    234 001245       235 001274       236 001300       237 001307       242 001311       246 001332       247 001337
    248 001341       249 001346       252 001347       254 001417       255 001420       256 001423       257 001425
    258 001427       259 001454       262 001456       264 001460       265 001461       266 001464       267 001465
    268 001466       269 001467       273 001477       274 001502       276 001504       283 001505       286 001524
    287 001530       288 001532       289 001534       290 001535       291 001537       293 001540       295 001557
    296 001561       297 001565       298 001570       299 001571       300 001572       302 001573       306 001575
    307 001624       308 001632       310 001634       313 001635       315 001636       316 001640       317 001652
    318 001656       319 001664       320 001675       321 001677       323 001700       326 001701       328 001702
    330 001703       331 001707       332 001716       333 001724       335 001727       336 001731       337 001734
    339 001736       341 001740       342 001747       343 001755       344 001761       345 001765       347 001771
    348 001775       349 001776       351 001777       352 002001       353 002005       354 002007       357 002011
    358 002013       359 002015       360 002021       362 002022       363 002026       364 002030       367 002032
    368 002034       369 002036       370 002042       372 002043       373 002047       374 002051       377 002053
    378 002060       379 002062       380 002066       382 002067       383 002073       384 002102       385 002104
    386 002105       388 002106       389 002112       390 002114       393 002116       394 002121       395 002125
    398 002127       400 002137       402 002150       403 002154       404 002156       405 002162       406 002164
    407 002170       408 002171       409 002172       410 002175       411 002202       412 002222       414 002224
    415 002227       416 002233       417 002235       418 002241       419 002245       420 002246       421 002255
    422 002256       424 002257       425 002267       426 002276       428 002300       429 002304       431 002305
    432 002306       433 002311       434 002315       435 002317       436 002320       438 002322       444 002323
    473 002324       474 002327       475 002330       476 002331       479 002332       480 002334       481 002343
    482 002351       483 002355       485 002357       486 002361       488 002363       489 002365       490 002400
    492 002420       493 002422       494 002446       495 002455       496 002461       497 002464       499 002465
    500 002467       501 002474       502 002477       503 002511       506 002512       507 002515       508 002522
    509 002526       511 002527       512 002534       514 002540       515 002561       517 002564       518 002566
    519 002572       525 002576       526 002600       527 002604       528 002606       530 002607       531 002611
    532 002640       533 002646       536 002650       537 002653       538 002657       539 002660       542 002661
    543 002665       544 002666       547 002670       548 002676       549 002702       550 002703       553 002705
    559 002706       569 002707       570 002711       571 002720       572 002726       573 002731       575 002733
    576 002737       577 002744       579 002750       580 002752       581 002756       582 002760       584 002761
    585 002765       586 002776       588 003000       601 003001       603 003002       604 003006       606 003007
    607 003011       608 003020       609 003024       610 003030       611 003032       612 003046       615 003047
    616 003052       617 003064       621 003100       623 003102       628 003103       630 003104       631 003114
    632 003125       633 003127       634 003135       637 003143       640 003144       644 003155       645 003207


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
