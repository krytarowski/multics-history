	COMPILATION LISTING OF SEGMENT dumper
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/20/88  1029.8 mst Wed
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 
       12 /****^  HISTORY COMMENTS:
       13*  1) change(81-12-16,Texada), approve(), audit(), install():
       14*     fix phx12050 and phx12187
       15*  2) change(82-08-01,Texada), approve(), audit(), install():
       16*     for phx12187, phx13713, phx13662
       17*  3) change(82-11-12,Texada), approve(), audit(), install():
       18*     to implement phx13262
       19*  4) change(82-11-16,Texada), approve(), audit(), install():
       20*     to implement phx14088,  allow preattachment of dump volumes to an
       21*     existing incremental dump.
       22*  5) change(83-01-26,Texada), approve(), audit(), install():
       23*     to support version 2 dmpr_data_ and fix a problem when volumes were
       24*     attached but not opened then crash.
       25*  6) change(83-03-01,Kittlitz), approve(), audit(), install():
       26*     for 256K segments.
       27*  7) change(83-04-05,Texada), approve(), audit(), install():
       28*     add trace entries.
       29*  8) change(83-08-18,Texada), approve(), audit(), install():
       30*     redefine -detach/-no_detach.
       31*  9) change(84-02-01,Texada), approve(), audit(), install():
       32*     support version 3 dmpr_data_.
       33* 10) change(84-03-05,Texada), approve(), audit(), install():
       34*     add set_volume_wakeup_interval.
       35* 11) change(85-11-05,GWMay), approve(85-12-02,MCR7310), audit(85-12-05,Dupuis),
       36*     install(85-12-16,MR12.0-1001):
       37*     modified the routine set_volume_wakeup_interval to allow a wakeup
       38*     interval up to 1440 minutes, this was raised from 480.  To
       39*     accomodate the size of the interval when converted to microseconds,
       40*     the variable my_interval was increased in size.
       41*                                                   END HISTORY COMMENTS */
       42 
       43 
       44 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
       45 
       46 dumper: proc;
       47 
       48 /* This proc provides the command interface for the volume dumper subsystem.  It initializes the static
       49*   data base and other external data bases, attaches to, opens and parses the dump
       50*   control file converting the control file into an ordered array of physical volume names and ids. It then
       51*   successivly dumps this array , volume by volume. */
       52         
       53 
       54 dcl Area		     area based (areap);
       55 dcl tp		     (4) ptr;
       56 dcl dump_control_name    char (32);
       57 dcl was_asleep	     bit (1);			/* if incr dump, is saved value of dmpr_data_.dmpr_asleep, else is "0"b*/
       58 dcl (YES, dmpr_data_already_locked, new_control_seg, trace) bit (1);
       59 dcl mname		     char (21);
       60 dcl (cycle_uid, ignored_lvid) bit (36);
       61 dcl answer	     char (3) var;
       62 dcl (ac, argl, narg, nelemt, idx, num_pv, first_pvx, nvols, tnpv) fixed bin;
       63 dcl control_seg_name     char (32);
       64 dcl (areap, argp)	     ptr;
       65 dcl line		     char (120) aligned;
       66 dcl tlvname	     char (32) aligned;
       67 dcl lvname	     (100) char (32);
       68 dcl pvname	     (100) char (32);
       69 dcl time_string	     char (24);
       70 dcl pvid		     (100) bit (36);
       71 dcl device_type	     (100) fixed bin;
       72 dcl (old_time, time_pass_started) fixed bin (71);		/* Time this pass started. */
       73 dcl (code, ignore)	     fixed bin (35);		/* Error code. */
       74 
       75 dcl 1 query_info	     aligned,
       76     2 version	     fixed bin init (2),
       77     2 yes		     bit (1) init ("1"b),
       78     2 name	     bit (1) init ("0"b),
       79     2 code	     fixed bin (35) init (0),
       80     2 pad		     fixed bin;
       81 
       82 dcl 1 pva		     (100) aligned,
       83     2 pvname	     char (32),
       84     2 device_type	     fixed bin,
       85     2 pvid	     bit (36);
       86 
       87 
       88 dcl type_char	     (3) char (4) int static init ("incr", "cons", "comp") options (constant);
       89 dcl force_write_bits     bit (36) init ((36)"0"b) int static options (constant); /* write pages in parallel			*/
       90 dcl lock_wait_time	     fixed bin static init (60) options (constant);
       91 
       92 dcl arg		     char (argl) based (argp);
       93 
       94 dcl iox_$user_io	     ptr external;
       95 dcl error_table_$action_not_performed fixed bin (35) ext static;
       96 dcl error_table_$end_of_info ext fixed bin (35);
       97 dcl error_table_$invalid_lock_reset ext fixed bin (35);
       98 dcl error_table_$inconsistent fixed bin (35) ext static;
       99 dcl error_table_$bad_arg ext fixed bin (35);
      100 dcl error_table_$bad_conversion fixed bin (35) ext static;
      101 dcl error_table_$wrong_no_of_args fixed bin (35) ext static;
      102 dcl command_query_$yes_no entry () options (variable);
      103 dcl cv_dec_check_	     entry (char (*), fixed bin (35)) returns (fixed bin (35));
      104 dcl get_system_free_area_ entry () returns (ptr);
      105 dcl suffixed_name_$make  entry (char (*), char (*), char (*), fixed bin (35));
      106 dcl hcs_$force_write     entry (ptr, bit (36), fixed bin (35));
      107 dcl hcs_$set_256K_switch entry (bit (2) aligned, bit (2) aligned, fixed bin (35));
      108 dcl hcs_$status_minf     entry (char (*), char (*), fixed bin, fixed bin, fixed bin, fixed bin (35));
      109 dcl manage_volume_pool_$set_pool_path entry (entry options (variable), char (*), ptr, fixed bin (35));
      110 dcl com_err_	     entry options (variable);
      111 dcl command_query_	     entry options (variable);
      112 dcl set_lock_$lock	     entry (bit (36) aligned, fixed bin, fixed bin (35));
      113 dcl ipc_$mask_ev_calls   entry (fixed bin (35));
      114 dcl ipc_$unmask_ev_calls entry (fixed bin (35));
      115 dcl ioa_$rsnnl	     entry options (variable);
      116 dcl cu_$arg_count	     entry (fixed bin);
      117 dcl cu_$arg_ptr	     entry (fixed bin, ptr, fixed bin, fixed bin (35));
      118 dcl hcs_$make_seg	     entry (char (*), char (*), char (*), fixed bin (5), ptr, fixed bin (35));
      119 dcl get_wdir_	     entry returns (char (168) aligned);
      120 dcl mdc_$check_mounted   entry (char (*) aligned, fixed bin (35));
      121 dcl add_epilogue_handler_ entry (entry, fixed bin (35));
      122 dcl iox_$control	     entry (ptr, char (*), ptr, fixed bin (35));
      123 dcl purge_volume_log_    entry (char (*) aligned, char (*) aligned, fixed bin, bit (1), fixed bin (35));
      124 dcl hc_backup_$init_dmpr entry (ptr, ptr, fixed bin (35));
      125 dcl dmpr_output_$init    entry (fixed bin (35));
      126 dcl dmpr_output_$end_pass_detach entry (fixed bin (35));
      127 dcl dmpr_output_$preattach_vols entry (fixed bin, fixed bin, fixed bin (35));
      128 dcl dmpr_output_$preattach_ioname entry (fixed bin, fixed bin, fixed bin (35));
      129 dcl get_temp_segments_   entry (char (*), (*) ptr, fixed bin (35));
      130 dcl dump_volume_	     entry (fixed bin (35));
      131 dcl dmpr_info_	     entry (fixed bin (35));
      132 dcl dmpr_arg_reader_     entry (ptr, fixed bin (35));
      133 dcl dmpr_finish_	     entry (fixed bin (35));
      134 dcl timer_manager_$alarm_wakeup entry (fixed bin (71), bit (2), fixed bin (71));
      135 dcl timer_manager_$get_schedule entry (ptr, ptr, fixed bin (35));
      136 dcl timer_manager_$reset_alarm_wakeup entry (fixed bin (71));
      137 dcl mdc_$lvname_info     entry (char (*) aligned, ptr, fixed bin, fixed bin (35));
      138 dcl mdc_$pvname_info     entry (char (*), bit (36), char (*), bit (36), fixed bin, fixed bin (35));
      139 dcl date_time_	     entry (fixed bin (71), char (*));
      140 dcl cu_$arg_list_ptr     entry (ptr);			/* Arg list location */
      141 dcl iox_$attach_ioname   entry (char (*), ptr, char (*), fixed bin (35));
      142 dcl iox_$position	     entry (ptr, fixed bin, fixed bin, fixed bin (35));
      143 dcl iox_$open	     entry (ptr, fixed bin, bit (36), fixed bin (35));
      144 dcl iox_$get_line	     entry (ptr, ptr, fixed bin, fixed bin, fixed bin (35));
      145 dcl ipc_$create_ev_chn   entry (fixed bin (71), fixed bin (35));
      146 dcl ipc_$decl_ev_call_chn entry (fixed bin (71), entry, ptr, fixed bin, fixed bin (35));
      147 dcl (dmpr_report_$error_output, dmpr_report_$online_output) entry options (variable);
      148 
      149 dcl (cleanup, finish)    condition;
      150 
      151 
      152 dcl (after, before, bit, rtrim, addr, clock, fixed, hbound, length, null, substr, verify) builtin;
      153 
      154 incremental_volume_dump: entry;
      155 
      156     call init (incr, "incremental_volume_dumper");
      157     go to start;					/* Go get arguments. */
      158 
      159 consolidated_volume_dump: entry;
      160 
      161     call init (cons, "consolidated_volume_dump");
      162     go to start;					/* Go get arguments. */
      163 
      164 complete_volume_dump: entry;				/* Entry to do complete volume dump */
      165 
      166     call init (comp, "complete_volume_dump");
      167 
      168 start:
      169     dmpr_data_.old_256K_switch = ""b;
      170     call add_epilogue_handler_ (end_volume_dump, code);
      171     if code ^= 0 then
      172          call dmpr_report_$error_output (code, dmpr_data_.myname, "Unable to set epilogue handler");
      173     on cleanup call dmpr_finish_ (ignore);
      174     on finish call dmpr_finish_ (ignore);
      175     call cu_$arg_list_ptr (argp);			/* get arg list ptr */
      176     call dmpr_arg_reader_ (argp, code);			/* Get any other arguments */
      177     if code ^= 0 then goto finale;
      178 
      179     call hcs_$set_256K_switch ("11"b, dmpr_data_.old_256K_switch, code);
      180     if code ^= 0 then do;
      181         call dmpr_report_$error_output (code, dmpr_data_.myname, "Could not enable 256KW segments.");
      182         goto finale;
      183       end;
      184     dmpr_data_.arg_init = "1"b;
      185     if (dmpr_data_.dump_type = incr) & (dmpr_data_.detach) & (dmpr_data_.pre_attach_vol ^= 0) then do;
      186         call dmpr_report_$error_output (error_table_$inconsistent, dmpr_data_.myname,
      187 	"The -detach and -preattach control arguments are mutually exclusive");
      188         goto finale;
      189       end;
      190 
      191     if dmpr_data_.control_name = "" | dmpr_data_.operator = "" then do;
      192         code = error_table_$bad_arg;			/* Must have dump control file and operator */
      193         call dmpr_report_$error_output (code, dmpr_data_.myname, "Missing control file or operator name");
      194         goto finale;
      195       end;
      196     if dmpr_data_.auto_vol then do;
      197         call manage_volume_pool_$set_pool_path (dmpr_report_$error_output,
      198 	rtrim (dmpr_data_.sys_dir) || ">Volume_Dumper", dmpr_data_.vpp, code);
      199 						/* set the pool path to the standard one */
      200         if code ^= 0 then do;
      201 	  call dmpr_report_$online_output (code, dmpr_data_.myname, "Unable to locate volume pool");
      202 	  goto finale;
      203 	end;
      204 
      205       end;
      206 						/* setup temp segs */
      207     call get_temp_segments_ ("dumper", tp, code);
      208     if code ^= 0 then do;
      209         call dmpr_report_$error_output (code, dmpr_data_.myname, "Temp seg init failure");
      210         goto finale;
      211       end;
      212 						/* initialize static ptrs */
      213     dmpr_data_.dirp = tp (1);
      214     dmpr_data_.inputp = tp (2);
      215     dmpr_data_.recordp = tp (3);
      216     dmpr_data_.infop = tp (4);
      217 						/* initialize info seg  - per dump info */
      218     call dmpr_info_ (code);
      219     if code ^= 0 then do;
      220         call dmpr_report_$error_output (code, dmpr_data_.myname, "Error initing info seg ");
      221         goto finale;
      222       end;
      223 						/* attach and open control file */
      224     call iox_$attach_ioname ("dump_control", dmpr_data_.control_iocbp, "vfile_ " || dmpr_data_.control_name, code);
      225     if code ^= 0 then do;
      226         call dmpr_report_$error_output (code,
      227 	dmpr_data_.myname, "Unable to attach to ^a",
      228 	dmpr_data_.control_name);
      229         goto finale;
      230       end;
      231     call iox_$open (dmpr_data_.control_iocbp, 1, "0"b, code);
      232     if code ^= 0 then do;				/* Was an error encountered? */
      233         call dmpr_report_$error_output (code, dmpr_data_.myname, "Open error on ^a", dmpr_data_.control_name);
      234         goto finale;				/* Quit. */
      235       end;
      236     if dmpr_data_.dump_type = incr then do;		/* Is this an incremental volume dump? */
      237         call ipc_$create_ev_chn (dmpr_data_.incr_ev_chn, code); /* Create an event channel. */
      238         if code ^= 0 then do;
      239 	  call dmpr_report_$error_output (code, dmpr_data_.myname, "Error creating event channel");
      240 	  goto finale;
      241 	end;					/* Make channel into call channel. */
      242         call ipc_$decl_ev_call_chn (dmpr_data_.incr_ev_chn, restart_volume_dump, null, 1, code);
      243         if code ^= 0 then do;				/* OK? */
      244 	  call dmpr_report_$error_output (code, dmpr_data_.myname, "Error make event call channel");
      245 	  goto finale;				/* Give up. */
      246 	end;
      247       end;
      248 						/* initialize ring 0 part of dumper */
      249     call hc_backup_$init_dmpr (dmpr_data_.dirp, dmpr_data_.segp, code);
      250     if code ^= 0 then do;
      251         call dmpr_report_$error_output (code, dmpr_data_.myname, "Ring 0 dmpr init failure");
      252         goto finale;
      253       end;
      254     call dmpr_output_$init (code);
      255     if code ^= 0 then do;
      256         if code ^= -1 then				/* this code says that an attach/open failed	*/
      257 	   call dmpr_report_$error_output (code, dmpr_data_.myname, "Output volume init failure");
      258         goto finale;
      259       end;
      260 						/* init input structure to ring 0 */
      261     inputp = dmpr_data_.inputp;
      262     dmpr_input.version = dmpr_input_version_1;
      263     dmpr_input.type = dmpr_data_.dump_type;
      264     dmpr_input.reset = dmpr_data_.reset;
      265     dmpr_input.no_update = dmpr_data_.no_update;
      266     dmpr_input.no_object = dmpr_data_.no_object;
      267     dmpr_input.mod_after_time = dmpr_data_.mod_after_time;
      268     dmpr_data_.dump_in_progress = "1"b;			/* Set flag to prevent recursion. */
      269     go to over;					/* Start dump pass. */
      270 
      271 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      272 
      273 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      274 
      275 wakeup_volume_dump: entry;				/* Enter here on  operator wakeup. */
      276     if dmprp = null then do;
      277 no_dump: call com_err_ (0, "wakeup_volume_dump", "No dump to wakeup");
      278         return;
      279       end;
      280     dmpr_data_.myname = "wakeup_volume_dump";
      281 
      282 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      283 
      284 
      285 restart_volume_dump: entry;				/* Enter here on alarm wakeup */
      286 
      287     if dmprp = null then do;
      288         call com_err_ (0, "restart_volume_dump", "no dump to restart");
      289         return;
      290       end;
      291     if dmpr_data_.dump_in_progress then do;		/* Is a dump pass being done now? */
      292         call dmpr_report_$online_output (0, dmpr_data_.myname,
      293 	"Dump pass presently in progress; this call ignored.");
      294         return;
      295       end;
      296 
      297     call timer_manager_$reset_alarm_wakeup (dmpr_data_.incr_ev_chn);
      298     dmpr_data_.dump_in_progress = "1"b;			/* Set flag. */
      299     dmpr_data_.dmpr_asleep = "0"b;
      300     new_control_seg = "0"b;
      301     dmpr_data_already_locked = "0"b;
      302     call dmpr_report_$online_output (0, dmpr_data_.myname, "Dumper waking up at ^a", time_now_ ());
      303 
      304 over:
      305     time_pass_started = clock;
      306 						/* position to front of control file */
      307     call iox_$position (dmpr_data_.control_iocbp, -1, 0, code);
      308     if code ^= 0 then do;				/* OK? */
      309         call dmpr_report_$error_output (code, dmpr_data_.myname, "Error positioning on ^a",
      310 	dmpr_data_.control_name);
      311         goto finale;				/* Give up. */
      312       end;
      313 						/* initialize local variables */
      314     num_pv = 0;
      315     lvname (*) = "";
      316     pvname (*) = "";
      317     pvid (*) = "0"b;
      318     device_type (*) = 0;
      319 
      320 
      321 /* This loop converts each line of the control file into a set(possibly one) of physical volume names and ids
      322*   and stores the entire result in a local array of 100 entries. This is a limit on the number of online
      323*   physical volumes that can be dumped by any one volume dumper. */
      324 
      325 read_line:
      326     line = "";
      327     call iox_$get_line (dmpr_data_.control_iocbp, addr (line), length (line), nelemt, code);
      328     if code ^= 0 then do;
      329         if code = error_table_$end_of_info then goto begin_vol_dump;
      330         else do;
      331 	  call dmpr_report_$error_output (code,
      332 	    dmpr_data_.myname, "error reading ^a",
      333 	    dmpr_data_.control_name);
      334 	  goto finale;				/* Give up. */
      335 	end;
      336       end;
      337 
      338     line = substr (line, 1, nelemt - 1);		/* strip off new line at end */
      339     if before (line, ",") = "lv" then do;
      340         tlvname = after (line, ",");
      341         call mdc_$lvname_info (tlvname, addr (pva), tnpv, code);
      342         if code ^= 0 then do;
      343 	  call dmpr_report_$error_output (code, dmpr_data_.myname, "Unable to convert ^a to physical volumes",
      344 	    tlvname);
      345 	  goto read_line;
      346 	end;
      347         do idx = 1 to tnpv;
      348 	lvname (num_pv + idx) = tlvname;
      349 	pvname (num_pv + idx) = pva (idx).pvname;
      350 	pvid (num_pv + idx) = pva (idx).pvid;
      351 	device_type (num_pv + idx) = pva (idx).device_type;
      352         end;
      353         num_pv = num_pv + tnpv;
      354       end;
      355     else if before (line, ",") = "pv" then do;
      356         num_pv = num_pv + 1;
      357         pvname (num_pv) = after (line, ",");
      358         call mdc_$pvname_info (pvname (num_pv), pvid (num_pv), lvname (num_pv), ignored_lvid,
      359 	device_type (num_pv), code);
      360         if code ^= 0 then do;
      361 	  call dmpr_report_$error_output (code, dmpr_data_.myname, "Unable to convert ^a to pvid",
      362 	    pvname (num_pv));
      363 	  num_pv = num_pv - 1;
      364 	  goto read_line;
      365 	end;
      366       end;
      367     else call dmpr_report_$error_output (0, dmpr_data_.myname, "Unrecognized line ^a", line);
      368     goto read_line;
      369 
      370 
      371 /* This loop dumps each volid specified in the just constructed array. If we are in restart mode,
      372*   then we skip over all volumes until a match is found and start from there. If not we start with the first volume
      373*   in the list. In either case we process(dumped) each volume in turn reporting when we start and when we end
      374*   and what we did. */
      375 
      376 begin_vol_dump:
      377     inputp = dmpr_data_.inputp;
      378     first_pvx = 1;
      379     if dmpr_data_.restart_pvname = "" /* no restart specified */
      380       & ^new_control_seg
      381       & ^was_asleep
      382       & (dmpr_data_already_locked | (dmpr_data_.pvname ^= pvname (num_pv))) then do;
      383         if dmpr_data_already_locked then do;
      384 	  dmpr_data_.restart_pvname = dmpr_data_.pvname;
      385 	  call dmpr_report_$online_output (0, dmpr_data_.myname, "Restarting with physical volume ^a.",
      386 	    dmpr_data_.restart_pvname);
      387 	end;
      388         else if dmpr_data_.dump_type ^= incr then do;	/* it must be cons or comp */
      389 	  call command_query_ (addr (query_info), answer, dmpr_data_.myname, "^/^a",
      390 	    "Previous dump cycle may not have completed. Do you want to restart ? ");
      391 	  if answer = "yes" then
      392 	       dmpr_data_.restart_pvname = dmpr_data_.pvname;
      393 	end;
      394       end;
      395     if dmpr_data_.restart_pvname ^= "" then do;
      396         if dmpr_data_.dump_type = incr then
      397 	   dmpr_data_.cycle_uid = substr (bit (clock, 72), 20, 36);
      398         do idx = 1 to num_pv while (pvname (idx) ^= dmpr_data_.restart_pvname);
      399         end;
      400         if idx > num_pv then do;
      401 	  call dmpr_report_$error_output (0, dmpr_data_.myname,
      402 	    "No match of restart pvname ^a in control seg",
      403 	    dmpr_data_.restart_pvname);
      404 	  goto finale;
      405 	end;
      406         first_pvx = idx;
      407       end;
      408     else dmpr_data_.cycle_uid = substr (bit (clock, 72), 20, 36);
      409 
      410 
      411     do idx = first_pvx to num_pv;
      412       dmpr_data_.pvid = pvid (idx);
      413       dmpr_data_.lvname = lvname (idx);
      414       dmpr_data_.pvname = pvname (idx);
      415       call mdc_$check_mounted (dmpr_data_.lvname, code);
      416       if code ^= 0 then do;
      417 	call dmpr_report_$online_output (code, dmpr_data_.myname,
      418 	  "Skipping logical volume ^a", dmpr_data_.lvname);
      419 	do while (lvname (idx) = dmpr_data_.lvname);
      420 	  idx = idx + 1;
      421 	end;
      422 	idx = idx - 1;
      423         end;
      424       else do;
      425 	dmpr_data_.disk_type = device_type (idx);	/* set for the volume log			*/
      426 	call hcs_$force_write (dmprp, force_write_bits, ignore);
      427 						/* save changed dmpr_data_			*/
      428 	if (dmpr_data_.dump_type = cons) | (dmpr_data_.dump_type = comp) then call dmpr_report_$online_output (0,
      429 	       dmpr_data_.myname, "Begin dump of physical volume ^a", dmpr_data_.pvname);
      430 	call dump_volume_ (code);
      431 	if code = 0 then do;
      432 	    call dmpr_report_$online_output (0, dmpr_data_.myname,
      433 	      "Processed ^a: ^d ^d ^d ^d ^d",
      434 	      dmpr_data_.pvname,
      435 	      dmpr_data_.physical_volume_dir_rec, dmpr_data_.physical_volume_dir_num,
      436 	      dmpr_data_.physical_volume_seg_rec, dmpr_data_.physical_volume_seg_num,
      437 	      dmpr_data_.num_null_vtoce);
      438 
      439 
      440 	    if dmpr_input.no_object then
      441 	         call dmpr_report_$online_output (0, dmpr_data_.myname,
      442 		 "Dumped ^d non null vtoces and ^d null vtoces",
      443 		 dmpr_data_.num_vtoce_only, dmpr_data_.num_null_vtoce);
      444 
      445 /* If this is a complete dump or the purge flag is on, then purge the volume log. This will release those dump
      446*   volumes that have been superseeded by this dump */
      447 
      448 
      449 	    if (dmpr_data_.dump_type = cons & dmpr_data_.incr_skip_count ^= -1)
      450 	      | dmpr_data_.dump_type = comp then do;
      451 	        call purge_volume_log_ (dmpr_data_.sys_dir, dmpr_data_.pvname, dmpr_data_.incr_skip_count,
      452 		dmpr_data_.manual_free & dmpr_data_.auto_vol, code);
      453 	        if code ^= 0 then
      454 		   call dmpr_report_$error_output (code, dmpr_data_.myname, "Unable to purge volume log ^a",
      455 		     dmpr_data_.pvname);
      456 	      end;
      457 	  end;
      458 	else if code = -1 then goto finale;		/* Operator abort				*/
      459 	else do;
      460 	    call dmpr_report_$error_output (code, dmpr_data_.myname,
      461 	      "Error dumping volume ^a", dmpr_data_.pvname);
      462 	  end;
      463         end;
      464     end;
      465 
      466 
      467     dmpr_data_.restart_pvname = "";			/* only do it once */
      468 
      469     call dmpr_report_$online_output (0, dmpr_data_.myname, "Dump finished at ^a", time_now_ ());
      470 
      471 /* If an incremental dump then setup alarm clock for wakeup */
      472     if dmpr_data_.dump_type = incr then do;
      473         call iox_$control (dmpr_data_.outputvol_iocbp, "error_count", addr (ignore), ignore);
      474         if dmpr_data_.detach then call dmpr_output_$end_pass_detach (ignore);
      475 						/* detach if we are supposed too.		*/
      476         call timer_manager_$alarm_wakeup (time_pass_started + dmpr_data_.wakeup_interval, "00"b,
      477 	dmpr_data_.incr_ev_chn);
      478         call dmpr_report_$online_output (0, dmpr_data_.myname, "Dumper going to sleep");
      479         call iox_$control (iox_$user_io, "start", null, code);
      480         if code ^= 0 then				/* OK? */
      481 	   call dmpr_report_$error_output (code, dmpr_data_.myname, "iox_$control on user_i/o");
      482         dmpr_data_.dump_in_progress = ""b;		/* Indicate dump no longer active. */
      483         dmpr_data_.dmpr_asleep = "1"b;
      484         dmpr_data_.myname = "incremental_volume_dumper";	/* could have been invoked as wakeup_volume_dumper*/
      485         call hcs_$force_write (dmprp, force_write_bits, ignore);
      486 						/* TRY and get it written now			*/
      487 
      488         return;					/* all done for this pass */
      489       end;
      490     goto finale;
      491 
      492 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      493 
      494 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      495 
      496 
      497 end_volume_dump: entry;				/* Finish up dumping. */
      498 
      499     if dmprp = null then do;				/* tell him there is no dump			*/
      500         call com_err_ (0, "end_volume_dump", "No dump to end.");
      501         return;
      502       end;
      503     dmpr_data_.myname = "end_volume_dump";
      504     dmpr_data_.dump_in_progress = "1"b;			/* let dmpr_finish_ turn it off		*/
      505     dmpr_data_.disable_error_report = "1"b;
      506     dmpr_data_.detach = "1"b;				/* detach output volume when finished */
      507 finale:
      508     call dmpr_finish_ (ignore);
      509 finale_nocleanup:
      510     return;					/* terminate processing */
      511 
      512 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      513 
      514 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      515 
      516 preattach_dump_volumes: entry;
      517 
      518 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      519 /*									*/
      520 /* Allow a running incremental dump to add volumes (just like the -preattach control	*/
      521 /* argument), without having to do an end_volume_dump and starting over.		*/
      522 /*									*/
      523 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      524 
      525 dcl announce_vols	     (nvols) char (32) based (addr (dmpr_data_.pre_attach_volname (dmpr_data_.pre_attach_vol + 1)));
      526 
      527 
      528     call ipc_$mask_ev_calls (code);			/* mask so we can do our work			*/
      529     if code ^= 0 then do;
      530         call com_err_ (code, "preattach_dump_volumes", "Unable to mask event calls, no preattachment performed.");
      531         return;
      532       end;
      533 
      534     if dmprp = null then do;				/* no funny stuff...			*/
      535         call com_err_ (0, "preattach_dump_volumes",
      536 	"No dump in progress, use the ""-preattach"" control argument to the incremental_volume_dump command.");
      537         goto UNMASK_EV;
      538       end;
      539 
      540     if dmpr_data_.dump_type ^= incr then do;
      541         call com_err_ (0, "preattach_dump_volumes", "This command is only valid for incremental volume dumps.");
      542         goto UNMASK_EV;
      543       end;
      544 
      545     call cu_$arg_count (narg);
      546     if narg ^= 1 then do;
      547         call com_err_ (error_table_$wrong_no_of_args, "preattach_dump_volumes",
      548 	"Usage is: preattach_dump_volumes no_of_volumes");
      549         goto UNMASK_EV;
      550       end;
      551     if dmpr_data_.detach then do;			/* ok, let's ask him if we should turn off this	*/
      552         call command_query_$yes_no (YES, 0, "preattach_dump_volumes",
      553 	"In the invocation of the incremental_volume_dump command, -detach was specified.
      554 This is used to detach  volumes after each pass of the dumper.  A ""yes"" answer will
      555 turn this feature ""off"". A ""no"" answer will abort the preattachment of these volumes.",
      556 	"Do you wish to turn off the effect of the -detach control argument (type ""?"" for an explaination).");
      557         if YES then dmpr_data_.detach = ""b;
      558         else goto UNMASK_EV;
      559       end;
      560 
      561     call cu_$arg_ptr (1, argp, argl, code);
      562     if verify (arg, "0123456789") = 0 then do;		/* only numbers fellas			*/
      563         nvols = fixed (arg, 17, 0);			/* now, be sure we don't have too many		*/
      564 
      565         if nvols = 0 then do;
      566 	  call com_err_ (0, "preattach_dump_volumes", "The number of volumes must be greater than zero.");
      567 	  goto UNMASK_EV;
      568 	end;
      569 
      570 
      571         if ((dmpr_data_.pre_attach_vol + nvols) > hbound (dmpr_data_.pre_attach_volname, 1) |
      572 	(hbound (dmpr_data_.pre_attach_volname, 1) - (nvols + dmpr_data_.pre_attach_vol) < 0)) then do;
      573 	  call com_err_ (error_table_$action_not_performed, "preattach_dump_volumes",
      574 	    "Too many volumes to preattach. Space available for ^d more.",
      575 	    (hbound (dmpr_data_.pre_attach_volname, 1) - dmpr_data_.pre_attach_vol));
      576 	  goto UNMASK_EV;
      577 	end;
      578       end;
      579     else do;
      580 
      581         call com_err_ (error_table_$bad_conversion, "preattach_dump_volumes", "^a", arg);
      582         goto UNMASK_EV;
      583       end;
      584 
      585     on cleanup begin;
      586         code = 0;
      587         do while (code = 0);
      588 	call ipc_$unmask_ev_calls (code);
      589         end;
      590       end;
      591 
      592     call dmpr_output_$preattach_vols (nvols, (dmpr_data_.pre_attach_vol + nvols) - (nvols - 1), code);
      593 						/* get the volume names from the user or the pool */
      594     if code ^= 0 then goto UNMASK_EV;
      595     call dmpr_report_$online_output (0, "preattach_dump_volumes", "Please get the following volume^[s^]: ^v(^a ^)",
      596 						/* announce which volumes to get		*/
      597       (nvols > 1), nvols, announce_vols (*));
      598 
      599     call dmpr_output_$preattach_ioname (nvols, (dmpr_data_.pre_attach_vol + nvols) - (nvols - 1), code);
      600 						/* do the attach				*/
      601     if code = 0 then dmpr_data_.pre_attach_vol = dmpr_data_.pre_attach_vol + nvols;
      602 UNMASK_EV:
      603     code = 0;
      604     do while (code = 0);
      605       call ipc_$unmask_ev_calls (code);
      606     end;
      607     return;
      608 
      609 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      610 
      611 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      612 
      613 
      614 set_volume_wakeup_interval: entry;
      615 
      616 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      617 /*									*/
      618 /* This entry allows the changing of the wakeup interval for a running incremental dump.	*/
      619 /*									*/
      620 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
      621 
      622 dcl i				fixed bin (35),
      623     my_interval			fixed bin (71);
      624 
      625     call ipc_$mask_ev_calls (code);
      626     if code ^= 0 then do;
      627         call com_err_ (code, "set_volume_wakeup_interval", "Unable to mask event calls, interval not changed.");
      628         return;
      629       end;
      630     areap, schedule_ptr = null ();
      631     areap = get_system_free_area_ ();
      632     on cleanup begin;
      633         if schedule_ptr ^= null () then free schedule in (Area);
      634         code = 0;
      635         do while (code = 0);
      636 	call ipc_$unmask_ev_calls (code);
      637         end;
      638       end;
      639     if dmprp = null then do;
      640         call com_err_ (0, "set_volume_wakeup_interval", "No dump in progress.");
      641         goto UNMASK_EV;
      642       end;
      643     if dmpr_data_.dump_type ^= incr then do;
      644         call com_err_ (0, "set_volume_wakeup_interval", "This command is valid only for incremental volume dumps.");
      645         goto UNMASK_EV;
      646       end;
      647     call cu_$arg_count (narg);
      648     if narg ^= 1 then do;
      649         call com_err_ (error_table_$wrong_no_of_args, "set_volume_wakeup_interval",
      650 	"Usage is: set_volume_wakeup_interval no_of_minutes");
      651         goto UNMASK_EV;
      652       end;
      653     call cu_$arg_ptr (1, argp, argl, code);
      654     if code ^= 0 then do;
      655         call com_err_ (code, "set_volume_wakeup_interval");
      656         goto UNMASK_EV;
      657       end;
      658     my_interval = cv_dec_check_ (arg, code);
      659     if code ^= 0 then do;
      660 badint: call com_err_ (0, "set_volume_wakeup_interval", "The interval must be in minutes (1 to 1440).");
      661         goto UNMASK_EV;
      662       end;
      663     if (my_interval < 1) | (my_interval > 1440) then goto badint;
      664 						/* make sure it's in the range		*/
      665     my_interval = my_interval * 60000000;		/* make it microseconds			*/
      666     call timer_manager_$get_schedule (areap, schedule_ptr, code);
      667     if code ^= 0 then do;
      668         call com_err_ (code, "set_volume_wakeup_interval", "Getting the event schedule.");
      669         goto UNMASK_EV;
      670       end;
      671     do i = 1 to schedule.n_timers;			/* now, find the right event channel		*/
      672       if schedule.timer (i).channel = dmpr_data_.incr_ev_chn then do;
      673 						/* here it is				*/
      674 	old_time = (schedule.timer (i).time - dmpr_data_.wakeup_interval);
      675 						/* this was the *base* time for the wakeup	*/
      676 	call timer_manager_$reset_alarm_wakeup (dmpr_data_.incr_ev_chn);
      677 						/* reset the *old* one			*/
      678 	dmpr_data_.wakeup_interval = my_interval;	/* set the new one				*/
      679 	call timer_manager_$alarm_wakeup (old_time + dmpr_data_.wakeup_interval, "00"b,
      680 	  dmpr_data_.incr_ev_chn);			/* and set the new wakeup			*/
      681 	call hcs_$force_write (dmprp, force_write_bits, ignore);
      682 						/* and get it written			*/
      683 	free schedule in (Area);			/* be clean				*/
      684 	goto UNMASK_EV;				/* let 'er rip				*/
      685         end;
      686     end;
      687     call com_err_ (0, "set_volume_wakeup_interval", "Unable to find the interval timer, no action performed.");
      688     free schedule in (Area);
      689     goto UNMASK_EV;
      690 
      691 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      692 
      693 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      694 
      695 volume_dump_trace_on: entry;
      696 
      697     trace = "1"b;					/* turn on tracing...			*/
      698     mname = "volume_dump_trace_on";
      699     goto trace_join;
      700 
      701 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      702 
      703 volume_dump_trace_off: entry ();
      704     mname = "volume_dump_trace_off";
      705     trace = "0"b;
      706 
      707 trace_join:
      708     if dmprp = null () then				/* no dump to trace yet...			*/
      709          call com_err_ (0, mname, "No dump in progress.");
      710     else do;
      711         call cu_$arg_count (narg);
      712         if narg > 0 then call com_err_ (error_table_$wrong_no_of_args, mname,
      713 	     "This command accepts no arguments.");
      714         else if dmpr_data_.trace = trace then call com_err_ (error_table_$action_not_performed, mname,
      715 	     "Tracing is already in the state requested, ^[on^;^off^]", trace);
      716         else dmpr_data_.trace = trace;
      717       end;
      718     return;
      719 
      720 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      721 
      722 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      723 
      724 
      725 init: proc (type, myname);
      726 
      727 dcl type		     fixed bin;
      728 dcl myname	     char (*);
      729 dcl (volname, pvname, prev_volname) char (32);
      730 dcl (dir_rec, dir_num, seg_num, seg_rec) fixed bin;
      731 
      732 /* This proc initializes the dumper's external static data base */
      733 
      734     call cu_$arg_count (narg);
      735     if narg < 2 then do;
      736         call dmpr_report_$error_output (error_table_$bad_arg, myname, "Required control args not specified");
      737         goto finale;
      738       end;
      739     if dmprp ^= null () then do;
      740         call com_err_ (0, myname, "Recursive invocations of the dumper are not allowed.^[^/Use end_volume_dump first.^]",
      741 	type = incr);
      742         goto finale_nocleanup;
      743       end;
      744     do ac = 1 to narg;
      745       call cu_$arg_ptr (ac, argp, argl, code);
      746       if arg = "-control" then do;
      747 	call cu_$arg_ptr (ac + 1, argp, argl, code);
      748 	if code ^= 0 then do;
      749 	    call dmpr_report_$error_output (code, myname,
      750 	      "No control segment specified after -control.");
      751 	    goto finale;
      752 	  end;
      753 	call suffixed_name_$make (arg, "dump", dump_control_name, code);
      754 	if code ^= 0 then do;
      755 	    call dmpr_report_$online_output (code, myname,
      756 	      "Unable to create dump control seg name from ^a", arg);
      757 	    goto finale;
      758 	  end;
      759 	call hcs_$status_minf (get_wdir_ (), dump_control_name, 0, (0), (0), code);
      760 	if code ^= 0 then do;
      761 	    call dmpr_report_$online_output (code, myname, "Unable to locate ^a>^a",
      762 	      get_wdir_ (), dump_control_name);
      763 	    goto finale;
      764 	  end;
      765 	call ioa_$rsnnl ("^a.^a.^a", control_seg_name, (0), arg, type_char (type), "control");
      766 	call hcs_$make_seg (get_wdir_ (), control_seg_name, "", 01010b, dmprp, code);
      767 	if code = 0 then do;			/* new control seg */
      768 new_control:  call dmpr_report_$online_output (0, myname, "^/Creating new control seg ^a>^a",
      769 	      get_wdir_ (), control_seg_name);
      770 	    new_control_seg = "1"b;
      771 	    dmpr_data_.version = dmpr_data_version_2;
      772 	    prev_volname, volname, pvname = "";
      773 	    cycle_uid = substr (bit (clock, 72), 20, 36);
      774 	    dir_rec, dir_num, seg_rec, seg_num = 0;
      775 	    call lock_dmpr_data;
      776 	  end;
      777 	else if dmprp ^= null then do;		/* already existed */
      778 	    new_control_seg = "0"b;
      779 	    if dmpr_data_.version ^= dmpr_data_version_3 then do;
      780 	        if dmpr_data_.version = dmpr_data_version_2 then do;
      781 		  dmpr_data_.version = dmpr_data_version_3;
      782 		  dmpr_data_.disk_type = 0;		/* totally invisible			*/
      783 		end;
      784 	        else do;
      785 		  call dmpr_report_$online_output (0, myname, "Invalid control seg found");
      786 		  goto new_control;
      787 		end;
      788 	      end;
      789 	    call lock_dmpr_data;
      790 	    if (dmpr_data_.not_reported & dmpr_data_.cur_vol_open) then
      791 						/* do only if the volume was opened.		*/
      792 	         call dmpr_report_$online_output (0, myname,
      793 		 "Finished volume ^a: ^d ^d ^d ^d", dmpr_data_.volname,
      794 		 dmpr_data_.dump_volume_dir_rec, dmpr_data_.dump_volume_dir_num,
      795 		 dmpr_data_.dump_volume_seg_rec,
      796 		 dmpr_data_.dump_volume_seg_num);
      797 	    cycle_uid = dmpr_data_.cycle_uid;
      798 	    if dmpr_data_.cur_vol_open then do;		/* if it was opened successfully		*/
      799 	        volname = dmpr_data_.volname;
      800 	        prev_volname = dmpr_data_.volname;
      801 	      end;
      802 	    else do;				/* nope, use the previous one			*/
      803 	        volname = dmpr_data_.prev_volname;
      804 	        prev_volname = dmpr_data_.prev_volname;
      805 	      end;
      806 	    pvname = dmpr_data_.pvname;
      807 	    dir_rec = dmpr_data_.physical_volume_dir_rec;
      808 	    dir_num = dmpr_data_.physical_volume_dir_num;
      809 	    seg_rec = dmpr_data_.physical_volume_seg_rec;
      810 	    seg_num = dmpr_data_.physical_volume_seg_num;
      811 	  end;
      812 	else do;					/* couldn't create it, so punt */
      813 	    call dmpr_report_$online_output (code, myname, "Unable to initialize control seg");
      814 	    goto finale;
      815 	  end;
      816         end;
      817     end;
      818     if dmprp = null then do;
      819         call dmpr_report_$online_output (0, myname,
      820 	"Control seg initialization failed - control seg not specified.");
      821         goto finale;
      822       end;
      823     dmpr_data_.ptrs = null;
      824     if type = incr then was_asleep = dmpr_data_.dmpr_asleep;
      825     else was_asleep = "0"b;				/* save or set for restart processing		*/
      826     dmpr_data_.bits = "0"b;
      827     dmpr_data_.fixed_bin = 0;
      828     dmpr_data_.disk_type = 0;
      829     dmpr_data_.chars = "";
      830     if type = incr then dmpr_data_.detach = "0"b;		/* default for incrs			*/
      831     else dmpr_data_.detach = "1"b;
      832     dmpr_data_.cycle_uid = cycle_uid;
      833     dmpr_data_.wakeup_interval = 3600000000;		/* Default, one hour (in micro seconds) */
      834     dmpr_data_.data_init = "1"b;
      835     dmpr_data_.incr_skip_count = -1;
      836     dmpr_data_.pre_attach_vol = 0;
      837     dmpr_data_.dump_type = type;
      838     dmpr_data_.sys_dir = ">daemon_dir_dir>volume_backup";
      839     dmpr_data_.myname = myname;
      840     dmpr_data_.pvname = pvname;
      841     dmpr_data_.volname = volname;
      842     dmpr_data_.prev_volname = prev_volname;
      843     dmpr_data_.physical_volume_dir_rec = dir_rec;
      844     dmpr_data_.physical_volume_dir_num = dir_num;
      845     dmpr_data_.physical_volume_seg_rec = seg_rec;
      846     dmpr_data_.physical_volume_seg_num = seg_num;
      847     code = 0;
      848   end init;
      849 
      850 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      851 
      852 
      853 time_now_: proc returns (char (6));
      854 
      855 /* This proc returns a time string suitable for printing of the present time */
      856 
      857     call date_time_ (clock, time_string);
      858     return (substr (time_string, 11, 6));
      859   end time_now_;
      860 
      861 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      862 
      863 
      864 lock_dmpr_data: proc;
      865     call set_lock_$lock (dmpr_data_.lock, lock_wait_time, code);
      866     if code ^= 0 then do;
      867         if code = error_table_$invalid_lock_reset then do;
      868 	  code = 0;
      869 	  dmpr_data_already_locked = "1"b;
      870 	end;
      871         else do;
      872 	  if dmpr_data_.dump_in_progress then do;
      873 	      call dmpr_report_$online_output (0, dmpr_data_.myname,
      874 	        "Dump pass presently in progress; this call ignored");
      875 	      goto finale_nocleanup;
      876 	    end;
      877 	  else if dmpr_data_.dmpr_asleep then do;
      878 	      call dmpr_report_$online_output (0, dmpr_data_.myname, "Dumper asleep. Use wakeup_volume_dump");
      879 	      goto finale_nocleanup;
      880 	    end;
      881 	  else do;
      882 	      call dmpr_report_$online_output (code, dmpr_data_.myname,
      883 	        "Dumper invoked recursively. Use end_volume_dump");
      884 	      goto finale_nocleanup;
      885 	    end;
      886 	end;
      887       end;
      888     else dmpr_data_already_locked = "0"b;
      889   end lock_dmpr_data;
      890 
  1     1 /* BEGIN INCLUDE FILE ... dmpr_data_.incl.pl1 Feb 1976 */
  1     2 /* format: style1,ind2,^inddcls,ifthenstmt,dclind2,declareind2,ifthendo,ifthen*/
  1     3 /* Modified 7/79 by D. Vinograd to add new variables and change to based structure */
  1     4 /* Modified: 1/26/83 by GA Texada to add cur_vol_open and change version to 2.	   */
  1     5 /* Modified: 04/05/83 by GA Texada to add trace switch to support tracing.	   */
  1     6 /* Modified 04/84 by GA Texada to change to version 3 (disk_type). This begins the adding of new items	*/
  1     7 /* to the END of the structure to facilite easy additions.						*/
  1     8 dcl dmprp		     ptr ext static init (null);
  1     9 dcl dmpr_data_version_2  fixed bin int static init (2) options (constant);
  1    10 dcl dmpr_data_version_3  fixed bin int static init (3) options (constant);
  1    11 						/* Version 3 is current			*/
  1    12 
  1    13 dcl 1 dmpr_data_	     aligned based (dmprp),
  1    14     2 version	     fixed bin,			/* version */
  1    15     2 lock	     bit (36),			/* inter-lock */
  1    16     2 ptrs,
  1    17       3 pre_attach_pvlp  (50) ptr,			/* array of pvolog ptrs */
  1    18       3 contents_namesp  ptr,				/* ptr to contents name seg */
  1    19       3 pre_attach_iocbp (50) ptr,			/* array of output iocbp */
  1    20       3 pvlp	     ptr,				/* ptr to dump volume log */
  1    21       3 account_iocbp    ptr,				/* iocbp for account seg */
  1    22       3 infop	     ptr,				/* ptr to info seg */
  1    23       3 inputp	     ptr,				/* ptr to input storage for sup interface */
  1    24       3 recordp	     ptr,				/* ditto for output */
  1    25       3 control_iocbp    ptr,				/* iocbp for dump control segment */
  1    26       3 error_iocbp	     ptr,				/* iocbp for error output file */
  1    27       3 outputvol_iocbp  ptr,				/* iocbp for dump volume */
  1    28       3 contentsp	     ptr,				/* ptr to dump volume table of contents */
  1    29       3 bvlp	     ptr,				/* ptr to volume log */
  1    30       3 dirp	     ptr,				/* ptr to directory buffer seg */
  1    31       3 segp	     ptr,				/* ptr to segment to be dumped */
  1    32       3 fcbp	     ptr,				/* ptr to file control block for contents_name msf */
  1    33       3 vpp	     ptr,				/* ptr to volume pool */
  1    34     2 fixed_bin,
  1    35       3 retrys	     fixed bin,			/* number of time segment disappeared while being dumped */
  1    36       3 physical_volume_dir_num fixed bin,		/* number of dirs dumped from this physical volume */
  1    37       3 physical_volume_dir_rec fixed bin,		/* number of dir records on this physical volume */
  1    38       3 physical_volume_seg_num fixed bin,		/* number of segs dumped from this physical volume */
  1    39       3 physical_volume_seg_rec fixed bin,		/* number of seg records dumped from this physical volume  */
  1    40       3 vol_log_dir_num  fixed bin,			/*  dirs dumped from pvol to dump vol */
  1    41       3 vol_log_dir_rec  fixed bin,			/*  dir rec on this pvol to dump vol */
  1    42       3 vol_log_seg_num  fixed bin,			/*  segs dumped from pvol to dump vol */
  1    43       3 vol_log_seg_rec  fixed bin,			/*  seg rec dumped from pvol to dump vol  */
  1    44       3 dump_volume_dir_num fixed bin,			/* number of dirs dumped on this dump volume */
  1    45       3 dump_volume_dir_rec fixed bin,			/* number of dir records on this dump volume */
  1    46       3 dump_volume_seg_num fixed bin,			/* number of segs dumped on this dump volume */
  1    47       3 dump_volume_seg_rec fixed bin,			/* number of seg records dumped on this dump volume  */
  1    48       3 num_null_vtoce   fixed bin,			/* number of null vtoce dumped from this physical volume */
  1    49       3 num_vtoce_only   fixed bin,			/* number of vtoce only  */
  1    50       3 mod_after_time   fixed bin (71),		/* dump all modified since this date */
  1    51       3 dump_type	     fixed bin,			/* type of dump */
  1    52       3 save_time	     fixed bin (71),		/* date, time of start of dump */
  1    53       3 start_time	     fixed bin (71),		/* start time of physical volume pass */
  1    54       3 wakeup_interval  fixed bin (71),		/* interval between wakeups of dumper in micro secs. */
  1    55       3 incr_ev_chn	     fixed bin (71),		/* event chn used to wakeup incremental dumper */
  1    56       3 incr_skip_count  fixed bin,			/* number of incr cycles skiped befor purging */
  1    57       3 pre_attach_vol   fixed bin,			/* if greater then 1 then pre attach output streams */
  1    58       3 vol_idx	     fixed bin,			/* index of multi volume attachment sequence */
  1    59       3 component	     fixed bin,			/* msf component of contents_name seg */
  1    60     2 bits,
  1    61       3 volid	     bit (36),			/* uid of dump volume */
  1    62       3 pre_attach_volid (50) bit (36),			/* array of volid */
  1    63       3 cycle_uid	     bit (36),			/* uid of this dump cycle */
  1    64       3 pvid	     bit (36),			/* uid of physical volume being dumped */
  1    65       3 flags,
  1    66       ( 4 purge	     bit (1),			/* if on purge volume logs */
  1    67         4 auto_vol	     bit (1),			/* if on use automatic dump volume selection */
  1    68         4 disable_error_report bit (1),			/* if on disables error reporting */
  1    69         4 arg_init	     bit (1),			/* if on indicates args have been processed */
  1    70         4 manual_free    bit (1),			/* on if manual free will be done */
  1    71         4 err_online     bit (1),			/* Flag error output to be online, default to a file */
  1    72         4 detach	     bit (1),			/* if on control detachment of dump volume */
  1    73         4 no_object	     bit (1),			/* if on not copy object from ring 0 */
  1    74         4 no_update	     bit (1),			/* if on prevent vtoce update */
  1    75         4 data_init	     bit (1),			/* if on indicates that data structure has been initialized */
  1    76         4 reset	     bit (1),			/* if on put items back on list */
  1    77         4 accounting     bit (1),			/* if on enables accounting */
  1    78         4 dmpr_asleep    bit (1),			/* dumper is asleep - interlock to prevent restart of last volume */
  1    79         4 dump_in_progress bit (1),			/* recursive entry interlock */
  1    80         4 not_reported   bit (1),			/* on if output counts not reported */
  1    81         4 names	     bit (1),			/* collect all names from dirs that are dumped */
  1    82         4 cur_vol_open   bit (1),			/* if a successful open on this volname		*/
  1    83         4 trace	     bit (1),			/* ON => trace				*/
  1    84         4 pad	     bit (18)) unal,		/* fill out the word properly			*/
  1    85       3 old_256K_switch bit(2) aligned,			/* 256K segs enabled prior to this dumper invocation?*/
  1    86       3 rpv_pvid        bit (36),			/* because the label really doesn't have it	*/
  1    87     2 chars,
  1    88       3 sys_dir	     char (168),			/* system directory where all volume dumper data lives */
  1    89       3 prev_volname     char (32),
  1    90       3 pre_attach_volname (50) char (32),		/* array of volnames */
  1    91       3 io_module	     char (32),			/* name of attached outer module for output io */
  1    92       3 pvname	     char (32),			/* name of physical volume being dumped */
  1    93       3 att_desc	     char (256),			/* attach description for output */
  1    94       3 volname	     char (32),			/* name of dump volume */
  1    95       3 control_name     char (32),			/* dump control file name   */
  1    96       3 myname	     char (32),			/* name of entry called */
  1    97       3 operator	     char (32),			/* operator name */
  1    98       3 restart_pvname   char (32),			/* where to restart complete or consolidated dump */
  1    99       3 lvname	     char (32),			/* name of logical volume being dumped */
  1   100    2 disk_type fixed bin;				/* disk type for recording in the volog		*/
  1   101 	
  1   102 
  1   103 /* END OF INCLUDE FILE ... dmpr_data_.incl.pl1 */
      891 
      892 
  2     1 /*     BEGIN INCLUDE FILE ... dmpr_input.incl.pl1 ... last modified Dec 1975 */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(88-05-27,GWMay), approve(88-05-27,MCR7883),
  2     6*     audit(88-06-14,Beattie), install(88-07-19,MR12.2-1061):
  2     7*     Added Sfirst_pass_for_pv bit and time stamp variables for use in
  2     8*     processing inconsistent dumper bit maps.
  2     9*                                                   END HISTORY COMMENTS */
  2    10 
  2    11 
  2    12 /* Input structure for supervisor interface for dumper */
  2    13 
  2    14 dcl  inputp ptr;
  2    15 
  2    16 dcl  dmpr_input_version_1 internal static init (1) options (constant);
  2    17 
  2    18 dcl 1 dmpr_input based (inputp) aligned,
  2    19     2 version fixed bin,				/* version number of structure */
  2    20     2 pvid bit (36),				/* physical volume id of volume to dump */
  2    21     2 type fixed bin,				/* type of dump */
  2    22     2 flags,
  2    23      (3 reset bit (1),				/* if on forces reseting in control bit map */
  2    24       3 no_update bit (1),				/* if on do not update vtoce (dtd and volid ) */
  2    25       3 no_object bit (1),				/* if on do not return object */
  2    26       3 retry bit (1),				/* if on indicates a retry of prev aborted call */
  2    27       3 request bit (1),				/* if on indicates caller will control what to dump */
  2    28       3 Sfirst_pass_for_pv bit (1),                         /* on = read disk label */
  2    29       3 pad bit (29))unal,
  2    30     2 prev_vtocx fixed bin,				/* vtoc index of previously dumped vtocx */
  2    31     2 request_vtocx fixed bin,			/* vtocx to be dumped if request mode enabled */
  2    32     2 volid bit (36),				/* volume id on which dump will be written */
  2    33     2 start_time fixed bin (71),			/* start time of this cycle */
  2    34     2 mod_after_time fixed bin (71),			/* time to check dtm against  */
  2    35     2 last_incr_dump_time fixed bin (71),
  2    36     2 last_cons_dump_time fixed bin (71);
  2    37 
  2    38 /*     END INCLUDE FILE ... dmpr_input.incl.pl1 ...  */
      893 
  3     1 /* BEGIN INCLUDE FILE ... backup_static_variables.incl.pl1 ... March 1976 */
  3     2 
  3     3 
  3     4 dcl  incr fixed bin init (1) internal static options (constant); /* incremental dump mode */
  3     5 dcl  cons fixed bin init (2) internal static options (constant); /* consolidated dump mode */
  3     6 dcl  comp fixed bin init (3) internal static options (constant); /* complete dump mode */
  3     7 dcl  backup_version_1 fixed bin init (1) static internal options (constant); /* backup_version_1 of input/output structures */
  3     8 
  3     9 
  3    10 
  3    11 /* END INCLUDE FILE ... backup_static_variables.incl.pl1 */
      894 
      895 
  4     1 /* BEGIN INCLUDE FILE ... backup_volume_header ... Feb 1976 */
  4     2 
  4     3 dcl  hdp ptr;					/* ptr to header */
  4     4 
  4     5 dcl 1 backup_volume_header based (hdp) aligned,
  4     6     2 pattern1 bit (36),				/* unique  word 1 */
  4     7     2 rec1_type fixed bin,				/* record 1 type */
  4     8     2 rec1_len fixed bin,				/* length in chars */
  4     9     2 pattern2 bit (36),				/* unique word 2 */
  4    10     2 rec2_type fixed bin,				/* record 2 type */
  4    11     2 rec2_len fixed bin,				/* length in chars */
  4    12     2 pattern3 bit (36),				/* unique word 3 */
  4    13     2 time_dumped bit (36);				/* dump time of this record */
  4    14 
  4    15 dcl  vtoce_type fixed bin static init (1) options (constant); /* type code for vtoce */
  4    16 dcl  dir_type fixed bin static init (2) options (constant); /* type code for directory */
  4    17 dcl  seg_type fixed bin static init (3) options (constant); /* type code for segment */
  4    18 dcl  null_type fixed bin static init (4) options (constant); /* type code for null record */
  4    19 dcl  volume_log_type fixed bin static init (5) options (constant); /* type code for volume log */
  4    20 dcl  prev_output_log_type fixed bin static init (6) options (constant); /* type code for prev output log */
  4    21 dcl  contents_type fixed bin static init (7) options (constant); /* type code for contents segment of previous volume */
  4    22 dcl  info_type fixed bin static init (8) options (constant); /* type code for info structure */
  4    23 
  4    24 dcl  pattern1 bit (36) int static init ("110111000011001100011101101010100101"b) options (constant);
  4    25 dcl  pattern2 bit (36) int static init ("101001010101101110001100110000111011"b) options (constant);
  4    26 dcl  pattern3 bit (36) int static init ("001000111100110011100010010101011010"b) options (constant);
  4    27 
  4    28 /* END INCLUDE FILE ... backup_volume_header */
      896 
      897 
  5     1 /* --------------- BEGIN include file timer_manager_schedule.incl.pl1 --------------- */
  5     2 /*	Last modified 9 September 1982 to add timer_manager_ data pointers	      */
  5     3 
  5     4 
  5     5 /****^  HISTORY COMMENTS:
  5     6*  1) change(86-08-12,Kissel), approve(86-08-12,MCR7473),
  5     7*     audit(86-10-08,Fawcett), install(86-11-03,MR12.0-1206):
  5     8*     Changed to support control point management.  These changes were actually
  5     9*     done in February 1985 by G. Palter.
  5    10*                                                   END HISTORY COMMENTS */
  5    11 
  5    12 
  5    13 dcl 1 schedule aligned based (schedule_ptr),
  5    14     2 version fixed bin,
  5    15     2 n_timers fixed bin,
  5    16     2 timer (N_Timers refer (schedule.n_timers)) aligned,
  5    17       3 time fixed bin (71),
  5    18       3 flags,
  5    19         4 inhibit bit (1) unaligned,
  5    20         4 alarm bit (1) unaligned,
  5    21         4 cpu bit (1) unaligned,
  5    22         4 call bit (1) unaligned,
  5    23         4 wakeup bit (1) unaligned,
  5    24         4 data_ptr_provided bit (1) unaligned,
  5    25         4 pad bit (30) unaligned,
  5    26       3 pad1 bit (36) aligned,
  5    27       3 channel fixed bin (71),
  5    28       3 routine entry variable options (variable),
  5    29       3 data_ptr pointer,
  5    30       3 control_point_id bit (36) aligned,
  5    31       3 pad (3) fixed bin (35);
  5    32 
  5    33 dcl  N_Timers fixed bin,
  5    34      schedule_ptr pointer,
  5    35 
  5    36      timer_manager_schedule_version_1 fixed bin static initial (1) options (constant),
  5    37      timer_manager_schedule_version_2 fixed bin static initial (2) options (constant),
  5    38      timer_manager_schedule_version_3 fixed bin static initial (3) options (constant);
  5    39      
  5    40 
  5    41 /* ---------------- END include file timer_manager_schedule.incl.pl1 ---------------- */
      898 
      899 
      900 
      901   end dumper;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/19/88  1535.6  dumper.pl1                        >special_ldd>install>MR12.2-1061>dumper.pl1
891          1    10/24/84  0933.1  dmpr_data_.incl.pl1               >ldd>include>dmpr_data_.incl.pl1
893          2    07/19/88  1523.2  dmpr_input.incl.pl1               >special_ldd>install>MR12.2-1061>dmpr_input.incl.pl1
894          3    09/05/80  1136.5  backup_static_variables.incl.pl1  >ldd>include>backup_static_variables.incl.pl1
896          4    09/05/80  1136.5  backup_volume_header.incl.pl1     >ldd>include>backup_volume_header.incl.pl1
898          5    11/07/86  1550.3  timer_manager_schedule.incl.pl1   >ldd>include>timer_manager_schedule.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
Area                                   based           area(1024)               dcl 54 ref 633 683 688
YES                             000121 automatic       bit(1)                   packed unaligned dcl 58 set ref 552* 557
ac                              000140 automatic       fixed bin(17,0)          dcl 62 set ref 744* 745* 747*
add_epilogue_handler_           000076 constant        entry                    external dcl 121 ref 170
addr                                                   builtin function         dcl 152 ref 327 327 341 341 389 389 473 473 595
after                                                  builtin function         dcl 152 ref 340 357
announce_vols                          based           char(32)                 array packed unaligned dcl 525 set ref 595*
answer                          000136 automatic       varying char(3)          dcl 61 set ref 389* 391
areap                           000162 automatic       pointer                  dcl 64 set ref 630* 631* 633 666* 683 688
arg                                    based           char                     packed unaligned dcl 92 set ref 562 563 581* 658*
                                                                                  746 753* 755* 765*
arg_init                475(03)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref
                                                                                  184*
argl                            000141 automatic       fixed bin(17,0)          dcl 62 set ref 561* 562 563 581 581 653* 658 658
                                                                                  745* 746 747* 753 753 755 755 765 765
argp                            000164 automatic       pointer                  dcl 64 set ref 175* 176* 561* 562 563 581 653* 658
                                                                                  745* 746 747* 753 755 765
auto_vol                475(01)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref 196
                                                                                  451
before                                                 builtin function         dcl 152 ref 339 355
bit                                                    builtin function         dcl 152 ref 396 408 773
bits                    410            based           structure                level 2 dcl 1-13 set ref 826*
channel                   6            based           fixed bin(71,0)          array level 3 dcl 5-13 ref 672
chars                   500            based           structure                level 2 dcl 1-13 set ref 829*
cleanup                         005636 stack reference condition                dcl 149 ref 173 585 632
clock                                                  builtin function         dcl 152 ref 304 396 408 773 857 857
code                            003656 automatic       fixed bin(35,0)          dcl 73 in procedure "dumper" set ref 170* 171 171*
                                                                                  176* 177 179* 180 181* 192* 193* 197* 200 201*
                                                                                  207* 208 209* 218* 219 220* 224* 225 226* 231* 232
                                                                                  233* 237* 238 239* 242* 243 244* 249* 250 251*
                                                                                  254* 255 256 256* 307* 308 309* 327* 328 329 331*
                                                                                  341* 342 343* 358* 360 361* 415* 416 417* 430* 431
                                                                                  451* 453 453* 458 460* 479* 480 480* 528* 529 530*
                                                                                  561* 586* 587 588* 592* 594 599* 601 602* 604 605*
                                                                                  625* 626 627* 634* 635 636* 653* 654 655* 658* 659
                                                                                  666* 667 668* 745* 747* 748 749* 753* 754 755*
                                                                                  759* 760 761* 766* 767 813* 847* 865* 866 867 868*
                                                                                  882*
code                      3     003660 automatic       fixed bin(35,0)          initial level 2 in structure "query_info" dcl 75
                                                                                  in procedure "dumper" set ref 75*
com_err_                        000050 constant        entry                    external dcl 110 ref 277 288 500 530 535 541 547 566
                                                                                  573 581 627 640 644 649 655 660 668 687 707 712
                                                                                  714 740
command_query_                  000052 constant        entry                    external dcl 111 ref 389
command_query_$yes_no           000030 constant        entry                    external dcl 102 ref 552
comp                                   constant        fixed bin(17,0)          initial dcl 3-6 set ref 166* 428 449
cons                                   constant        fixed bin(17,0)          initial dcl 3-5 set ref 161* 428 449
control_iocbp           326            based           pointer                  level 3 dcl 1-13 set ref 224* 231* 307* 327*
control_name           1532            based           char(32)                 level 3 dcl 1-13 set ref 191 224 226* 233* 309* 331*
control_seg_name                000151 automatic       char(32)                 packed unaligned dcl 63 set ref 765* 766* 768*
cu_$arg_count                   000064 constant        entry                    external dcl 116 ref 545 647 711 734
cu_$arg_list_ptr                000144 constant        entry                    external dcl 140 ref 175
cu_$arg_ptr                     000066 constant        entry                    external dcl 117 ref 561 653 745 747
cur_vol_open            475(16)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref 790
                                                                                  798
cv_dec_check_                   000032 constant        entry                    external dcl 103 ref 658
cycle_uid               473            based           bit(36)                  level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 396* 408* 797 832*
cycle_uid                       000133 automatic       bit(36)                  packed unaligned dcl 60 in procedure "dumper" set
                                                                                  ref 773* 797* 832
data_init               475(09)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref
                                                                                  834*
date_time_                      000142 constant        entry                    external dcl 139 ref 857
detach                  475(06)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref 185
                                                                                  474 506* 551 557* 830* 831*
device_type              10     003665 automatic       fixed bin(17,0)          array level 2 in structure "pva" dcl 82 in procedure
                                                                                  "dumper" set ref 351
device_type                     003506 automatic       fixed bin(17,0)          array dcl 71 in procedure "dumper" set ref 318* 351*
                                                                                  358* 425
dir_num                         005727 automatic       fixed bin(17,0)          dcl 730 set ref 774* 808* 844
dir_rec                         005726 automatic       fixed bin(17,0)          dcl 730 set ref 774* 807* 843
dirp                    340            based           pointer                  level 3 dcl 1-13 set ref 213* 249*
disable_error_report    475(02)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref
                                                                                  505*
disk_type              1602            based           fixed bin(17,0)          level 2 dcl 1-13 set ref 425* 782* 828*
dmpr_arg_reader_                000124 constant        entry                    external dcl 132 ref 176
dmpr_asleep             475(12)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref
                                                                                  299* 483* 824 877
dmpr_data_                             based           structure                level 1 dcl 1-13
dmpr_data_already_locked        000122 automatic       bit(1)                   packed unaligned dcl 58 set ref 301* 379 383 869*
                                                                                  888*
dmpr_data_version_2                    constant        fixed bin(17,0)          initial dcl 1-9 ref 771 780
dmpr_data_version_3             000000 constant        fixed bin(17,0)          initial dcl 1-10 ref 779 781
dmpr_finish_                    000126 constant        entry                    external dcl 133 ref 173 174 507
dmpr_info_                      000122 constant        entry                    external dcl 131 ref 218
dmpr_input                             based           structure                level 1 dcl 2-18
dmpr_input_version_1                   constant        fixed bin(17,0)          initial dcl 2-16 ref 262
dmpr_output_$end_pass_detach    000110 constant        entry                    external dcl 126 ref 474
dmpr_output_$init               000106 constant        entry                    external dcl 125 ref 254
dmpr_output_$preattach_ioname   000114 constant        entry                    external dcl 128 ref 599
dmpr_output_$preattach_vols     000112 constant        entry                    external dcl 127 ref 592
dmpr_report_$error_output       000162 constant        entry                    external dcl 147 ref 171 181 186 193 197 197 209 220
                                                                                  226 233 239 244 251 256 309 331 343 361 367 401
                                                                                  453 460 480 736 749
dmpr_report_$online_output      000164 constant        entry                    external dcl 147 ref 201 292 302 385 417 428 432 440
                                                                                  469 478 595 755 761 768 785 790 813 819 873 878
                                                                                  882
dmprp                           000166 external static pointer                  initial dcl 1-8 set ref 168 171 179 181 184 185 185
                                                                                  185 186 191 191 193 196 197 197 201 209 213 214
                                                                                  215 216 220 224 224 226 226 231 233 233 236 237
                                                                                  239 242 244 249 249 251 256 261 263 264 265 266
                                                                                  267 268 276 280 287 291 292 297 298 299 302 307
                                                                                  309 309 327 331 331 343 361 367 376 379 379 384
                                                                                  384 385 385 388 389 391 391 395 396 396 398 401
                                                                                  401 408 412 413 414 415 417 417 419 425 426* 428
                                                                                  428 428 428 432 432 432 432 432 432 432 440 440
                                                                                  440 449 449 449 451 451 451 451 451 453 453 460
                                                                                  460 467 469 472 473 474 476 476 478 480 482 483
                                                                                  484 485* 499 503 504 505 506 534 540 551 557 571
                                                                                  571 571 571 573 573 592 595 595 599 601 601 639
                                                                                  643 672 674 676 678 679 679 681* 707 714 716 739
                                                                                  766* 771 777 779 780 781 782 790 790 790 790 790
                                                                                  790 790 797 798 799 800 803 804 806 807 808 809
                                                                                  810 818 823 824 826 827 828 829 830 831 832 833
                                                                                  834 835 836 837 838 839 840 841 842 843 844 845
                                                                                  846 865 872 873 877 878 882
dump_control_name               000110 automatic       char(32)                 packed unaligned dcl 56 set ref 753* 759* 761*
dump_in_progress        475(13)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref
                                                                                  268* 291 298* 482* 504* 872
dump_type               372            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 185 236 263 388 396 428 428
                                                                                  449 449 472 540 643 837*
dump_volume_                    000120 constant        entry                    external dcl 130 ref 430
dump_volume_dir_num     361            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 790*
dump_volume_dir_rec     362            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 790*
dump_volume_seg_num     363            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 790*
dump_volume_seg_rec     364            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 790*
error_table_$action_not_performed
                                000012 external static fixed bin(35,0)          dcl 95 set ref 573* 714*
error_table_$bad_arg            000022 external static fixed bin(35,0)          dcl 99 set ref 192 736*
error_table_$bad_conversion     000024 external static fixed bin(35,0)          dcl 100 set ref 581*
error_table_$end_of_info        000014 external static fixed bin(35,0)          dcl 96 ref 329
error_table_$inconsistent       000020 external static fixed bin(35,0)          dcl 98 set ref 186*
error_table_$invalid_lock_reset 000016 external static fixed bin(35,0)          dcl 97 ref 867
error_table_$wrong_no_of_args   000026 external static fixed bin(35,0)          dcl 101 set ref 547* 649* 712*
finish                          005644 stack reference condition                dcl 149 ref 174
first_pvx                       000146 automatic       fixed bin(17,0)          dcl 62 set ref 378* 406* 411
fixed                                                  builtin function         dcl 152 ref 563
fixed_bin               350            based           structure                level 2 dcl 1-13 set ref 827*
flags                   475            based           structure                level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper"
flags                     3            based           structure                level 2 in structure "dmpr_input" dcl 2-18
                                                                                  in procedure "dumper"
force_write_bits                000105 constant        bit(36)                  initial packed unaligned dcl 89 set ref 426* 485*
                                                                                  681*
get_system_free_area_           000034 constant        entry                    external dcl 104 ref 631
get_temp_segments_              000116 constant        entry                    external dcl 129 ref 207
get_wdir_                       000072 constant        entry                    external dcl 119 ref 759 759 761 761 766 766 768 768
hbound                                                 builtin function         dcl 152 ref 571 571 573
hc_backup_$init_dmpr            000104 constant        entry                    external dcl 124 ref 249
hcs_$force_write                000040 constant        entry                    external dcl 106 ref 426 485 681
hcs_$make_seg                   000070 constant        entry                    external dcl 118 ref 766
hcs_$set_256K_switch            000042 constant        entry                    external dcl 107 ref 179
hcs_$status_minf                000044 constant        entry                    external dcl 108 ref 759
i                               005652 automatic       fixed bin(35,0)          dcl 622 set ref 671* 672 674*
idx                             000144 automatic       fixed bin(17,0)          dcl 62 set ref 347* 348 349 349 350 350 351 351*
                                                                                  398* 398* 400 406 411* 412 413 414 419 420* 420
                                                                                  422* 422 425*
ignore                          003657 automatic       fixed bin(35,0)          dcl 73 set ref 173* 174* 426* 473 473 473* 474* 485*
                                                                                  507* 681*
ignored_lvid                    000134 automatic       bit(36)                  packed unaligned dcl 60 set ref 358*
incr                                   constant        fixed bin(17,0)          initial dcl 3-4 set ref 156* 185 236 388 396 472 540
                                                                                  643 740 824 830
incr_ev_chn             402            based           fixed bin(71,0)          level 3 dcl 1-13 set ref 237* 242* 297* 476* 672
                                                                                  676* 679*
incr_skip_count         404            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 449 451* 835*
infop                   320            based           pointer                  level 3 dcl 1-13 set ref 216*
inputp                          005656 automatic       pointer                  dcl 2-14 in procedure "dumper" set ref 261* 262 263
                                                                                  264 265 266 267 376* 440
inputp                  322            based           pointer                  level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 214* 261 376
ioa_$rsnnl                      000062 constant        entry                    external dcl 115 ref 765
iox_$attach_ioname              000146 constant        entry                    external dcl 141 ref 224
iox_$control                    000100 constant        entry                    external dcl 122 ref 473 479
iox_$get_line                   000154 constant        entry                    external dcl 144 ref 327
iox_$open                       000152 constant        entry                    external dcl 143 ref 231
iox_$position                   000150 constant        entry                    external dcl 142 ref 307
iox_$user_io                    000010 external static pointer                  dcl 94 set ref 479*
ipc_$create_ev_chn              000156 constant        entry                    external dcl 145 ref 237
ipc_$decl_ev_call_chn           000160 constant        entry                    external dcl 146 ref 242
ipc_$mask_ev_calls              000056 constant        entry                    external dcl 113 ref 528 625
ipc_$unmask_ev_calls            000060 constant        entry                    external dcl 114 ref 588 605 636
length                                                 builtin function         dcl 152 ref 327 327
line                            000166 automatic       char(120)                dcl 65 set ref 325* 327 327 327 327 338* 338 339 340
                                                                                  355 357 367*
lock                      1            based           bit(36)                  level 2 dcl 1-13 set ref 865*
lock_wait_time                  000001 constant        fixed bin(17,0)          initial dcl 90 set ref 865*
lvname                          000234 automatic       char(32)                 array packed unaligned dcl 67 in procedure "dumper"
                                                                                  set ref 315* 348* 358* 413 419
lvname                 1572            based           char(32)                 level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 413* 415* 417* 419
manage_volume_pool_$set_pool_path
                                000046 constant        entry                    external dcl 109 ref 197
manual_free             475(04)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref 451
mdc_$check_mounted              000074 constant        entry                    external dcl 120 ref 415
mdc_$lvname_info                000136 constant        entry                    external dcl 137 ref 341
mdc_$pvname_info                000140 constant        entry                    external dcl 138 ref 358
mname                           000125 automatic       char(21)                 packed unaligned dcl 59 set ref 698* 704* 707* 712*
                                                                                  714*
mod_after_time           12            based           fixed bin(71,0)          level 2 in structure "dmpr_input" dcl 2-18
                                                                                  in procedure "dumper" set ref 267*
mod_after_time          370            based           fixed bin(71,0)          level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 267
my_interval                     005654 automatic       fixed bin(71,0)          dcl 622 set ref 658* 663 663 665* 665 678
myname                                 parameter       char                     packed unaligned dcl 728 in procedure "init" set ref
                                                                                  725 736* 740* 749* 755* 761* 768* 785* 790* 813*
                                                                                  819* 839
myname                 1542            based           char(32)                 level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 171* 181* 186* 193*
                                                                                  201* 209* 220* 226* 233* 239* 244* 251* 256* 280*
                                                                                  292* 302* 309* 331* 343* 361* 367* 385* 389* 401*
                                                                                  417* 428* 432* 440* 453* 460* 469* 478* 480* 484*
                                                                                  503* 839* 873* 878* 882*
n_timers                  1            based           fixed bin(17,0)          level 2 dcl 5-13 ref 633 671 683 688
name                      2     003660 automatic       bit(1)                   initial level 2 dcl 75 set ref 75*
narg                            000142 automatic       fixed bin(17,0)          dcl 62 set ref 545* 546 647* 648 711* 712 734* 735
                                                                                  744
nelemt                          000143 automatic       fixed bin(17,0)          dcl 62 set ref 327* 338
new_control_seg                 000123 automatic       bit(1)                   packed unaligned dcl 58 set ref 300* 379 770* 778*
no_object                 3(02)        based           bit(1)                   level 3 in structure "dmpr_input" packed packed
                                                                                  unaligned dcl 2-18 in procedure "dumper" set ref
                                                                                  266* 440
no_object               475(07)        based           bit(1)                   level 4 in structure "dmpr_data_" packed packed
                                                                                  unaligned dcl 1-13 in procedure "dumper" set ref
                                                                                  266
no_update               475(08)        based           bit(1)                   level 4 in structure "dmpr_data_" packed packed
                                                                                  unaligned dcl 1-13 in procedure "dumper" set ref
                                                                                  265
no_update                 3(01)        based           bit(1)                   level 3 in structure "dmpr_input" packed packed
                                                                                  unaligned dcl 2-18 in procedure "dumper" set ref
                                                                                  265*
not_reported            475(14)        based           bit(1)                   level 4 packed packed unaligned dcl 1-13 set ref 790
null                                                   builtin function         dcl 152 ref 242 242 276 287 479 479 499 534 630 633
                                                                                  639 707 739 777 818 823
num_null_vtoce          365            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 432* 440*
num_pv                          000145 automatic       fixed bin(17,0)          dcl 62 set ref 314* 348 349 350 351 353* 353 356*
                                                                                  356 357 358 358 358 358 361 363* 363 379 398 400
                                                                                  411
num_vtoce_only          366            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 440*
nvols                           000147 automatic       fixed bin(17,0)          dcl 62 set ref 563* 565 571 571 592* 592 592 595
                                                                                  595* 595 599* 599 599 601
old_256K_switch         476            based           bit(2)                   level 3 dcl 1-13 set ref 168* 179*
old_time                        003652 automatic       fixed bin(71,0)          dcl 72 set ref 674* 679
operator               1552            based           char(32)                 level 3 dcl 1-13 set ref 191
outputvol_iocbp         332            based           pointer                  level 3 dcl 1-13 set ref 473*
physical_volume_dir_num
                        351            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 432* 808 844*
physical_volume_dir_rec
                        352            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 432* 807 843*
physical_volume_seg_num
                        353            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 432* 810 846*
physical_volume_seg_rec
                        354            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 432* 809 845*
pre_attach_vol          405            based           fixed bin(17,0)          level 3 dcl 1-13 set ref 185 571 571 573 592 595 599
                                                                                  601* 601 836*
pre_attach_volname      562            based           char(32)                 array level 3 dcl 1-13 set ref 571 571 573 595
prev_volname            552            based           char(32)                 level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 803 804 842*
prev_volname                    005716 automatic       char(32)                 packed unaligned dcl 729 in procedure "init" set ref
                                                                                  772* 800* 804* 842
ptrs                      2            based           structure                level 2 dcl 1-13 set ref 823*
purge_volume_log_               000102 constant        entry                    external dcl 123 ref 451
pva                             003665 automatic       structure                array level 1 dcl 82 set ref 341 341
pvid                            003342 automatic       bit(36)                  array packed unaligned dcl 70 in procedure "dumper"
                                                                                  set ref 317* 350* 358* 412
pvid                     11     003665 automatic       bit(36)                  array level 2 in structure "pva" dcl 82 in procedure
                                                                                  "dumper" set ref 350
pvid                    474            based           bit(36)                  level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 412*
pvname                          005706 automatic       char(32)                 packed unaligned dcl 729 in procedure "init" set ref
                                                                                  772* 806* 840
pvname                          001674 automatic       char(32)                 array packed unaligned dcl 68 in procedure "dumper"
                                                                                  set ref 316* 349* 357* 358* 361* 379 398 414
pvname                          003665 automatic       char(32)                 array level 2 in structure "pva" dcl 82 in procedure
                                                                                  "dumper" set ref 349
pvname                 1412            based           char(32)                 level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 379 384 391 414*
                                                                                  428* 432* 451* 453* 460* 806 840*
query_info                      003660 automatic       structure                level 1 dcl 75 set ref 389 389
recordp                 324            based           pointer                  level 3 dcl 1-13 set ref 215*
reset                   475(10)        based           bit(1)                   level 4 in structure "dmpr_data_" packed packed
                                                                                  unaligned dcl 1-13 in procedure "dumper" set ref
                                                                                  264
reset                     3            based           bit(1)                   level 3 in structure "dmpr_input" packed packed
                                                                                  unaligned dcl 2-18 in procedure "dumper" set ref
                                                                                  264*
restart_pvname         1562            based           char(32)                 level 3 dcl 1-13 set ref 379 384* 385* 391* 395 398
                                                                                  401* 467*
rtrim                                                  builtin function         dcl 152 ref 197
schedule                               based           structure                level 1 dcl 5-13 ref 633 683 688
schedule_ptr                    005660 automatic       pointer                  dcl 5-33 set ref 630* 633 633 666* 671 672 674 683
                                                                                  688
seg_num                         005730 automatic       fixed bin(17,0)          dcl 730 set ref 774* 810* 846
seg_rec                         005731 automatic       fixed bin(17,0)          dcl 730 set ref 774* 809* 845
segp                    342            based           pointer                  level 3 dcl 1-13 set ref 249*
set_lock_$lock                  000054 constant        entry                    external dcl 112 ref 865
substr                                                 builtin function         dcl 152 ref 338 396 408 773 858
suffixed_name_$make             000036 constant        entry                    external dcl 105 ref 753
sys_dir                 500            based           char(168)                level 3 dcl 1-13 set ref 197 451* 838*
time                      2            based           fixed bin(71,0)          array level 3 dcl 5-13 ref 674
time_pass_started               003654 automatic       fixed bin(71,0)          dcl 72 set ref 304* 476
time_string                     003334 automatic       char(24)                 packed unaligned dcl 69 set ref 857* 858
timer                     2            based           structure                array level 2 dcl 5-13
timer_manager_$alarm_wakeup     000130 constant        entry                    external dcl 134 ref 476 679
timer_manager_$get_schedule     000132 constant        entry                    external dcl 135 ref 666
timer_manager_$reset_alarm_wakeup
                                000134 constant        entry                    external dcl 136 ref 297 676
tlvname                         000224 automatic       char(32)                 dcl 66 set ref 340* 341* 343* 348
tnpv                            000150 automatic       fixed bin(17,0)          dcl 62 set ref 341* 347 353
tp                              000100 automatic       pointer                  array dcl 55 set ref 207* 213 214 215 216
trace                           000124 automatic       bit(1)                   packed unaligned dcl 58 in procedure "dumper" set
                                                                                  ref 697* 705* 714 714* 716
trace                   475(17)        based           bit(1)                   level 4 in structure "dmpr_data_" packed packed
                                                                                  unaligned dcl 1-13 in procedure "dumper" set ref
                                                                                  714 716*
type                                   parameter       fixed bin(17,0)          dcl 727 in procedure "init" ref 725 740 765 824 830
                                                                                  837
type                      2            based           fixed bin(17,0)          level 2 in structure "dmpr_input" dcl 2-18
                                                                                  in procedure "dumper" set ref 263*
type_char                       000002 constant        char(4)                  initial array packed unaligned dcl 88 set ref 765*
verify                                                 builtin function         dcl 152 ref 562
version                                based           fixed bin(17,0)          level 2 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 771* 779 780 781*
version                                based           fixed bin(17,0)          level 2 in structure "dmpr_input" dcl 2-18
                                                                                  in procedure "dumper" set ref 262*
version                         003660 automatic       fixed bin(17,0)          initial level 2 in structure "query_info" dcl 75
                                                                                  in procedure "dumper" set ref 75*
volname                1522            based           char(32)                 level 3 in structure "dmpr_data_" dcl 1-13
                                                                                  in procedure "dumper" set ref 790* 799 800 841*
volname                         005676 automatic       char(32)                 packed unaligned dcl 729 in procedure "init" set ref
                                                                                  772* 799* 803* 841
vpp                     346            based           pointer                  level 3 dcl 1-13 set ref 197*
wakeup_interval         400            based           fixed bin(71,0)          level 3 dcl 1-13 set ref 476 674 678* 679 833*
was_asleep                      000120 automatic       bit(1)                   packed unaligned dcl 57 set ref 379 824* 825*
yes                       1     003660 automatic       bit(1)                   initial level 2 dcl 75 set ref 75*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
N_Timers                               automatic       fixed bin(17,0)          dcl 5-33
backup_version_1                       internal static fixed bin(17,0)          initial dcl 3-7
backup_volume_header                   based           structure                level 1 dcl 4-5
contents_type                          internal static fixed bin(17,0)          initial dcl 4-21
dir_type                               internal static fixed bin(17,0)          initial dcl 4-16
hdp                                    automatic       pointer                  dcl 4-3
info_type                              internal static fixed bin(17,0)          initial dcl 4-22
null_type                              internal static fixed bin(17,0)          initial dcl 4-18
pattern1                               internal static bit(36)                  initial packed unaligned dcl 4-24
pattern2                               internal static bit(36)                  initial packed unaligned dcl 4-25
pattern3                               internal static bit(36)                  initial packed unaligned dcl 4-26
prev_output_log_type                   internal static fixed bin(17,0)          initial dcl 4-20
seg_type                               internal static fixed bin(17,0)          initial dcl 4-17
timer_manager_schedule_version_1       internal static fixed bin(17,0)          initial dcl 5-33
timer_manager_schedule_version_2       internal static fixed bin(17,0)          initial dcl 5-33
timer_manager_schedule_version_3       internal static fixed bin(17,0)          initial dcl 5-33
volume_log_type                        internal static fixed bin(17,0)          initial dcl 4-19
vtoce_type                             internal static fixed bin(17,0)          initial dcl 4-15

NAMES DECLARED BY EXPLICIT CONTEXT.
UNMASK_EV                       006460 constant        label                    dcl 602 ref 537 542 549 557 567 576 582 594 641 645
                                                                                  651 656 661 669 684 689
badint                          007054 constant        label                    dcl 660 ref 663
begin_vol_dump                  004161 constant        label                    dcl 376 ref 329
complete_volume_dump            001644 constant        entry                    external dcl 164
consolidated_volume_dump        001623 constant        entry                    external dcl 159
dumper                          001575 constant        entry                    external dcl 46
end_volume_dump                 005440 constant        entry                    external dcl 497 ref 170 170
finale                          005523 constant        label                    dcl 507 ref 177 182 188 194 202 210 221 229 234 240
                                                                                  245 252 258 311 334 404 458 490 737 751 757 763
                                                                                  814 821
finale_nocleanup                005532 constant        label                    dcl 509 ref 742 875 879 884
incremental_volume_dump         001605 constant        entry                    external dcl 154
init                            007527 constant        entry                    internal dcl 725 ref 156 161 166
lock_dmpr_data                  011326 constant        entry                    internal dcl 864 ref 775 789
new_control                     010310 constant        label                    dcl 768 set ref 786
no_dump                         003146 constant        label                    dcl 277
over                            003367 constant        label                    dcl 304 ref 269
preattach_dump_volumes          005534 constant        entry                    external dcl 516
read_line                       003524 constant        label                    dcl 325 ref 345 364 368
restart_volume_dump             003210 constant        entry                    external dcl 285 ref 242 242
set_volume_wakeup_interval      006476 constant        entry                    external dcl 614
start                           001660 constant        label                    dcl 168 ref 157 162
time_now_                       011277 constant        entry                    internal dcl 853 ref 302 302 469 469
trace_join                      007364 constant        label                    dcl 707 ref 699
volume_dump_trace_off           007351 constant        entry                    external dcl 703
volume_dump_trace_on            007334 constant        entry                    external dcl 695
wakeup_volume_dump              003133 constant        entry                    external dcl 275

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     13024       13214   11761       13034
Length     14016   11761       170         565    1043           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
dumper                             3620 external procedure  is an external procedure.  
on unit on line 173                  68 on unit               
on unit on line 174                  68 on unit               
on unit on line 585                  68 on unit               
on unit on line 632                  68 on unit               
init                                    internal procedure  shares stack frame of external procedure dumper.  
time_now_                               internal procedure  shares stack frame of external procedure dumper.  
lock_dmpr_data                          internal procedure  shares stack frame of external procedure dumper.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
dumper                   000100 tp                          dumper
                         000110 dump_control_name           dumper
                         000120 was_asleep                  dumper
                         000121 YES                         dumper
                         000122 dmpr_data_already_locked    dumper
                         000123 new_control_seg             dumper
                         000124 trace                       dumper
                         000125 mname                       dumper
                         000133 cycle_uid                   dumper
                         000134 ignored_lvid                dumper
                         000136 answer                      dumper
                         000140 ac                          dumper
                         000141 argl                        dumper
                         000142 narg                        dumper
                         000143 nelemt                      dumper
                         000144 idx                         dumper
                         000145 num_pv                      dumper
                         000146 first_pvx                   dumper
                         000147 nvols                       dumper
                         000150 tnpv                        dumper
                         000151 control_seg_name            dumper
                         000162 areap                       dumper
                         000164 argp                        dumper
                         000166 line                        dumper
                         000224 tlvname                     dumper
                         000234 lvname                      dumper
                         001674 pvname                      dumper
                         003334 time_string                 dumper
                         003342 pvid                        dumper
                         003506 device_type                 dumper
                         003652 old_time                    dumper
                         003654 time_pass_started           dumper
                         003656 code                        dumper
                         003657 ignore                      dumper
                         003660 query_info                  dumper
                         003665 pva                         dumper
                         005652 i                           dumper
                         005654 my_interval                 dumper
                         005656 inputp                      dumper
                         005660 schedule_ptr                dumper
                         005676 volname                     init
                         005706 pvname                      init
                         005716 prev_volname                init
                         005726 dir_rec                     init
                         005727 dir_num                     init
                         005730 seg_num                     init
                         005731 seg_rec                     init

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_g_a               r_e_as              alloc_char_temp     call_ext_out_desc   call_ext_out        return_mac
mpfx2               enable_op           shorten_stack       ext_entry           int_entry           any_to_any_truncate_
op_freen_           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
add_epilogue_handler_         com_err_                      command_query_                command_query_$yes_no
cu_$arg_count                 cu_$arg_list_ptr              cu_$arg_ptr                   cv_dec_check_
date_time_                    dmpr_arg_reader_              dmpr_finish_                  dmpr_info_
dmpr_output_$end_pass_detach  dmpr_output_$init             dmpr_output_$preattach_ioname dmpr_output_$preattach_vols
dmpr_report_$error_output     dmpr_report_$online_output    dump_volume_                  get_system_free_area_
get_temp_segments_            get_wdir_                     hc_backup_$init_dmpr          hcs_$force_write
hcs_$make_seg                 hcs_$set_256K_switch          hcs_$status_minf              ioa_$rsnnl
iox_$attach_ioname            iox_$control                  iox_$get_line                 iox_$open
iox_$position                 ipc_$create_ev_chn            ipc_$decl_ev_call_chn         ipc_$mask_ev_calls
ipc_$unmask_ev_calls          manage_volume_pool_$set_pool_path                           mdc_$check_mounted
mdc_$lvname_info              mdc_$pvname_info              purge_volume_log_             set_lock_$lock
suffixed_name_$make           timer_manager_$alarm_wakeup   timer_manager_$get_schedule
timer_manager_$reset_alarm_wakeup

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
dmprp                         error_table_$action_not_performed                           error_table_$bad_arg
error_table_$bad_conversion   error_table_$end_of_info      error_table_$inconsistent
error_table_$invalid_lock_reset                             error_table_$wrong_no_of_args iox_$user_io




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     75 001564        46 001574       154 001603       156 001613       157 001621       159 001622       161 001631
    162 001642       164 001643       166 001652       168 001660       170 001664       171 001700       173 001730
    174 001754       175 002000       176 002007       177 002020       179 002022       180 002041       181 002043
    182 002070       184 002071       185 002076       186 002106       188 002131       191 002132       192 002142
    193 002144       194 002167       196 002170       197 002173       200 002251       201 002254       202 002302
    207 002303       208 002326       209 002330       210 002361       213 002362       214 002367       215 002373
    216 002377       218 002403       219 002411       220 002413       221 002444       224 002445       225 002506
    226 002510       229 002544       231 002545       232 002570       233 002572       234 002626       236 002627
    237 002635       238 002645       239 002647       240 002675       242 002676       243 002727       244 002731
    245 002757       249 002760       250 002775       251 002777       252 003030       254 003031       255 003040
    256 003042       258 003072       261 003073       262 003100       263 003102       264 003106       265 003113
    266 003120       267 003125       268 003127       269 003131       275 003132       276 003141       277 003146
    278 003200       280 003201       285 003206       287 003216       288 003223       289 003255       291 003256
    292 003263       294 003307       297 003310       298 003316       299 003323       300 003325       301 003326
    302 003327       304 003367       307 003371       308 003413       309 003415       311 003451       314 003452
    315 003453       316 003470       317 003504       318 003514       325 003524       327 003527       328 003554
    329 003556       331 003561       334 003614       338 003615       339 003622       340 003634       341 003652
    342 003701       343 003703       345 003734       347 003735       348 003745       349 003754       350 003764
    351 003766       352 003770       353 003772       354 003774       355 003775       356 004001       357 004002
    358 004024       360 004060       361 004062       363 004116       364 004120       366 004121       367 004122
    368 004160       376 004161       378 004165       379 004167       383 004212       384 004214       385 004217
    387 004246       388 004247       389 004252       391 004311       395 004324       396 004333       398 004350
    399 004370       400 004372       401 004375       404 004427       406 004430       407 004431       408 004432
    411 004444       412 004453       413 004460       414 004465       415 004471       416 004505       417 004507
    419 004540       420 004552       421 004553       422 004554       423 004556       425 004557       426 004565
    428 004577       430 004635       431 004644       432 004646       440 004720       449 004762       451 004776
    453 005037       457 005072       458 005073       460 005075       464 005131       467 005133       469 005141
    472 005176       473 005204       474 005236       476 005252       478 005274       479 005326       480 005356
    482 005411       483 005416       484 005420       485 005423       488 005435       490 005436       497 005437
    499 005446       500 005453       501 005507       503 005510       504 005515       505 005517       506 005521
    507 005523       509 005532       516 005533       528 005542       529 005551       530 005553       531 005605
    534 005606       535 005613       537 005645       540 005646       541 005653       542 005705       545 005706
    546 005714       547 005717       549 005751       551 005752       552 005760       557 006025       561 006035
    562 006053       563 006067       565 006102       566 006104       567 006137       571 006140       573 006155
    576 006215       578 006216       581 006217       582 006257       585 006260       586 006274       587 006276
    588 006301       589 006310       590 006311       592 006312       594 006333       595 006335       599 006425
    601 006451       602 006460       604 006461       605 006464       606 006473       607 006474       614 006475
    625 006504       626 006513       627 006515       628 006544       630 006545       631 006550       632 006557
    633 006573       634 006606       635 006610       636 006613       637 006622       638 006623       639 006624
    640 006631       641 006663       643 006664       644 006671       645 006720       647 006721       648 006727
    649 006732       651 006761       653 006762       654 007001       655 007003       656 007023       658 007024
    659 007052       660 007054       661 007104       663 007105       665 007115       666 007121       667 007134
    668 007136       669 007165       671 007166       672 007177       674 007210       676 007214       678 007222
    679 007227       681 007245       683 007260       684 007266       686 007267       687 007274       688 007324
    689 007332       695 007333       697 007342       698 007344       699 007347       703 007350       704 007357
    705 007362       707 007364       711 007421       712 007427       714 007456       716 007521       718 007526
    725 007527       734 007540       735 007547       736 007552       737 007600       739 007601       740 007606
    742 007644       744 007645       745 007655       746 007672       747 007700       748 007720       749 007722
    751 007750       753 007751       754 010003       755 010005       757 010042       759 010043       760 010113
    761 010115       763 010165       765 010166       766 010235       767 010306       768 010310       770 010356
    771 010360       772 010364       773 010375       774 010404       775 010410       776 010411       777 010412
    778 010417       779 010420       780 010424       781 010426       782 010430       783 010432       785 010433
    786 010461       789 010462       790 010463       797 010541       798 010546       799 010551       800 010554
    801 010557       803 010560       804 010563       806 010566       807 010571       808 010573       809 010575
    810 010577       811 010601       813 010602       814 010627       817 010630       818 010632       819 010637
    821 010665       823 010666       824 010777       825 011012       826 011013       827 011103       828 011135
    829 011136       830 011220       831 011227       832 011231       833 011233       834 011235       835 011237
    836 011241       837 011242       838 011244       839 011247       840 011254       841 011257       842 011262
    843 011265       844 011267       845 011271       846 011273       847 011275       848 011276       853 011277
    857 011301       858 011320       864 011326       865 011327       866 011344       867 011346       868 011351
    869 011352       870 011354       872 011355       873 011362       875 011406       877 011407       878 011412
    879 011436       882 011437       884 011462       887 011463       888 011464       889 011465


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
