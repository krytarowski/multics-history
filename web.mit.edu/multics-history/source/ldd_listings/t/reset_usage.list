	COMPILATION LISTING OF SEGMENT reset_usage
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/13/88  1020.8 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 
       13 
       14 
       15 /****^  HISTORY COMMENTS:
       16*  1) change(86-09-26,Parisek), approve(87-06-17,MCR7570),
       17*     audit(87-06-15,Hirneisen), install(87-08-06,MR12.1-1066):
       18*     Free renamed projects (state = 3) in the SAT also.
       19*                                                   END HISTORY COMMENTS */
       20 
       21 
       22 
       23 /* format: style5,ind5 */
       24 
       25 reset_usage:
       26      procedure () options (variable);
       27 
       28 /**** This program substracts the resource usage in the saved admin
       29*      copy of the PDTs (copied via the crank) from the resource usage
       30*      figures in the real, live copy of the corresponding PDT.
       31*
       32*      This program MODIFIES the system copy of the PDTs and in the case
       33*      of delete projects, the SAT as well.
       34*
       35*      This program takes four arguments:
       36*
       37*      1) pathname of system copy of the SAT
       38*      2) pathname of system copy of the directory containing PDTs
       39*      3) pathname of the admin copy of the SAT (not used)
       40*      4) pathname of the admin copy of the directory containing PDTs. */
       41 
       42 /* Written by Janice B. Phillipps, April 14, 1972
       43*   Revised 8/3/72 J. Phillipps
       44*   Modified by R. McDonald May 1980 to include page charges
       45*   Modified 1894-07-11 BIM for cleanup handler!
       46*   Modified 1984-10-31 by E. Swenson to not attempt to terminate PDTs
       47*   that were not initiated.  Also use current declaration of external
       48*   entries.
       49*   Modified 1985-04-10 by E. Swenson to work if a user has been added to
       50*   the PDT after the crank has copied the PDTs.  Also re-written to use
       51*   modern programming techniques and routines.  Fixed cleanup handler
       52*   introduced above.
       53**/
       54 
       55 /* Automatic */
       56 
       57      dcl	   argument_lth	       fixed bin (21);
       58      dcl	   argument_ptr	       ptr;
       59      dcl	   code		       fixed bin (35);
       60      dcl	   cpdt_dir	       char (168);	      /* location of admin copy of PDTs */
       61      dcl	   n_arguments	       fixed bin;
       62      dcl	   pdt_dir	       char (168);	      /* location of system copy of PDTs */
       63      dcl	   pdt_name	       char (32);	      /* entryname of the pdt directory */
       64      dcl	   sat_dir	       char (168);	      /* location of system copy of sat */
       65      dcl	   sat_name	       char (32);	      /* entryname of the sat */
       66      dcl	   sci_ptr	       ptr;	      /* pointer to subsystem invocation */
       67      dcl	   sp		       ptr;
       68      dcl	   cp		       ptr;
       69      dcl	   cpdtp		       ptr;
       70      dcl	   pdtp		       ptr;
       71      dcl	   pdtep		       ptr;
       72      dcl	   satp		       ptr;
       73      dcl	   satep		       ptr;
       74      dcl	   (i, j, k, kk)	       fixed bin;
       75      dcl	   delta		       fixed bin;
       76      dcl	   doubledelta	       fixed bin (71);
       77      dcl	   current_time	       fixed bin (71);    /* time of this PDT update */
       78      dcl	   deltafloat	       float bin;
       79      dcl	   twodays	       fixed bin (35) int static
       80 			       init (2880000000);
       81      dcl	   baderrct	       fixed bin;
       82      dcl	   locked_pdtep	       pointer;
       83 
       84 /* Based */
       85 
       86      dcl	   argument	       char (argument_lth) based (argument_ptr);
       87 
       88 /* Conditions */
       89 
       90      dcl	   cleanup	       condition;
       91 
       92 /* Builtin */
       93 
       94      dcl	   addr		       builtin;
       95      dcl	   clock		       builtin;
       96      dcl	   null		       builtin;
       97      dcl	   unspec		       builtin;
       98 
       99 /* Constant */
      100 
      101      dcl	   ME		       char (32) initial ("reset_usage")
      102 			       internal static options (constant);
      103 
      104 /* External Entries */
      105 
      106      dcl	   absolute_pathname_      entry (char (*), char (*), fixed bin (35));
      107      dcl	   com_err_	       entry () options (variable);
      108      dcl	   cu_$arg_list_ptr	       entry () returns (ptr);
      109      dcl	   delete_$path	       entry (char (*), char (*),
      110 			       bit (36) aligned, char (*), fixed bin (35))
      111 			       ;
      112      dcl	   expand_pathname_	       entry (char (*), char (*), char (*),
      113 			       fixed bin (35));
      114      dcl	   get_lock_id_	       entry returns (bit (36) aligned);
      115      dcl	   initiate_file_	       entry (char (*), char (*), bit (*), ptr,
      116 			       fixed bin (24), fixed bin (35));
      117      dcl	   ioa_$rsnnl	       entry options (variable);
      118      dcl	   pathname_	       entry (char (*), char (*))
      119 			       returns (char (168));
      120      dcl	   ssu_$abort_line	       entry () options (variable);
      121      dcl	   ssu_$arg_count	       entry (ptr, fixed bin);
      122      dcl	   ssu_$arg_ptr	       entry (ptr, fixed bin, ptr, fixed bin (21))
      123 			       ;
      124      dcl	   ssu_$destroy_invocation entry (ptr);
      125      dcl	   ssu_$print_message      entry () options (variable);
      126      dcl	   ssu_$standalone_invocation
      127 			       entry (ptr, char (*), char (*), ptr, entry,
      128 			       fixed bin (35));
      129      dcl	   set_lock_$lock	       entry (bit (36) aligned, fixed bin,
      130 			       fixed bin (35));
      131      dcl	   set_lock_$unlock	       entry (bit (36) aligned, fixed bin (35));
      132      dcl	   terminate_file_	       entry (ptr, fixed bin (24), bit (*),
      133 			       fixed bin (35));
      134 
      135 /* External Static */
      136 
      137      dcl	   error_table_$lock_wait_time_exceeded
      138 			       fixed bin ext;
      139 
      140 
      141 /* Program */
      142 
      143      sci_ptr = null ();
      144      locked_pdtep = null ();
      145      satp = null ();
      146      pdtp = null ();
      147      cpdtp = null ();
      148 
      149      on condition (cleanup) call CLEAN_UP ();
      150 
      151      call ssu_$standalone_invocation (sci_ptr, ME, "1.0", cu_$arg_list_ptr (),
      152          SSU_ABORT, code);
      153      if code ^= 0 then
      154 	do;
      155 	call com_err_ (code, ME, "Unable to create subsystem invocation.");
      156 	return;
      157 	end;
      158 
      159      call PROCESS_ARGUMENTS ();
      160 
      161      current_time = clock ();			      /* get time for PDT time_last_update */
      162 
      163 /**** Set up delete_options structure in case we need it for delete_. */
      164 
      165      unspec (delete_options) = ""b;
      166      delete_options.force = "1"b;		      /* ignore safety switch */
      167      delete_options.segment = "1"b;		      /* pdts are segments */
      168      delete_options.raw = "1"b;		      /* use hcs_ to delete, not fs_util_ */
      169 
      170 /**** Loop through all the projects in the SAT. */
      171 
      172      do i = 1 to satp -> sat.current_size;
      173 	satep = addr (satp -> sat.project (i));	      /* locate a PDT */
      174 	call ioa_$rsnnl ("^a.pdt", pdt_name, kk, satep -> project.project_id);
      175 	call PROCESS_PROJECT ();
      176      end;
      177 
      178 ABORT_LABEL:
      179      call CLEAN_UP ();
      180      return;
      181 
      182 PROCESS_ARGUMENTS:
      183      procedure ();
      184 
      185 /**** This internal procedure processes the arguments of reset_usage.  It
      186*      ensures that all required arguments are present and initiates the
      187*      system copy of the sat. */
      188 
      189      call ssu_$arg_count (sci_ptr, n_arguments);
      190      if n_arguments ^= 4 then
      191 	call ssu_$abort_line (sci_ptr, 0,
      192 	    "Usage: ^a system_sat system_pdt_dir admin_sat_copy admin_pdt_copy_dir",
      193 	    ME);
      194 
      195      call ssu_$arg_ptr (sci_ptr, 1, argument_ptr, argument_lth);
      196      call expand_pathname_ (argument, sat_dir, sat_name, code);
      197      if code ^= 0 then
      198 	call ssu_$abort_line (sci_ptr, code, "^a", argument);
      199 
      200      call ssu_$arg_ptr (sci_ptr, 2, argument_ptr, argument_lth);
      201      call absolute_pathname_ (argument, pdt_dir, code);
      202      if code ^= 0 then
      203 	call ssu_$abort_line (sci_ptr, code, "^a", argument);
      204 
      205 /**** Note that we do not use the admin copy of the SAT.  For
      206*      compatibility, we do not change the calling sequence. */
      207 
      208      call ssu_$arg_ptr (sci_ptr, 4, argument_ptr, argument_lth);
      209      call absolute_pathname_ (argument, cpdt_dir, code);
      210      if code ^= 0 then
      211 	call ssu_$abort_line (sci_ptr, code, "^a", argument);
      212 
      213 /**** Now initiate the system copy of the SAT. */
      214 
      215      call initiate_file_ (sat_dir, sat_name, RW_ACCESS, satp, (0), code);
      216      if code ^= 0 then
      217 	call ssu_$abort_line (sci_ptr, code, "^a",
      218 	    pathname_ (sat_dir, sat_name));
      219 
      220      end PROCESS_ARGUMENTS;
      221 
      222 PROCESS_PROJECT:
      223      procedure ();
      224 
      225      if satep -> project.state = 1 then
      226 	do;				      /* if project active */
      227 /**** Initiate admin copy of PDT. */
      228 
      229 	call initiate_file_ (cpdt_dir, pdt_name, R_ACCESS, cpdtp, (0), code);
      230 	if code ^= 0 then
      231 PDT_INIT_ERROR:
      232 	     do;
      233 	     call ssu_$print_message (sci_ptr, 0, "Could not initiate ^a.",
      234 	         pathname_ (cpdt_dir, pdt_name));
      235 	     return;			      /* skip this PDT entry */
      236 	     end;
      237 
      238 	call initiate_file_ (pdt_dir, pdt_name, RW_ACCESS, pdtp, (0), code);
      239 	if code ^= 0 then
      240 	     do;
      241 	     call terminate_file_ (cpdtp, 0, TERM_FILE_TERM, (0));
      242 	     goto PDT_INIT_ERROR;
      243 	     end;
      244 
      245 /**** Now go through each entry in the PDT. */
      246 
      247 	do j = 1 to pdtp -> pdt.current_size;	      /* loop thru each PDT to reset all users */
      248 
      249 /**** The following check ensures that the system PDT entry we are examining
      250*      has not been added since the PDT copy was made.  Actually, another
      251*      check in PROCESS_USER makes another check for the same reason */
      252 
      253 	     if j ^> cpdtp -> pdt.current_size then
      254 		do;
      255 		sp = addr (pdtp -> pdt.user (j));   /* system copy of PDT */
      256 		cp = addr (cpdtp -> pdt.user (j));  /* admin copy of PDT */
      257 		call PROCESS_USER ();
      258 		end;
      259 	end;
      260 
      261 	if pdtp ^= null () then
      262 	     call terminate_file_ (pdtp, 0, TERM_FILE_TERM, (0));
      263 	if cpdtp ^= null () then
      264 	     call terminate_file_ (cpdtp, 0, TERM_FILE_TERM, (0));
      265 	end;
      266      else if satep -> project.state = 2 | satep -> project.state = 3 then
      267 	do;
      268 	satep -> project.state = 0;		      /* free slot of deleted project */
      269 	satep -> project.chain = satp -> sat.freep;
      270 	satp -> sat.freep = i;		      /* index of free slot on chain */
      271 					      /* threaded slot of deleted project on free list */
      272 	call delete_$path (pdt_dir, pdt_name, unspec (delete_options), ME,
      273 	    (0));
      274 	end;
      275      else if satep -> project.state = 0 then	      /* no project here */
      276 	;
      277      else
      278 	do;				      /* Well what is it then? */
      279 	call ssu_$print_message (sci_ptr, 0,
      280 	    "project.state (^d) invalid for project ^a", project.state,
      281 	    project.project_id);
      282 	end;
      283      return;
      284 
      285      end PROCESS_PROJECT;
      286 
      287 PROCESS_USER:
      288      procedure ();
      289 
      290      if sp -> user.state = 0 then
      291 	;				      /* state = 0, no user entry */
      292      else if sp -> user.state = 1 then
      293 	do;				      /* user active -- subtract usage */
      294 /**** But first, some consistency checks */
      295 	if cp -> user.state = 0 then		      /* person added after copy */
      296 	     return;			      /* no usage since he is new */
      297 	if sp -> user.person_id ^= cp -> user.person_id then
      298 	     do;
      299 	     call ssu_$print_message (sci_ptr, 0,
      300 	         "Admin copy of ^a is out of phase with system copy.  System copy = ^a, Admin copy = ^a.",
      301 	         satep -> project.project_id, sp -> user.person_id,
      302 	         cp -> user.person_id);
      303 	     return;
      304 	     end;
      305 
      306 	baderrct = 0;			      /* no errors yet */
      307 
      308 	call RESET_USER_USAGE ();
      309 
      310 	if baderrct > 0 then		      /* any errors? */
      311 	     do;
      312 	     call ssu_$print_message (sci_ptr, 0,
      313 	         "Warning:  Encountered a negative delta for user ^a on project ^a.",
      314 	         sp -> user.person_id, satep -> project.project_id);
      315 	     end;
      316 	end;
      317       else if sp -> user.state = 2 then
      318 	do;				      /* user deleted -- add entry to free chain */
      319 	sp -> user.state = 0;		      /* make entry unused */
      320 	sp -> user.chain = pdtp -> pdt.freep;	      /* add to free chain */
      321 	pdtp -> pdt.freep = j;		      /* index of freed slot on chain */
      322 	end;
      323      else					      /* invalid state */
      324 	call ssu_$print_message (sci_ptr, 0,
      325 	    "Warning: Invalid state (^d) for user ^a on project ^a.",
      326 	    sp -> user.state, sp -> user.person_id,
      327 	    satep -> project.project_id);
      328 
      329      return;
      330 
      331      end PROCESS_USER;
      332 
      333 RESET_USER_USAGE:
      334      procedure ();
      335 
      336      call LOCK_PDT ();
      337      if code ^= 0 then
      338 	return;				      /* message already printed */
      339 
      340      if (current_time - sp -> user.time_last_reset < twodays) then
      341 	do;
      342 	call ssu_$print_message (sci_ptr, code,
      343 	    "Warning: PDT usage has been reset within the last two days.  Skipping user ^a on project ^a.",
      344 	    sp -> user.person_id, satep -> project.project_id);
      345 	call UNLOCK_PDT ();
      346 	return;
      347 	end;
      348 
      349      deltafloat = sp -> user.dollar_charge - cp -> user.dollar_charge;
      350 					      /* total user charge */
      351      if deltafloat >= 0 then
      352 	sp -> user.dollar_charge = deltafloat;
      353      else
      354 	baderrct = baderrct + 1;
      355 
      356      delta = sp -> user.logins - cp -> user.logins;
      357      if delta >= 0 then
      358 	sp -> user.logins = delta;		      /* number of logins */
      359      else
      360 	baderrct = baderrct + 1;
      361 
      362      delta = sp -> user.crashes - cp -> user.crashes;   /* sessions abnormally terminated */
      363      if delta >= 0 then
      364 	sp -> user.crashes = delta;
      365      else
      366 	baderrct = baderrct + 1;
      367 
      368      do k = 0 to 7;				      /* interactive use shifts 0 - 7 */
      369 	deltafloat =
      370 	    sp -> user.interactive.charge (k)
      371 	    - cp -> user.interactive.charge (k);
      372 	if deltafloat >= 0e0 then
      373 	     sp -> user.interactive.charge (k) = deltafloat;
      374 					      /* total dollar charge this shift */
      375 	else
      376 	     baderrct = baderrct + 1;
      377 
      378 	doubledelta =
      379 	    sp -> user.interactive.cpu (k) - cp -> user.interactive.cpu (k);
      380 	if doubledelta >= 0 then
      381 	     sp -> user.interactive.cpu (k) = doubledelta;
      382 					      /* cpu usage in microseconds */
      383 	else
      384 	     baderrct = baderrct + 1;
      385 
      386 	doubledelta =
      387 	    sp -> user.interactive.core (k) - cp -> user.interactive.core (k);
      388 	if doubledelta >= 0 then
      389 	     sp -> user.interactive.core (k) = doubledelta;
      390 	else
      391 	     baderrct = baderrct + 1;
      392 
      393 	doubledelta =
      394 	    sp -> user.interactive.connect (k)
      395 	    - cp -> user.interactive.connect (k);
      396 	if doubledelta >= 0 then
      397 	     sp -> user.interactive.connect (k) = doubledelta;
      398 					      /* total console time in microseconds */
      399 	else
      400 	     baderrct = baderrct + 1;
      401 
      402 	doubledelta =
      403 	    sp -> user.interactive.io_ops (k)
      404 	    - cp -> user.interactive.io_ops (k);
      405 	if doubledelta >= 0 then
      406 	     sp -> user.interactive.io_ops (k) = doubledelta;
      407 					      /* total io_ops time in microsecs */
      408 	else
      409 	     baderrct = baderrct + 1;
      410 
      411      end;					      /* end processing interactive usage */
      412 
      413      do k = 1 to 4;				      /* absentee use of queues 1 - 4 */
      414 	deltafloat =
      415 	    sp -> user.absentee.charge (k) - cp -> user.absentee.charge (k);
      416 	if deltafloat >= 0 then
      417 	     sp -> user.absentee.charge (k) = deltafloat;
      418 					      /* dollar charge this queue */
      419 	else
      420 	     baderrct = baderrct + 1;
      421 
      422 	delta = sp -> user.absentee.jobs (k) - cp -> user.absentee.jobs (k);
      423 					      /* jobs submitted */
      424 	if delta >= 0 then
      425 	     sp -> user.absentee.jobs (k) = delta;
      426 	else
      427 	     baderrct = baderrct + 1;
      428 
      429 	doubledelta =
      430 	    sp -> user.absentee.cpu (k) - cp -> user.absentee.cpu (k);
      431 					      /*  usecs */
      432 	if doubledelta >= 0 then
      433 	     sp -> user.absentee.cpu (k) = doubledelta;
      434 	else
      435 	     baderrct = baderrct + 1;
      436 
      437 	doubledelta =
      438 	    sp -> user.absentee.memory (k) - cp -> user.absentee.memory (k);
      439 	if doubledelta >= 0 then
      440 	     sp -> user.absentee.memory (k) = doubledelta;
      441 	else
      442 	     baderrct = baderrct + 1;
      443 
      444      end;					      /* end processing absentee usage */
      445 
      446 /**** Process I/O daemon queue use */
      447 
      448      do k = 1 to 4;				      /* io daemon use queues 1 - 4 */
      449 	deltafloat = sp -> user.iod.charge (k) - cp -> user.iod.charge (k);
      450 					      /* $ charge this queue */
      451 	if deltafloat >= 0e0 then
      452 	     sp -> user.iod.charge (k) = deltafloat;
      453 	else
      454 	     baderrct = baderrct + 1;
      455 
      456 	delta = sp -> user.iod.pieces (k) - cp -> user.iod.pieces (k);
      457 	if delta >= 0 then
      458 	     sp -> user.iod.pieces (k) = delta;
      459 	else
      460 	     baderrct = baderrct + 1;
      461 
      462 	doubledelta = sp -> user.iod.pages (k) - cp -> user.iod.pages (k);
      463 	if doubledelta >= 0 then
      464 	     sp -> user.iod.pages (k) = doubledelta;
      465 	else
      466 	     baderrct = baderrct + 1;
      467 
      468 	doubledelta = sp -> user.iod.lines (k) - cp -> user.iod.lines (k);
      469 	if doubledelta >= 0 then
      470 	     sp -> user.iod.lines (k) = doubledelta;
      471 	else
      472 	     baderrct = baderrct + 1;
      473 
      474      end;					      /* end processing io daemon queues */
      475 
      476 /**** Process device charges */
      477 
      478      do k = 1 to 16;			      /* device charges */
      479 	deltafloat = sp -> user.devices (k) - cp -> user.devices (k);
      480 	if deltafloat >= 0 then
      481 	     sp -> user.devices (k) = deltafloat;
      482 	else
      483 	     baderrct = baderrct + 1;
      484      end;					      /* end processing device charges */
      485 
      486 
      487 /**** Update last reset time in PDT entry */
      488      sp -> user.time_last_reset = current_time;
      489 
      490      call UNLOCK_PDT ();
      491      return;
      492 
      493      end RESET_USER_USAGE;
      494 
      495 LOCK_PDT:
      496      procedure ();
      497 
      498      locked_pdtep = sp;
      499      call set_lock_$lock (sp -> user.lock, 600, code);  /* lock data base while resetting */
      500      if code = error_table_$lock_wait_time_exceeded then
      501 	call ssu_$print_message (sci_ptr, code,
      502 	    "The PDTE entry for ^a on project ^a is locked.  Continuing onto next user.",
      503 	    sp -> user.person_id, satep -> project.project_id);
      504      return;
      505      end LOCK_PDT;
      506 
      507 UNLOCK_PDT:
      508      procedure ();
      509 
      510      call set_lock_$unlock (sp -> user.lock, code);
      511      locked_pdtep = null ();
      512      return;
      513      end UNLOCK_PDT;
      514 
      515 SSU_ABORT:
      516      procedure ();
      517 
      518      goto ABORT_LABEL;
      519      end SSU_ABORT;
      520 
      521 CLEAN_UP:
      522      procedure ();
      523 
      524      if locked_pdtep ^= null () then
      525 	do;
      526 	if locked_pdtep -> user.lock = get_lock_id_ () then
      527 	     call set_lock_$unlock (locked_pdtep -> user.lock, (0));
      528 	locked_pdtep = null ();
      529 	end;
      530 
      531 /**** Note that terminate_file_ returns if ptr is null. */
      532 
      533      call terminate_file_ (pdtp, 0, TERM_FILE_TERM, (0));
      534      call terminate_file_ (cpdtp, 0, TERM_FILE_TERM, (0));
      535      call terminate_file_ (satp, 0, TERM_FILE_TERM, (0));
      536 
      537      if sci_ptr ^= null () then
      538 	call ssu_$destroy_invocation (sci_ptr);
      539      return;
      540 
      541      end CLEAN_UP;
      542 
      543 
      544 /* format: off */
      545  /* BEGIN INCLUDE FILE ... access_mode_values.incl.pl1
  1     2*
  1     3*   Values for the "access mode" argument so often used in hardcore
  1     4*   James R. Davis 26 Jan 81  MCR 4844
  1     5*   Added constants for SM access 4/28/82 Jay Pattin
  1     6*   Added text strings 03/19/85 Chris Jones
  1     7**/
  1     8 
  1     9 
  1    10 /* format: style4,delnl,insnl,indattr,ifthen,dclind10 */
  1    11 dcl	(
  1    12 	N_ACCESS		   init ("000"b),
  1    13 	R_ACCESS		   init ("100"b),
  1    14 	E_ACCESS		   init ("010"b),
  1    15 	W_ACCESS		   init ("001"b),
  1    16 	RE_ACCESS		   init ("110"b),
  1    17 	REW_ACCESS	   init ("111"b),
  1    18 	RW_ACCESS		   init ("101"b),
  1    19 	S_ACCESS		   init ("100"b),
  1    20 	M_ACCESS		   init ("010"b),
  1    21 	A_ACCESS		   init ("001"b),
  1    22 	SA_ACCESS		   init ("101"b),
  1    23 	SM_ACCESS		   init ("110"b),
  1    24 	SMA_ACCESS	   init ("111"b)
  1    25 	)		   bit (3) internal static options (constant);
  1    26 
  1    27 /* The following arrays are meant to be accessed by doing either 1) bin (bit_value) or
  1    28*   2) divide (bin_value, 2) to come up with an index into the array. */
  1    29 
  1    30 dcl	SEG_ACCESS_MODE_NAMES  (0:7) init ("null", "W", "E", "EW", "R", "RW", "RE", "REW") char (4) internal
  1    31 			   static options (constant);
  1    32 
  1    33 dcl	DIR_ACCESS_MODE_NAMES  (0:7) init ("null", "A", "M", "MA", "S", "SA", "SM", "SMA") char (4) internal
  1    34 			   static options (constant);
  1    35 
  1    36 dcl	(
  1    37 	N_ACCESS_BIN	   init (00000b),
  1    38 	R_ACCESS_BIN	   init (01000b),
  1    39 	E_ACCESS_BIN	   init (00100b),
  1    40 	W_ACCESS_BIN	   init (00010b),
  1    41 	RW_ACCESS_BIN	   init (01010b),
  1    42 	RE_ACCESS_BIN	   init (01100b),
  1    43 	REW_ACCESS_BIN	   init (01110b),
  1    44 	S_ACCESS_BIN	   init (01000b),
  1    45 	M_ACCESS_BIN	   init (00010b),
  1    46 	A_ACCESS_BIN	   init (00001b),
  1    47 	SA_ACCESS_BIN	   init (01001b),
  1    48 	SM_ACCESS_BIN	   init (01010b),
  1    49 	SMA_ACCESS_BIN	   init (01011b)
  1    50 	)		   fixed bin (5) internal static options (constant);
  1    51 
  1    52 /* END INCLUDE FILE ... access_mode_values.incl.pl1 */
      545 
      546  /* BEGIN INCLUDE FILE:  delete_options.incl.pl1 */
  2     2 
  2     3 /* control flag bit string passed to delete_$path and delete_$ptr
  2     4*
  2     5*   Jay Pattin 6/6/83 */
  2     6 
  2     7 declare   1 delete_options,
  2     8           2 force                       bit (1) unaligned,  /* ON = delete w/o asking is safety switch on */
  2     9           2 question                    bit (1) unaligned,  /* ON = ask user if safety switch on */
  2    10           2 directory                   bit (1) unaligned,  /* ON = delete directories */
  2    11           2 segment                     bit (1) unaligned,  /* ON = delete segments */
  2    12           2 link                        bit (1) unaligned,  /* ON = delete links */
  2    13           2 chase                       bit (1) unaligned,  /* ON = delete through links */
  2    14           2 library                     bit (1) unaligned,  /* ON = use installation_tools_ */
  2    15           2 raw                         bit (1) unaligned,  /* ON = use hcs_, not object_type_ */
  2    16           2 mbz                         bit (28) unaligned;
  2    17 
  2    18 /* END INCLUDE FILE:  delete_options.incl.pl1 */
      546 
      547  /* BEGIN INCLUDE FILE ... pdt.incl.pl1 */
  3     2 /* Requires user_attributes.incl.pl1 */
  3     3 
  3     4 /* Modified 740723 by PG to add AIM info */
  3     5 /* Modified 750604 by T. Casey to add priority scheduler parameters */
  3     6 /* Modified May 1976 by T. Casey to add cutoff warning thresholds and change version to 3 */
  3     7 /* Modified May 1977 by John Gintell to add reqfile, projfile, and SAT to header */
  3     8 /* Modified May 1978 by T. Casey to add pdir_quota to user entry */
  3     9 /* Modified June 1978 by T. Casey to add rel ptr to pdt hash table */
  3    10 /* Modified November 1978 by T. Casey to add max_(fore back)ground, n_(fore back)ground and abs_foreground_cpu_limit */
  3    11 /* Modified October 1979 by T. Casey to add counters for interactive and disconnected processes. */
  3    12 /* Modified Feb 1980 by M. B. Armstrong to implement multiple rate structures (UNCA). */
  3    13 /* Modified May 1980 by R. McDonald to use iod cpu time field for page charging (UNCA) */
  3    14 /* Modified December 1981 by E. N. Kittlitz for user_warn fields */
  3    15 /* Modified January 1982 by E. N. Kittlitz for user_attributes.incl.pl1 changes */
  3    16 /* Modified September 1982 by E. N. Kittlitz for default ring. */
  3    17 /* Modified 1984-07-05 BIM for min authorization, version to 4 */
  3    18 
  3    19 dcl (PDT_version init (4),				/* version of this declaration */
  3    20      PDT_header_lth init (256),			/* length in words of PDT head */
  3    21      PDT_entry_lth init (256),			/* length in words of PDT entry */
  3    22 
  3    23      PDT_project_name_length init (9),			/* proper length of pdt.project_name */
  3    24      PDT_person_id_length init (22)			/* proper length of user.person_id */
  3    25      ) fixed bin internal static options (constant);
  3    26 
  3    27 dcl 1 pdt based (pdtp) aligned,
  3    28 
  4     1 /* BEGIN INCLUDE FILE author.incl.pl1 */
  4     2 
  4     3 /* the "author" items must always be the first ones in the table. The
  4     4*   module which moves the converted table to the System Control process
  4     5*   fills in these data items and assumes them to be at the head of the segment
  4     6*   regardless of the specific table's actual declaration. The variables
  4     7*   "lock" and "last_install_time" used to be "process_id" and "ev_channel"
  4     8*    respectively. For tables installed in multiple processes, these
  4     9*    are to be used to lock out multiple installations. */
  4    10 
  4    11 /*  Lock should be used as a modification lock. Since, in general,
  4    12*    entries may not be moved in system tables, even by installations,
  4    13*    it is sufficient for only installers and programs that change threads
  4    14*    to set or respect the lock. Simply updating data in an entry
  4    15*    requires no such protection.
  4    16*
  4    17*    Last_install_time is used by readers of system tables to detect
  4    18*    installations or other serious modifications. By checking it before
  4    19*    and after copying a block of data, they can be protected against
  4    20*    modifications.
  4    21*
  4    22*    Modules that set the lock should save proc_group_id, and then
  4    23*    put their group id there for the time they hold the lock.
  4    24*    if they do not actually install the, they should restore the group id.
  4    25**/
  4    26 
  4    27     2 author aligned,				/* validation data about table's author */
  4    28       3 proc_group_id char (32),			/* process-group-id  (personid.projectid.tag) */
  4    29       3 lock bit (36),				/* installation lock */
  4    30       3 update_attributes bit (1) unal,			/* update/add/delete attributes */
  4    31       3 update_authorization bit (1) unal,		/* update only authorizations */
  4    32       3 deferral_notified bit (1) unal,			/* installer notified of deferral of installation */
  4    33       3 pad bit (33) unaligned,
  4    34       3 last_install_time fixed bin (71),
  4    35       3 table char (4),				/* name of table, e.g., SAT MGT TTT RTDT PDT etc. */
  4    36       3 w_dir char (64),				/* author's working directory */
  4    37 
  4    38 /* END INCLUDE FILE author.incl.pl1 */
  3    29 
  3    30     2 max_size fixed bin,				/* max number of entries table can grow */
  3    31     2 current_size fixed bin,				/* current size of table (in entries) */
  3    32     2 version fixed bin,				/* table version */
  3    33     2 freep fixed bin,				/* relptr to begin of free chain */
  3    34     2 n_users fixed bin,				/* number of entries actually used */
  3    35     2 project_name char (28),				/* name of project */
  3    36     2 project_dir char (64),				/* treename of project's directory */
  3    37     2 projfile_version fixed bin,
  3    38     2 projentry bit (66*36),
  3    39     2 pad3 (5) bit (36) aligned,
  3    40     2 reqfile_version fixed bin,
  3    41     2 reqentry bit (40*36),
  3    42     2 pad4 (9) fixed bin,
  3    43     2 sat_version fixed bin,
  3    44     2 satentry bit (52*36),				/* everything in sat.project from project.at on */
  3    45     2 pad5 (4) bit (36) aligned,
  3    46     2 date_reqfile_copied fixed bin (71),
  3    47     2 rs_number fixed bin (9) unsigned unaligned,		/* rate structure number, easier than looking in satentry */
  3    48     2 pad2l bit (27) unaligned,
  3    49     2 pad2 (16) fixed bin,				/* make header 256 words long */
  3    50     2 ht_relp fixed bin (18) aligned,			/* if nonzero, pdt has hash table at that loc */
  3    51     2 user (1019) aligned,				/* the project definition table entries */
  3    52       3 pad (256) bit (36) aligned;			/* each entry is 256 words long  */
  3    53 
  3    54 /* The hash table, if there is one, is right after the last user, and is described in hashst.incl.pl1 */
  3    55 
  3    56 
  3    57 
  3    58 dcl 1 user based (pdtep) aligned,			/* declaration of a single PDT entry  */
  3    59     2 state fixed bin,				/* 1 = normal, 2 = deleted 0 = free */
  3    60     2 lock bit (36),				/* update lock */
  3    61     2 person_id char (24) aligned,			/* login name of user */
  3    62     2 now_in fixed bin,				/* count of users logged in on this entry */
  3    63     2 password char (8) aligned,			/* password for anonymous user */
  3    64     2 at like user_attributes aligned,			/* include user_attributes.incl.pl1 */
  3    65     2 initial_procedure char (64) aligned,		/* initproc and subsystem name packed into one string */
  3    66     2 home_dir char (64) aligned,			/* user's default working directory */
  3    67     2 bump_grace fixed bin,				/* number of minutes he is protected */
  3    68     2 high_ring fixed bin,				/* highest ring user may use */
  3    69     2 default_ring fixed bin (17) unal,			/* ring user will start in */
  3    70     2 low_ring fixed bin (17) unal,			/* lowest ring user may use */
  3    71     2 outer_module char (32),				/* outer module used if user is interactive */
  3    72     2 lot_size fixed bin,				/* size of linkage offset table */
  3    73     2 kst_size fixed bin,				/* size of known segment table */
  3    74     2 cls_size fixed bin,				/* size of combined linkage */
  3    75     2 uflags,					/* various flags */
  3    76       3 dont_call_init_admin bit (1) unal,		/* call overseer direct */
  3    77       3 ip_given bit (1) unal,			/* ip_len gives length of initproc packed in initial_procedure */
  3    78       3 ss_given bit (1) unal,			/* subsystem name is packed in initial_procedure */
  3    79       3 flagpad bit (33) unal,
  3    80     2 ip_len fixed bin (17) unal,			/* length of initproc name packed in initial_procedure */
  3    81     2 ss_len fixed bin (17) unal,			/* length of subsystem name packed in initial_procedure */
  3    82     2 dollar_limit float bin,
  3    83     2 dollar_charge float bin,			/* total dollars spent this month */
  3    84     2 shift_limit (0: 7) float bin,
  3    85     2 daton fixed bin (71),				/* date user added to system */
  3    86     2 datof fixed bin (71),				/* date user deleted */
  3    87     2 last_login_time fixed bin (71),			/* time of last login */
  3    88     2 last_login_unit char (4),			/* terminal id last used */
  3    89     2 last_login_type fixed bin (17) unal,		/* terminal type */
  3    90     2 last_login_line_type fixed bin (17) unal,		/* terminal line type */
  3    91     2 time_last_bump fixed bin (71),			/* for bump-wait */
  3    92     2 last_update fixed bin (71),			/* time of last transaction */
  3    93     2 logins fixed bin,				/* number of logins */
  3    94     2 crashes fixed bin,				/* sessions abnormally terminated */
  3    95     2 interactive (0: 7),				/* interactive use, shifts 0-7 */
  3    96       3 charge float bin,				/* total dollar charge this shift */
  3    97       3 xxx fixed bin,
  3    98       3 cpu fixed bin (71),				/* cpu usage in microseconds */
  3    99       3 core fixed bin (71),				/* core demand in page-microseconds */
  3   100       3 connect fixed bin (71),			/* total console time in microseconds */
  3   101       3 io_ops fixed bin (71),			/* total i/o ops on terminal */
  3   102     2 absentee (4),					/* absentee use, queues 1-4 */
  3   103       3 charge float bin,				/* dollar charge this queue */
  3   104       3 jobs fixed bin,				/* number of jobs submitted */
  3   105       3 cpu fixed bin (71),				/* total cpu time in microseconds */
  3   106       3 memory fixed bin (71),			/* total memory demand */
  3   107     2 iod (4),					/* io daemon use, queues 1-4 */
  3   108       3 charge float bin,				/* dollar charge this queue */
  3   109       3 pieces fixed bin,				/* pieces of output requested */
  3   110       3 pad fixed bin (35),
  3   111       3 pages fixed bin (35),				/* number of pages output */
  3   112       3 lines fixed bin (71),				/* total record count of output */
  3   113     2 devices (16) float bin,				/* device charges */
  3   114     2 time_last_reset fixed bin (71),			/* time PDT last updated */
  3   115     2 absolute_limit float bin,			/* Limit, not reset monthly */
  3   116     2 absolute_spent float bin,			/* Spending against this */
  3   117     2 absolute_cutoff fixed bin (71),			/* Spending will be reset on this date */
  3   118     2 absolute_increm fixed bin,			/* .. time increment code. 0 = don't reset */
  3   119     2 pad_was_authorization bit (72) aligned,
  3   120     2 group char (8),				/* group for this user (if at.igroup = "1"b) */
  3   121     2 warn_days fixed bin (17) unaligned,		/* warn user if less than this many days to cutoff */
  3   122     2 warn_pct fixed bin (17) unaligned,		/* warn user if less than this percent of funds left */
  3   123     2 warn_dollars float bin,				/* warn user if less than this amount of funds left */
  3   124     2 n_foreground fixed bin (9) unsigned unaligned,	/* number of foreground and background processes */
  3   125     2 n_background fixed bin (9) unsigned unaligned,	/* that this user has. see limits just below */
  3   126     2 max_foreground fixed bin (9) unsigned unaligned,	/* max simultaneous foreground and */
  3   127     2 max_background fixed bin (9) unsigned unaligned,	/* background processes that this user can have */
  3   128     2 n_interactive fixed bin (9) unsigned unaligned,	/* number of interactive processes that user has */
  3   129     2 n_disconnected fixed bin (9) unsigned unaligned,	/* number of disconnected processes that user has */
  3   130     2 pdtupad1 fixed bin (18) unsigned unaligned,
  3   131     2 user_warn_days fixed bin (17) unaligned,		/* warn user if less than this many days to user cutoff */
  3   132     2 user_warn_pct fixed bin (17) unaligned,		/* warn user if less than this percent of user funds left */
  3   133     2 user_warn_dollars float bin,			/* warn user if less than this amount of user funds left */
  3   134     2 user_authorization (2) bit (72) aligned,		/* range */
  3   135     2 pdtupad (5) fixed bin,
  3   136     2 abs_foreground_cpu_limit fixed bin (17) unaligned,	/* time limit (sec) on foreground absentee jobs */
  3   137     2 pdir_quota fixed bin (17) unaligned,		/* quota to put on user's pdir (0 => use default) */
  3   138     2 chain fixed bin;				/* free chain */
  3   139 
  3   140 /* END INCLUDE FILE ... pdt.incl.pl1 */
      547 
      548  /* BEGIN INCLUDE FILE ... sat.incl.pl1 */
  5     2 
  5     3 
  5     4 
  5     5 
  5     6 /****^  HISTORY COMMENTS:
  5     7*  1) change(86-09-05,Parisek), approve(87-06-17,MCR7570),
  5     8*     audit(87-06-15,Hirneisen), install(87-08-06,MR12.1-1066):
  5     9*     Expand comment line of project.state to include the renamed state (state =
  5    10*     3).
  5    11*                                                   END HISTORY COMMENTS */
  5    12 
  5    13 
  5    14 
  5    15 /* Modified 740723 by PG to add AIM info */
  5    16 /* Modified 750604 by T. Casey to add priority scheduler parameters */
  5    17 /* Modified May 1976 by T. Casey to add project cutoff limits */
  5    18 /* Modified May 1978 by T. Casey to add pdir_quota */
  5    19 /* Modified November 1978 by T. Casey to add max_(fore back)ground and abs_foreground_cpu_limit */
  5    20 /* Modified July 1979 by J. N. R. Barnecut  to support multiple rate structures. (UNCA) */
  5    21 /* Modified January 1982 by E. N. Kittlitz for user_attributes.incl.pl1 changes */
  5    22 /* Modified 1984-07-05 BIM range of authorizations, version 3 */
  5    23 
  5    24 dcl (SAT_version init (3),				/* version 2 of this declaration */
  5    25 
  5    26      SAT_header_lth init (466),			/* length in words of SAT header */
  5    27      SAT_entry_lth init (80), 			/* length in words of SAT entry */
  5    28 
  5    29      SAT_project_name_length init (9)			/* proper length of project.project_id */
  5    30      ) fixed bin internal static options (constant);
  5    31 
  5    32 dcl 1 sat based (satp) aligned,
  5    33 
  6     1 /* BEGIN INCLUDE FILE author.incl.pl1 */
  6     2 
  6     3 /* the "author" items must always be the first ones in the table. The
  6     4*   module which moves the converted table to the System Control process
  6     5*   fills in these data items and assumes them to be at the head of the segment
  6     6*   regardless of the specific table's actual declaration. The variables
  6     7*   "lock" and "last_install_time" used to be "process_id" and "ev_channel"
  6     8*    respectively. For tables installed in multiple processes, these
  6     9*    are to be used to lock out multiple installations. */
  6    10 
  6    11 /*  Lock should be used as a modification lock. Since, in general,
  6    12*    entries may not be moved in system tables, even by installations,
  6    13*    it is sufficient for only installers and programs that change threads
  6    14*    to set or respect the lock. Simply updating data in an entry
  6    15*    requires no such protection.
  6    16*
  6    17*    Last_install_time is used by readers of system tables to detect
  6    18*    installations or other serious modifications. By checking it before
  6    19*    and after copying a block of data, they can be protected against
  6    20*    modifications.
  6    21*
  6    22*    Modules that set the lock should save proc_group_id, and then
  6    23*    put their group id there for the time they hold the lock.
  6    24*    if they do not actually install the, they should restore the group id.
  6    25**/
  6    26 
  6    27     2 author aligned,				/* validation data about table's author */
  6    28       3 proc_group_id char (32),			/* process-group-id  (personid.projectid.tag) */
  6    29       3 lock bit (36),				/* installation lock */
  6    30       3 update_attributes bit (1) unal,			/* update/add/delete attributes */
  6    31       3 update_authorization bit (1) unal,		/* update only authorizations */
  6    32       3 deferral_notified bit (1) unal,			/* installer notified of deferral of installation */
  6    33       3 pad bit (33) unaligned,
  6    34       3 last_install_time fixed bin (71),
  6    35       3 table char (4),				/* name of table, e.g., SAT MGT TTT RTDT PDT etc. */
  6    36       3 w_dir char (64),				/* author's working directory */
  6    37 
  6    38 /* END INCLUDE FILE author.incl.pl1 */
  5    34 
  5    35     2 max_size fixed bin,				/* max number of entries table can grow */
  5    36     2 current_size fixed bin,				/* current size of table  (in entries) */
  5    37     2 version fixed bin,				/* version number of table (word 32) */
  5    38     2 freep fixed bin,				/* free chain ptr. 0 if no free entries */
  5    39     2 n_projects fixed bin,				/* number of entries actually used */
  5    40     2 pad_was_max_users bit (36) aligned,
  5    41     2 max_units fixed bin,				/* maximum number of login-units per session */
  5    42     2 pad_was_max_prim bit (36) aligned,	
  5    43     2 uwt_size fixed bin,				/* size of User Weight Table */
  5    44     2 uwt (24) aligned,				/* User Weight Table */
  5    45       3 initproc char (64) unaligned,			/* user's initial procedure  */
  5    46       3 units fixed bin,				/* weight of initial procedure */
  5    47     2 system_admin (2) char (32) unal,			/* system administrator ID */
  5    48     2 pad1 (4) fixed bin,				/* padding to 466 wds */
  5    49     2 project (3258),				/* The SAT entries. 255K segment. */
  5    50       3 pad (80) fixed bin;				/* each entry is 80 words long  */
  5    51 
  5    52 
  5    53 dcl 1 project based (satep) aligned,			/* declaration of a single SAT entry  */
  5    54     2 state fixed bin,				/* state 1 = normal, 0 = free, 2 = deleted, 3 = renamed */
  5    55     2 project_id char (12) unaligned,			/* project's name */
  5    56     2 project_dir char (64) unaligned,			/* project's directory */
  5    57     2 pdt_ptr pointer,				/* pointer to current PDT */
  5    58     2 max_users fixed bin,				/* maximum number of users from project */
  5    59     2 n_users fixed bin,				/* current number */
  5    60     2 at like user_attributes aligned,			/* include user_attributes.incl.pl1 */
  5    61     2 admin (4) aligned,				/* list of project's administrators  */
  5    62       3 userid char (30) unal,			/* administrator's user-id (personid.projectid) */
  5    63       3 pad char (2) unal,
  5    64     2 cutoff char (1),				/* if project is cut off, why. */
  5    65     2 min_ring fixed bin,				/* lowest ring for project */
  5    66     2 max_ring fixed bin,				/* highest ring for project */
  5    67     2 alias char (8) unal,				/* project alias */
  5    68     2 group char (8) unal,				/* default group for this project */
  5    69     2 grace_max fixed bin,				/* maximum bump grace */
  5    70     2 audit bit (36),				/* audit flags for project */
  5    71     2 project_authorization (2) bit (72),		/* authorization of this project */
  5    72     2 groups (2) char (8) unal,			/* authorized groups for this project */
  5    73     2 days_to_cutoff fixed bin (17) unaligned,		/* these figures are as of last running of daily_summary */
  5    74     2 pct_balance fixed bin (17) unaligned,		/* they are used for warning message printing only */
  5    75     2 dollars_to_cutoff float bin,			/* and are not to be taken as up-to-date figures */
  5    76     2 pdir_quota fixed bin (17) unaligned,		/* max pdir quota allowed for project */
  5    77     2 max_foreground fixed bin (9) unsigned unaligned,	/* max simultaneous foreground and background */
  5    78     2 max_background fixed bin (9) unsigned unaligned,	/* processes that a user on this project can have */
  5    79     2 abs_foreground_cpu_limit fixed bin (17) unaligned,	/* time limit on foreground absentee jobs */
  5    80     2 rs_number fixed bin (9) unsigned unaligned,		/* rate structure number (0=default rates ) */
  5    81     2 satpad1 fixed bin (9) unsigned unaligned,
  5    82     2 satpad (1) bit (36) aligned,			/* pad to 80 words */
  5    83     2 chain fixed bin;				/* if free entry, chain */
  5    84 
  5    85 /* END INCLUDE FILE ... sat.incl.pl1 */
      548 
      549  /* BEGIN INCLUDE FILE ... terminate_file.incl.pl1 */
  7     2 /* format: style2,^inddcls,idind32 */
  7     3 
  7     4 declare 1 terminate_file_switches	based,
  7     5 	2 truncate		bit (1) unaligned,
  7     6 	2 set_bc			bit (1) unaligned,
  7     7 	2 terminate		bit (1) unaligned,
  7     8 	2 force_write		bit (1) unaligned,
  7     9 	2 delete			bit (1) unaligned;
  7    10 
  7    11 declare TERM_FILE_TRUNC		bit (1) internal static options (constant) initial ("1"b);
  7    12 declare TERM_FILE_BC		bit (2) internal static options (constant) initial ("01"b);
  7    13 declare TERM_FILE_TRUNC_BC		bit (2) internal static options (constant) initial ("11"b);
  7    14 declare TERM_FILE_TERM		bit (3) internal static options (constant) initial ("001"b);
  7    15 declare TERM_FILE_TRUNC_BC_TERM	bit (3) internal static options (constant) initial ("111"b);
  7    16 declare TERM_FILE_FORCE_WRITE		bit (4) internal static options (constant) initial ("0001"b);
  7    17 declare TERM_FILE_DELETE		bit (5) internal static options (constant) initial ("00001"b);
  7    18 
  7    19 /* END INCLUDE FILE ... terminate_file.incl.pl1 */
      549 
      550  /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
  8     2 
  8     3 
  8     4 /****^  HISTORY COMMENTS:
  8     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
  8     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
  8     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
  8     8*     attribute switches.
  8     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  8    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  8    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
  8    12*         be deleted.
  8    13*      B) Add constants identifying attributes that can be changed by user at
  8    14*         login, etc.
  8    15*                                                   END HISTORY COMMENTS */
  8    16 
  8    17 
  8    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
  8    19 
  8    20 /* format: style4 */
  8    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
  8    22        (2 administrator bit (1),			/* 1  system administrator privileges */
  8    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
  8    24        2 nobump bit (1),				/* 2  user cannot be bumped */
  8    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
  8    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
  8    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
  8    28*						   .  of same project (distinct from "nobump") */
  8    29        2 nolist bit (1),				/* 7  don't list user on "who" */
  8    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
  8    31        2 multip bit (1),				/* 9  user may have several processes */
  8    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
  8    33        2 brief bit (1),				/* 11 no login or logout message */
  8    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
  8    35        2 vhomedir bit (1),				/* 13 user may change homedir */
  8    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
  8    37        2 sb_ok bit (1),				/* 15 user may be standby */
  8    38        2 pm_ok bit (1),				/* 16 user may be primary */
  8    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
  8    40        2 daemon bit (1),				/* 18 user may login as daemon */
  8    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
  8    42        2 no_warning bit (1),				/* 20 no warning message */
  8    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
  8    44*						   .  in PDT: this user has an individual load control group */
  8    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
  8    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
  8    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
  8    48        2 pad bit (12)) unaligned;
  8    49 
  8    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  8    51     ("none",					/* 0 */
  8    52      "administrator",				/* 1 */
  8    53      "primary_line",				/* 2 */
  8    54      "nobump",					/* 3 */
  8    55      "guaranteed_login",				/* 4 */
  8    56      "anonymous",					/* 5 */
  8    57      "nopreempt",					/* 6 */
  8    58      "nolist",					/* 7 */
  8    59      "dialok",					/* 8 */
  8    60      "multip",					/* 9 */
  8    61      "bumping",					/* 10 */
  8    62      "brief",					/* 11 */
  8    63      "vinitproc",					/* 12 */
  8    64      "vhomedir",					/* 13 */
  8    65      "nostartup",					/* 14 */
  8    66      "no_secondary",				/* 15 */
  8    67      "no_prime",					/* 16 */
  8    68      "no_eo",					/* 17 */
  8    69      "daemon",					/* 18 */
  8    70      "",						/* 19 vdim OBSOLETE */
  8    71      "no_warning",					/* 20 */
  8    72      "igroup",					/* 21 */
  8    73      "save_pdir",					/* 22 */
  8    74      "disconnect_ok",				/* 23 */
  8    75      "save_on_disconnect");				/* 24 */
  8    76 
  8    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  8    78     ("null",					/* 0 */
  8    79      "admin",					/* 1 */
  8    80      "", "",					/* 2 - 3 */
  8    81      "guar",					/* 4 */
  8    82      "anon",					/* 5 */
  8    83      "", "",					/* 6 - 7 */
  8    84      "dial",					/* 8 */
  8    85      "multi_login",					/* 9 */
  8    86      "preempting",					/* 10 */
  8    87      "",						/* 11 */
  8    88      "v_process_overseer",				/* 12 */
  8    89      "v_home_dir",					/* 13 */
  8    90      "no_start_up",					/* 14 */
  8    91      "no_sec",					/* 15 */
  8    92      "no_primary",					/* 16 */
  8    93      "no_edit_only",				/* 17 */
  8    94      "op_login",					/* 18 */
  8    95      "",						/* 19 */
  8    96      "nowarn",					/* 20 */
  8    97      "", "", "",					/* 21 - 23 */
  8    98      "save");					/* 24 */
  8    99 
  8   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
  8   101      options(constant) init("000000000010000000010000000000000000"b);
  8   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
  8   103 
  8   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
  8   105      options(constant) init("000000000010000000010000000000000000"b);
  8   106     /* PDT value for (brief, no_warning) is default */
  8   107 
  8   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
  8   109      options(constant) init("000100000110010000010000000000000000"b);	
  8   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
  8   111 
  9     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  9     2 
  9     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9     4 /*							       */
  9     5 /* This include file describes the attributes of an absentee job.  It is     */
  9     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
  9     7 /* and PIT.incl.pl1.   */
  9     8 /*							       */
  9     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  9    10 
  9    11 /****^  HISTORY COMMENTS:
  9    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  9    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    14*     Separated abs_attributes from the request structure
  9    15*     (abs_message_format.incl.pl1) so that the identical structure could be
  9    16*     used in the ute structure (user_table_entry.incl.pl1).
  9    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  9    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  9    19*     Added ABS_ATTRIBUTE_NAMES array.
  9    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  9    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  9    22*     Added the no_start_up flag. SCP6367
  9    23*                                                   END HISTORY COMMENTS */
  9    24 
  9    25 dcl 1 user_abs_attributes		aligned based,
  9    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
  9    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
  9    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
  9    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
  9    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
  9    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
  9    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
  9    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
  9    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
  9    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
  9    36       2 attributes_pad		bit (26) unaligned;
  9    37 
  9    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
  9    39 	"restartable",
  9    40 	"user_deferred_until_time",
  9    41 	"proxy",
  9    42 	"set_bit_cnt",
  9    43 	"time_in_gmt",
  9    44 	"user_deferred_indefinitely",
  9    45 	"secondary_ok",
  9    46 	"truncate_absout",
  9    47 	"restarted",
  9    48 	"no_start_up");
  9    49 
  9    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  9    51 
  8   112 
  8   113 
  8   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      550 
      551 
      552      end reset_usage;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/13/88  0941.2  reset_usage.pl1                   >special_ldd>install>MR12.2-1047>reset_usage.pl1
545          1    04/11/85  1452.6  access_mode_values.incl.pl1       >ldd>include>access_mode_values.incl.pl1
546          2    10/14/83  1606.7  delete_options.incl.pl1           >ldd>include>delete_options.incl.pl1
547          3    09/13/84  0921.6  pdt.incl.pl1                      >ldd>include>pdt.incl.pl1
3-29         4    04/21/82  1211.8  author.incl.pl1                   >ldd>include>author.incl.pl1
548          5    08/06/87  1416.6  sat.incl.pl1                      >ldd>include>sat.incl.pl1
5-34         6    04/21/82  1211.8  author.incl.pl1                   >ldd>include>author.incl.pl1
549          7    04/06/83  1239.4  terminate_file.incl.pl1           >ldd>include>terminate_file.incl.pl1
550          8    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
8-112        9    07/13/88  0900.1  user_abs_attributes.incl.pl1      >special_ldd>install>MR12.2-1047>user_abs_attributes.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
ME                              000001 constant        char(32)                 initial packed unaligned dcl 101 set ref 151* 155*
                                                                                  190* 272*
RW_ACCESS                       000037 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 215* 238*
R_ACCESS                        000034 constant        bit(3)                   initial packed unaligned dcl 1-11 set ref 229*
TERM_FILE_TERM                  000000 constant        bit(3)                   initial packed unaligned dcl 7-14 set ref 241* 261*
                                                                                  263* 533* 534* 535*
absentee                244            based           structure                array level 2 dcl 3-58
absolute_pathname_              000010 constant        entry                    external dcl 106 ref 201 209
addr                                                   builtin function         dcl 94 ref 173 255 256
argument                               based           char                     packed unaligned dcl 86 set ref 196* 197* 201* 202*
                                                                                  209* 210*
argument_lth                    000100 automatic       fixed bin(21,0)          dcl 57 set ref 195* 196 196 197 197 200* 201 201 202
                                                                                  202 208* 209 209 210 210
argument_ptr                    000102 automatic       pointer                  dcl 58 set ref 195* 196 197 200* 201 202 208* 209
                                                                                  210
baderrct                        000355 automatic       fixed bin(17,0)          dcl 81 set ref 306* 310 353* 353 359* 359 365* 365
                                                                                  375* 375 383* 383 390* 390 399* 399 408* 408 419*
                                                                                  419 426* 426 434* 434 441* 441 453* 453 459* 459
                                                                                  465* 465 471* 471 482* 482
chain                   377            based           fixed bin(17,0)          level 2 in structure "user" dcl 3-58 in procedure
                                                                                  "reset_usage" set ref 320*
chain                   117            based           fixed bin(17,0)          level 2 in structure "project" dcl 5-53 in procedure
                                                                                  "reset_usage" set ref 269*
charge                  244            based           float bin(27)            array level 3 in structure "user" dcl 3-58
                                                                                  in procedure "reset_usage" set ref 414 414 416*
charge                  124            based           float bin(27)            array level 3 in structure "user" dcl 3-58
                                                                                  in procedure "reset_usage" set ref 369 369 372*
charge                  274            based           float bin(27)            array level 3 in structure "user" dcl 3-58
                                                                                  in procedure "reset_usage" set ref 449 449 451*
cleanup                         000360 stack reference condition                dcl 90 ref 149
clock                                                  builtin function         dcl 95 ref 161
code                            000104 automatic       fixed bin(35,0)          dcl 59 set ref 151* 153 155* 196* 197 197* 201* 202
                                                                                  202* 209* 210 210* 215* 216 216* 229* 230 238* 239
                                                                                  337 342* 499* 500 500* 510*
com_err_                        000012 constant        entry                    external dcl 107 ref 155
connect                 132            based           fixed bin(71,0)          array level 3 dcl 3-58 set ref 393 393 396*
core                    130            based           fixed bin(71,0)          array level 3 dcl 3-58 set ref 386 386 388*
cp                              000330 automatic       pointer                  dcl 68 set ref 256* 295 297 299 349 356 362 369 378
                                                                                  386 393 402 414 422 429 437 449 456 462 468 479
cpdt_dir                        000105 automatic       char(168)                packed unaligned dcl 60 set ref 209* 229* 233* 233*
cpdtp                           000332 automatic       pointer                  dcl 69 set ref 147* 229* 241* 253 256 263 263* 534*
cpu                     246            based           fixed bin(71,0)          array level 3 in structure "user" dcl 3-58
                                                                                  in procedure "reset_usage" set ref 429 429 432*
cpu                     126            based           fixed bin(71,0)          array level 3 in structure "user" dcl 3-58
                                                                                  in procedure "reset_usage" set ref 378 378 380*
crashes                 123            based           fixed bin(17,0)          level 2 dcl 3-58 set ref 362 362 363*
cu_$arg_list_ptr                000014 constant        entry                    external dcl 108 ref 151 151
current_size             36            based           fixed bin(17,0)          level 2 in structure "sat" dcl 5-32 in procedure
                                                                                  "reset_usage" ref 172
current_size             36            based           fixed bin(17,0)          level 2 in structure "pdt" dcl 3-27 in procedure
                                                                                  "reset_usage" ref 247 253
current_time                    000352 automatic       fixed bin(71,0)          dcl 77 set ref 161* 340 488
delete_$path                    000016 constant        entry                    external dcl 109 ref 272
delete_options                  000366 automatic       structure                level 1 packed packed unaligned dcl 2-7 set ref 165*
                                                                                  272 272
delta                           000346 automatic       fixed bin(17,0)          dcl 75 set ref 356* 357 357 362* 363 363 422* 424
                                                                                  424 456* 457 457
deltafloat                      000354 automatic       float bin(27)            dcl 78 set ref 349* 351 351 369* 372 372 414* 416
                                                                                  416 449* 451 451 479* 480 480
devices                 324            based           float bin(27)            array level 2 dcl 3-58 set ref 479 479 480*
dollar_charge            75            based           float bin(27)            level 2 dcl 3-58 set ref 349 349 351*
doubledelta                     000350 automatic       fixed bin(71,0)          dcl 76 set ref 378* 380 380 386* 388 388 393* 396
                                                                                  396 402* 405 405 429* 432 432 437* 439 439 462*
                                                                                  463 463 468* 469 469
error_table_$lock_wait_time_exceeded
                                000054 external static fixed bin(17,0)          dcl 137 ref 500
expand_pathname_                000020 constant        entry                    external dcl 112 ref 196
force                           000366 automatic       bit(1)                   level 2 packed packed unaligned dcl 2-7 set ref 166*
freep                    40            based           fixed bin(17,0)          level 2 in structure "sat" dcl 5-32 in procedure
                                                                                  "reset_usage" set ref 269 270*
freep                    40            based           fixed bin(17,0)          level 2 in structure "pdt" dcl 3-27 in procedure
                                                                                  "reset_usage" set ref 320 321*
get_lock_id_                    000022 constant        entry                    external dcl 114 ref 526
i                               000342 automatic       fixed bin(17,0)          dcl 74 set ref 172* 173* 270
initiate_file_                  000024 constant        entry                    external dcl 115 ref 215 229 238
interactive             124            based           structure                array level 2 dcl 3-58
io_ops                  134            based           fixed bin(71,0)          array level 3 dcl 3-58 set ref 402 402 405*
ioa_$rsnnl                      000026 constant        entry                    external dcl 117 ref 174
iod                     274            based           structure                array level 2 dcl 3-58
j                               000343 automatic       fixed bin(17,0)          dcl 74 set ref 247* 253 255 256* 321
jobs                    245            based           fixed bin(17,0)          array level 3 dcl 3-58 set ref 422 422 424*
k                               000344 automatic       fixed bin(17,0)          dcl 74 set ref 368* 369 369 372 378 378 380 386 386
                                                                                  388 393 393 396 402 402 405* 413* 414 414 416 422
                                                                                  422 424 429 429 432 437 437 439* 448* 449 449 451
                                                                                  456 456 457 462 462 463 468 468 469* 478* 479 479
                                                                                  480*
kk                              000345 automatic       fixed bin(17,0)          dcl 74 set ref 174*
lines                   300            based           fixed bin(71,0)          array level 3 dcl 3-58 set ref 468 468 469*
lock                      1            based           bit(36)                  level 2 dcl 3-58 set ref 499* 510* 526 526*
locked_pdtep                    000356 automatic       pointer                  dcl 82 set ref 144* 498* 511* 524 526 526 528*
logins                  122            based           fixed bin(17,0)          level 2 dcl 3-58 set ref 356 356 357*
memory                  250            based           fixed bin(71,0)          array level 3 dcl 3-58 set ref 437 437 439*
n_arguments                     000157 automatic       fixed bin(17,0)          dcl 61 set ref 189* 190
null                                                   builtin function         dcl 96 ref 143 144 145 146 147 261 263 511 524 528
                                                                                  537
pages                   277            based           fixed bin(35,0)          array level 3 dcl 3-58 set ref 462 462 463*
pathname_                       000030 constant        entry                    external dcl 118 ref 216 216 233 233
pdt                                    based           structure                level 1 dcl 3-27
pdt_dir                         000160 automatic       char(168)                packed unaligned dcl 62 set ref 201* 238* 272*
pdt_name                        000232 automatic       char(32)                 packed unaligned dcl 63 set ref 174* 229* 233* 233*
                                                                                  238* 272*
pdtp                            000334 automatic       pointer                  dcl 70 set ref 146* 238* 247 255 261 261* 320 321
                                                                                  533*
person_id                 2            based           char(24)                 level 2 dcl 3-58 set ref 297 297 299* 299* 312* 323*
                                                                                  342* 500*
pieces                  275            based           fixed bin(17,0)          array level 3 dcl 3-58 set ref 456 456 457*
project                 722            based           structure                array level 2 in structure "sat" dcl 5-32
                                                                                  in procedure "reset_usage" set ref 173
project                                based           structure                level 1 dcl 5-53 in procedure "reset_usage"
project_id                1            based           char(12)                 level 2 packed packed unaligned dcl 5-53 set ref
                                                                                  174* 279* 299* 312* 323* 342* 500*
raw                       0(07) 000366 automatic       bit(1)                   level 2 packed packed unaligned dcl 2-7 set ref 168*
sat                                    based           structure                level 1 dcl 5-32
sat_dir                         000242 automatic       char(168)                packed unaligned dcl 64 set ref 196* 215* 216* 216*
sat_name                        000314 automatic       char(32)                 packed unaligned dcl 65 set ref 196* 215* 216* 216*
satep                           000340 automatic       pointer                  dcl 73 set ref 173* 174 225 266 266 268 269 275 279
                                                                                  279 299 312 323 342 500
satp                            000336 automatic       pointer                  dcl 72 set ref 145* 172 173 215* 269 270 535*
sci_ptr                         000324 automatic       pointer                  dcl 66 set ref 143* 151* 189* 190* 195* 197* 200*
                                                                                  202* 208* 210* 216* 233* 279* 299* 312* 323* 342*
                                                                                  500* 537 537*
segment                   0(03) 000366 automatic       bit(1)                   level 2 packed packed unaligned dcl 2-7 set ref 167*
set_lock_$lock                  000046 constant        entry                    external dcl 129 ref 499
set_lock_$unlock                000050 constant        entry                    external dcl 131 ref 510 526
sp                              000326 automatic       pointer                  dcl 67 set ref 255* 290 292 297 299 312 317 319 320
                                                                                  323 323 340 342 349 351 356 357 362 363 369 372
                                                                                  378 380 386 388 393 396 402 405 414 416 422 424
                                                                                  429 432 437 439 449 451 456 457 462 463 468 469
                                                                                  479 480 488 498 499 500 510
ssu_$abort_line                 000032 constant        entry                    external dcl 120 ref 190 197 202 210 216
ssu_$arg_count                  000034 constant        entry                    external dcl 121 ref 189
ssu_$arg_ptr                    000036 constant        entry                    external dcl 122 ref 195 200 208
ssu_$destroy_invocation         000040 constant        entry                    external dcl 124 ref 537
ssu_$print_message              000042 constant        entry                    external dcl 125 ref 233 279 299 312 323 342 500
ssu_$standalone_invocation      000044 constant        entry                    external dcl 126 ref 151
state                                  based           fixed bin(17,0)          level 2 in structure "project" dcl 5-53 in procedure
                                                                                  "reset_usage" set ref 225 266 266 268* 275 279*
state                                  based           fixed bin(17,0)          level 2 in structure "user" dcl 3-58 in procedure
                                                                                  "reset_usage" set ref 290 292 295 317 319* 323*
terminate_file_                 000052 constant        entry                    external dcl 132 ref 241 261 263 533 534 535
time_last_reset         344            based           fixed bin(71,0)          level 2 dcl 3-58 set ref 340 488*
twodays                         000011 constant        fixed bin(35,0)          initial dcl 79 ref 340
unspec                                                 builtin function         dcl 97 set ref 165* 272 272
user                                   based           structure                level 1 dcl 3-58 in procedure "reset_usage"
user                    400            based           structure                array level 2 in structure "pdt" dcl 3-27
                                                                                  in procedure "reset_usage" set ref 255 256
user_attributes                        based           structure                level 1 dcl 8-21

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 9-38
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 8-77
A_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
A_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
DIR_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-33
E_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
E_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
M_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
M_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
N_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
N_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
PDT_entry_lth                          internal static fixed bin(17,0)          initial dcl 3-19
PDT_header_lth                         internal static fixed bin(17,0)          initial dcl 3-19
PDT_person_id_length                   internal static fixed bin(17,0)          initial dcl 3-19
PDT_project_name_length                internal static fixed bin(17,0)          initial dcl 3-19
PDT_version                            internal static fixed bin(17,0)          initial dcl 3-19
REW_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
REW_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
RE_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
RE_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
RW_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
R_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
SAT_entry_lth                          internal static fixed bin(17,0)          initial dcl 5-24
SAT_header_lth                         internal static fixed bin(17,0)          initial dcl 5-24
SAT_project_name_length                internal static fixed bin(17,0)          initial dcl 5-24
SAT_version                            internal static fixed bin(17,0)          initial dcl 5-24
SA_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SA_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
SEG_ACCESS_MODE_NAMES                  internal static char(4)                  initial array packed unaligned dcl 1-30
SMA_ACCESS                             internal static bit(3)                   initial packed unaligned dcl 1-11
SMA_ACCESS_BIN                         internal static fixed bin(5,0)           initial dcl 1-36
SM_ACCESS                              internal static bit(3)                   initial packed unaligned dcl 1-11
SM_ACCESS_BIN                          internal static fixed bin(5,0)           initial dcl 1-36
S_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
S_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
TERM_FILE_BC                           internal static bit(2)                   initial packed unaligned dcl 7-12
TERM_FILE_DELETE                       internal static bit(5)                   initial packed unaligned dcl 7-17
TERM_FILE_FORCE_WRITE                  internal static bit(4)                   initial packed unaligned dcl 7-16
TERM_FILE_TRUNC                        internal static bit(1)                   initial packed unaligned dcl 7-11
TERM_FILE_TRUNC_BC                     internal static bit(2)                   initial packed unaligned dcl 7-13
TERM_FILE_TRUNC_BC_TERM                internal static bit(3)                   initial packed unaligned dcl 7-15
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 8-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 8-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 8-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 8-50
W_ACCESS                               internal static bit(3)                   initial packed unaligned dcl 1-11
W_ACCESS_BIN                           internal static fixed bin(5,0)           initial dcl 1-36
pdtep                                  automatic       pointer                  dcl 71
terminate_file_switches                based           structure                level 1 packed packed unaligned dcl 7-4
user_abs_attributes                    based           structure                level 1 dcl 9-25

NAMES DECLARED BY EXPLICIT CONTEXT.
ABORT_LABEL                     000505 constant        label                    dcl 178 ref 518
CLEAN_UP                        002476 constant        entry                    internal dcl 521 ref 149 178
LOCK_PDT                        002364 constant        entry                    internal dcl 495 ref 336
PDT_INIT_ERROR                  001235 constant        label                    dcl 230 ref 242
PROCESS_ARGUMENTS               000512 constant        entry                    internal dcl 182 ref 159
PROCESS_PROJECT                 001171 constant        entry                    internal dcl 222 ref 175
PROCESS_USER                    001626 constant        entry                    internal dcl 287 ref 257
RESET_USER_USAGE                002031 constant        entry                    internal dcl 333 ref 308
SSU_ABORT                       002465 constant        entry                    internal dcl 515 ref 151 151
UNLOCK_PDT                      002446 constant        entry                    internal dcl 507 ref 345 490
reset_usage                     000271 constant        entry                    external dcl 25

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      3146        3224    2664        3156
Length      3632    2664        56         372     262           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
reset_usage                         704 external procedure  is an external procedure.  
on unit on line 149                  64 on unit               
PROCESS_ARGUMENTS                       internal procedure  shares stack frame of external procedure reset_usage.  
PROCESS_PROJECT                         internal procedure  shares stack frame of external procedure reset_usage.  
PROCESS_USER                            internal procedure  shares stack frame of external procedure reset_usage.  
RESET_USER_USAGE                        internal procedure  shares stack frame of external procedure reset_usage.  
LOCK_PDT                                internal procedure  shares stack frame of external procedure reset_usage.  
UNLOCK_PDT                              internal procedure  shares stack frame of external procedure reset_usage.  
SSU_ABORT                            64 internal procedure  is assigned to an entry variable.  
CLEAN_UP                             94 internal procedure  is called by several nonquick procedures.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
reset_usage              000100 argument_lth                reset_usage
                         000102 argument_ptr                reset_usage
                         000104 code                        reset_usage
                         000105 cpdt_dir                    reset_usage
                         000157 n_arguments                 reset_usage
                         000160 pdt_dir                     reset_usage
                         000232 pdt_name                    reset_usage
                         000242 sat_dir                     reset_usage
                         000314 sat_name                    reset_usage
                         000324 sci_ptr                     reset_usage
                         000326 sp                          reset_usage
                         000330 cp                          reset_usage
                         000332 cpdtp                       reset_usage
                         000334 pdtp                        reset_usage
                         000336 satp                        reset_usage
                         000340 satep                       reset_usage
                         000342 i                           reset_usage
                         000343 j                           reset_usage
                         000344 k                           reset_usage
                         000345 kk                          reset_usage
                         000346 delta                       reset_usage
                         000350 doubledelta                 reset_usage
                         000352 current_time                reset_usage
                         000354 deltafloat                  reset_usage
                         000355 baderrct                    reset_usage
                         000356 locked_pdtep                reset_usage
                         000366 delete_options              reset_usage

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
call_ext_out_desc   call_ext_out        call_int_this       call_int_other      return_mac          tra_ext_1
enable_op           ext_entry           int_entry           clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
absolute_pathname_            com_err_                      cu_$arg_list_ptr              delete_$path
expand_pathname_              get_lock_id_                  initiate_file_                ioa_$rsnnl
pathname_                     set_lock_$lock                set_lock_$unlock              ssu_$abort_line
ssu_$arg_count                ssu_$arg_ptr                  ssu_$destroy_invocation       ssu_$print_message
ssu_$standalone_invocation    terminate_file_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$lock_wait_time_exceeded




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     25 000270       143 000276       144 000300       145 000301       146 000302       147 000303       149 000304
    151 000326       153 000376       155 000400       156 000424       159 000425       161 000426       165 000430
    166 000431       167 000433       168 000435       172 000437       173 000447       174 000453       175 000502
    176 000503       178 000505       180 000511       182 000512       189 000513       190 000524       195 000560
    196 000577       197 000627       200 000663       201 000702       202 000726       208 000762       209 001001
    210 001025       215 001061       216 001117       220 001170       222 001171       225 001172       229 001175
    230 001233       233 001235       235 001311       238 001312       239 001350       241 001352       242 001401
    247 001402       253 001413       255 001416       256 001421       257 001423       259 001424       261 001426
    263 001461       265 001514       266 001515       268 001521       269 001522       270 001526       272 001530
    274 001563       275 001564       279 001567       283 001625       287 001626       290 001627       292 001632
    295 001634       297 001637       299 001645       303 001706       306 001707       308 001710       310 001711
    312 001713       316 001752       317 001753       319 001755       320 001756       321 001762       322 001764
    323 001765       329 002030       333 002031       336 002032       337 002033       340 002036       342 002046
    345 002103       346 002104       349 002105       351 002111       353 002114       356 002115       357 002120
    359 002123       362 002124       363 002127       365 002132       368 002133       369 002137       372 002146
    375 002152       378 002153       380 002156       383 002161       386 002162       388 002165       390 002170
    393 002171       396 002174       399 002177       402 002200       405 002203       408 002206       411 002207
    413 002211       414 002217       416 002226       419 002232       422 002233       424 002236       426 002241
    429 002242       432 002245       434 002250       437 002251       439 002254       441 002257       444 002260
    448 002262       449 002267       451 002276       453 002302       456 002303       457 002306       459 002311
    462 002312       463 002320       465 002323       468 002324       469 002327       471 002332       474 002333
    478 002335       479 002343       480 002351       482 002354       484 002355       488 002357       490 002362
    491 002363       495 002364       498 002365       499 002367       500 002404       504 002445       507 002446
    510 002447       511 002461       512 002463       515 002464       518 002472       521 002475       524 002503
    526 002510       528 002535       533 002540       534 002567       535 002617       537 002647       539 002663


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
