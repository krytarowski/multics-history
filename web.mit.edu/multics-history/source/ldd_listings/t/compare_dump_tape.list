	COMPILATION LISTING OF SEGMENT compare_dump_tape
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 07/16/87  1328.4 mst Thu
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   *                                                         *
        4*   * Copyright, (C) Honeywell Information Systems Inc., 1981 *
        5*   *                                                         *
        6*   *                                                         *
        7*   *********************************************************** */
        8 
        9 compare_dump_tape:
       10 	proc;
       11 
       12 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       13 	/*									*/
       14 	/*  This routine provides for comparing dump tapes to make sure contents of both are	*/
       15 	/* identical.								*/
       16 	/*  Selective comparisons implemented June 1980 to go along with selective copying in	*/
       17 	/* copy_dump_tape.								*/
       18 	/*									*/
       19 	/* Created:    Oct 1979, A.R. Downing						*/
       20 	/* Modified:   April 1981, JM Stansbury						*/
       21 	/*             For much reformatting, and tying of loose ends.			*/
       22 	/* Modified:   Sept 1983, G.C. Dixon - improve error messages			*/
       23 	/* Modified:   June 1985, G.C. Dixon - skip file duplicated on master tape.  Report	*/
       24 	/*	     failure due to compare_dump_tape count of copied files disagreing with	*/
       25 	/*	     count of copy_dump_tape.  This is a kludgy count, anyway.  Failures due	*/
       26 	/*	     to it alone need to be diagnosed.					*/
       27 	/*									*/
       28 	/*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
       29 
       30 
       31 /*   E X T E R N A L   E N T R I E S  */
       32 
       33 dcl  com_err_	     entry options (variable),
       34      compare_copy_$input_init
       35 		     entry (ptr, fixed bin (35)),
       36      compare_copy_$rd_tape
       37 		     entry (ptr, fixed bin (35), ptr, fixed bin (35), fixed bin (35)),
       38      compare_copy_$input_finish
       39 		     entry,
       40      compare_master_$input_init
       41 		     entry (ptr, fixed bin (35)),
       42      compare_master_$rd_tape
       43 		     entry (ptr, fixed bin (35), ptr, fixed bin (35), fixed bin (35)),
       44      compare_master_$input_finish
       45 		     entry,
       46      cu_$arg_count	     entry (fixed bin),
       47      cu_$arg_ptr	     entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
       48      date_time_	     entry (fixed bin (71), char (*)),
       49      get_pdir_	     entry returns (char (168)),
       50      get_temp_segment_   entry (char (*), ptr, fixed bin (35)),
       51      hcs_$set_max_length_seg
       52 		     entry (ptr, fixed bin (35), fixed bin (35)),
       53      ioa_	               entry options (variable),
       54      pathname_	     entry (char(*), char(*)) returns(char(168)),
       55      release_temp_segment_
       56 		     entry (char (*), ptr, fixed bin (35));
       57 	
       58 
       59 /*   I N T E R N A L   S T A T I C  */
       60 
       61 dcl  False               bit (1) aligned init ("0"b) int static options (constant),
       62      True		     bit (1) aligned init ("1"b) int static options (constant),
       63      id_sw	     bit (1) int static init ("1"b),
       64      info_p	     ptr int static,
       65      recurse_bit	     bit (1) int static init ("0"b);
       66 	
       67 
       68 /*   E X T E R N A L   S T A T I C  */
       69 
       70 dcl  Ncopied	     fixed bin ext static init (0),	/* used to insure that skipped master entries */
       71 						/* SHOULD HAVE BEEN skipped */
       72      sys_info$max_seg_size
       73 		     fixed bin(35) ext static,
       74      compare_dump_tape_severity_
       75 		     ext static fixed bin init(0),
       76     (error_table_$badcall,
       77      error_table_$badopt,
       78      error_table_$end_of_info,
       79      error_table_$segknown) ext fixed bin (35);
       80 
       81 
       82 /*   A U T O M A T I C  */
       83 
       84 dcl  ap		     ptr,				/* for arg processing */
       85      argcnt	     fixed bin,			/* no. of args. */
       86      argl		     fixed bin (21),		/* arg length */
       87      code		     fixed bin (35),
       88      copy_read	     fixed bin,			/* count of items read from copy tape(s) */
       89      cpsw		     bit (1),			/* true, if "-cvol" used */
       90      dens 	     char (32) varying,
       91      hcnt 	     fixed bin (35),		/* temp seg for lgth of copy tape preamble */
       92      hp	               ptr,				/* for copy tape preamble */
       93      i		     fixed bin,
       94      input_descrip	     char (100) varying,
       95      j		     fixed bin,
       96      k		     fixed bin,
       97      1 last_copy	     aligned like last_master,
       98      1 last_master	     aligned,
       99        2 path	     unal,			/* path of last object read from master tape. */
      100          3 dir	     char (168),
      101          3 ent	     char (32),
      102        2 size,					/* size of last object read from master tape. */
      103          3 h	     fixed bin(35),			/*   header. */
      104          3 s	     fixed bin(35),			/*   segment (object) itself */
      105      master_read	     fixed bin,			/* count of items read from master tape(s) */
      106      mhcnt 	     fixed bin (35),		/* temp seg for lgth of master preamble */
      107      mp	               ptr,				/* for master tape preamble */
      108      mscnt	     fixed bin (35),		/* no. bytes read from master preamble */
      109      msf_count	     fixed bin,			/* count of MSFs */
      110      mssw		     bit (1),			/* true, if "-mvol" used */
      111      mstr_buff	     ptr,				/* ptr to temp seg fro master preamble */
      112      output_descrip	     char (100) varying,
      113      pd		     char (168) var,		/* process directory path */
      114      scnt 	     fixed bin (35),		/* no. bytes read from copy preamble */
      115      seg_buff	     ptr,				/* ptr to temp seg for copy tape preamble */
      116      segcnt	     fixed bin (35),		/* temporary storage */
      117      segs_skipped	     fixed bin (35),
      118      set_c_options	     bit (1),			/* for "-cvol" */
      119      set_cpsw 	     bit (1),			/* for "-cvol */
      120      set_m_options       bit (1),			/* for "-mvol" */
      121      set_mssw 	     bit (1),			/* for "-mvol" */
      122      skip_copy_read      bit (1) aligned,
      123      stop_sw             bit (1) aligned,
      124      total_on_copy	     fixed bin,			/* total items on copy tape(s) */
      125      track 	     char (32) varying,
      126      wdcnt	     fixed bin (35);		/* temporary storage */
      127 	
      128 
      129 
      130 /*   B A S E D   S T R U C T U R E S   A N D   V A R I A B L E S  */
      131 
      132 dcl 1 based_common_info  aligned based (info_p),
      133       2 cdt_output_labels,
      134         3 cp1	     (1:10) char (32) aligned varying,
      135         3 ncp1	     fixed bin,
      136         3 cp2	     (1:10) char (32) aligned varying,
      137         3 ncp2	     fixed bin,
      138         3 cp3	     (1:10) char (32) aligned varying,
      139         3 ncp3	     fixed bin,
      140       2 R1	     fixed bin,
      141       2 R2	     fixed bin,
      142       2 R3	     fixed bin,
      143       2 pname	     char (32) varying,
      144       2 selecting	     bit (1) aligned,
      145       2 last1	     fixed dec (10, 3),
      146       2 last2	     fixed dec (10, 3),
      147       2 last3	     fixed dec (10, 3),
      148       2 written	     fixed bin (35),
      149       2 insw	     bit (1) aligned,
      150       2 inswcp	     bit (1) aligned,
      151       2 outsw	     bit (1) aligned,
      152       2 in_reel	     (10) char (32) varying,
      153       2 next_in	     fixed bin,
      154       2 next_incp	     fixed bin,
      155       2 nin	     fixed bin,
      156       2 nincp	     fixed bin;
      157 
      158 dcl 1 common_info	     aligned like based_common_info;
      159 
      160 dcl 1 mstrpre	     based (mp),			/* master tape preamble */
      161       2 seg_dir	     char (168) var,
      162       2 seg_name	     char (32) var;
      163 
      164 dcl 1 cpypre	     based (hp),			/* copy tape preamble */
      165       2 seg_dir	     char (168) var,
      166       2 seg_name	     char (32) var;
      167 
      168 dcl  arg		     based (ap) char (argl);
      169 dcl  master_preamble     (0:261119) based (mp) fixed bin (35),
      170      copy_preamble	     (0:261119) based (hp) fixed bin (35),
      171      master_seg	     (0:261119) based (mstr_buff) fixed bin (35),
      172      copy_seg	     (0:261119) based (seg_buff) fixed bin (35);
      173 
      174 
      175 
      176 /*   C O N D I T I O N S  */
      177 
      178 dcl  cleanup condition;
      179 
      180 
      181 /*  B U I L T I N S  */
      182 
      183 dcl (addr, before, substr, unspec)	builtin;
      184 
      185 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      186 
      187 	input_descrip = "tape_mult_ ";
      188 	output_descrip = "tape_mult_ ";
      189 	on cleanup recurse_bit = False;
      190 	if recurse_bit then do;
      191 	     code = error_table_$badcall;
      192 	     call com_err_ (code, "compare_dump_tape", 
      193                   "compare_dump_tape has been recursively invoked, release or restart the prior invocation.");
      194 	     revert cleanup;
      195 	     return;
      196 	     end;
      197 	recurse_bit = True;
      198 	if id_sw then do;
      199 	     id_sw = False;
      200 	     call ioa_ ("^a: ^a: Begin comparison", "compare_dump_tape", time());
      201 	     end;
      202 	on cleanup id_sw, recurse_bit = False;
      203 	info_p = addr (common_info);
      204 	skip_copy_read = False;
      205 	common_info.selecting = False;
      206 	segs_skipped = 0;
      207 	common_info.next_in = 0;
      208 	common_info.next_incp = 0;
      209 	common_info.pname = "compare_dump_tape";
      210 	common_info.nin = 0;
      211 	common_info.nincp = 0;
      212 	stop_sw = False;
      213 	set_mssw = False;
      214 	set_cpsw = False;
      215 	mssw = False;
      216 	cpsw = False;
      217 	i = 0;
      218 	j = 0;
      219 	k = 0;
      220 	msf_count = 0;
      221 	master_read = 0;
      222 	copy_read = 0;
      223 	total_on_copy = 0;
      224 
      225 	compare_dump_tape_severity_ = 4;
      226 	call get_temp_segment_ ((common_info.pname), mp, code);
      227 	if code ^= 0 & code ^= error_table_$segknown then
      228 	     go to buff_err;
      229 	call get_temp_segment_ ((common_info.pname), hp, code);
      230 	if code ^= 0 & code ^= error_table_$segknown then
      231 	     go to buff_err;
      232 	call get_temp_segment_ ((common_info.pname), mstr_buff, code);
      233 	if code ^= 0 & code ^= error_table_$segknown then
      234 	     go to buff_err;
      235 	call get_temp_segment_ ((common_info.pname), seg_buff, code);
      236 	if code ^= 0 & code ^= error_table_$segknown then do;
      237 buff_err:	     call com_err_ (code, "compare_dump_tape", "Allocating temporary buffers.");
      238 	     call terminate;
      239 	     recurse_bit = False;
      240 	     return;
      241 	end;
      242 	call hcs_$set_max_length_seg (seg_buff, sys_info$max_seg_size, code);
      243 	call hcs_$set_max_length_seg (mstr_buff, sys_info$max_seg_size, code);
      244 	segcnt = 0;				/* Initialize segment counter */
      245 	common_info.in_reel (*) = "";
      246 	common_info.cp1 (*) = "";
      247 	call cu_$arg_count (argcnt);
      248 	if argcnt > 0 then do i = 1 to argcnt;
      249 	     call cu_$arg_ptr (i, ap, argl, code);
      250 	     if arg = "-abort" | arg = "-perfect" then
      251 		stop_sw = True;
      252 	     else if arg = "-select" then
      253 		common_info.selecting = True;		/* to skip over uncopied portions of master tape set */
      254 	     else if arg = "-density" | arg = "-den" then do;
      255 		call cu_$arg_ptr (i+1, ap, argl, code);
      256 		if code = 0 then do;
      257 		     i = i + 1;
      258 		     dens = arg;
      259 		     end;
      260 		else do;
      261 bad_arg:		     call com_err_ (code, "compare_dump_tape", "-den requires an operand.");
      262 		     return;
      263 		     end;
      264 		if set_m_options & common_info.nin > 0 then
      265 		     do k = 1 to common_info.nin;
      266 			common_info.in_reel (k) = common_info.in_reel (k) || " -density " || dens;
      267 			end;
      268 		else if set_c_options & common_info.nincp > 0 then
      269 		     do k = 1 to common_info.nincp;
      270 			common_info.cp1 (k) = common_info.cp1 (k) || " -density " || dens;
      271 			end;
      272 		k = 0;
      273 		end;
      274 	     else if arg = "-track" | arg = "-trk" | arg = "-tk" then do;
      275 		call cu_$arg_ptr (i+1, ap, argl, code);
      276 		if code = 0 then do;
      277 		     i = i + 1;
      278 		     track = arg;
      279 		     end;
      280 		else do;
      281 		     call com_err_ (code, "compare_dump_tape", "-tk requires an operand.");
      282 		     return;
      283 		     end;
      284 		if set_m_options & common_info.nin > 0 then
      285 		     do k = 1 to common_info.nin;
      286 			common_info.in_reel (k) = common_info.in_reel (k) || " -track " || track;
      287 			end;
      288 		else if set_c_options & common_info.nincp > 0 then
      289 		     do k = 1 to common_info.nincp;
      290 			common_info.cp1 (k) = common_info.cp1 (k) || " -track " || track;
      291 			end;
      292 	     k = 0;
      293 	     end;
      294 	else if arg = "-master_volume"
      295 	     | arg = "-mvol"
      296 	     | arg = "-ms"
      297 	     | arg = "-master" then do;
      298 		set_m_options = True;
      299 		set_c_options = False;
      300 		mssw = True;
      301 		cpsw = False;
      302 		set_mssw = True;
      303 		end;
      304 	     else if arg = "-copy_volume"
      305 	     | arg = "-cvol"
      306 	     | arg = "-cp"
      307 	     | arg = "-copy" then do;
      308 		set_c_options = True;
      309 		set_m_options = False;
      310 		set_cpsw = True;
      311 		mssw = False;
      312 		cpsw = True;
      313 		end;
      314 	     else if mssw then do;
      315 		j = j+1;
      316 		common_info.in_reel (j) = substr (arg, 1, argl);
      317 		common_info.nin = common_info.nin+1;
      318 		end;
      319 	     else if cpsw then do;
      320 		k = k+1;
      321 		common_info.cp1 (k) = substr (arg, 1, argl);
      322 		common_info.nincp = common_info.nincp+1;
      323 		end;
      324 	     else do;
      325 		call com_err_ (error_table_$badopt, "compare_dump_tape", "^a", arg);
      326 		call clean_up;
      327 		return;
      328 		end;
      329 	end;					/* end arg processing */
      330 	common_info.insw = set_mssw;
      331 	mssw = set_mssw;
      332 	common_info.inswcp = set_cpsw;
      333 	cpsw = set_cpsw;
      334 	on cleanup call clean_up;
      335 	pd = before (get_pdir_ (), " ");
      336 	call compare_master_$input_init (info_p, code);	/* mount a master tape */
      337 	if code ^= 0 then do;
      338 	     call com_err_ (code, "compare_dump_tape", "^a: Error mounting master tape.", time());
      339 	     call clean_up;
      340 	     return;
      341 	     end;
      342 	call compare_copy_$input_init (info_p, code);	/* mount a copy tape */
      343 						/* Initiate copy tape read package */
      344 	if code ^= 0 then do;
      345 	     call com_err_ (code, "compare_dump_tape", "^a: Error mounting copy tape.", time());
      346 	     call clean_up;
      347 	     return;
      348 	     end;
      349 	call ioa_ ("^a: ^a: Start tape verify.", "compare_dump_tape", time());
      350 						/* This is the main verify loop */
      351 	compare_dump_tape_severity_ = 0;
      352 	last_master.path, last_copy.path = "";
      353 	last_master.size, last_copy.size = 0;
      354 next:	do while ("1"b);
      355 	     call compare_master_$rd_tape (mp, mhcnt, mstr_buff, mscnt, code);
      356 						/* get first or next master record */
      357 	     if code ^= 0 then do;			/* check for end of last master tape */
      358 		if code = error_table_$end_of_info then /* Is this the end of the last tape? */
      359 		     code = 0;			/* end of job */
      360 		else call com_err_ (code, "compare_dump_tape", "^a: Error reading master tape.", time());
      361 		call clean_up;
      362 		return;
      363 		end;
      364 	     if mhcnt = 0 then do;			/* problem with master tape preamble */
      365 		call ioa_ ("^a: ^a: Segment ^d -- Zero length master preamble.",
      366 		   "compare_dump_tape", time(), segcnt);
      367 		compare_dump_tape_severity_ = 3;
      368 	     end;
      369 	     if last_master.dir ^= "" then do;		/* See if this is duplicate of master file	*/
      370 		if last_master.dir = mstrpre.seg_dir &	/* just read from tape.  If so, skip it.  This	*/
      371 		   last_master.ent = mstrpre.seg_name &	/* can occur when exactly fit on end of one tape, */
      372 		   last_master.size.h = mhcnt &	/* but it got rewritten at start of next master 	*/
      373 		   last_master.size.s = mscnt then do;	/* tape, as well.				*/
      374 		     call ioa_ (
      375 "compare_dump_tape: ^a: NOTE: Skipping master file ^a, 
      376 which was duplicated within master volume set.", time(), 
      377 			pathname_ (last_master.dir, last_master.ent));
      378 		     go to next;
      379 		end;
      380 	     end;
      381 	     last_master.dir = mstrpre.seg_dir;
      382 	     last_master.ent = mstrpre.seg_name;
      383 	     last_master.size.h = mhcnt;
      384 	     last_master.size.s = mscnt;
      385 
      386 	     master_read = master_read + 1;
      387 	     if ^skip_copy_read then do;		/* read copy */
      388 next_copy:          call compare_copy_$rd_tape (hp, hcnt, seg_buff, scnt, code);
      389 		if code ^= 0 then do;
      390 		     if code ^= 1 | code ^= error_table_$end_of_info then
      391 			call com_err_ (code, "compare_dump_tape", "^a: Error reading copy tape.", time());
      392 		     call clean_up;
      393 		     return;
      394 		end;
      395 		if last_copy.dir ^= "" then do;	/* See if this is duplicate of master file	*/
      396 		     if last_copy.dir= cpypre.seg_dir &	/* just read from tape.  If so, skip it.  This	*/
      397 		        last_copy.ent= cpypre.seg_name &/* can occur when exactly fit on end of one tape, */
      398 		        last_copy.size.h = hcnt &	/* but it got rewritten at start of next master 	*/
      399 		        last_copy.size.s = scnt then do;/* tape, as well.				*/
      400 			call ioa_ (
      401 "compare_dump_tape: ^a: NOTE: Skipping copy file ^a, 
      402 which was duplicated within copy volume set.", time(), 
      403 			     pathname_ (last_copy.dir, last_copy.ent));
      404 			go to next_copy;
      405 		     end;
      406 		end;
      407 		last_copy.dir = cpypre.seg_dir;
      408 		last_copy.ent = cpypre.seg_name;
      409 		last_copy.size.h = hcnt;
      410 		last_copy.size.s = scnt;
      411 	     end;
      412 
      413 	     if common_info.selecting then		/* if we should skip uncopied portions */
      414 						/* of master tapes, then.... */
      415 		if mstrpre.seg_dir ^= cpypre.seg_dir
      416 		 | mstrpre.seg_name ^= cpypre.seg_name then do;
      417 						/* if the master and copy preambles don't match.. */
      418 
      419 		     skip_copy_read = "1"b;
      420 		     segs_skipped = segs_skipped + 1;	/* skip it and go on. */
      421 		     go to next;
      422 		     end;
      423 	     skip_copy_read = "0"b;			/* else we found a matching preamble */
      424 	     copy_read = copy_read + 1;
      425 	     if mhcnt ^= hcnt then do;		/* if the size of the preambles don't match... */
      426 		compare_dump_tape_severity_ = 3;
      427 		call ioa_ ("^a: ^a: Preamble ^d -- Preamble length discrepancy.
      428 		   Master = ^d, Copy = ^d", "compare_dump_tape", time(), segcnt, mhcnt, hcnt);
      429 		end;
      430 	     if mstrpre.seg_dir ^= cpypre.seg_dir
      431 	      | mstrpre.seg_name ^= cpypre.seg_name then do;
      432 						/* if the pathnames don't match... */
      433 		compare_dump_tape_severity_ = 3;
      434 		call ioa_ ("^a: ^a: Preamble ^d -- Pathname discrepancy.
      435 ^2-Master = ^a^/^2-Copy   = ^a",
      436 		   "compare_dump_tape", time(), segcnt,
      437 		   pathname_ ((mstrpre.seg_dir), (mstrpre.seg_name)),
      438 		   pathname_ ((cpypre.seg_dir), (cpypre.seg_name)));
      439 	     end;
      440 	     else if mhcnt ^= 0 then do;		/* if the master preamble length is not 0... */
      441 		if unspec (substr (unspec (master_preamble), 1, mhcnt * 36))
      442 		^= unspec (substr (unspec (copy_preamble), 1, mhcnt * 36)) then
      443 						/* compare whole block at once */
      444 		     do wdcnt = 0 to mhcnt-1;
      445 		     if master_preamble (wdcnt) ^= copy_preamble (wdcnt) then do;
      446 			compare_dump_tape_severity_ = 3;
      447 			call ioa_ ("^a: ^a: Preamble ^d -- Discrepancy in word ^o, Master = ^o, Copy = ^o",
      448 			   "compare_dump_tape", time(), segcnt, wdcnt, master_preamble (wdcnt), copy_preamble (wdcnt));
      449 			end;
      450 		     end;
      451 		end;
      452 	     if mscnt ^= scnt then do;		/* if seg lengths disagree... */
      453 		call ioa_ ("^a: ^a: Segment ^d -- Segment length discrepancy. Master = ^d, Copy = ^d",
      454 		   "compare_dump_tape", time(), segcnt, mscnt, scnt);
      455 		compare_dump_tape_severity_ = 3;
      456 		end;
      457 	     else if mscnt ^= 0 then do;		/* if seg length from master not 0... */
      458 		if unspec (substr (unspec (master_seg), 1, mscnt * 36)) ^=
      459 						/* check block at one time */
      460 		unspec (substr (unspec (copy_seg), 1, mscnt * 36)) then
      461 		     do wdcnt = 0 to mscnt-1;
      462 		     if master_seg (wdcnt) ^= copy_seg (wdcnt) then do;
      463 			compare_dump_tape_severity_ = 3;
      464 			call ioa_ ("^a: ^a: Segment ^d -- Discrepancy in word ^o, Master = ^o, Copy = ^o",
      465 			   "compare_dump_tape", time(), segcnt, wdcnt, master_seg (wdcnt), copy_seg (wdcnt));
      466 			end;
      467 		     end;
      468 		end;
      469 	     if hp -> h.record_type = sec_dir
      470 	      & hp -> h.bitcnt > 0 then		/* an MSF */
      471 		msf_count = msf_count + 1;
      472                else segcnt = segcnt + 1;		/* else an entry or MSF component. */
      473 	     total_on_copy = total_on_copy + 1;
      474 						/* not a good compare */
      475 	     if stop_sw then
      476 		if compare_dump_tape_severity_ ^= 0 then do;
      477 		     call clean_up;
      478 		     call ioa_ ("^a: ^a: Segment ^d contained discrepancies, verification aborted.", 
      479 		        "compare_dump_tape", time(), segcnt-1);
      480 		     return;
      481 		     end;
      482 		else;
      483 	     else;
      484 	end next;
      485 	
      486 
      487 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      488 
      489 
      490 terminate:
      491 	proc;
      492 
      493 	call release_temp_segment_ ((common_info.pname), hp, code);
      494 	call release_temp_segment_ ((common_info.pname), mp, code);
      495 	call release_temp_segment_ ((common_info.pname), mstr_buff, code);
      496 	call release_temp_segment_ ((common_info.pname), seg_buff, code);
      497 	return;
      498 	end terminate;
      499 	
      500 
      501 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      502 
      503 
      504 clean_up: proc;
      505 
      506 clean:	call compare_master_$input_finish;		/* if done, clean up i/o */
      507 	call compare_copy_$input_finish;
      508 	call terminate;
      509 	if common_info.selecting then
      510 	     call ioa_ ("^a: ^a: Master tape set:^/^4x^d read,^/^4x^d skipped.",
      511 	      "compare_dump_tape", time(), master_read, segs_skipped);
      512 	     
      513 	if segcnt > 0 | msf_count > 0 then do;
      514 	     call ioa_ ("^a: ^a: Copy tape set:^/^4x^d entries and ^d MSFs compared for a total of ^d.",
      515 	          "compare_dump_tape", time(), segcnt, msf_count, total_on_copy);
      516 	     if Ncopied > 0 then			/* Ncopied is ext variable set by prior		*/
      517 	     if Ncopied ^= total_on_copy then do;	/* copy_dump_tape command in this process.  If 	*/
      518 						/* variable has been set, then copy_dump_tape	*/
      519 						/* set it.  Presume we are comparing the same	*/
      520 						/* tapes just copied, and see if our count of	*/
      521 						/* copied items agrees with copy_dump_tape's.	*/
      522 		call ioa_ (
      523 "compare_dump_tape: ^a: ^d ^[item was^;items were^] copied by the preceding
      524 copy_dump_tape command, but only ^d ^[item was^;items were^] found by
      525 compare_dump_tape on the copy volume set.  Severity code prior to this
      526 count mismatch was ^d.",
      527 		     time(), Ncopied, Ncopied=1, 
      528 		     total_on_copy, total_on_copy=1, 
      529 		     compare_dump_tape_severity_);
      530 	          if compare_dump_tape_severity_ < 3 then
      531 		     compare_dump_tape_severity_ = 3;
      532 	     end;
      533 	end;
      534 	id_sw = False;
      535 	recurse_bit = False;
      536 	return;
      537 	end clean_up;
      538 
      539 
      540 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      541 
      542 
      543 time:	proc returns(char(6));
      544 
      545 dcl  clock			builtin,
      546      date				char(24),
      547      time				char(6);
      548 
      549 	call date_time_ (clock(), date);
      550 	time = substr(date, 11, 6);
      551 	return (time);
      552 
      553 	end time;
      554 
      555 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * 	*/
      556      
      557      
  1     2 /* Begin include file ... backup_preamble_header.incl.pl1 */
  1     3 /* Modified 1/29/73 by N. I. Morris */
  1     4 /* Modified 7/15/74 by R. E. Mullen */
  1     5 /* Modified 10/10/74 by A. Kobziar */
  1     6 
  1     7 dcl 1 h based aligned,				/* backup preamble (segment header) */
  1     8 
  1     9     2 dlen fixed binary,
  1    10     2 dname character (168),
  1    11     2 elen fixed binary,
  1    12     2 ename character (32),
  1    13     2 bitcnt fixed binary (24),
  1    14     2 record_type fixed binary,			/* Logical record type. */
  1    15     2 dtd fixed binary (52),				/* Date and time dump occurred. */
  1    16     2 dumper_id character (32),			/* Identification of dumper procedure. */
  1    17 
  1    18     2 bp bit (18),					/* Pointer to branches. */
  1    19     2 bc fixed binary,				/* Branch count. */
  1    20     2 lp bit (18),					/* Pointer to links. */
  1    21     2 lc fixed binary,				/* Link count. */
  1    22     2 aclp bit (18),				/* Pointer to ACL or CACL */
  1    23     2 aclc fixed binary,				/* ACL count. */
  1    24     2 actind bit (18),				/* File activity indicator */
  1    25     2 actime bit (36),				/* File activity time */
  1    26 
  1    27     2 quota fixed binary,				/* Record quota for directory_list record. */
  1    28     2 trp fixed binary (35),				/* Time-record product .. */
  1    29     2 tlu fixed binary (35),				/* Time last updated .. */
  1    30     2 inf_acct fixed binary,				/* Inferior account switch .. */
  1    31     2 term_acct fixed binary (1),			/* Terminal account switch .. */
  1    32     2 pad1 (3),					/* To even out area to 0 mod 8 */
  1    33 
  1    34     2 max_length fixed bin (18),			/* Max. length of segment */
  1    35     2 switches unal,
  1    36       3 safety_sw bit (1) unal,			/* Segment safety switch */
  1    37       3 entrypt_sw bit (1) unal,			/* "1"b -> call limiter enabled */
  1    38       3 security_oosw bit(1) unal,			/* security out-of-service */
  1    39       3 audit_flag bit(1) unal,			/* flag for seg reference auditing */
  1    40       3 multiple_class bit (1) unal,			/* system segment: access class may be higher than parent's */
  1    41       3 pad2 bit(2) unal,				/* =pad2 in dir_entry */
  1    42       3 master_dir bit (1) unal,			/* "1"b => was master dir */
  1    43       3 tpd bit (1) unal,				/* TRUE => never put on paging device */
  1    44       3 sw_pad bit (13) unal,				/* padding in this structure */
  1    45     2 entrypt_bound bit (14) unal,			/* Call limiter. */
  1    46     2 access_class bit(72),				/* access class of entry */
  1    47     2 spad bit(36),					/* last word of dir entry */
  1    48     2 status_version fixed bin,			/* version of status_for_backup struct */
  1    49     2 nss_info_relp bit (18) aligned,			/* NONZERO => NSS INFO */
  1    50     2 dq_info_relp bit (18) aligned,				/* NONZERO => DIRQUOTA INFO */
  1    51 
  1    52     2 inaclp (0:7) bit (18),				/* Pointer to initial ACL for each ring. */
  1    53     2 inaclc (0:7) fixed bin,				/* Initial ACL count for each ring. */
  1    54     2 dir_inaclp (0:7) bit (18),			/* Directory initial ACL pointer for each ring. */
  1    55     2 dir_inaclc (0:7) fixed bin,			/* Directory initial ACL count for each ring. */
  1    56 
  1    57     2 bitcount_author char (32),			/* last modifier of the bit count */
  1    58 
  1    59     2 list_area /* area */ (65408);			/* Area for list_dir and readacl. */
  1    60 
  1    61 dcl  author char (32) aligned based;			/* Author of entry */
  1    62 						/* N. B.  Author is an overlay starting at h.quota */
  1    63 
  1    64 /* End of include file ... backup_preamble_header.incl.pl1 */
  1    65 
      557 
      558      
      559      /*  BEGIN:   backup_record_types.incl.pl1		  *  *  *  *  *  */
  2     2 
  2     3 
  2     4 /****^  HISTORY COMMENTS:
  2     5*  1) change(87-01-05,GDixon), approve(87-04-15,MCR7617),
  2     6*     audit(87-06-22,RBarstad), install(87-07-15,MR12.1-1040):
  2     7*     Converted internal static variables to named constants.  Renamed
  2     8*     record_type array to RECORD_TYPE, to avoid naming conflict with
  2     9*     backup_preamble_header.incl.pl1's h.record_type variable.
  2    10*                                                   END HISTORY COMMENTS */
  2    11 
  2    12 
  2    13 /* Created June 1970, R H Campbell. */
  2    14 /* Modified 1/16/73 by N. I. Morris	*/
  2    15 /* Modified 7/17/75 by R. Bratt */
  2    16 /* Modified 11/04/83 by G. Dixon - better comments */
  2    17 
  2    18 dcl  ndc_segment fixed binary int static options(constant) initial (1);
  2    19 						/* Record of segment with NDC attributes */
  2    20 dcl  ndc_directory fixed binary int static options(constant) initial (2);
  2    21 						/* Record of directory with NDC attributes */
  2    22 dcl  ndc_directory_list fixed binary int static options(constant) initial (3);
  2    23 						/* Record of directory list with initial ACL */
  2    24 dcl  sec_seg fixed binary int static options(constant) initial(19);
  2    25 						/* Seg with security & call_limiter */
  2    26 dcl  sec_dir fixed binary int static options(constant) initial(20);
  2    27 						/* Dir with security & call_limiter */
  2    28 
  2    29 dcl  RECORD_TYPE (0: 20) character (10) aligned		/* Name of the record types. */
  2    30      int static options(constant)
  2    31      initial (*, "NDC seg", "NDC dir", "NDC dirlst", *, *, *, *,
  2    32 	    *, *, *, *, *, *, *, *,
  2    33 	    *, *, *, "SEG", "DIR");
  2    34 
  2    35 /* The following is an excerpt from a backup map showing the relationship
  2    36*   between entries in the backup map and the named constants given above.
  2    37*   I don't know under what conditions the ndc_seg and ndc_dir named constants
  2    38*   are ever used.  (G. Dixon)
  2    39*
  2    40*			        Map Excerpt
  2    41*   		 ---------------------------------------------
  2    42*Named Constant       ENTRY NAME                   BLOCKS REC_TYPE  
  2    43*
  2    44*sec_dir		 >library_dir_dir>system_library_unbundled
  2    45*		  object			     0 directory 
  2    46*			 o
  2    47*sec_dir		  source			     0 directory
  2    48*		           s
  2    49*
  2    50*ndc_directory_list	 >library_dir_dir>system_library_unbundled>object
  2    51*				               0 directory 
  2    52*sec_seg		  bound_gcos_tss_.1.archive	   104 segment   
  2    53*
  2    54*
  2    55*ndc_directory_list   >library_dir_dir>system_library_unbundled>source
  2    56*				               0 directory
  2    57*sec_seg               bound_gcos_tss_.1.s.archive	   134 segment
  2    58*
  2    59*
  2    60*						          */
  2    61 
  2    62 
  2    63 /*  END OF:  backup_record_types.incl.pl1		  *  *  *  *  *  */
      559 
      560      
      561      end compare_dump_tape;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/15/87  1600.0  compare_dump_tape.pl1             >special_ldd>install>MR12.1-1040>compare_dump_tape.pl1
557          1    04/29/76  1058.2  backup_preamble_header.incl.pl1   >ldd>include>backup_preamble_header.incl.pl1
559          2    07/15/87  1546.5  backup_record_types.incl.pl1      >spec>install>1040>backup_record_types.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
False                                  constant        bit(1)                   initial dcl 61 ref 189 199 202 204 205 212 213 214
                                                                                  215 216 239 299 301 309 311 534 535
Ncopied                         000056 external static fixed bin(17,0)          initial dcl 70 set ref 516 516 522* 522
True                                   constant        bit(1)                   initial dcl 61 ref 197 250 252 298 300 302 308 310
                                                                                  312
addr                                                   builtin function         dcl 183 ref 203
ap                              000100 automatic       pointer                  dcl 84 set ref 249* 250 250 252 254 254 255* 258 274
                                                                                  274 274 275* 278 294 294 294 294 304 304 304 304
                                                                                  316 321 325
arg                                    based           char                     unaligned dcl 168 set ref 250 250 252 254 254 258
                                                                                  274 274 274 278 294 294 294 294 304 304 304 304
                                                                                  316 321 325*
argcnt                          000102 automatic       fixed bin(17,0)          dcl 84 set ref 247* 248 248
argl                            000103 automatic       fixed bin(21,0)          dcl 84 set ref 249* 250 250 252 254 254 255* 258 274
                                                                                  274 274 275* 278 294 294 294 294 304 304 304 304
                                                                                  316 316 321 321 325 325
based_common_info                      based           structure                level 1 dcl 132
before                                                 builtin function         dcl 183 ref 335
bitcnt                   64            based           fixed bin(24,0)          level 2 dcl 1-7 ref 469
cdt_output_labels               000477 automatic       structure                level 2 dcl 158
cleanup                         001310 stack reference condition                dcl 178 ref 189 194 202 334
clock                                                  builtin function         dcl 545 ref 549 549
code                            000104 automatic       fixed bin(35,0)          dcl 84 set ref 191* 192* 226* 227 227 229* 230 230
                                                                                  232* 233 233 235* 236 236 237* 242* 243* 249* 255*
                                                                                  256 261* 275* 276 281* 336* 337 338* 342* 344 345*
                                                                                  355* 357 358 358* 360* 388* 389 390 390 390* 493*
                                                                                  494* 495* 496*
com_err_                        000016 constant        entry                    external dcl 33 ref 192 237 261 281 325 338 345 360
                                                                                  390
common_info                     000477 automatic       structure                level 1 dcl 158 set ref 203
compare_copy_$input_finish      000024 constant        entry                    external dcl 33 ref 507
compare_copy_$input_init        000020 constant        entry                    external dcl 33 ref 342
compare_copy_$rd_tape           000022 constant        entry                    external dcl 33 ref 388
compare_dump_tape_severity_     000062 external static fixed bin(17,0)          initial dcl 70 set ref 225* 351* 367* 426* 433* 446*
                                                                                  455* 463* 475 522* 530 530*
compare_master_$input_finish    000032 constant        entry                    external dcl 33 ref 506
compare_master_$input_init      000026 constant        entry                    external dcl 33 ref 336
compare_master_$rd_tape         000030 constant        entry                    external dcl 33 ref 355
copy_preamble                          based           fixed bin(35,0)          array dcl 169 set ref 441 445 447*
copy_read                       000105 automatic       fixed bin(17,0)          dcl 84 set ref 222* 424* 424
copy_seg                               based           fixed bin(35,0)          array dcl 169 set ref 458 462 464*
cp1                             000477 automatic       varying char(32)         array level 3 dcl 158 set ref 246* 270* 270 290* 290
                                                                                  321*
cpsw                            000106 automatic       bit(1)                   unaligned dcl 84 set ref 216* 301* 312* 319 333*
cpypre                                 based           structure                level 1 unaligned dcl 164
cu_$arg_count                   000034 constant        entry                    external dcl 33 ref 247
cu_$arg_ptr                     000036 constant        entry                    external dcl 33 ref 249 255 275
date                            000100 automatic       char(24)                 unaligned dcl 545 set ref 549* 550
date_time_                      000040 constant        entry                    external dcl 33 ref 549
dens                            000107 automatic       varying char(32)         dcl 84 set ref 258* 266 270
dir                             000161 automatic       char(168)                level 3 in structure "last_copy" packed unaligned
                                                                                  dcl 84 in procedure "compare_dump_tape" set ref
                                                                                  395 396 400* 400* 407*
dir                             000245 automatic       char(168)                level 3 in structure "last_master" packed unaligned
                                                                                  dcl 84 in procedure "compare_dump_tape" set ref
                                                                                  369 370 374* 374* 381*
ent                      52     000245 automatic       char(32)                 level 3 in structure "last_master" packed unaligned
                                                                                  dcl 84 in procedure "compare_dump_tape" set ref
                                                                                  370 374* 374* 382*
ent                      52     000161 automatic       char(32)                 level 3 in structure "last_copy" packed unaligned
                                                                                  dcl 84 in procedure "compare_dump_tape" set ref
                                                                                  396 400* 400* 408*
error_table_$badcall            000064 external static fixed bin(35,0)          dcl 70 ref 191
error_table_$badopt             000066 external static fixed bin(35,0)          dcl 70 set ref 325*
error_table_$end_of_info        000070 external static fixed bin(35,0)          dcl 70 ref 358 390
error_table_$segknown           000072 external static fixed bin(35,0)          dcl 70 ref 227 230 233 236
get_pdir_                       000042 constant        entry                    external dcl 33 ref 335
get_temp_segment_               000044 constant        entry                    external dcl 33 ref 226 229 232 235
h                        62     000161 automatic       fixed bin(35,0)          level 3 in structure "last_copy" dcl 84 in procedure
                                                                                  "compare_dump_tape" set ref 396 409*
h                        62     000245 automatic       fixed bin(35,0)          level 3 in structure "last_master" dcl 84
                                                                                  in procedure "compare_dump_tape" set ref 370 383*
h                                      based           structure                level 1 dcl 1-7 in procedure "compare_dump_tape"
hcnt                            000120 automatic       fixed bin(35,0)          dcl 84 set ref 388* 396 409 425 427*
hcs_$set_max_length_seg         000046 constant        entry                    external dcl 33 ref 242 243
hp                              000122 automatic       pointer                  dcl 84 set ref 229* 388* 396 396 407 408 413 413 430
                                                                                  430 434 434 434 434 441 445 447 469 469 493*
i                               000124 automatic       fixed bin(17,0)          dcl 84 set ref 217* 248* 249* 255 257* 257 275 277*
                                                                                  277*
id_sw                           000010 internal static bit(1)                   initial unaligned dcl 61 set ref 198 199* 202* 534*
in_reel                 453     000477 automatic       varying char(32)         array level 2 dcl 158 set ref 245* 266* 266 286* 286
                                                                                  316*
info_p                          000012 internal static pointer                  dcl 61 set ref 203* 336* 342*
input_descrip                   000125 automatic       varying char(100)        dcl 84 set ref 187*
insw                    450     000477 automatic       bit(1)                   level 2 dcl 158 set ref 330*
inswcp                  451     000477 automatic       bit(1)                   level 2 dcl 158 set ref 332*
ioa_                            000050 constant        entry                    external dcl 33 ref 200 349 365 374 400 427 434 447
                                                                                  453 464 478 509 514 522
j                               000157 automatic       fixed bin(17,0)          dcl 84 set ref 218* 315* 315 316
k                               000160 automatic       fixed bin(17,0)          dcl 84 set ref 219* 264* 266 266* 268* 270 270* 272*
                                                                                  284* 286 286* 288* 290 290* 292* 320* 320 321
last_copy                       000161 automatic       structure                level 1 dcl 84
last_master                     000245 automatic       structure                level 1 dcl 84
master_preamble                        based           fixed bin(35,0)          array dcl 169 set ref 441 445 447*
master_read                     000331 automatic       fixed bin(17,0)          dcl 84 set ref 221* 386* 386 509*
master_seg                             based           fixed bin(35,0)          array dcl 169 set ref 458 462 464*
mhcnt                           000332 automatic       fixed bin(35,0)          dcl 84 set ref 355* 364 370 383 425 427* 440 441 441
                                                                                  441
mp                              000334 automatic       pointer                  dcl 84 set ref 226* 355* 370 370 381 382 413 413 430
                                                                                  430 434 434 434 434 441 445 447 494*
mscnt                           000336 automatic       fixed bin(35,0)          dcl 84 set ref 355* 370 384 452 453* 457 458 458 458
msf_count                       000337 automatic       fixed bin(17,0)          dcl 84 set ref 220* 469* 469 513 514*
mssw                            000340 automatic       bit(1)                   unaligned dcl 84 set ref 215* 300* 311* 314 331*
mstr_buff                       000342 automatic       pointer                  dcl 84 set ref 232* 243* 355* 458 462 464 495*
mstrpre                                based           structure                level 1 unaligned dcl 160
next_in                 605     000477 automatic       fixed bin(17,0)          level 2 dcl 158 set ref 207*
next_incp               606     000477 automatic       fixed bin(17,0)          level 2 dcl 158 set ref 208*
nin                     607     000477 automatic       fixed bin(17,0)          level 2 dcl 158 set ref 210* 264 264 284 284 317*
                                                                                  317
nincp                   610     000477 automatic       fixed bin(17,0)          level 2 dcl 158 set ref 211* 268 268 288 288 322*
                                                                                  322
output_descrip                  000344 automatic       varying char(100)        dcl 84 set ref 188*
path                            000245 automatic       structure                level 2 in structure "last_master" packed unaligned
                                                                                  dcl 84 in procedure "compare_dump_tape" set ref
                                                                                  352*
path                            000161 automatic       structure                level 2 in structure "last_copy" packed unaligned
                                                                                  dcl 84 in procedure "compare_dump_tape" set ref
                                                                                  352*
pathname_                       000052 constant        entry                    external dcl 33 ref 374 374 400 400 434 434 434 434
pd                              000376 automatic       varying char(168)        dcl 84 set ref 335*
pname                   424     000477 automatic       varying char(32)         level 2 dcl 158 set ref 209* 226 229 232 235 493 494
                                                                                  495 496
record_type              65            based           fixed bin(17,0)          level 2 dcl 1-7 ref 469
recurse_bit                     000014 internal static bit(1)                   initial unaligned dcl 61 set ref 189* 190 197* 202*
                                                                                  239* 535*
release_temp_segment_           000054 constant        entry                    external dcl 33 ref 493 494 495 496
s                        63     000161 automatic       fixed bin(35,0)          level 3 in structure "last_copy" dcl 84 in procedure
                                                                                  "compare_dump_tape" set ref 396 410*
s                        63     000245 automatic       fixed bin(35,0)          level 3 in structure "last_master" dcl 84
                                                                                  in procedure "compare_dump_tape" set ref 370 384*
scnt                            000451 automatic       fixed bin(35,0)          dcl 84 set ref 388* 396 410 452 453*
sec_dir                                constant        fixed bin(17,0)          initial dcl 2-26 ref 469
seg_buff                        000452 automatic       pointer                  dcl 84 set ref 235* 242* 388* 458 462 464 496*
seg_dir                                based           varying char(168)        level 2 in structure "cpypre" dcl 164 in procedure
                                                                                  "compare_dump_tape" ref 396 407 413 430 434 434
seg_dir                                based           varying char(168)        level 2 in structure "mstrpre" dcl 160 in procedure
                                                                                  "compare_dump_tape" ref 370 381 413 430 434 434
seg_name                 53            based           varying char(32)         level 2 in structure "cpypre" dcl 164 in procedure
                                                                                  "compare_dump_tape" ref 396 408 413 430 434 434
seg_name                 53            based           varying char(32)         level 2 in structure "mstrpre" dcl 160 in procedure
                                                                                  "compare_dump_tape" ref 370 382 413 430 434 434
segcnt                          000454 automatic       fixed bin(35,0)          dcl 84 set ref 244* 365* 427* 434* 447* 453* 464*
                                                                                  472* 472 478 513 514*
segs_skipped                    000455 automatic       fixed bin(35,0)          dcl 84 set ref 206* 420* 420 509*
selecting               435     000477 automatic       bit(1)                   level 2 dcl 158 set ref 205* 252* 413 509
set_c_options                   000456 automatic       bit(1)                   unaligned dcl 84 set ref 268 288 299* 308*
set_cpsw                        000457 automatic       bit(1)                   unaligned dcl 84 set ref 214* 310* 332 333
set_m_options                   000460 automatic       bit(1)                   unaligned dcl 84 set ref 264 284 298* 309*
set_mssw                        000461 automatic       bit(1)                   unaligned dcl 84 set ref 213* 302* 330 331
size                     62     000245 automatic       structure                level 2 in structure "last_master" dcl 84
                                                                                  in procedure "compare_dump_tape" set ref 353*
size                     62     000161 automatic       structure                level 2 in structure "last_copy" dcl 84 in procedure
                                                                                  "compare_dump_tape" set ref 353*
skip_copy_read                  000462 automatic       bit(1)                   dcl 84 set ref 204* 387 419* 423*
stop_sw                         000463 automatic       bit(1)                   dcl 84 set ref 212* 250* 475
substr                                                 builtin function         dcl 183 ref 316 321 441 441 458 458 550
sys_info$max_seg_size           000060 external static fixed bin(35,0)          dcl 70 set ref 242* 243*
time                            000106 automatic       char(6)                  unaligned dcl 545 set ref 550* 551
total_on_copy                   000464 automatic       fixed bin(17,0)          dcl 84 set ref 223* 473* 473 514* 516 522* 522
track                           000465 automatic       varying char(32)         dcl 84 set ref 278* 286 290
unspec                                                 builtin function         dcl 183 ref 441 441 441 441 458 458 458 458
wdcnt                           000476 automatic       fixed bin(35,0)          dcl 84 set ref 441* 445 445 447* 447 447* 458* 462
                                                                                  462 464* 464 464*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
RECORD_TYPE                            internal static char(10)                 initial array dcl 2-29
author                                 based           char(32)                 dcl 1-61
ndc_directory                          internal static fixed bin(17,0)          initial dcl 2-20
ndc_directory_list                     internal static fixed bin(17,0)          initial dcl 2-22
ndc_segment                            internal static fixed bin(17,0)          initial dcl 2-18
sec_seg                                internal static fixed bin(17,0)          initial dcl 2-24

NAMES DECLARED BY EXPLICIT CONTEXT.
bad_arg                         001527 constant        label                    dcl 261
buff_err                        001271 constant        label                    dcl 237 ref 227 230 233
clean                           004431 constant        label                    dcl 506
clean_up                        004424 constant        entry                    internal dcl 504 ref 326 334 339 346 361 392 477
compare_dump_tape               000663 constant        entry                    external dcl 9
next                            002636 constant        label                    dcl 354 ref 378 421
next_copy                       003120 constant        label                    dcl 388 ref 404
terminate                       004242 constant        entry                    internal dcl 490 ref 238 508
time                            004702 constant        entry                    internal dcl 543 ref 200 200 338 338 345 345 349 349
                                                                                  360 360 365 365 374 374 390 390 400 400 427 427
                                                                                  434 434 447 447 453 453 464 464 478 478 509 509
                                                                                  514 514 522 522

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      5270        5364    4737        5300
Length      5704    4737        74         303     331           6

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
compare_dump_tape                   890 external procedure  is an external procedure.  
on unit on line 189                  64 on unit               
on unit on line 202                  65 on unit               
on unit on line 334                  64 on unit               
terminate                            82 internal procedure  is called by several nonquick procedures.  
clean_up                            232 internal procedure  is called by several nonquick procedures.  
time                                 84 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 id_sw                       compare_dump_tape
000012 info_p                      compare_dump_tape
000014 recurse_bit                 compare_dump_tape

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
compare_dump_tape        000100 ap                          compare_dump_tape
                         000102 argcnt                      compare_dump_tape
                         000103 argl                        compare_dump_tape
                         000104 code                        compare_dump_tape
                         000105 copy_read                   compare_dump_tape
                         000106 cpsw                        compare_dump_tape
                         000107 dens                        compare_dump_tape
                         000120 hcnt                        compare_dump_tape
                         000122 hp                          compare_dump_tape
                         000124 i                           compare_dump_tape
                         000125 input_descrip               compare_dump_tape
                         000157 j                           compare_dump_tape
                         000160 k                           compare_dump_tape
                         000161 last_copy                   compare_dump_tape
                         000245 last_master                 compare_dump_tape
                         000331 master_read                 compare_dump_tape
                         000332 mhcnt                       compare_dump_tape
                         000334 mp                          compare_dump_tape
                         000336 mscnt                       compare_dump_tape
                         000337 msf_count                   compare_dump_tape
                         000340 mssw                        compare_dump_tape
                         000342 mstr_buff                   compare_dump_tape
                         000344 output_descrip              compare_dump_tape
                         000376 pd                          compare_dump_tape
                         000451 scnt                        compare_dump_tape
                         000452 seg_buff                    compare_dump_tape
                         000454 segcnt                      compare_dump_tape
                         000455 segs_skipped                compare_dump_tape
                         000456 set_c_options               compare_dump_tape
                         000457 set_cpsw                    compare_dump_tape
                         000460 set_m_options               compare_dump_tape
                         000461 set_mssw                    compare_dump_tape
                         000462 skip_copy_read              compare_dump_tape
                         000463 stop_sw                     compare_dump_tape
                         000464 total_on_copy               compare_dump_tape
                         000465 track                       compare_dump_tape
                         000476 wdcnt                       compare_dump_tape
                         000477 common_info                 compare_dump_tape
time                     000100 date                        time
                         000106 time                        time

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this
call_int_other      return_mac          enable_op           shorten_stack       ext_entry           int_entry
clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      compare_copy_$input_finish    compare_copy_$input_init      compare_copy_$rd_tape
compare_master_$input_finish  compare_master_$input_init    compare_master_$rd_tape       cu_$arg_count
cu_$arg_ptr                   date_time_                    get_pdir_                     get_temp_segment_
hcs_$set_max_length_seg       ioa_                          pathname_                     release_temp_segment_

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
Ncopied                       compare_dump_tape_severity_   error_table_$badcall          error_table_$badopt
error_table_$end_of_info      error_table_$segknown         sys_info$max_seg_size




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
      9 000662       187 000670       188 000675       189 000701       190 000717       191 000722       192 000724
    194 000752       195 000753       197 000754       198 000756       199 000760       200 000761       202 001021
    203 001041       204 001044       205 001045       206 001046       207 001047       208 001050       209 001051
    210 001056       211 001057       212 001060       213 001061       214 001062       215 001063       216 001064
    217 001065       218 001066       219 001067       220 001070       221 001071       222 001072       223 001073
    225 001074       226 001076       227 001126       229 001134       230 001165       232 001173       233 001224
    235 001232       236 001263       237 001271       238 001317       239 001323       240 001325       242 001326
    243 001341       244 001354       245 001355       246 001367       247 001401       248 001410       249 001421
    250 001436       252 001453       254 001462       255 001472       256 001512       257 001514       258 001515
    259 001526       261 001527       262 001556       264 001557       266 001571       267 001631       268 001635
    270 001647       271 001707       272 001712       273 001713       274 001714       275 001730       276 001750
    277 001752       278 001753       279 001764       281 001765       282 002017       284 002020       286 002033
    287 002073       288 002077       290 002111       291 002151       292 002154       293 002155       294 002156
    298 002176       299 002200       300 002201       301 002202       302 002203       303 002204       304 002205
    308 002225       309 002227       310 002230       311 002231       312 002232       313 002233       314 002234
    315 002236       316 002237       317 002253       318 002254       319 002255       320 002257       321 002260
    322 002274       323 002275       325 002276       326 002333       327 002337       329 002340       330 002342
    331 002344       332 002345       333 002347       334 002350       335 002372       336 002415       337 002426
    338 002430       339 002471       340 002475       342 002476       344 002507       345 002511       346 002552
    347 002556       349 002557       351 002614       352 002616       353 002632       355 002636       357 002655
    358 002657       360 002664       361 002725       362 002731       364 002732       365 002734       367 002775
    369 003000       370 003004       374 003025       378 003077       381 003100       382 003105       383 003111
    384 003113       386 003115       387 003116       388 003120       389 003137       390 003141       392 003207
    393 003213       395 003214       396 003220       400 003241       404 003313       407 003314       408 003321
    409 003325       410 003327       413 003331       419 003351       420 003353       421 003357       423 003360
    424 003361       425 003362       426 003365       427 003370       430 003437       433 003455       434 003460
    439 003634       440 003636       441 003640       445 003660       446 003664       447 003667       450 003742
    452 003747       453 003752       455 004021       456 004024       457 004025       458 004027       462 004052
    463 004056       464 004061       467 004134       469 004141       472 004151       473 004155       475 004156
    477 004163       478 004167       480 004236       484 004237       561 004240       490 004241       493 004247
    494 004300       495 004333       496 004366       497 004421       504 004423       506 004431       507 004435
    508 004442       509 004447       513 004521       514 004526       516 004600       522 004606       530 004667
    534 004675       535 004677       536 004700       543 004701       549 004707       550 004726       551 004731


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
