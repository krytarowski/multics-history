	COMPILATION LISTING OF SEGMENT terminal_report
	Compiled by: Multics PL/I Compiler, Release 30, of February 16, 1988
	Compiled at: Honeywell Bull, Phoenix AZ, SysM
	Compiled on: 07/13/88  1009.6 mst Wed
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1986 *
        6*        *                                                         *
        7*        *********************************************************** */
        8 
        9 
       10 /****^  HISTORY COMMENTS:
       11*  1) change(86-11-12,Parisek), approve(86-12-18,MCR7588),
       12*     audit(87-07-17,Johnson), install(87-08-07,MR12.1-1070):
       13*     Initially coded to scan the system answering service logs for login and
       14*     logout messages, and build a list of used terminal types based on this
       15*     information.
       16*                                                   END HISTORY COMMENTS */
       17 
       18 terminal_report:
       19 	proc;
       20 
       21 	log_read_ptr, log_message_ptr, vptr, sci_ptr, vptr_ansb, vptr_two,
       22 	     temp_ptr, temp_two_ptr, ttp_tot_ptr, temp_as_ptr = null ();
       23 
       24 	on cleanup begin;
       25 	     if sci_ptr ^= null () then
       26 		call ssu_$destroy_invocation (sci_ptr);
       27 	end;
       28 	
       29 	call ssu_$standalone_invocation (sci_ptr, "terminal_report", "1.0",
       30 	     cu_$arg_list_ptr (), ssu_abort, code);
       31 	if code ^= 0 then do;
       32 	     call com_err_ (code, "terminal_report", "Failed to create ssu_ invocation.");
       33 	     return;
       34 	end;					/* Using ssu_ entries because calls to log subroutines require the sci_ptr */
       35 
       36 	call initialize_options ();
       37 	
       38 	on condition (cleanup)
       39 	     call clean_up ();
       40 	
       41 	call log_match_$add_match (opt.lmd_ptr, "LOGIN");
       42 						/* scan the logs for LOGIN messages only */
       43 	call process_arguments ();			/* validate arguments */
       44 	if ttpsw & usersw then do;
       45 	     call ssu_$abort_line (sci_ptr, error_table_$inconsistent, "-user and -ttp");
       46 	     call clean_up;
       47 	end;
       48 	if output_file ^= "" then do;			/* not default */
       49 	     call iox_$attach_name ("terminal_report_output", opt.iocb,
       50 		"vfile_ " || output_file, null, code);
       51 	     if code ^= 0 then do;
       52 		call ssu_$abort_line (sci_ptr, code, "Could not attach to ^a", output_file);
       53 		call clean_up ();
       54 	     end;
       55 	     attached = "1"b;			/* output file is attached */
       56 	     call iox_$open (opt.iocb, 2, ""b, code);
       57 	     if code ^= 0 then do;
       58 		call ssu_$abort_line (sci_ptr, code, "Could not open file ^a", output_file);
       59 		call iox_$detach_iocb (opt.iocb, code);
       60 		call clean_up ();
       61 	     end;
       62 	     opened = "1"b;				/* output file is opened */
       63 	end;
       64 
       65 	if opt.reader_procedure = "" then do;
       66 	     call log_read_$open (">sc1>as_logs", "log", log_read_ptr, code);
       67 	end;					/* get ptr to log segment */
       68 	if code ^= 0 then 
       69 	     call ssu_$abort_line (sci_ptr, code, "Cannot open log");
       70 
       71 	call log_limit_scan_ (sci_ptr, addr(opt.limit), "0"b, log_read_ptr);
       72 						/* determine where to start & stop in log scanning */
       73 	log_message_ptr = opt.first_msg;
       74 	first_msg_count, ansb_msg_count, index_count = 0;
       75 						/* initialize */
       76 
       77 	call get_temp_segments_ ("terminal_report", temp_ptrs, code);
       78 	if code ^= 0 then do;
       79 	     call com_err_ (code, "terminal_report", "Error opening temporary segment.");
       80 	     call clean_up ();
       81 	end;
       82 	temp_ptr = temp_ptrs (1);
       83 	temp_as_ptr = temp_ptrs (2);
       84 	temp_two_ptr = temp_ptrs (3);
       85 	ttp = temp_ptrs (4);
       86 	ttp_tot_ptr = temp_ptrs (5);
       87 
       88 	on condition (out_of_bounds)
       89 	     call oob ();				/* it's possible we will fill a temp segment past 255K */
       90 
       91 	call system_info_$titles (coxx, dpxx, cods, dpds);
       92 						/* Report banner stuff */
       93 	call ioa_$ioa_switch (opt.iocb, "^a^/^a^/", cods, dpds);
       94 	if opt.first_msg = null () then
       95 	     call ioa_$ioa_switch (opt.iocb, "Terminal report to ^a^3/", 
       96 	     log_format_time_ ((opt.last_msg -> log_message.time)));
       97 	else if opt.last_msg = null () then
       98 	     call ioa_$ioa_switch (opt.iocb, "Terminal report from ^a^3/", 
       99 	     log_format_time_ ((opt.first_msg -> log_message.time)));
      100 	else call ioa_$ioa_switch (opt.iocb, "Terminal report from ^a to ^a^3/", 
      101 	     log_format_time_ ((opt.first_msg -> log_message.time)),
      102 	     log_format_time_ ((opt.last_msg -> log_message.time)));
      103 
      104 scan_log: 
      105 	do while (log_message_ptr ^= null ());
      106 	     if log_match_$test (opt.lmd_ptr, log_message_ptr, "") then do;
      107 						/* find log message containing info we want, based on match data */
      108 		audit_record_ptr = addr (log_message.data (1));
      109 		audit_record_size = dimension (log_message.data, 1);
      110 		info_ptr = audit_record_ptr;
      111 		info_size = audit_record_size;
      112 		info_size = info_size - size (audit_record_header);
      113 		info_ptr = addrel (info_ptr, size (audit_record_header));
      114 						/* ptr to expanded data */
      115 		if info_size > 0 & audit_record_header.subject.tag = "a"
      116 		     & audit_record_header.subject.process_id = ""b then do;
      117 						/* interactive only */
      118 		     if looking_for ^= "" then do;
      119 			if usersw then do;
      120 			     if audit_record_header.subject.person ^= choosen_name then goto Next;
      121 			end;
      122 			else do;
      123 			     if rtrim(info_ptr -> as_ia_audit_record_.terminal_type)
      124 				^= rtrim(looking_for) then goto Next;
      125 			end;			/* skip message if TTP match not found when -match was given */
      126 		     end;
      127 		     first_msg_count = first_msg_count + 1;
      128 						/* increment valid message count */
      129 		     temp.ttp (first_msg_count) = info_ptr -> as_ia_audit_record_.terminal_type;
      130 		     temp.name (first_msg_count) = audit_record_header.subject.person;
      131 		     temp.chn (first_msg_count) = info_ptr -> as_ia_audit_record_.channel;
      132 		     temp.ansb (first_msg_count) = info_ptr -> as_ia_audit_record_.answerback;
      133 		     temp_as.ansb (first_msg_count) = info_ptr -> as_ia_audit_record_.answerback;
      134 		     temp.time (first_msg_count) = log_message.time;
      135 		     temp.cpu (first_msg_count), temp.connect (first_msg_count) = "";
      136 						/* fill in temp array data */
      137 		     if index (log_message.text, "DENIED") ^= 0 then do;
      138 						/* if this is a "LOGIN DENIED" message */
      139 			temp.failed (first_msg_count) = "1"b;
      140 			failsw = "1"b;
      141 			call add_ttp_data ();
      142 			failsw = ""b;
      143 			first_msg_count = first_msg_count - 1;
      144 			goto Next;
      145 		     end;
      146 		     else do;
      147 			temp.failed (first_msg_count) = ""b;
      148 			call add_ttp_data ();
      149 		     end;
      150 		     temp.logins (first_msg_count) = 1;
      151 		     if ^mtsw then do;
      152 			call check_for_dups (MCH);
      153 			if MCH then first_msg_count = first_msg_count - 1;
      154 			goto Next;
      155 		     end;
      156 		     NAME = rtrim(temp.name (first_msg_count));
      157 		     CHN = rtrim(temp.chn (first_msg_count));
      158 		     TIME = temp.time (first_msg_count);
      159 		     auto_log_read_ptr = log_read_ptr;
      160 		     auto_log_message_ptr = log_message_ptr;
      161 		     call scan_LOGOUTS (NAME, CHN, TIME);
      162 						/* called only for looking up cpu & connect data */
      163 		     log_message_ptr = auto_log_message_ptr;
      164 		     log_read_ptr = auto_log_read_ptr;
      165 		end;
      166                end;
      167 
      168 Next:
      169 	     call log_read_$next_message (log_read_ptr, log_message_ptr, code);
      170 	     if code = error_table_$no_log_message then log_message_ptr = null ();
      171 						/* find next log message */
      172 	     if log_message_ptr = opt.last_msg then goto sort_em;
      173 	     else goto scan_log;
      174 	end;
      175 
      176 sort_em:						/* sort items */
      177 
      178 	vptr = pointer (temp_ptr, currentsize (temp));
      179 	vptr_ansb = pointer (temp_as_ptr, currentsize (temp_as));
      180 	vptr_two = pointer (ttp_tot_ptr, currentsize (ttp_tot));
      181 
      182 	V.n = first_msg_count;
      183 	V_thr.n_thr = first_msg_count;
      184 
      185 	do inx = 1 to V.n;
      186 	     V.vector (inx) = addr (temp_ptr -> temp.data (inx));
      187 	end;
      188 
      189 	do inx = 1 to V_thr.n_thr;
      190 	     V_thr.vector_thr (inx) = addr (temp_as_ptr -> temp_as.ansbs (inx));
      191 	end;
      192 
      193 	V_two.n_two = ttx;
      194 	do inx = 1 to V_two.n_two;
      195 	     V_two.vector_two (inx) = addr (ttp_tot_ptr -> ttp_tot.tot_data (inx));
      196 	end;
      197 	if V.n > 1 then call sort_items_$varying_char (vptr);
      198 	if V_two.n_two > 1 then call sort_items_$varying_char (vptr_two);
      199 	if V_thr.n_thr > 1 then call sort_items_$varying_char (vptr_ansb);
      200 
      201 	if mtsw then call ioa_$ioa_switch (opt.iocb, 
      202 	     "Terminal usage sorted by type:^50t(*) = Still active^2/");
      203 	else call ioa_$ioa_switch (opt.iocb, 
      204 	     "Terminal usage sorted by type:^2/");
      205 	if mtsw then call ioa_$ioa_switch (opt.iocb, 
      206 	     "Type^36tLogins^50tNologins^62tCpu^70tConnect^/");
      207 	else call ioa_$ioa_switch (opt.iocb, "Type^36tLogins^50tNologins^/");
      208 	if mtsw then do;
      209 	     ttp_meters, final_tab = "1"b;
      210 	end;
      211 	do inx = 1 to ttx;
      212 	     tot_logi, tot_logo = 0;
      213 	     tot_cpu, tot_connect = "";
      214 	     do inxx = 1 to V_two.vector_two (inx) -> ttp_tot_data.ascnt;
      215 		tot_logi = tot_logi + V_two.vector_two (inx) 
      216 		     -> ttp_tot_data.ansbks.login (inxx);
      217 		tot_logo = tot_logo + V_two.vector_two (inx) 
      218 		     -> ttp_tot_data.ansbks.fails (inxx);
      219 		if mtsw then do;
      220 		     add_cpus = "1"b;
      221 		     if tot_cpu = "" then tot_cpu = "000:00";
      222 		     call add_common_times ();
      223 		     add_cpus = ""b;
      224 		     if tot_connect = "" then tot_connect = "00000:00";
      225 		     call add_common_times ();
      226 		end;
      227 	     end;
      228 						/* add up number of logins and failed logins */
      229 
      230 	     if mtsw then call ioa_$ioa_switch (opt.iocb, "^a^36t^5d^50t^5d^60t^a^70t^a", 
      231 		V_two.vector_two (inx) -> ttp_tot_data.type, tot_logi, tot_logo, tot_cpu, tot_connect);
      232 	     else call ioa_$ioa_switch (opt.iocb, "^a^36t^5d^50t^5d", 
      233 		V_two.vector_two (inx) -> ttp_tot_data.type, tot_logi, tot_logo);
      234 	end;
      235 	if ttp_meters then ttp_meters, final_tab = ""b;
      236 
      237 	if mtsw then call ioa_$ioa_switch (opt.iocb, 
      238 	     "^3/Terminal usage sorted by Answerback:^50t(*) = Still active^2/");
      239 	else call ioa_$ioa_switch (opt.iocb, 
      240 	     "^3/Terminal usage sorted by Answerback:^2/");
      241 	if mtsw then call ioa_$ioa_switch (opt.iocb, 
      242 	     "Ansbk^8tType^38tLogins^52tNologins^64tCpu^72tConnect");
      243 	else call ioa_$ioa_switch (opt.iocb, 
      244 	     "Ansbk^8tType^38tLogins^52tNologins");
      245 	call ioa_$ioa_switch (opt.iocb, "^10tUser");
      246 	call output_data ();
      247 
      248 	call clean_up;
      249 	return;
      250 
      251 						/* procedure for determining cpu times */
      252 get_cpu_time:
      253 	proc ();
      254 
      255 	datax = index (temp_two.text (1), "$") - 7;
      256 	cpu_data = substr (temp_two.text (1), datax, 6);
      257 	temp.cpu (first_msg_count) = cpu_data;
      258 	call get_connect_time ();
      259 	ttp_meters = "1"b;
      260 	call add_ttp_data ();
      261 	ttp_meters = ""b;
      262 	return;
      263 
      264      end get_cpu_time;
      265 
      266 	
      267 check_for_dups:					/* procedure to add cpu times up if user 
      268*	     & ttp are listed in our temp array more than once */
      269           proc (match_made);
      270 
      271 dcl match_made bit (1) aligned parameter;
      272 
      273 	if first_msg_count < 2 then return;
      274 	match_made = ""b;
      275 	do inx = 1 to first_msg_count-1;
      276 	     if rtrim(temp.ttp (inx)) = rtrim(temp.ttp (first_msg_count)) & 
      277 		rtrim(temp.name (inx)) = rtrim(temp.name (first_msg_count)) &
      278 		rtrim(temp.ansb (inx)) = rtrim(temp.ansb (first_msg_count)) then do;
      279 		temp.logins (inx) = temp.logins (inx) + 1;
      280 		if ^mtsw then do;
      281 		     match_made = "1"b;
      282 		     return;
      283 		end;
      284 		if index (temp.cpu (inx), ":") ^= 0 &
      285 		     rtrim(temp.cpu (first_msg_count)) = "" then 
      286 		     temp.cpu (inx) = rtrim(temp.cpu (inx)) || " (*)";
      287 		else if index (temp.cpu (first_msg_count), ":") ^= 0 &
      288 		     rtrim(temp.cpu (inx)) = "" then 
      289 		     temp.cpu (inx) = rtrim(temp.cpu (first_msg_count)) || " (*)";
      290 		else if index (temp.cpu (inx), ":") ^= 0 then do;
      291 		     add_cpus = "1"b;     
      292 		     call add_common_times ();
      293 		     add_cpus = ""b;
      294 		     call add_common_times ();
      295 		end;
      296 		match_made = "1"b;			/* match was found */
      297 		return;
      298 	     end;
      299 	end;
      300 	return;
      301 	
      302      end check_for_dups;
      303 
      304 
      305 get_connect_time:					/* procedure to determine connect times */
      306           proc ();
      307 
      308 dcl date_time_$from_clock_interval entry (fixed bin(71), fixed bin(71), ptr, fixed bin(35));
      309 dcl 1 to aligned like time_offset;
      310 dcl 1 toa aligned like time_offset_array;
      311 dcl (time_one, time_two) fixed bin (71);
      312 dcl (ihour, imin, isec) fixed bin;
      313 dcl connect_time char (8);
      314 
      315 	to.version, toa.version = Vtime_offset_2;
      316 	toa.flag (1) = UNUSED;
      317 	toa.flag (2) = UNUSED;
      318 	toa.flag (3) = UNUSED;
      319 	toa.flag (4) = UNUSED;
      320 	toa.flag (5) = INTEGER;
      321 	toa.flag (6) = INTEGER;
      322 	toa.flag (7) = INTEGER;
      323 	toa.flag (8) = UNUSED;
      324 	time_one = temp_two.time (1);
      325 	time_two = temp.time (first_msg_count);
      326 	call date_time_$from_clock_interval (time_two, time_one, addr(toa), code);
      327 	ihour = toa.val (5) + .0;
      328 	imin = toa.val (6) + .0;
      329 	isec = toa.val (7) + .0;
      330 	imin = imin + ihour*60;
      331 	call ioa_$rsnnl ("^5d:^2d", connect_time, len, imin, isec);
      332 	temp.connect (first_msg_count) = connect_time;
      333 	
      334 	return;
      335      end get_connect_time;
      336 	
      337 
      338 add_common_times:					/* procedure to add cpu/connect times for common ttps/users */
      339           proc ();
      340 
      341 dcl (common_temp, common_tempx) char (8);
      342 dcl (sub_one_one, sub_one_two, sub_two_one, sub_two_two,
      343 	common_min_char, common_sec_char) char (5);
      344 dcl (common_one_one, common_one_two, common_two_one, common_two_two,
      345 	common_min, common_sec) fixed bin;
      346 
      347 	if ttp_meters then do;
      348 	     if add_cpus then do;
      349 		if final_tab then do;
      350 		     common_temp = rtrim(V_two.vector_two (inx) -> 
      351 			ttp_tot_data.ansbks.cpu (inxx));
      352 		     common_tempx = rtrim(tot_cpu);
      353 		end;
      354 		else do;
      355 		     common_temp = rtrim(temp.cpu (first_msg_count));
      356 		     common_tempx = rtrim(tot_cpu);
      357 		end;
      358 	     end;
      359 	     else do;
      360 		if final_tab then do;
      361 		     common_temp = rtrim(V_two.vector_two (inx) ->
      362 			ttp_tot_data.ansbks.connect (inxx));
      363 		     common_tempx = rtrim(tot_connect);
      364 		end;
      365 		else do;
      366 		     common_temp = rtrim(temp.connect (first_msg_count));
      367 		     common_tempx = rtrim(tot_connect);
      368 		end;
      369 	     end;
      370 	end;
      371 
      372 	else do;
      373 	     if add_cpus then do;
      374 		common_temp = rtrim(temp.cpu (inx));
      375 		common_tempx = rtrim(temp.cpu (first_msg_count));
      376 	     end;
      377 	     else do;
      378 		common_temp = rtrim(temp.connect (inx));
      379 		common_tempx = rtrim(temp.connect (first_msg_count));
      380 	     end;
      381 	end;
      382 
      383 	if add_cpus then do;
      384 	     sub_one_one = substr (common_temp, 1, 3);
      385 	     sub_one_two = substr (common_temp, 5, 2);
      386 	     sub_two_one = substr (common_tempx, 1, 3);
      387 	     sub_two_two = substr (common_tempx, 5, 2);
      388 	end;
      389 	else do;
      390 	     sub_one_one = substr (common_temp, 1, 5);
      391 	     sub_one_two = substr (common_temp, 7, 2);
      392 	     sub_two_one = substr (common_tempx, 1, 5);
      393 	     sub_two_two = substr (common_tempx, 7, 2);
      394 	end;
      395 	
      396 	common_one_one = cv_dec_check_ (rtrim(ltrim(sub_one_one)), code);
      397 	common_one_two = cv_dec_check_ (rtrim(sub_one_two), code);
      398 	common_two_one = cv_dec_check_ (rtrim(ltrim(sub_two_one)), code);
      399 	common_two_two = cv_dec_check_ (rtrim(sub_two_two), code);
      400 	
      401 	common_min = common_one_one + common_two_one;
      402 	common_sec = common_one_two + common_two_two;
      403 	if common_sec > 59 then do;
      404 	     common_min = common_min + 1;
      405 	     common_sec = common_sec - 60;
      406 	end;
      407 	
      408 	if add_cpus then call ioa_$rsnnl ("^3d", common_min_char, len, common_min);
      409 	else call ioa_$rsnnl ("^5d", common_min_char, len, common_min);
      410 	call ioa_$rsnnl ("^2d", common_sec_char, len, common_sec);
      411 	if ttp_meters then do;
      412 	     if add_cpus then tot_cpu = rtrim(common_min_char) || ":" || rtrim(common_sec_char);
      413 	     else tot_connect = rtrim(common_min_char) || ":" || rtrim(common_sec_char);
      414 	     return;
      415 	end;
      416 	if add_cpus then temp.cpu (inx) = rtrim(common_min_char) || ":" || rtrim(common_sec_char);
      417 	else temp.connect (inx) = rtrim(common_min_char) || ":" || rtrim(common_sec_char);
      418 	return;
      419      end add_common_times;
      420 
      421 
      422 
      423 scan_LOGOUTS:
      424           proc (login_name, chan_name, login_time);	/* procedure that scans the logs finding "LOGOUT" messages
      425*	     that correspond to "LOGIN" messages for determining cpu & connect time usage */
      426 
      427 dcl login_name char(22) parameter;
      428 dcl chan_name char(32) parameter;
      429 dcl login_time fixed bin (71) parameter;
      430 dcl msg_count fixed bin (35);
      431 
      432 	msg_count = 0;
      433 	log_message_ptr = opt.first_msg;		/* start with first message again */
      434 	call log_match_$clear_text_strings (opt.lmd_ptr);
      435 	call log_match_$add_match (opt.lmd_ptr, "LOGOUT");
      436 						/* change the match string from LOGIN to LOGOUT */
      437 	do while (log_message_ptr ^= null ());
      438 	     if log_match_$test (opt.lmd_ptr, log_message_ptr, "") then do;
      439 		msg_count = msg_count + 1;
      440 		audit_record_ptr = addr (log_message.data (1));
      441 		audit_record_size = dimension (log_message.data, 1);
      442 		info_ptr = audit_record_ptr;
      443 		info_size = audit_record_size;
      444 		info_size = info_size - size (audit_record_header);
      445 		info_ptr = addrel (info_ptr, size (audit_record_header));
      446 		if index (log_message.text, "disconnect") = 0 then do;	
      447 		     if index (log_message.text, rtrim(login_name)) ^= 0 &
      448 			index (log_message.text, rtrim(chan_name)) ^= 0 &
      449 			log_message.time > login_time then do;
      450 			if index_count > 0 then do inx = 1 to index_count;
      451 			     if msg_count = temp_thr.index (inx) then goto skip_msg_count;
      452 			end;
      453 			temp_two.text (1) = log_message.text;
      454 			temp_two.time (1) = log_message.time;
      455 			index_count = index_count + 1;
      456 			temp_thr.index (index_count) = msg_count;
      457 			call get_cpu_time ();
      458 			goto setup;
      459 		     end;
      460 		end;
      461                end;
      462 skip_msg_count:
      463 	     
      464 	     call log_read_$next_message (log_read_ptr, log_message_ptr, code);
      465 						/* goto next log message */
      466 	     if log_message_ptr = opt.last_msg then do;
      467 		temp.cpu (first_msg_count) = "";
      468 		temp.connect (first_msg_count) = "";
      469 		goto setup;
      470 	     end;
      471 	     if code = error_table_$no_log_message then log_message_ptr = null ();
      472 	end;
      473 
      474 setup:	call check_for_dups (MCH);
      475 	if MCH then first_msg_count = first_msg_count - 1;
      476 	call log_match_$clear_text_strings (opt.lmd_ptr);
      477 	call log_match_$add_match (opt.lmd_ptr, "LOGIN");
      478 						/* change the match string back to LOGIN before returning
      479*		to original log scan */
      480 	return;
      481 
      482      end scan_LOGOUTS;
      483      
      484 
      485 add_ttp_data:
      486           proc ();					/* procedure for adding up & sorting different answerbacks
      487*	     per different ttps */
      488 
      489 	if ttx = 0 then do;
      490 	     ttx = ttx + 1;
      491 	     ttp_tot.type (ttx) = temp.ttp (first_msg_count);
      492 	     ttp_tot.ascnt (ttx) = 1;
      493 	     ttp_tot.ansbks (ttx).ansbk (1) = temp.ansb (first_msg_count);
      494 	     if failsw then ttp_tot.ansbks (ttx).fails (1) = 1;
      495      	     else ttp_tot.ansbks (ttx).login (1) = 1;
      496 	     ttp_tot.ansbks (ttx).cpu (1) = "  0: 0";
      497 	     ttp_tot.ansbks (ttx).connect (1) = "    0: 0";
      498 	end;
      499 	else do;
      500 	     do inx = 1 to ttx;
      501 		if temp.ttp (first_msg_count) = ttp_tot.type (inx) then do;
      502 		     do ttxx = 1 to ttp_tot.ascnt (inx);
      503 			if ttp_tot.ansbks (inx).ansbk (ttxx) = 
      504 			     temp.ansb (first_msg_count) then do;
      505 			     if ttp_meters then do;
      506 				add_cpus = "1"b;
      507 				if tot_cpu = "" then tot_cpu = "000:00";
      508 				else tot_cpu = ttp_tot.ansbks (inx).cpu (ttxx);
      509 				call add_common_times ();
      510 				add_cpus = ""b;
      511 				ttp_tot.ansbks (inx).cpu (ttxx) = 
      512 				     tot_cpu;
      513 				if tot_connect = "" then tot_connect = "00000:00";
      514 				else tot_connect = ttp_tot.ansbks (inx).connect (ttxx);
      515 				call add_common_times ();
      516 				ttp_tot.ansbks (inx).connect (ttxx) = 
      517 				     tot_connect;
      518 			     end;
      519 			     else if failsw then ttp_tot.ansbks (inx).fails (ttxx) = 
      520 				ttp_tot.ansbks (inx).fails (ttxx) + 1;
      521 			     else ttp_tot.ansbks (inx).login (ttxx) = 
      522 				ttp_tot.ansbks (inx).login (ttxx) + 1;
      523 			     return;
      524 			end;
      525 		     end;
      526 		     ttp_tot.ascnt (inx) = ttp_tot.ascnt (inx) + 1;
      527 		     ttp_tot.ansbks (inx).ansbk (ttp_tot.ascnt (inx)) = 
      528 			temp.ansb (first_msg_count);
      529 		     ttp_tot.ansbks (inx).cpu (ttp_tot.ascnt (inx)) = "  0: 0";
      530 		     ttp_tot.ansbks (inx).connect (ttp_tot.ascnt (inx)) = "    0: 0";
      531 		     if failsw then ttp_tot.ansbks (inx).fails (ttp_tot.ascnt (inx)) = 
      532 			ttp_tot.ansbks (inx).fails (ttp_tot.ascnt (inx)) + 1;
      533 		     else ttp_tot.ansbks (inx).login (ttp_tot.ascnt (inx)) = 
      534 			ttp_tot.ansbks (inx).login (ttp_tot.ascnt (inx)) + 1;
      535 		     return;
      536 		end;
      537 	     end;
      538 	     ttx = ttx + 1;
      539 	     ttp_tot.ascnt (ttx) = 1;
      540 	     ttp_tot.type (ttx) = temp.ttp (first_msg_count);
      541 	     ttp_tot.ansbks (ttx).ansbk (ttp_tot.ascnt (ttx)) = 
      542 		temp.ansb (first_msg_count);
      543 	     ttp_tot.ansbks (ttx).cpu (ttp_tot.ascnt (ttx)) = "  0: 0";
      544 	     ttp_tot.ansbks (ttx).connect (ttp_tot.ascnt (ttx)) = "    0: 0";
      545 	     if failsw then ttp_tot.ansbks (ttx).fails (ttp_tot.ascnt (ttx)) = 1;
      546 	     else ttp_tot.ansbks (ttx).login (ttp_tot.ascnt (ttx)) = 1;
      547 	end;
      548 	return;
      549      end add_ttp_data;
      550 	     
      551 
      552 output_data:
      553           proc ();					/* display results to user_output or output file */
      554 
      555 dcl (inxxx, inxxxx) fixed bin;
      556 dcl atype char (36) varying;
      557 
      558 	ttype, atype = "";
      559 	
      560 	do inx = 1 to V_thr.n_thr;
      561 	     if  V_thr.vector_thr (inx) -> temporary_ansb.ansb ^= atype then do;
      562 		atype = V_thr.vector_thr (inx) -> temporary_ansb.ansb;
      563 	     end;
      564 	     else goto skip_call;
      565 	     do inxx = 1 to V_two.n_two;
      566 		do inxxx = 1 to V.n;
      567 		     if V.vector (inxxx) -> temporary.ttp = 
      568 			V_two.vector_two (inxx) -> ttp_tot_data.type & V.vector (inxxx) -> temporary.ansb = 
      569 			V_thr.vector_thr (inx) -> temporary_ansb.ansb then do;
      570 			if ttype ^= V_thr.vector_thr (inx) -> temporary_ansb.ansb 
      571 			     || "   " || V_two.vector_two (inxx) -> ttp_tot_data.type then do;
      572 			     ttype = V_thr.vector_thr (inx) -> temporary_ansb.ansb 
      573 				|| "   " || V_two.vector_two (inxx) -> ttp_tot_data.type;
      574 			     tot_logi, tot_logo = 0;
      575 			     do inxxxx = 1 to V_two.vector_two (inxx) -> ttp_tot_data.ascnt;
      576 				if V_two.vector_two (inxx) -> ttp_tot_data.ansbk (inxxxx) = 
      577 				     V_thr.vector_thr (inx) -> temporary_ansb.ansb then do;
      578 				     tot_logi = tot_logi + V_two.vector_two (inxx) 
      579 					-> ttp_tot_data.ansbks.login (inxxxx);
      580 				     tot_logo = tot_logo + V_two.vector_two (inxx) 
      581 					-> ttp_tot_data.ansbks.fails (inxxxx);
      582 				     if mtsw then do;
      583 					tot_cpu = V_two.vector_two (inxx)
      584 					-> ttp_tot_data.ansbks.cpu (inxxxx);
      585 					tot_connect = V_two.vector_two (inxx)
      586 					-> ttp_tot_data.ansbks.connect (inxxxx);
      587 				     end;
      588 				end;
      589 			     end;
      590 			     if mtsw then call ioa_$ioa_switch (opt.iocb, "^/^a^38t^5d^52t^5d^62t^a^72t^a", 
      591 				ttype, tot_logi, tot_logo, tot_cpu, tot_connect);
      592 			     else call ioa_$ioa_switch (opt.iocb, "^/^a^38t^5d^52t^5d", 
      593 				ttype, tot_logi, tot_logo);
      594 			end;
      595 			if mtsw then do;
      596 			     if index (V.vector (inxxx) -> temporary.cpu, ":") = 0 then
      597 			     V.vector (inxxx) -> temporary.cpu = "  (*)";
      598 			call ioa_$ioa_switch (opt.iocb, "^10t^a^38t^5d^62t^a^72t^a", 
      599 			     V.vector (inxxx) -> temporary.name,
      600 			     V.vector (inxxx) -> temporary.logins,
      601 			     V.vector (inxxx) -> temporary.cpu,
      602 			     V.vector (inxxx) -> temporary.connect);
      603                    	          end;
      604 			else do;
      605 			     call ioa_$ioa_switch (opt.iocb, "^10t^a^38t^5d",
      606 				V.vector (inxxx) -> temporary.name,
      607 				V.vector (inxxx) -> temporary.logins);
      608 			end;
      609 		     end;
      610 		end;
      611 	     end;
      612 skip_call:     
      613 	end;
      614 	return;
      615      end output_data;
      616 
      617 
      618 oob:      proc ();
      619 	call ioa_$ioa_switch (opt.iocb, "Cannot continue... Out_of_bounds condition detected.");
      620 	call clean_up ();
      621      end oob;
      622      
      623 
      624 	
      625 clean_up:	proc ();
      626 	if log_read_ptr ^= null () then
      627 	     call log_read_$close (log_read_ptr, (0));
      628 	if opt.lmd_ptr ^= null () then
      629 	     call log_match_$free (opt.lmd_ptr);
      630 	if temp_ptrs (1) ^= null () then
      631 	     call release_temp_segments_ ("terminal_report", temp_ptrs, code);
      632 	if opened then do;
      633 	     call iox_$close (opt.iocb, code);
      634 	     if code ^= 0 then do;
      635 		call ssu_$abort_line (sci_ptr, code, "Could not close file ^a", output_file);
      636 	     end;
      637 	     opened = ""b;
      638 	end;
      639 	if attached then do;
      640 	     call iox_$detach_iocb (opt.iocb, code);
      641 	     if code ^= 0 then do;
      642 		call ssu_$abort_line (sci_ptr, code, "Could not detach file ^a", output_file);
      643 	     end;
      644 	     attached = ""b;
      645 	end;
      646 	if sci_ptr ^= null () then
      647 	     call ssu_$destroy_invocation (sci_ptr);
      648 
      649 	goto exit;
      650      end clean_up;
      651 
      652      
      653 exit:	return;
      654 	
      655 
      656 process_arguments:
      657           proc ();					/* validate arguments */
      658 	
      659 dcl arg char (argl) based (argp);
      660 dcl (argn, nargs) fixed bin;
      661 dcl argl fixed bin (21);
      662 dcl argp ptr;
      663 dcl cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35));
      664 	
      665 	call ssu_$arg_count (sci_ptr, nargs);
      666 
      667 	looking_for = "";
      668 	do argn = 1 to nargs;
      669 	     call ssu_$arg_ptr (sci_ptr, argn, argp, argl);
      670 	     if arg = "-from" | arg = "-fm" then 
      671 		call get_next_arg (opt.limit.from_opt);
      672 	     else if arg = "-to" then call get_next_arg (opt.limit.to_opt);
      673 	     else if arg = "-for" then call get_next_arg (opt.limit.for_opt);
      674 	     else if arg = "-last" | arg = "-lt" then 
      675 		call get_next_arg (opt.limit.last_opt);
      676 	     else if arg = "-output_file" | arg = "-of" then do;
      677 		call get_next_arg (output_file);
      678 		if code ^= 0 then output_file = "terminal_report_output";
      679 		else output_file = arg;
      680 	     end;
      681 	     else if arg = "-no_output_file" | arg = "-nof" then output_file = "";
      682 	     else if arg = "-terminal_type" | arg = "-ttp" then do;
      683 		call get_next_arg (looking_for);
      684 		call process_looking_for ();
      685 		ttpsw = "1"b;
      686 	     end;
      687 	     else if arg = "-all_terminal_types" | arg = "-att" then do;
      688 		looking_for = "";
      689 		ttpsw = "0"b;
      690 	     end;
      691 	     else if arg = "-user" then do;
      692 		call get_next_arg (looking_for);     
      693 		call process_looking_for ();
      694 		choosen_name = looking_for;
      695 		usersw = "1"b;
      696 	     end;
      697 	     else if arg = "-all_users" | arg = "-au" then do;
      698 		looking_for = "";
      699 		usersw = "0"b;
      700 	     end;
      701 	     else if arg = "-meters" | arg = "-mt" then mtsw = "1"b;
      702 	     else if arg = "-nometers" | arg = "-nmt" then mtsw = ""b;
      703 	     else if substr (arg, 1, 1) = "-" then do;
      704 		call ssu_$abort_line (sci_ptr, error_table_$badopt, "^a", arg);
      705 		call clean_up ();
      706 	     end;
      707 	     else call ssu_$abort_line (sci_ptr, error_table_$bad_arg, "^a", arg);
      708 	end;
      709 	call check_options ();
      710 	return;
      711 	
      712 
      713 process_looking_for:
      714 	proc ();					/* procedure for validating -match or -ttp strings */
      715 
      716 	if substr (arg, 1, 1) = "/" & substr (arg, argl, 1) ^= "/" then do;
      717 INVALID_ERROR:
      718 	          call ssu_$abort_line (sci_ptr, error_table_$bad_arg,
      719 		"Invalid regular expression ""^a""", arg);
      720 		call clean_up ();
      721 	     end;
      722 	     else if substr (arg, argl, 1) = "/" & substr (arg, 1, 1) ^= "/" then
      723 		goto INVALID_ERROR;
      724 	     else if arg = "/" then goto INVALID_ERROR;
      725 	     return;
      726      end process_looking_for;
      727 
      728 
      729 get_next_arg:
      730           proc (option);
      731 
      732 dcl option char (*) varying parameter;
      733 	
      734 	argn = argn + 1;
      735 	call cu_$arg_ptr (argn, argp, argl, code);
      736 	option = arg;
      737 	return;
      738      end get_next_arg;
      739      
      740 check_options:
      741           proc ();					/* procedure for determining what date/time to start & stop
      742*	     log scanning */
      743 	
      744 dcl temp_number fixed bin;
      745 dcl (from_time, to_time) fixed bin(71);
      746 dcl exchange_opt char (50) varying;
      747 
      748 	if opt.limit.from_opt ^= "" & opt.limit.to_opt ^= "" then do;
      749 	     temp_number = cv_dec_check_ ((opt.limit.from_opt), code);
      750 	     if code ^= 0 then do;
      751 		temp_number = cv_dec_check_ ((opt.limit.to_opt), code);
      752 		if code ^= 0 then do;
      753 		     call convert_date_to_binary_ ((opt.limit.from_opt), from_time, 0);
      754 		     call convert_date_to_binary_ ((opt.limit.to_opt), to_time, 0);
      755 		     if from_time > to_time then do;
      756 			exchange_opt = opt.limit.from_opt;
      757 			opt.limit.from_opt = opt.limit.to_opt;
      758 			opt.limit.to_opt = exchange_opt;
      759 		     end;
      760 		end;
      761 	     end;
      762 	end;
      763 	return;
      764      end check_options;
      765      end process_arguments;
      766 
      767      
      768 ssu_abort:
      769 	proc ();
      770 	call clean_up ();
      771 	return;
      772      end ssu_abort;
      773      
      774 
      775 initialize_options:
      776 	proc ();
      777 	unspec (opt) = ""b;
      778 	opt.pointers = null ();
      779 	opt.lmd_ptr = null ();
      780 	opt.limit.version = LOG_LIMIT_INFO_VERSION_1;
      781 	opt.limit.to_opt = "";
      782 	opt.limit.from_opt = "";
      783 	opt.limit.for_opt = "";
      784 	opt.log_pathname = "";
      785 	opt.iocb = iox_$user_output;
      786 	opt.reader_procedure = "";
      787 /*	unspec (log_message) = ""b;*/
      788 	output_file, tot_cpu, tot_connect = "";
      789 	attached, opened, mtsw, failsw, ttp_meters, final_tab, usersw,
      790 	     ttpsw = ""b;
      791 	ttx = 0;
      792 	unspec (ttp_tot) = ""b;
      793 	return;
      794      end initialize_options;
      795      
      796 
      797 
  1     1 /* BEGIN INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
  1     2 /* Modified 1984-12-16, BIM: for a version number */
  1     3 
  1     4 declare   log_limit_info_ptr pointer;
  1     5 
  1     6 declare 1 log_limit_info      aligned based (log_limit_info_ptr),
  1     7           2 version           char (8) aligned,
  1     8           2 to_opt            char (50) varying,            /* Input: options supplied after control */
  1     9           2 from_opt          char (50) varying,            /* argument of this name */
  1    10           2 for_opt           char (50) varying,
  1    11           2 last_opt          char (50) varying,
  1    12 
  1    13           2 first_msg         pointer,                      /* Output: results of successful processing */
  1    14           2 last_msg          pointer,                      /* of above options */
  1    15           2 msg_count         fixed bin (35);
  1    16 
  1    17 declare LOG_LIMIT_INFO_VERSION_1 char (8) init ("lliv0001") internal static options (constant);
  1    18 
  1    19 /* END INCLUDE FILE ... log_limit_info.incl.pl1 ... 84-07-04 ... W. Olin Sibert */
      798 
  2     1 /*  BEGIN:   as_audit_structures.incl.pl1		  *  *  *  *  *  */
  2     2 
  2     3 /****^  HISTORY COMMENTS:
  2     4*  1) change(84-01-17,Swenson), approve(), audit(), install():
  2     5*     Initial coding.
  2     6*  2) change(87-06-08,GDixon), approve(87-07-13,MCR7741),
  2     7*     audit(87-07-31,Brunelle), install(87-08-04,MR12.1-1056):
  2     8*      A) Add AS_AUDIT_CHANNEL_ACTIONS, AS_AUDIT_CHANNEL_DIRECTION, and
  2     9*         AS_AUDIT_CHANNEL_SERVICE_INFO arrays.
  2    10*      B) Add channel audit actions for dialin, dialout and dial system.
  2    11*      C) Correct declaration of as_channel_audit_record_.pad2.
  2    12*      D) Revise channel_audit_info.
  2    13*  3) change(87-07-15,GDixon), approve(87-07-15,MCR7741),
  2    14*     audit(87-07-31,Brunelle), install(87-08-04,MR12.1-1056):
  2    15*      A) Add AS_AUDIT_PROCESS_TERMINATE action code.
  2    16*                                                   END HISTORY COMMENTS */
  2    17 
  2    18 /* format: style2 */
  2    19 
  2    20 /* This include file describes the binary data associated with
  2    21*   Answering Service audit records.  */
  2    22 
  2    23 /**** This first structure defines the Identification and Authentication
  2    24*      (I&A) audit records associated with login attempts for interactive
  2    25*      and daemon logins */
  2    26 
  2    27      dcl	   1 as_ia_audit_record_int_dmn
  2    28 			      structure aligned based,
  2    29 	     2 header	      like audit_record_header aligned,
  2    30 	     2 record	      like as_ia_audit_record_;
  2    31 
  2    32 /**** This one is for absentee logins which are not proxy absentees */
  2    33 
  2    34      dcl	   1 as_ia_audit_record_abs
  2    35 			      structure aligned based,
  2    36 	     2 header	      like audit_record_header aligned,
  2    37 	     2 record	      like as_ia_audit_record_,
  2    38 	     2 absentee_input_path
  2    39 			      char (168);
  2    40 
  2    41      dcl	   1 as_ia_audit_record_abs_proxy
  2    42 			      structure aligned based,
  2    43 	     2 header	      like audit_record_header aligned,
  2    44 	     2 record	      like as_ia_audit_record_,
  2    45 	     2 absentee_input_path
  2    46 			      char (168),
  2    47 	     2 proxy_user	      char (32);
  2    48 
  2    49 /**** The following structure is common to all the I&A records.  It
  2    50*      contains the relevant information about the I&A process. */
  2    51 
  2    52      dcl	   1 as_ia_audit_record_  structure aligned based,
  2    53 	     2 type	      fixed bin (9) unsigned unaligned,
  2    54 	     2 version	      fixed bin (9) unsigned unaligned,
  2    55 	     2 process_type	      fixed bin (3) unsigned unaligned,
  2    56 	     2 min_ring	      fixed bin (3) unsigned unaligned,
  2    57 	     2 max_ring	      fixed bin (3) unsigned unaligned,
  2    58 	     2 pad1	      bit (9) unaligned,
  2    59 	     2 attributes	      like user_attributes,
  2    60 	     2 audit_flags	      bit (36) aligned,
  2    61 	     2 channel	      char (32) aligned,
  2    62 	     2 terminal_type      char (32) aligned,
  2    63 	     2 answerback	      char (4) aligned;
  2    64 
  2    65 /**** The following structure represents the binary information 
  2    66*      associated with a communications channel access audit message. */
  2    67 
  2    68      dcl	   1 as_channel_audit_record
  2    69 			      structure aligned based,
  2    70 	     2 header	      like audit_record_header aligned,
  2    71 	     2 record	      like as_channel_audit_record_;
  2    72 
  2    73 
  2    74      dcl	   1 as_channel_audit_record_
  2    75 			      structure aligned based,
  2    76 	     2 type	      fixed bin (9) unsigned unaligned,
  2    77 	     2 version	      fixed bin (9) unsigned unaligned,
  2    78 	     2 flags	      unaligned,
  2    79 	       3 channel_info_valid
  2    80 			      bit (1) unaligned,
  2    81 	       3 current_access_class_valid
  2    82 			      bit (1) unaligned,
  2    83 	       3 pad1	      bit (16) unaligned,
  2    84 	     2 channel_name	      char (32),
  2    85 	     2 current_access_class
  2    86 			      (2) bit (72) aligned,
  2    87 	     2 access_class_range (2) bit (72) aligned,
  2    88 	     2 current_service_type
  2    89 			      fixed bin (17) unaligned,
  2    90 	     2 service_type	      fixed bin (17) unaligned,
  2    91 	     2 terminal_type      char (32),
  2    92 	     2 authenticated_user aligned,
  2    93 	       3 personid	      char (22) unaligned,
  2    94 	       3 projectid	      char (9) unaligned,
  2    95 	       3 pad2	      bit (9) unaligned;
  2    96 
  2    97 /**** The following structure represents the binary information 
  2    98*      associated with a dial service audit record */
  2    99 
  2   100      dcl	   1 as_dial_service_audit_record
  2   101 			      structure aligned based,
  2   102 	     2 header	      like audit_record_header aligned,
  2   103 	     2 record	      like as_dial_service_audit_record_;
  2   104 
  2   105      dcl	   1 as_dial_service_audit_record_
  2   106 			      structure aligned based,
  2   107 	     2 type	      fixed bin (9) unsigned unaligned,
  2   108 	     2 version	      fixed bin (9) unsigned unaligned,
  2   109 	     2 dial_server_ring   fixed bin (3) unsigned unaligned,
  2   110 	     2 flags	      unaligned,
  2   111 	       3 registered_server
  2   112 			      bit (1) unaligned,
  2   113 	       3 privileged_server
  2   114 			      bit (1) unaligned,
  2   115 	       3 pad1	      bit (13) unaligned,
  2   116 	     2 dial_qualifier     char (32);
  2   117 
  2   118 /**** The following structure is used by dial_ctl_ to pass the required
  2   119*      information to as_access_audit_.  This structure is necessary since
  2   120*      the data is not available in the user_table_entry or cdte. */
  2   121 
  2   122      dcl	   dial_server_info_ptr   ptr;		/* pointer to following structure */
  2   123 
  2   124      dcl	   1 dial_server_info     structure aligned based (dial_server_info_ptr),
  2   125 	     2 server_ring	      fixed bin (3) unaligned,
  2   126 	     2 flags	      unaligned,
  2   127 	       3 registered	      bit (1) unaligned,
  2   128 	       3 privileged	      bit (1) unaligned,
  2   129 	       3 pad1	      bit (31) unaligned,
  2   130 	     2 dial_qualifier     char (32);
  2   131 
  2   132 /**** The following structure is used by dial_ctl_ to pass relevant information
  2   133*      to as_access_audit_.  The channel name is passed here when we do not
  2   134*      have a cdtep, for instance. */
  2   135 
  2   136      dcl	   channel_audit_info_ptr ptr;
  2   137 
  2   138      dcl	   1 channel_audit_info   aligned based (channel_audit_info_ptr),
  2   139 	     2 channel_name	      char (32),
  2   140 	     2 valid,
  2   141 	      (3 service_info,
  2   142 	       3 access_class,
  2   143 	       3 access_class_range,
  2   144 	       3 user_validation_level)
  2   145 			      bit(1) unal,
  2   146 	       3 mbz	      bit(32) unal,
  2   147 	     2 service_info	      char (32),
  2   148 	     2 access_class	      bit(72) aligned,
  2   149 	     2 access_class_range (2) bit(72) aligned,
  2   150 	     2 user_validation_level
  2   151 			      fixed bin (3);
  2   152 
  2   153      dcl	   AS_AUDIT_RECORD_IA_VERSION_1
  2   154 			      fixed bin (9) initial (1) internal static options (constant);
  2   155 
  2   156      dcl	   AS_AUDIT_RECORD_CHN_VERSION_1
  2   157 			      fixed bin (9) initial (1) internal static options (constant);
  2   158 
  2   159      dcl	   AS_AUDIT_RECORD_DIALID_VERSION_1
  2   160 			      fixed bin (9) initial (1) internal static options (constant);
  2   161 
  2   162      dcl	   (
  2   163 	   AS_AUDIT_PROCESS_CREATE
  2   164 			      initial (1),
  2   165 	   AS_AUDIT_PROCESS_DESTROY
  2   166 			      initial (2),
  2   167 	   AS_AUDIT_PROCESS_CONNECT
  2   168 			      initial (3),
  2   169 	   AS_AUDIT_PROCESS_DISCONNECT
  2   170 			      initial (4),
  2   171 	   AS_AUDIT_PROCESS_TERMINATE
  2   172 			      initial (5)
  2   173 	   )		      fixed bin (17) internal static options (constant);
  2   174 
  2   175      dcl	   (
  2   176 	   AS_AUDIT_CHANNEL_ATTACH
  2   177 			      initial (1),
  2   178 	   AS_AUDIT_CHANNEL_DETACH
  2   179 			      initial (2),
  2   180 	   AS_AUDIT_CHANNEL_DIALIN
  2   181 			      initial (3),
  2   182 	   AS_AUDIT_CHANNEL_DIALOUT
  2   183 			      initial (4),
  2   184 	   AS_AUDIT_CHANNEL_DIAL_SYSTEM
  2   185 			      initial (5)
  2   186 	   )		      fixed bin (17) internal static options (constant);
  2   187 
  2   188      dcl	   (
  2   189 	   AS_AUDIT_DIALID_START  initial (1),
  2   190 	   AS_AUDIT_DIALID_STOP   initial (2)
  2   191 	   )		      fixed bin (17) internal static options (constant);
  2   192 
  2   193      dcl	   AS_AUDIT_CHANNEL_ACTIONS	
  2   194 			      (5) char (12) internal static options (constant)
  2   195 			      initial ("ATTACH", "DETACH", "DIALIN", "DIALOUT", "DIAL SYSTEM");
  2   196      dcl     AS_AUDIT_CHANNEL_DIRECTION
  2   197 			      (5) char (4) internal static options (constant)
  2   198 			      initial ("to", "from", "to", "from", "to");
  2   199      dcl     AS_AUDIT_CHANNEL_SERVICE_INFO
  2   200 			      (5) char (12) internal static options (constant)
  2   201 			      initial ("Service", "Service", "Dial ID", "Destination", "VChannel");
  2   202      dcl	   AS_AUDIT_PROCESS_ACTIONS
  2   203 			      (5) char (10) internal static options (constant)
  2   204 			      initial ("CREATE", "DESTROY", "CONNECT", "DISCONNECT", "TERMINATE");
  2   205 
  2   206 /*  END OF:  as_audit_structures.incl.pl1		  *  *  *  *  *  */
      799 
  3     1 /* BEGIN INCLUDE FILE ... log_message.incl.pl1 ... 84-04-25 ... W. Olin Sibert */
  3     2 
  3     3 declare 1 log_message_header  aligned based,                /* Items marked "(SET)" are set by $create_message */
  3     4           2 sentinel          bit (36) aligned,             /* Proper value declared in log_segment.incl.pl1 */
  3     5           2 sequence          fixed bin (35),               /* Sequence number for this message (SET) */
  3     6           2 severity          fixed bin (8) unaligned,      /* Severity of message */
  3     7           2 data_class_lth    fixed bin (9) unaligned unsigned, /* Length of data class-- 0 to 16 (SET) */
  3     8           2 time              fixed bin (53) unaligned,     /* Time message originated */
  3     9           2 text_lth          fixed bin (17) unaligned,     /* Length of message text. Must be nonzero (SET) */
  3    10           2 data_lth          fixed bin (17) unaligned,     /* Length of binary data. May be zero (SET) */
  3    11           2 process_id        bit (36) aligned;             /* Process id of process writing message */
  3    12 
  3    13 declare 1 log_message         aligned based (log_message_ptr),
  3    14           2 header            aligned like log_message_header,
  3    15           2 text              char (log_message_text_lth         refer (log_message.text_lth)) unaligned,
  3    16           2 data_class        char (log_message_data_class_lth   refer (log_message.data_class_lth)) unaligned,
  3    17           2 data              dim (log_message_data_lth          refer (log_message.data_lth)) bit (36) aligned;
  3    18 
  3    19 declare   log_message_ptr pointer;
  3    20 declare   log_message_text_lth fixed bin;
  3    21 declare   log_message_data_class_lth fixed bin;
  3    22 declare   log_message_data_lth fixed bin;
  3    23 
  3    24 /* END INCLUDE FILE ... log_message.incl.pl1 */
      800 
  4     1 /* BEGIN INCLUDE FILE ... user_attributes.incl.pl1  TAC 10/79 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(86-12-11,Brunelle), approve(87-07-13,MCR7741),
  4     6*     audit(87-04-19,GDixon), install(87-08-04,MR12.1-1056):
  4     7*     Add incl for abs_attributes.incl.pl1 to automatically include absentee
  4     8*     attribute switches.
  4     9*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  4    10*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  4    11*      A) Add USER_ATTRIBUTE_NAMES arrays.  attribute_names.incl.pl1 can thereby
  4    12*         be deleted.
  4    13*      B) Add constants identifying attributes that can be changed by user at
  4    14*         login, etc.
  4    15*                                                   END HISTORY COMMENTS */
  4    16 
  4    17 
  4    18 /* Modified 82-01-03  E. N. Kittlitz.  to declare a complete level-1 structure */
  4    19 
  4    20 /* format: style4 */
  4    21 dcl  1 user_attributes aligned based,			/* the user user_attributes */
  4    22        (2 administrator bit (1),			/* 1  system administrator privileges */
  4    23        2 primary_line bit (1),			/* 2  user has primary-line privileges  */
  4    24        2 nobump bit (1),				/* 2  user cannot be bumped */
  4    25        2 guaranteed_login bit (1),			/* 4  user has guaranteed login privileges */
  4    26        2 anonymous bit (1),				/* 5  used only in SAT. project may have anon.users */
  4    27        2 nopreempt bit (1),				/* 6  used only in PDT. user not preemptable by others
  4    28*						   .  of same project (distinct from "nobump") */
  4    29        2 nolist bit (1),				/* 7  don't list user on "who" */
  4    30        2 dialok bit (1),				/* 8  user may have multiple consoles */
  4    31        2 multip bit (1),				/* 9  user may have several processes */
  4    32        2 bumping bit (1),				/* 10 in SAT. Can users in project bump each other? */
  4    33        2 brief bit (1),				/* 11 no login or logout message */
  4    34        2 vinitproc bit (1),				/* 12 user may change initial procedure */
  4    35        2 vhomedir bit (1),				/* 13 user may change homedir */
  4    36        2 nostartup bit (1),				/* 14 user does not want start_up.ec */
  4    37        2 sb_ok bit (1),				/* 15 user may be standby */
  4    38        2 pm_ok bit (1),				/* 16 user may be primary */
  4    39        2 eo_ok bit (1),				/* 17 user may be edit_only */
  4    40        2 daemon bit (1),				/* 18 user may login as daemon */
  4    41        2 vdim bit (1),				/* 19 * OBSOLETE * user may change outer mdle */
  4    42        2 no_warning bit (1),				/* 20 no warning message */
  4    43        2 igroup bit (1),				/* 21 in SAT: this project may give its users individual groups
  4    44*						   .  in PDT: this user has an individual load control group */
  4    45        2 save_pdir bit (1),				/* 22 save pdir after fatal process error */
  4    46        2 disconnect_ok bit (1),			/* 23 ok to save user's disconnected processes */
  4    47        2 save_on_disconnect bit (1),			/* 24 save them unless -nosave login arg is given */
  4    48        2 pad bit (12)) unaligned;
  4    49 
  4    50 dcl  USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  4    51     ("none",					/* 0 */
  4    52      "administrator",				/* 1 */
  4    53      "primary_line",				/* 2 */
  4    54      "nobump",					/* 3 */
  4    55      "guaranteed_login",				/* 4 */
  4    56      "anonymous",					/* 5 */
  4    57      "nopreempt",					/* 6 */
  4    58      "nolist",					/* 7 */
  4    59      "dialok",					/* 8 */
  4    60      "multip",					/* 9 */
  4    61      "bumping",					/* 10 */
  4    62      "brief",					/* 11 */
  4    63      "vinitproc",					/* 12 */
  4    64      "vhomedir",					/* 13 */
  4    65      "nostartup",					/* 14 */
  4    66      "no_secondary",				/* 15 */
  4    67      "no_prime",					/* 16 */
  4    68      "no_eo",					/* 17 */
  4    69      "daemon",					/* 18 */
  4    70      "",						/* 19 vdim OBSOLETE */
  4    71      "no_warning",					/* 20 */
  4    72      "igroup",					/* 21 */
  4    73      "save_pdir",					/* 22 */
  4    74      "disconnect_ok",				/* 23 */
  4    75      "save_on_disconnect");				/* 24 */
  4    76 
  4    77 dcl  ALT_USER_ATTRIBUTE_NAMES (0:24) char (20) int static options (constant) init
  4    78     ("null",					/* 0 */
  4    79      "admin",					/* 1 */
  4    80      "", "",					/* 2 - 3 */
  4    81      "guar",					/* 4 */
  4    82      "anon",					/* 5 */
  4    83      "", "",					/* 6 - 7 */
  4    84      "dial",					/* 8 */
  4    85      "multi_login",					/* 9 */
  4    86      "preempting",					/* 10 */
  4    87      "",						/* 11 */
  4    88      "v_process_overseer",				/* 12 */
  4    89      "v_home_dir",					/* 13 */
  4    90      "no_start_up",					/* 14 */
  4    91      "no_sec",					/* 15 */
  4    92      "no_primary",					/* 16 */
  4    93      "no_edit_only",				/* 17 */
  4    94      "op_login",					/* 18 */
  4    95      "",						/* 19 */
  4    96      "nowarn",					/* 20 */
  4    97      "", "", "",					/* 21 - 23 */
  4    98      "save");					/* 24 */
  4    99 
  4   100 dcl  USER_ATTRIBUTES_always_allowed bit (36) aligned int static
  4   101      options(constant) init("000000000010000000010000000000000000"b);
  4   102     /* SAT/PDT attributes not needed for user to give (brief, no_warning) */
  4   103 
  4   104 dcl  USER_ATTRIBUTES_default_in_pdt bit (36) aligned int static
  4   105      options(constant) init("000000000010000000010000000000000000"b);
  4   106     /* PDT value for (brief, no_warning) is default */
  4   107 
  4   108 dcl  USER_ATTRIBUTES_settable_by_user bit (36) aligned int static
  4   109      options(constant) init("000100000110010000010000000000000000"b);	
  4   110     /* user MIGHT set (bump, ns, brief, guar, no_warning) */
  4   111 
  5     1 /* BEGIN INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  5     2 
  5     3 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5     4 /*							       */
  5     5 /* This include file describes the attributes of an absentee job.  It is     */
  5     6 /* used by user_table_entry.incl.pl1, abs_message_format.incl.pl1            */
  5     7 /* and PIT.incl.pl1.   */
  5     8 /*							       */
  5     9 /* *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  * */
  5    10 
  5    11 /****^  HISTORY COMMENTS:
  5    12*  1) change(86-12-08,GDixon), approve(87-07-13,MCR7741),
  5    13*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  5    14*     Separated abs_attributes from the request structure
  5    15*     (abs_message_format.incl.pl1) so that the identical structure could be
  5    16*     used in the ute structure (user_table_entry.incl.pl1).
  5    17*  2) change(87-04-19,GDixon), approve(87-07-13,MCR7741),
  5    18*     audit(87-07-16,Brunelle), install(87-08-04,MR12.1-1056):
  5    19*     Added ABS_ATTRIBUTE_NAMES array.
  5    20*  3) change(87-11-11,Parisek), approve(88-02-11,MCR7849),
  5    21*     audit(88-03-22,Lippard), install(88-07-13,MR12.2-1047):
  5    22*     Added the no_start_up flag. SCP6367
  5    23*                                                   END HISTORY COMMENTS */
  5    24 
  5    25 dcl 1 user_abs_attributes		aligned based,
  5    26       2 restartable			bit (1) unaligned,	/* 1 if request may be started over from the beginning */
  5    27       2 user_deferred_until_time	bit (1) unaligned,	/* 1 if request was specified as deferred */
  5    28       2 proxy			bit (1) unaligned,	/* 1 if request submitted for someone else */
  5    29       2 set_bit_cnt			bit (1) unaligned,	/* 1 if should set bit count after every write call */
  5    30       2 time_in_gmt			bit (1) unaligned,	/* 1 if deferred_time is in GMT */
  5    31       2 user_deferred_indefinitely	bit (1) unaligned,	/* 1 if operator is to say when to run it */
  5    32       2 secondary_ok		bit (1) unaligned,	/* 1 if ok to log in as secondary foreground user */
  5    33       2 truncate_absout		bit (1) unaligned,	/* 1 if .absout is to be truncated */
  5    34       2 restarted			bit (1) unaligned,	/* 1 if job is restarted */
  5    35       2 no_start_up                     bit (1) unaligned,	/* 1 if requested -ns */
  5    36       2 attributes_pad		bit (26) unaligned;
  5    37 
  5    38 dcl  ABS_ATTRIBUTE_NAMES (10) char (28) varying int static options(constant) init(
  5    39 	"restartable",
  5    40 	"user_deferred_until_time",
  5    41 	"proxy",
  5    42 	"set_bit_cnt",
  5    43 	"time_in_gmt",
  5    44 	"user_deferred_indefinitely",
  5    45 	"secondary_ok",
  5    46 	"truncate_absout",
  5    47 	"restarted",
  5    48 	"no_start_up");
  5    49 
  5    50 /* END INCLUDE FILE ... user_abs_attributes.incl.pl1 */
  5    51 
  4   112 
  4   113 
  4   114 /* END INCLUDE FILE ... user_attributes.incl.pl1 */
      801 
  6     1 /* BEGIN include file access_audit_bin_header.incl.pl1 */
  6     2 
  6     3 /* format: style4 */
  6     4 
  6     5 /* NOTE: All changes must also be done to access_audit_bin_header.incl.alm */
  6     6 
  6     7 /* 85-01-18 E. Swenson - renamed to access_audit_bin_header.incl.pl1 */
  6     8 /* 85-01-17 E. Swenson - restructured, added session_uid, changed
  6     9*   min and max authorization to authorization range. */
  6    10 /* 85-01-07 EJ Sharpe - added min_authorization, cleanup */
  6    11 /* 84-11-15 EJ Sharpe - added event_flags word */
  6    12 /* 84-11-06 EJ Sharpe - added unaligned attr to version and proxy_flag */
  6    13 /* 84-10-24 EJ Sharpe - added the constants */
  6    14 /* 84-09-04 BIM - created */
  6    15 
  6    16 declare  audit_record_ptr pointer;
  6    17 
  6    18 dcl  1 audit_record_header aligned based (audit_record_ptr),
  6    19        2 header aligned like arh_header_,
  6    20        2 subject aligned like arh_user_info_;
  6    21 
  6    22 dcl  1 audit_record_header_proxy aligned based (audit_record_ptr),
  6    23        2 header aligned like arh_header_,
  6    24        2 subjects (2) aligned like arh_user_info_;
  6    25 
  6    26 dcl  1 arh_header_ aligned based,
  6    27        2 type fixed bin (9) unsigned unaligned,
  6    28        2 version fixed bin (9) unsigned unaligned,
  6    29        2 flags unaligned,
  6    30          3 (
  6    31          subject_is_process,				/* binary data in subject is valid */
  6    32          object_is_valid				/* There is an object */
  6    33          ) bit (1) unaligned,
  6    34          3 pad bit (16) unaligned,
  6    35        2 operation_code bit (36) aligned,		/* like access_audit_encoded_op */
  6    36        2 event_flags bit (36) aligned,			/* like access_audit_eventflags */
  6    37        2 session_uid fixed bin (35);			/* uid for the login session */
  6    38 
  6    39 dcl  1 arh_user_info_ aligned based,
  6    40        2 person char (22) unaligned,			/* see anonymous bit */
  6    41        2 project char (9) unaligned,			/*  blank  for nologin w/out proj */
  6    42        2 tag char (1) unaligned,
  6    43        2 ring fixed bin (3) uns unaligned,
  6    44        2 anonymous bit (1) unaligned,
  6    45        2 pad3 bit (32) unaligned,
  6    46        2 process_id bit (36) aligned,
  6    47        2 authorization bit (72) aligned,
  6    48        2 authorization_range (2) bit (72) aligned;
  6    49 
  6    50 dcl  ARH_TYPE_PROXY fixed bin init (2)
  6    51 	static options (constant);
  6    52 dcl  ARH_TYPE_NO_PROXY fixed bin init (1)
  6    53 	static options (constant);
  6    54 dcl  ACCESS_AUDIT_HEADER_VERSION_3 fixed bin (9) unsigned
  6    55 	init (3) static options (constant);
  6    56 
  6    57 /* End include file access_audit_bin_header.incl.pl1 */
      802 
  7     1 /* BEGIN INCLUDE FILE ..... time_offset.incl.pl1 ..... 08/23/79 J Falksen */
  7     2 
  7     3 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  7     4 /*							       */
  7     5 /* Name:  time_offset.incl.pl1				       */
  7     6 /*							       */
  7     7 /* 1) This structure provides input to date_time_$offset_to_clock.	       */
  7     8 /*  Both integer and real fields may be supplied. Each field containing data */
  7     9 /*  must have its use bit set.  All values may be positive or negative.      */
  7    10 /*  a) dw is applied first.					       */
  7    11 /*  b) The size of a year is dependant upon WHICH year.  The base year is    */
  7    12 /*   determined.  The (adjusted) clock value is the reference for this.      */
  7    13 /*   The integral years (whether from fixed, float, or both) are added to    */
  7    14 /*   this base year.  The new base year is used to determine what value the  */
  7    15 /*   fraction is applied to.					       */
  7    16 /*  c) The size of a month is dependant upon WHICH month of WHICH year.      */
  7    17 /*   The base year/month is determined.  The (adjusted) clock value is the   */
  7    18 /*   reference for this.  The integral months are added to this base month,  */
  7    19 /*   forming a new base year/month.  The new base month in used to determine */
  7    20 /*   value the fraction is applied to.				       */
  7    21 /*  d) Values smaller than a month are added "in parallel" because their     */
  7    22 /*   size is always constant (leap-seconds ignored).		       */
  7    23 /*							       */
  7    24 /* 2) This structure receives output from date_time_$from_clock_interval.    */
  7    25 /*  time_offset.dw is not used.  The input values in val are ignored; they   */
  7    26 /*  are reset.  flag specifies the units in which the output is to be	       */
  7    27 /*  expressed and whether the fractional amount is desired. If only the      */
  7    28 /*  smallest unit is set to receive the fraction it leaves the structure in  */
  7    29 /*  a state that it may be given to $offset_to_clock without modification.   */
  7    30 /*							       */
  7    31 /* Status							       */
  7    32 /* 06/07/83 jaf 0) Created					       */
  7    33 /* 84-11-19 jaf 1) Changed the form of the dw field, added named constants   */
  7    34 /*							       */
  7    35 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  7    36 
  7    37 dcl 1 time_offset	aligned based(Ptime_offset),
  7    38       2 version	char (8),
  7    39       2 flag,
  7    40         3 yr	fixed bin,
  7    41         3 mo	fixed bin,
  7    42         3 wk	fixed bin,
  7    43         3 da	fixed bin,
  7    44         3 hr	fixed bin,
  7    45         3 min	fixed bin,
  7    46         3 sec	fixed bin,
  7    47         3 Usec	fixed bin,
  7    48       2 val,
  7    49         3 yr	float dec (20),	/* years			       */
  7    50         3 mo	float dec (20),	/* months			       */
  7    51         3 wk	float dec (20),	/* weeks			       */
  7    52         3 da	float dec (20),	/* days			       */
  7    53         3 hr	float dec (20),	/* hours			       */
  7    54         3 min	float dec (20),	/* minutes		       */
  7    55         3 sec	float dec (20),	/* seconds		       */
  7    56         3 Usec	float dec (20),	/* microseconds		       */
  7    57       2 dw,
  7    58         3 flag	fixed bin,	/* how to select day, if at all      */
  7    59         3 val	fixed bin;	/* Day of the week (1=Mon...7=Sun).  */
  7    60 
  7    61 /**** time_offset.flag settings for $offset_to_clock		       */
  7    62 dcl (UNUSED	init (0),	/* this offset unit is unused		       */
  7    63      USED		init (1), /* this offset unit has a value	       */
  7    64 /**** time_offset.flag settings for $from_clock_interval		       */
  7    65 /****UNUSED	init (0),	/* this offset unit is unused		       */
  7    66      INTEGER	init (1),	/* return interval unit as an integer	       */
  7    67      FRACTION	init (2),	/* return interval unit as integer+fraction    */
  7    68 /**** offset.dw.flag settings for $offset_to_clock. Tells how to select the  */
  7    69 			/* day given in offset.dw.val		       */
  7    70      BEFORE	init (-2),/*        before day given in clock_in	       */
  7    71      ON_OR_BEFORE	init (-1),/*  on or before day given in clock_in	       */
  7    72 /****UNUSED	init (0),	/*     don't apply day of week offset	       */
  7    73      ON_OR_AFTER	init (1),	/*  on or after  day given in clock_in	       */
  7    74      AFTER	init (2)	/*        after  day given in clock_in	       */
  7    75     )		fixed bin int static options (constant);
  7    76 
  7    77 dcl  Ptime_offset	ptr,
  7    78      Vtime_offset_2	char (8) int static options(constant) init("timeoff2");
  7    79 
  7    80 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  7    81 /*							       */
  7    82 /* Name:  time_offset_array_.incl.pl1				       */
  7    83 /*							       */
  7    84 /* This is an array form of time_offset.			       */
  7    85 /*							       */
  7    86 /*  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *  *   */
  7    87 
  7    88 dcl 1 time_offset_array	aligned based(Ptime_offset),
  7    89     2 version		char (8),
  7    90     2 flag		(8) fixed bin,
  7    91     2 val			(8) float dec (20),
  7    92     2 dw,
  7    93       3 (flag, val) 	fixed bin;
  7    94 
  7    95 /* END INCLUDE FILE ..... time_offset.incl.pl1 ..... */
      803 
      804 
      805 
      806 /* Builtins */
      807 
      808 dcl (index, substr, addr, addrel, currentsize, ltrim, rtrim,
      809      null, pointer, unspec, dimension, size) builtin;
      810 
      811 
      812 /* Automatic */
      813 
      814 dcl 1 opt automatic,				/* structure required by the system log subroutines */
      815       2 log_pathname char (168),
      816       2 pointers,
      817         3 expand_select_ptr ptr,
      818         3 lmd_ptr ptr,
      819       2 limit aligned like log_limit_info,
      820       2 reader_procedure char (32) varying,
      821       2 iocb ptr,
      822       2 flags aligned,
      823         3 debug_sw bit (1),
      824         3 dm_system_log_sw bit (1),
      825         3 reverse_sw bit (1),
      826         3 from_sw bit (1),
      827         3 to_sw bit (1),
      828         3 for_sw bit (1),
      829         3 last_sw bit (1),
      830         3 expand_sw bit (1),
      831         3 octal_sw bit (1),
      832         3 interpret_sw bit (1),
      833         3 log_path_sw bit (1),
      834         3 no_header_sw bit (1),
      835         3 limit_sw bit (1),
      836         3 process_id_sw bit (1),
      837         3 data_class_sw bit (1);
      838 
      839 dcl 1 ttp_tot (ttx) aligned based (ttp_tot_ptr),
      840       2 tot_data like ttp_tot_data;
      841 						/* ttp & ansback data */
      842 dcl 1 ttp_tot_data aligned based,			/* above data sorted */
      843       2 type char(32) varying,
      844       2 ascnt fixed bin,
      845       2 ansbks (1000),
      846         3 ansbk char(4),
      847         3 login fixed bin(35),
      848         3 fails fixed bin(35),
      849         3 connect char(8),
      850         3 cpu char(6);
      851 
      852 dcl 1 temp_as (first_msg_count) aligned based (temp_as_ptr),
      853       2 ansbs like temporary_ansb;			/* ansback data */
      854 dcl 1 temporary_ansb aligned based,
      855       2 ansb char (4) varying;			/* above data sorted */
      856 
      857 dcl 1 temporary aligned based,			/* terminal data */
      858       2 name char (22) varying,
      859       2 ttp char(32),
      860       2 ansb char(4),
      861       2 chn char(32),
      862       2 time fixed bin(71),
      863       2 logins fixed bin(35),
      864       2 failed bit (1) aligned,
      865       2 connect char(8),
      866       2 cpu char(10);
      867 
      868 dcl 1 temp (first_msg_count) aligned based (temp_ptr),
      869       2 data like temporary;				/* above data sorted */
      870 
      871 dcl 1 temp_two (1) aligned based (temp_two_ptr),
      872       2 text char(128) varying,			/* LOGOUT data */
      873       2 time fixed bin(71);
      874 
      875 dcl 1 temp_thr (index_count) aligned based (ttp),
      876       2 index fixed bin (35);				/* array of LOGOUT messages already seen and matched */
      877 
      878 dcl 1 V aligned based (vptr),
      879       2 n fixed bin(18),
      880       2 vector (n) ptr unaligned;
      881 dcl 1 V_two aligned based (vptr_two),
      882       2 n_two fixed bin(18),
      883       2 vector_two (n_two) ptr unaligned;
      884 dcl 1 V_thr aligned based (vptr_ansb),
      885       2 n_thr fixed bin(18),
      886       2 vector_thr (n_thr) ptr unaligned;
      887 
      888 dcl (info_size, audit_record_size, ttx, ttxx, inx, inxx, datax, tot_logi,
      889           tot_logo) fixed bin;
      890 dcl tot_connect char (8);
      891 dcl tot_cpu char (6);
      892 dcl choosen_name char (22) varying;
      893 dcl looking_for char (32) varying;
      894 dcl CHN char (32);
      895 dcl NAME char (22);
      896 dcl (cods, dpds) char (120) aligned;
      897 dcl (coxx, dpxx) char (4) aligned;
      898 dcl cpu_data char (9);
      899 dcl output_file char (168) varying;
      900 dcl ttype char (32);
      901 dcl (code, index_count) fixed bin (35);
      902 dcl (attached, opened, add_cpus) bit (1);
      903 dcl (failsw, ttp_meters, final_tab, MCH, mtsw, usersw, ttpsw) bit (1) aligned;
      904 dcl TIME fixed bin (71);
      905 dcl len fixed bin (21);
      906 dcl (first_msg_count, ansb_msg_count) fixed bin (35);
      907 
      908 
      909 /* External entries */
      910 
      911 dcl log_read_$open entry (char (*), char (*), ptr, fixed bin (35));
      912 dcl log_read_$close entry (ptr, fixed bin (35));
      913 dcl log_read_$next_message entry (ptr, ptr, fixed bin (35));
      914 dcl log_match_$add_match entry (ptr, char (*));
      915 dcl log_match_$free entry (ptr);
      916 dcl log_match_$test entry (ptr, ptr, char (*) varying) returns (bit (1) aligned);
      917 dcl log_match_$clear_text_strings entry (ptr);
      918 dcl log_limit_scan_ entry (ptr, ptr, bit (1) aligned, ptr);
      919 dcl log_format_time_ entry (fixed bin (71)) returns (char (32) varying);
      920 dcl (ioa_$ioa_switch, ioa_$rsnnl, com_err_) entry options (variable);
      921 dcl cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35));
      922 dcl convert_date_to_binary_ entry (char (*), fixed bin (71), fixed bin (35));
      923 dcl system_info_$titles entry (char (*) aligned, char (*) aligned,
      924           char (*) aligned, char (*) aligned);
      925 dcl sort_items_$varying_char entry (ptr);
      926 dcl (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr,
      927           fixed bin (35));
      928 dcl ssu_$standalone_invocation entry (ptr, char (*), char (*), ptr, entry,
      929           fixed bin (35));
      930 dcl ssu_$destroy_invocation entry (ptr);
      931 dcl ssu_$abort_line entry options (variable);
      932 dcl ssu_$arg_ptr entry (ptr, fixed bin, ptr, fixed bin (21));
      933 dcl ssu_$arg_list_ptr entry returns (ptr);
      934 dcl ssu_$arg_count entry (ptr, fixed bin);
      935 dcl cu_$arg_list_ptr entry returns (ptr);
      936 dcl iox_$attach_name entry (char (*), ptr, char (*), ptr, fixed bin (35));
      937 dcl iox_$open entry (ptr, fixed bin, bit (*), fixed bin (35));
      938 dcl iox_$detach_iocb entry (ptr, fixed bin (35));
      939 dcl iox_$close entry (ptr, fixed bin (35));
      940 
      941 
      942 /* Pointers */
      943 
      944 dcl (log_read_ptr, temp_as_ptr, temp_ptrs (5), auto_log_read_ptr,
      945           auto_log_message_ptr, sci_ptr, temp_ptr, temp_two_ptr, ttp_tot_ptr,
      946           ttp, vptr, vptr_two, vptr_ansb, info_ptr) ptr;
      947 dcl iox_$user_output ptr ext static;
      948 
      949 
      950 /* conditions */
      951 
      952 dcl (out_of_bounds, cleanup) condition;
      953 
      954 
      955 /* error messages */
      956 
      957 dcl (error_table_$no_log_message, error_table_$badopt, error_table_$bad_arg,
      958           error_table_$inconsistent) fixed bin (35) ext static;
      959 
      960 end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    07/13/88  0942.4  terminal_report.pl1               >special_ldd>install>MR12.2-1047>terminal_report.pl1
798          1    01/21/85  0912.2  log_limit_info.incl.pl1           >ldd>include>log_limit_info.incl.pl1
799          2    08/06/87  0913.4  as_audit_structures.incl.pl1      >ldd>include>as_audit_structures.incl.pl1
800          3    01/21/85  0912.2  log_message.incl.pl1              >ldd>include>log_message.incl.pl1
801          4    08/06/87  0913.6  user_attributes.incl.pl1          >ldd>include>user_attributes.incl.pl1
4-112        5    07/13/88  0900.1  user_abs_attributes.incl.pl1      >special_ldd>install>MR12.2-1047>user_abs_attributes.incl.pl1
802          6    02/12/85  1429.5  access_audit_bin_header.incl.pl1  >ldd>include>access_audit_bin_header.incl.pl1
803          7    12/21/84  1239.8  time_offset.incl.pl1              >ldd>include>time_offset.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
CHN                             000350 automatic       char(32)                 packed unaligned dcl 894 set ref 157* 161*
INTEGER                                constant        fixed bin(17,0)          initial dcl 7-62 ref 320 321 322
LOG_LIMIT_INFO_VERSION_1        000002 constant        char(8)                  initial packed unaligned dcl 1-17 ref 780
MCH                             000562 automatic       bit(1)                   dcl 903 set ref 152* 153 474* 475
NAME                            000360 automatic       char(22)                 packed unaligned dcl 895 set ref 156* 161*
TIME                            000566 automatic       fixed bin(71,0)          dcl 904 set ref 158* 161*
UNUSED                                 constant        fixed bin(17,0)          initial dcl 7-62 ref 316 317 318 319 323
V                                      based           structure                level 1 dcl 878
V_thr                                  based           structure                level 1 dcl 884
V_two                                  based           structure                level 1 dcl 881
Vtime_offset_2                  000000 constant        char(8)                  initial packed unaligned dcl 7-77 ref 315
add_cpus                        000556 automatic       bit(1)                   packed unaligned dcl 902 set ref 220* 223* 291* 293*
                                                                                  348 373 383 408 412 416 506* 510*
addr                                                   builtin function         dcl 808 ref 71 71 108 186 190 195 326 326 440
addrel                                                 builtin function         dcl 808 ref 113 445
ansb                                   based           varying char(4)          array level 3 in structure "temp_as" dcl 852
                                                                                  in procedure "terminal_report" set ref 133*
ansb                     17            based           char(4)                  level 2 in structure "temporary" dcl 857
                                                                                  in procedure "terminal_report" ref 567
ansb                     17            based           char(4)                  array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 132* 276
                                                                                  276 493 503 527 541
ansb                                   based           varying char(4)          level 2 in structure "temporary_ansb" dcl 854
                                                                                  in procedure "terminal_report" ref 561 562 567 570
                                                                                  572 576
ansb_msg_count                  000572 automatic       fixed bin(35,0)          dcl 906 set ref 74*
ansbk                    12            based           char(4)                  array level 4 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 493* 503
                                                                                  527* 541*
ansbk                    12            based           char(4)                  array level 3 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" ref 576
ansbks                   12            based           structure                array level 3 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report"
ansbks                   12            based           structure                array level 2 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report"
ansbs                                  based           structure                array level 2 dcl 852 set ref 190
answerback               23            based           char(4)                  level 2 dcl 2-52 ref 132 133
arg                                    based           char                     packed unaligned dcl 659 set ref 670 670 672 673 674
                                                                                  674 676 676 679 681 681 682 682 687 687 691 697
                                                                                  697 701 701 702 702 703 704* 707* 716 716 717* 722
                                                                                  722 724 736
argl                            001222 automatic       fixed bin(21,0)          dcl 661 set ref 669* 670 670 672 673 674 674 676 676
                                                                                  679 681 681 682 682 687 687 691 697 697 701 701
                                                                                  702 702 703 704 704 707 707 716 716 716 717 717
                                                                                  722 722 722 724 735* 736
argn                            001220 automatic       fixed bin(17,0)          dcl 660 set ref 668* 669* 734* 734 735*
argp                            001224 automatic       pointer                  dcl 662 set ref 669* 670 670 672 673 674 674 676 676
                                                                                  679 681 681 682 682 687 687 691 697 697 701 701
                                                                                  702 702 703 704 707 716 716 717 722 722 724 735*
                                                                                  736
arh_header_                            based           structure                level 1 dcl 6-26
arh_user_info_                         based           structure                level 1 dcl 6-39
as_channel_audit_record_               based           structure                level 1 dcl 2-74
as_dial_service_audit_record_          based           structure                level 1 dcl 2-105
as_ia_audit_record_                    based           structure                level 1 dcl 2-52
ascnt                    11            based           fixed bin(17,0)          array level 3 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 492* 502
                                                                                  526* 526 527 529 530 531 531 533 533 539* 541 543
                                                                                  544 545 546
ascnt                    11            based           fixed bin(17,0)          level 2 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" ref 214 575
attached                        000554 automatic       bit(1)                   packed unaligned dcl 902 set ref 55* 639 644* 789*
atype                           001174 automatic       varying char(36)         dcl 556 set ref 558* 561 562*
audit_record_header                    based           structure                level 1 dcl 6-18 ref 112 113 444 445
audit_record_ptr                000102 automatic       pointer                  dcl 6-16 set ref 108* 110 112 113 115 115 120 130
                                                                                  440* 442 444 445
audit_record_size               000314 automatic       fixed bin(17,0)          dcl 888 set ref 109* 111 441* 443
auto_log_message_ptr            000614 automatic       pointer                  dcl 944 set ref 160* 163
auto_log_read_ptr               000612 automatic       pointer                  dcl 944 set ref 159* 164
chan_name                              parameter       char(32)                 packed unaligned dcl 428 ref 423 447
channel                   3            based           char(32)                 level 2 dcl 2-52 ref 131
chn                      20            based           char(32)                 array level 3 dcl 868 set ref 131* 157
choosen_name                    000330 automatic       varying char(22)         dcl 892 set ref 120 694*
cleanup                         000646 stack reference condition                dcl 952 ref 24 38
code                            000552 automatic       fixed bin(35,0)          dcl 901 set ref 29* 31 32* 49* 51 52* 56* 57 58* 59*
                                                                                  66* 68 68* 77* 78 79* 168* 170 326* 396* 397* 398*
                                                                                  399* 462* 471 630* 633* 634 635* 640* 641 642* 678
                                                                                  735* 749* 750 751* 752
cods                            000366 automatic       char(120)                dcl 896 set ref 91* 93*
com_err_                        000036 constant        entry                    external dcl 920 ref 32 79
common_min                      001142 automatic       fixed bin(17,0)          dcl 344 set ref 401* 404* 404 408* 409*
common_min_char                 001132 automatic       char(5)                  packed unaligned dcl 342 set ref 408* 409* 412 413
                                                                                  416 417
common_one_one                  001136 automatic       fixed bin(17,0)          dcl 344 set ref 396* 401
common_one_two                  001137 automatic       fixed bin(17,0)          dcl 344 set ref 397* 402
common_sec                      001143 automatic       fixed bin(17,0)          dcl 344 set ref 402* 403 405* 405 410*
common_sec_char                 001134 automatic       char(5)                  packed unaligned dcl 342 set ref 410* 412 413 416
                                                                                  417
common_temp                     001116 automatic       char(8)                  packed unaligned dcl 341 set ref 350* 355* 361* 366*
                                                                                  374* 378* 384 385 390 391
common_tempx                    001120 automatic       char(8)                  packed unaligned dcl 341 set ref 352* 356* 363* 367*
                                                                                  375* 379* 386 387 392 393
common_two_one                  001140 automatic       fixed bin(17,0)          dcl 344 set ref 398* 401
common_two_two                  001141 automatic       fixed bin(17,0)          dcl 344 set ref 399* 402
connect                  34            based           char(8)                  level 2 in structure "temporary" dcl 857
                                                                                  in procedure "terminal_report" set ref 598*
connect                  15            based           char(8)                  array level 3 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" ref 361 585
connect                  34            based           char(8)                  array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 135* 332*
                                                                                  366 378 379 417* 468*
connect                  15            based           char(8)                  array level 4 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 497* 514
                                                                                  516* 530* 544*
connect_time                    001106 automatic       char(8)                  packed unaligned dcl 313 set ref 331* 332
convert_date_to_binary_         000042 constant        entry                    external dcl 922 ref 753 754
coxx                            000462 automatic       char(4)                  dcl 897 set ref 91*
cpu                      17            based           char(6)                  array level 4 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 496* 508
                                                                                  511* 529* 543*
cpu                      36            based           char(10)                 level 2 in structure "temporary" dcl 857
                                                                                  in procedure "terminal_report" set ref 596 596*
                                                                                  598*
cpu                      17            based           char(6)                  array level 3 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" ref 350 583
cpu                      36            based           char(10)                 array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 135* 257*
                                                                                  284 284 284* 284 287 287 287* 287 290 355 374 375
                                                                                  416* 467*
cpu_data                        000464 automatic       char(9)                  packed unaligned dcl 898 set ref 256* 257
cu_$arg_list_ptr                000066 constant        entry                    external dcl 935 ref 29 29
cu_$arg_ptr                     000114 constant        entry                    external dcl 663 ref 735
currentsize                                            builtin function         dcl 808 ref 176 179 180
cv_dec_check_                   000040 constant        entry                    external dcl 921 ref 396 397 398 399 749 751
data                                   based           structure                array level 2 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 186
data                                   based           bit(36)                  array level 2 in structure "log_message" dcl 3-13
                                                                                  in procedure "terminal_report" set ref 108 109 440
                                                                                  441
data_class_lth            2(09)        based           fixed bin(9,0)           level 3 packed packed unsigned unaligned dcl 3-13
                                                                                  ref 108 109 440 441
data_lth                  4(18)        based           fixed bin(17,0)          level 3 packed packed unaligned dcl 3-13 ref 109 441
datax                           000321 automatic       fixed bin(17,0)          dcl 888 set ref 255* 256
date_time_$from_clock_interval  000112 constant        entry                    external dcl 308 ref 326
dimension                                              builtin function         dcl 808 ref 109 441
dpds                            000424 automatic       char(120)                dcl 896 set ref 91* 93*
dpxx                            000463 automatic       char(4)                  dcl 897 set ref 91*
error_table_$bad_arg            000106 external static fixed bin(35,0)          dcl 957 set ref 707* 717*
error_table_$badopt             000104 external static fixed bin(35,0)          dcl 957 set ref 704*
error_table_$inconsistent       000110 external static fixed bin(35,0)          dcl 957 set ref 45*
error_table_$no_log_message     000102 external static fixed bin(35,0)          dcl 957 ref 170 471
exchange_opt                    001260 automatic       varying char(50)         dcl 746 set ref 756* 758
failed                   33            based           bit(1)                   array level 3 dcl 868 set ref 139* 147*
fails                    14            based           fixed bin(35,0)          array level 3 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" ref 217 580
fails                    14            based           fixed bin(35,0)          array level 4 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 494* 519*
                                                                                  519 531* 531 545*
failsw                          000557 automatic       bit(1)                   dcl 903 set ref 140* 142* 494 519 531 545 789*
final_tab                       000561 automatic       bit(1)                   dcl 903 set ref 209* 235* 349 360 789*
first_msg               150     000104 automatic       pointer                  level 3 dcl 814 set ref 73 94 97 100 433
first_msg_count                 000571 automatic       fixed bin(35,0)          dcl 906 set ref 74* 127* 127 129 130 131 132 133 134
                                                                                  135 135 139 143* 143 147 150 153* 153 156 157 158
                                                                                  176 179 182 183 257 273 275 276 276 276 284 287
                                                                                  287 325 332 355 366 375 379 467 468 475* 475 491
                                                                                  493 501 503 527 540 541
flag                      2     001002 automatic       fixed bin(17,0)          array level 2 dcl 310 set ref 316* 317* 318* 319*
                                                                                  320* 321* 322* 323*
for_opt                 114     000104 automatic       varying char(50)         level 3 dcl 814 set ref 673* 783*
from_opt                 76     000104 automatic       varying char(50)         level 3 dcl 814 set ref 670* 748 749 753 756 757*
                                                                                  782*
from_time                       001254 automatic       fixed bin(71,0)          dcl 745 set ref 753* 755
get_temp_segments_              000050 constant        entry                    external dcl 926 ref 77
header                                 based           structure                level 2 dcl 3-13
ihour                           001102 automatic       fixed bin(17,0)          dcl 312 set ref 327* 330
imin                            001103 automatic       fixed bin(17,0)          dcl 312 set ref 328* 330* 330 331*
index                                  based           fixed bin(35,0)          array level 2 in structure "temp_thr" dcl 875
                                                                                  in procedure "terminal_report" set ref 451 456*
index                                                  builtin function         dcl 808 in procedure "terminal_report" ref 137 255
                                                                                  284 287 290 446 447 447 596
index_count                     000553 automatic       fixed bin(35,0)          dcl 901 set ref 74* 450 450 455* 455 456
info_ptr                        000636 automatic       pointer                  dcl 944 set ref 110* 113* 113 123 129 131 132 133
                                                                                  442* 445* 445
info_size                       000313 automatic       fixed bin(17,0)          dcl 888 set ref 111* 112* 112 115 443* 444* 444
inx                             000317 automatic       fixed bin(17,0)          dcl 888 set ref 185* 186 186* 189* 190 190* 194* 195
                                                                                  195* 211* 214 215 217 230 232* 275* 276 276 276
                                                                                  279 279 284 284 284 287 287 290* 350 361 374 378
                                                                                  416 417 450* 451* 500* 501 502 503 508 511 514 516
                                                                                  519 519 521 521 526 526 527 527 529 529 530 530
                                                                                  531 531 531 531 533 533 533 533* 560* 561 562 567
                                                                                  570 572 576*
inxx                            000320 automatic       fixed bin(17,0)          dcl 888 set ref 214* 215 217* 350 361 565* 567 570
                                                                                  572 575 576 578 580 583 585*
inxxx                           001172 automatic       fixed bin(17,0)          dcl 555 set ref 566* 567 567 596 596 598 598 598 598
                                                                                  605 605*
inxxxx                          001173 automatic       fixed bin(17,0)          dcl 555 set ref 575* 576 578 580 583 585*
ioa_$ioa_switch                 000032 constant        entry                    external dcl 920 ref 93 94 97 100 201 203 205 207
                                                                                  230 232 237 239 241 243 245 590 592 598 605 619
ioa_$rsnnl                      000034 constant        entry                    external dcl 920 ref 331 408 409 410
iocb                    166     000104 automatic       pointer                  level 2 dcl 814 set ref 49* 56* 59* 93* 94* 97* 100*
                                                                                  201* 203* 205* 207* 230* 232* 237* 239* 241* 243*
                                                                                  245* 590* 592* 598* 605* 619* 633* 640* 785*
iox_$attach_name                000070 constant        entry                    external dcl 936 ref 49
iox_$close                      000076 constant        entry                    external dcl 939 ref 633
iox_$detach_iocb                000074 constant        entry                    external dcl 938 ref 59 640
iox_$open                       000072 constant        entry                    external dcl 937 ref 56
iox_$user_output                000100 external static pointer                  dcl 947 ref 785
isec                            001104 automatic       fixed bin(17,0)          dcl 312 set ref 329* 331*
last_msg                152     000104 automatic       pointer                  level 3 dcl 814 set ref 94 97 100 172 466
last_opt                132     000104 automatic       varying char(50)         level 3 dcl 814 set ref 674*
len                             000570 automatic       fixed bin(21,0)          dcl 905 set ref 331* 408* 409* 410*
limit                    56     000104 automatic       structure                level 2 dcl 814 set ref 71 71
lmd_ptr                  54     000104 automatic       pointer                  level 3 dcl 814 set ref 41* 106* 434* 435* 438* 476*
                                                                                  477* 628 628* 779*
log_format_time_                000030 constant        entry                    external dcl 919 ref 94 97 100 100
log_limit_info                         based           structure                level 1 dcl 1-6
log_limit_scan_                 000026 constant        entry                    external dcl 918 ref 71
log_match_$add_match            000016 constant        entry                    external dcl 914 ref 41 435 477
log_match_$clear_text_strings   000024 constant        entry                    external dcl 917 ref 434 476
log_match_$free                 000020 constant        entry                    external dcl 915 ref 628
log_match_$test                 000022 constant        entry                    external dcl 916 ref 106 438
log_message                            based           structure                level 1 dcl 3-13
log_message_header                     based           structure                level 1 dcl 3-3
log_message_ptr                 000100 automatic       pointer                  dcl 3-19 set ref 21* 73* 104 106* 108 109 134 137
                                                                                  160 163* 168* 170* 172 433* 437 438* 440 441 446
                                                                                  447 447 447 453 454 462* 466 471*
log_pathname                    000104 automatic       char(168)                level 2 packed packed unaligned dcl 814 set ref 784*
log_read_$close                 000012 constant        entry                    external dcl 912 ref 626
log_read_$next_message          000014 constant        entry                    external dcl 913 ref 168 462
log_read_$open                  000010 constant        entry                    external dcl 911 ref 66
log_read_ptr                    000574 automatic       pointer                  dcl 944 set ref 21* 66* 71* 159 164* 168* 462* 626
                                                                                  626*
login                    13            based           fixed bin(35,0)          array level 4 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 495* 521*
                                                                                  521 533* 533 546*
login                    13            based           fixed bin(35,0)          array level 3 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" ref 215 578
login_name                             parameter       char(22)                 packed unaligned dcl 427 ref 423 447
login_time                             parameter       fixed bin(71,0)          dcl 429 ref 423 447
logins                   32            based           fixed bin(35,0)          array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 150* 279*
                                                                                  279
logins                   32            based           fixed bin(35,0)          level 2 in structure "temporary" dcl 857
                                                                                  in procedure "terminal_report" set ref 598* 605*
looking_for                     000337 automatic       varying char(32)         dcl 893 set ref 118 123 667* 683* 688* 692* 694 698*
ltrim                                                  builtin function         dcl 808 ref 396 396 398 398
match_made                             parameter       bit(1)                   dcl 271 set ref 267 274* 281* 296*
msg_count                       001152 automatic       fixed bin(35,0)          dcl 430 set ref 432* 439* 439 451 456
mtsw                            000563 automatic       bit(1)                   dcl 903 set ref 151 201 205 208 219 230 237 241 280
                                                                                  582 590 595 701* 702* 789*
n                                      based           fixed bin(18,0)          level 2 dcl 878 set ref 182* 185 197 566
n_thr                                  based           fixed bin(18,0)          level 2 dcl 884 set ref 183* 189 199 560
n_two                                  based           fixed bin(18,0)          level 2 dcl 881 set ref 193* 194 198 565
name                                   based           varying char(22)         array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 130* 156
                                                                                  276 276
name                                   based           varying char(22)         level 2 in structure "temporary" dcl 857
                                                                                  in procedure "terminal_report" set ref 598* 605*
nargs                           001221 automatic       fixed bin(17,0)          dcl 660 set ref 665* 668
null                                                   builtin function         dcl 808 ref 21 25 49 49 94 97 104 170 437 471 626
                                                                                  628 630 646 778 779
opened                          000555 automatic       bit(1)                   packed unaligned dcl 902 set ref 62* 632 637* 789*
opt                             000104 automatic       structure                level 1 unaligned dcl 814 set ref 777*
option                                 parameter       varying char             dcl 732 set ref 729 736*
out_of_bounds                   000640 stack reference condition                dcl 952 ref 88
output_file                     000467 automatic       varying char(168)        dcl 899 set ref 48 49 52* 58* 635* 642* 677* 678*
                                                                                  679* 681* 788*
person                    4            based           char(22)                 level 3 packed packed unaligned dcl 6-18 ref 120 130
pointer                                                builtin function         dcl 808 ref 176 179 180
pointers                 52     000104 automatic       structure                level 2 unaligned dcl 814 set ref 778*
process_id               15            based           bit(36)                  level 3 dcl 6-18 ref 115
reader_procedure        155     000104 automatic       varying char(32)         level 2 dcl 814 set ref 65 786*
release_temp_segments_          000052 constant        entry                    external dcl 926 ref 630
rtrim                                                  builtin function         dcl 808 ref 123 123 156 157 276 276 276 276 276 276
                                                                                  284 284 287 287 350 352 355 356 361 363 366 367
                                                                                  374 375 378 379 396 396 397 397 398 398 399 399
                                                                                  412 412 413 413 416 416 417 417 447 447
sci_ptr                         000616 automatic       pointer                  dcl 944 set ref 21* 25 25* 29* 45* 52* 58* 68* 71*
                                                                                  635* 642* 646 646* 665* 669* 704* 707* 717*
size                                                   builtin function         dcl 808 ref 112 113 444 445
sort_items_$varying_char        000046 constant        entry                    external dcl 925 ref 197 198 199
ssu_$abort_line                 000060 constant        entry                    external dcl 931 ref 45 52 58 68 635 642 704 707 717
ssu_$arg_count                  000064 constant        entry                    external dcl 934 ref 665
ssu_$arg_ptr                    000062 constant        entry                    external dcl 932 ref 669
ssu_$destroy_invocation         000056 constant        entry                    external dcl 930 ref 25 646
ssu_$standalone_invocation      000054 constant        entry                    external dcl 928 ref 29
sub_one_one                     001122 automatic       char(5)                  packed unaligned dcl 342 set ref 384* 390* 396 396
sub_one_two                     001124 automatic       char(5)                  packed unaligned dcl 342 set ref 385* 391* 397 397
sub_two_one                     001126 automatic       char(5)                  packed unaligned dcl 342 set ref 386* 392* 398 398
sub_two_two                     001130 automatic       char(5)                  packed unaligned dcl 342 set ref 387* 393* 399 399
subject                   4            based           structure                level 2 dcl 6-18
substr                                                 builtin function         dcl 808 ref 256 384 385 386 387 390 391 392 393 703
                                                                                  716 716 722 722
system_info_$titles             000044 constant        entry                    external dcl 923 ref 91
tag                      13(27)        based           char(1)                  level 3 packed packed unaligned dcl 6-18 ref 115
temp                                   based           structure                array level 1 dcl 868 set ref 176
temp_as                                based           structure                array level 1 dcl 852 set ref 179
temp_as_ptr                     000576 automatic       pointer                  dcl 944 set ref 21* 83* 133 179 179 190
temp_number                     001252 automatic       fixed bin(17,0)          dcl 744 set ref 749* 751*
temp_ptr                        000620 automatic       pointer                  dcl 944 set ref 21* 82* 129 130 131 132 134 135 135
                                                                                  139 147 150 156 157 158 176 176 186 257 276 276
                                                                                  276 276 276 276 279 279 284 284 284 284 287 287
                                                                                  287 287 290 325 332 355 366 374 375 378 379 416
                                                                                  417 467 468 491 493 501 503 527 540 541
temp_ptrs                       000600 automatic       pointer                  array dcl 944 set ref 77* 82 83 84 85 86 630 630*
temp_thr                               based           structure                array level 1 dcl 875
temp_two                               based           structure                array level 1 dcl 871
temp_two_ptr                    000622 automatic       pointer                  dcl 944 set ref 21* 84* 255 256 324 453 454
temporary                              based           structure                level 1 dcl 857
temporary_ansb                         based           structure                level 1 dcl 854
terminal_type            13            based           char(32)                 level 2 dcl 2-52 ref 123 129
text                                   based           varying char(128)        array level 2 in structure "temp_two" dcl 871
                                                                                  in procedure "terminal_report" set ref 255 256
                                                                                  453*
text                      6            based           char                     level 2 in structure "log_message" packed packed
                                                                                  unaligned dcl 3-13 in procedure "terminal_report"
                                                                                  ref 137 446 447 447 453
text_lth                  4            based           fixed bin(17,0)          level 3 packed packed unaligned dcl 3-13 ref 108 109
                                                                                  137 440 441 446 447 447 453
time                      2(18)        based           fixed bin(53,0)          level 3 in structure "log_message" packed packed
                                                                                  unaligned dcl 3-13 in procedure "terminal_report"
                                                                                  ref 94 97 100 100 134 447 454
time                     42            based           fixed bin(71,0)          array level 2 in structure "temp_two" dcl 871
                                                                                  in procedure "terminal_report" set ref 324 454*
time                     30            based           fixed bin(71,0)          array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 134* 158
                                                                                  325
time_offset                            based           structure                level 1 dcl 7-37
time_offset_array                      based           structure                level 1 dcl 7-88
time_one                        001076 automatic       fixed bin(71,0)          dcl 311 set ref 324* 326*
time_two                        001100 automatic       fixed bin(71,0)          dcl 311 set ref 325* 326*
to                              000706 automatic       structure                level 1 dcl 309
to_opt                   60     000104 automatic       varying char(50)         level 3 dcl 814 set ref 672* 748 751 754 757 758*
                                                                                  781*
to_time                         001256 automatic       fixed bin(71,0)          dcl 745 set ref 754* 755
toa                             001002 automatic       structure                level 1 dcl 310 set ref 326 326
tot_connect                     000324 automatic       char(8)                  packed unaligned dcl 890 set ref 213* 224 224* 230*
                                                                                  363 367 413* 513 513* 514* 516 585* 590* 788*
tot_cpu                         000326 automatic       char(6)                  packed unaligned dcl 891 set ref 213* 221 221* 230*
                                                                                  352 356 412* 507 507* 508* 511 583* 590* 788*
tot_data                               based           structure                array level 2 dcl 839 set ref 195
tot_logi                        000322 automatic       fixed bin(17,0)          dcl 888 set ref 212* 215* 215 230* 232* 574* 578*
                                                                                  578 590* 592*
tot_logo                        000323 automatic       fixed bin(17,0)          dcl 888 set ref 212* 217* 217 230* 232* 574* 580*
                                                                                  580 590* 592*
ttp                             000626 automatic       pointer                  dcl 944 in procedure "terminal_report" set ref 85*
                                                                                  451 456
ttp                       7            based           char(32)                 array level 3 in structure "temp" dcl 868
                                                                                  in procedure "terminal_report" set ref 129* 276
                                                                                  276 491 501 540
ttp                       7            based           char(32)                 level 2 in structure "temporary" dcl 857
                                                                                  in procedure "terminal_report" ref 567
ttp_meters                      000560 automatic       bit(1)                   dcl 903 set ref 209* 235 235* 259* 261* 347 411 505
                                                                                  789*
ttp_tot                                based           structure                array level 1 dcl 839 set ref 180 792*
ttp_tot_data                           based           structure                level 1 dcl 842
ttp_tot_ptr                     000624 automatic       pointer                  dcl 944 set ref 21* 86* 180 180 195 491 492 493 494
                                                                                  495 496 497 501 502 503 508 511 514 516 519 519
                                                                                  521 521 526 526 527 527 529 529 530 530 531 531
                                                                                  531 531 533 533 533 533 539 540 541 541 543 543
                                                                                  544 544 545 545 546 546 792
ttpsw                           000565 automatic       bit(1)                   dcl 903 set ref 44 685* 689* 789*
ttx                             000315 automatic       fixed bin(17,0)          dcl 888 set ref 180 193 211 489 490* 490 491 492 493
                                                                                  494 495 496 497 500 538* 538 539 540 541 541 543
                                                                                  543 544 544 545 545 546 546 791* 792
ttxx                            000316 automatic       fixed bin(17,0)          dcl 888 set ref 502* 503 508 511 514 516 519 519 521
                                                                                  521*
ttype                           000542 automatic       char(32)                 packed unaligned dcl 900 set ref 558* 570 572* 590*
                                                                                  592*
type                                   based           varying char(32)         array level 3 in structure "ttp_tot" dcl 839
                                                                                  in procedure "terminal_report" set ref 491* 501
                                                                                  540*
type                                   based           varying char(32)         level 2 in structure "ttp_tot_data" dcl 842
                                                                                  in procedure "terminal_report" set ref 230* 232*
                                                                                  567 570 572
unspec                                                 builtin function         dcl 808 set ref 777* 792*
user_attributes                        based           structure                level 1 dcl 4-21
usersw                          000564 automatic       bit(1)                   dcl 903 set ref 44 119 695* 699* 789*
val                      12     001002 automatic       float dec(20)            array level 2 dcl 310 set ref 327 328 329
vector                    1            based           pointer                  array level 2 packed packed unaligned dcl 878 set
                                                                                  ref 186* 567 567 596 596 598 598 598 598 605 605
vector_thr                1            based           pointer                  array level 2 packed packed unaligned dcl 884 set
                                                                                  ref 190* 561 562 567 570 572 576
vector_two                1            based           pointer                  array level 2 packed packed unaligned dcl 881 set
                                                                                  ref 195* 214 215 217 230 232 350 361 567 570 572
                                                                                  575 576 578 580 583 585
version                         001002 automatic       char(8)                  level 2 in structure "toa" dcl 310 in procedure
                                                                                  "get_connect_time" set ref 315*
version                  56     000104 automatic       char(8)                  level 3 in structure "opt" dcl 814 in procedure
                                                                                  "terminal_report" set ref 780*
version                         000706 automatic       char(8)                  level 2 in structure "to" dcl 309 in procedure
                                                                                  "get_connect_time" set ref 315*
vptr                            000630 automatic       pointer                  dcl 944 set ref 21* 176* 182 185 186 197 197* 566
                                                                                  567 567 596 596 598 598 598 598 605 605
vptr_ansb                       000634 automatic       pointer                  dcl 944 set ref 21* 179* 183 189 190 199 199* 560
                                                                                  561 562 567 570 572 576
vptr_two                        000632 automatic       pointer                  dcl 944 set ref 21* 180* 193 194 195 198 198* 214
                                                                                  215 217 230 232 350 361 565 567 570 572 575 576
                                                                                  578 580 583 585

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABS_ATTRIBUTE_NAMES                    internal static varying char(28)         initial array dcl 5-38
ACCESS_AUDIT_HEADER_VERSION_3          internal static fixed bin(9,0)           initial unsigned dcl 6-54
AFTER                                  internal static fixed bin(17,0)          initial dcl 7-62
ALT_USER_ATTRIBUTE_NAMES               internal static char(20)                 initial array packed unaligned dcl 4-77
ARH_TYPE_NO_PROXY                      internal static fixed bin(17,0)          initial dcl 6-52
ARH_TYPE_PROXY                         internal static fixed bin(17,0)          initial dcl 6-50
AS_AUDIT_CHANNEL_ACTIONS               internal static char(12)                 initial array packed unaligned dcl 2-193
AS_AUDIT_CHANNEL_ATTACH                internal static fixed bin(17,0)          initial dcl 2-175
AS_AUDIT_CHANNEL_DETACH                internal static fixed bin(17,0)          initial dcl 2-175
AS_AUDIT_CHANNEL_DIALIN                internal static fixed bin(17,0)          initial dcl 2-175
AS_AUDIT_CHANNEL_DIALOUT               internal static fixed bin(17,0)          initial dcl 2-175
AS_AUDIT_CHANNEL_DIAL_SYSTEM           internal static fixed bin(17,0)          initial dcl 2-175
AS_AUDIT_CHANNEL_DIRECTION             internal static char(4)                  initial array packed unaligned dcl 2-196
AS_AUDIT_CHANNEL_SERVICE_INFO          internal static char(12)                 initial array packed unaligned dcl 2-199
AS_AUDIT_DIALID_START                  internal static fixed bin(17,0)          initial dcl 2-188
AS_AUDIT_DIALID_STOP                   internal static fixed bin(17,0)          initial dcl 2-188
AS_AUDIT_PROCESS_ACTIONS               internal static char(10)                 initial array packed unaligned dcl 2-202
AS_AUDIT_PROCESS_CONNECT               internal static fixed bin(17,0)          initial dcl 2-162
AS_AUDIT_PROCESS_CREATE                internal static fixed bin(17,0)          initial dcl 2-162
AS_AUDIT_PROCESS_DESTROY               internal static fixed bin(17,0)          initial dcl 2-162
AS_AUDIT_PROCESS_DISCONNECT            internal static fixed bin(17,0)          initial dcl 2-162
AS_AUDIT_PROCESS_TERMINATE             internal static fixed bin(17,0)          initial dcl 2-162
AS_AUDIT_RECORD_CHN_VERSION_1          internal static fixed bin(9,0)           initial dcl 2-156
AS_AUDIT_RECORD_DIALID_VERSION_1       internal static fixed bin(9,0)           initial dcl 2-159
AS_AUDIT_RECORD_IA_VERSION_1           internal static fixed bin(9,0)           initial dcl 2-153
BEFORE                                 internal static fixed bin(17,0)          initial dcl 7-62
FRACTION                               internal static fixed bin(17,0)          initial dcl 7-62
ON_OR_AFTER                            internal static fixed bin(17,0)          initial dcl 7-62
ON_OR_BEFORE                           internal static fixed bin(17,0)          initial dcl 7-62
Ptime_offset                           automatic       pointer                  dcl 7-77
USED                                   internal static fixed bin(17,0)          initial dcl 7-62
USER_ATTRIBUTES_always_allowed         internal static bit(36)                  initial dcl 4-100
USER_ATTRIBUTES_default_in_pdt         internal static bit(36)                  initial dcl 4-104
USER_ATTRIBUTES_settable_by_user       internal static bit(36)                  initial dcl 4-108
USER_ATTRIBUTE_NAMES                   internal static char(20)                 initial array packed unaligned dcl 4-50
as_channel_audit_record                based           structure                level 1 dcl 2-68
as_dial_service_audit_record           based           structure                level 1 dcl 2-100
as_ia_audit_record_abs                 based           structure                level 1 dcl 2-34
as_ia_audit_record_abs_proxy           based           structure                level 1 dcl 2-41
as_ia_audit_record_int_dmn             based           structure                level 1 dcl 2-27
audit_record_header_proxy              based           structure                level 1 dcl 6-22
channel_audit_info                     based           structure                level 1 dcl 2-138
channel_audit_info_ptr                 automatic       pointer                  dcl 2-136
dial_server_info                       based           structure                level 1 dcl 2-124
dial_server_info_ptr                   automatic       pointer                  dcl 2-122
log_limit_info_ptr                     automatic       pointer                  dcl 1-4
log_message_data_class_lth             automatic       fixed bin(17,0)          dcl 3-21
log_message_data_lth                   automatic       fixed bin(17,0)          dcl 3-22
log_message_text_lth                   automatic       fixed bin(17,0)          dcl 3-20
ssu_$arg_list_ptr               000000 constant        entry                    external dcl 933
user_abs_attributes                    based           structure                level 1 dcl 5-25

NAMES DECLARED BY EXPLICIT CONTEXT.
INVALID_ERROR                   007704 constant        label                    dcl 717 ref 722 724
Next                            002364 constant        label                    dcl 168 set ref 120 123 144 154
add_common_times                004052 constant        entry                    internal dcl 338 ref 222 225 292 294 509 515
add_ttp_data                    005760 constant        entry                    internal dcl 485 ref 141 148 260
check_for_dups                  003263 constant        entry                    internal dcl 267 ref 152 474
check_options                   010023 constant        entry                    internal dcl 740 ref 709
clean_up                        007035 constant        entry                    internal dcl 625 ref 38 46 53 60 80 248 620 705 720
                                                                                  770
exit                            003226 constant        label                    dcl 653 ref 649
get_connect_time                003701 constant        entry                    internal dcl 305 ref 258
get_cpu_time                    003227 constant        entry                    internal dcl 252 ref 457
get_next_arg                    007760 constant        entry                    internal dcl 729 ref 670 672 673 674 677 683 692
initialize_options              010255 constant        entry                    internal dcl 775 ref 36
oob                             007004 constant        entry                    internal dcl 618 ref 88
output_data                     006331 constant        entry                    internal dcl 552 ref 246
process_arguments               007267 constant        entry                    internal dcl 656 ref 43
process_looking_for             007665 constant        entry                    internal dcl 713 ref 684 693
scan_LOGOUTS                    005366 constant        entry                    internal dcl 423 ref 161
scan_log                        002007 constant        label                    dcl 104 ref 173
setup                           005716 constant        label                    dcl 474 ref 458 469
skip_call                       007001 constant        label                    dcl 612 ref 561
skip_msg_count                  005653 constant        label                    dcl 462 ref 451
sort_em                         002412 constant        label                    dcl 176 ref 172
ssu_abort                       010242 constant        entry                    internal dcl 768 ref 29 29
terminal_report                 000566 constant        entry                    external dcl 18

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     11074       11212   10422       11104
Length     11666   10422       116         437     451           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
terminal_report                    1094 external procedure  is an external procedure.  
on unit on line 24                   68 on unit               
on unit on line 38                   64 on unit               
on unit on line 88                   94 on unit               
get_cpu_time                            internal procedure  shares stack frame of external procedure terminal_report.  
check_for_dups                          internal procedure  shares stack frame of external procedure terminal_report.  
get_connect_time                        internal procedure  shares stack frame of external procedure terminal_report.  
add_common_times                        internal procedure  shares stack frame of external procedure terminal_report.  
scan_LOGOUTS                            internal procedure  shares stack frame of external procedure terminal_report.  
add_ttp_data                            internal procedure  shares stack frame of external procedure terminal_report.  
output_data                             internal procedure  shares stack frame of external procedure terminal_report.  
oob                                     internal procedure  shares stack frame of on unit on line 88.  
clean_up                            104 internal procedure  is called by several nonquick procedures.  
process_arguments                       internal procedure  shares stack frame of external procedure terminal_report.  
process_looking_for                     internal procedure  shares stack frame of external procedure terminal_report.  
get_next_arg                            internal procedure  shares stack frame of external procedure terminal_report.  
check_options                           internal procedure  shares stack frame of external procedure terminal_report.  
ssu_abort                            64 internal procedure  is assigned to an entry variable.  
initialize_options                      internal procedure  shares stack frame of external procedure terminal_report.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
terminal_report          000100 log_message_ptr             terminal_report
                         000102 audit_record_ptr            terminal_report
                         000104 opt                         terminal_report
                         000313 info_size                   terminal_report
                         000314 audit_record_size           terminal_report
                         000315 ttx                         terminal_report
                         000316 ttxx                        terminal_report
                         000317 inx                         terminal_report
                         000320 inxx                        terminal_report
                         000321 datax                       terminal_report
                         000322 tot_logi                    terminal_report
                         000323 tot_logo                    terminal_report
                         000324 tot_connect                 terminal_report
                         000326 tot_cpu                     terminal_report
                         000330 choosen_name                terminal_report
                         000337 looking_for                 terminal_report
                         000350 CHN                         terminal_report
                         000360 NAME                        terminal_report
                         000366 cods                        terminal_report
                         000424 dpds                        terminal_report
                         000462 coxx                        terminal_report
                         000463 dpxx                        terminal_report
                         000464 cpu_data                    terminal_report
                         000467 output_file                 terminal_report
                         000542 ttype                       terminal_report
                         000552 code                        terminal_report
                         000553 index_count                 terminal_report
                         000554 attached                    terminal_report
                         000555 opened                      terminal_report
                         000556 add_cpus                    terminal_report
                         000557 failsw                      terminal_report
                         000560 ttp_meters                  terminal_report
                         000561 final_tab                   terminal_report
                         000562 MCH                         terminal_report
                         000563 mtsw                        terminal_report
                         000564 usersw                      terminal_report
                         000565 ttpsw                       terminal_report
                         000566 TIME                        terminal_report
                         000570 len                         terminal_report
                         000571 first_msg_count             terminal_report
                         000572 ansb_msg_count              terminal_report
                         000574 log_read_ptr                terminal_report
                         000576 temp_as_ptr                 terminal_report
                         000600 temp_ptrs                   terminal_report
                         000612 auto_log_read_ptr           terminal_report
                         000614 auto_log_message_ptr        terminal_report
                         000616 sci_ptr                     terminal_report
                         000620 temp_ptr                    terminal_report
                         000622 temp_two_ptr                terminal_report
                         000624 ttp_tot_ptr                 terminal_report
                         000626 ttp                         terminal_report
                         000630 vptr                        terminal_report
                         000632 vptr_two                    terminal_report
                         000634 vptr_ansb                   terminal_report
                         000636 info_ptr                    terminal_report
                         000706 to                          get_connect_time
                         001002 toa                         get_connect_time
                         001076 time_one                    get_connect_time
                         001100 time_two                    get_connect_time
                         001102 ihour                       get_connect_time
                         001103 imin                        get_connect_time
                         001104 isec                        get_connect_time
                         001106 connect_time                get_connect_time
                         001116 common_temp                 add_common_times
                         001120 common_tempx                add_common_times
                         001122 sub_one_one                 add_common_times
                         001124 sub_one_two                 add_common_times
                         001126 sub_two_one                 add_common_times
                         001130 sub_two_two                 add_common_times
                         001132 common_min_char             add_common_times
                         001134 common_sec_char             add_common_times
                         001136 common_one_one              add_common_times
                         001137 common_one_two              add_common_times
                         001140 common_two_one              add_common_times
                         001141 common_two_two              add_common_times
                         001142 common_min                  add_common_times
                         001143 common_sec                  add_common_times
                         001152 msg_count                   scan_LOGOUTS
                         001172 inxxx                       output_data
                         001173 inxxxx                      output_data
                         001174 atype                       output_data
                         001220 argn                        process_arguments
                         001221 nargs                       process_arguments
                         001222 argl                        process_arguments
                         001224 argp                        process_arguments
                         001252 temp_number                 check_options
                         001254 from_time                   check_options
                         001256 to_time                     check_options
                         001260 exchange_opt                check_options

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     cat_realloc_chars   call_ext_out_desc   call_ext_out        call_int_this       call_int_other
return_mac          tra_ext_1           enable_op           shorten_stack       ext_entry           int_entry
set_chars_eis       index_chars_eis

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_date_to_binary_       cu_$arg_list_ptr              cu_$arg_ptr
cv_dec_check_                 date_time_$from_clock_interval                              get_temp_segments_
ioa_$ioa_switch               ioa_$rsnnl                    iox_$attach_name              iox_$close
iox_$detach_iocb              iox_$open                     log_format_time_              log_limit_scan_
log_match_$add_match          log_match_$clear_text_strings log_match_$free               log_match_$test
log_read_$close               log_read_$next_message        log_read_$open                release_temp_segments_
sort_items_$varying_char      ssu_$abort_line               ssu_$arg_count                ssu_$arg_ptr
ssu_$destroy_invocation       ssu_$standalone_invocation    system_info_$titles

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_arg          error_table_$badopt           error_table_$inconsistent     error_table_$no_log_message
iox_$user_output




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     18 000565        21 000573        24 000606        25 000622        27 000635        29 000636        31 000714
     32 000716        33 000750        36 000751        38 000752        41 000774        43 001013        44 001014
     45 001020        46 001047        48 001053        49 001060        51 001132        52 001135        53 001165
     55 001171        56 001173        57 001222        58 001224        59 001254        60 001265        62 001271
     65 001273        66 001300        68 001333        71 001364        73 001405        74 001407        77 001412
     78 001441        79 001443        80 001475        82 001501        83 001503        84 001505        85 001507
     86 001511        88 001513        91 001531        93 001554        94 001602        97 001652       100 001722
    104 002007       106 002014       108 002044       109 002062       110 002066       111 002067       112 002070
    113 002072       115 002075       118 002105       119 002112       120 002114       121 002121       123 002122
    127 002153       129 002157       130 002165       131 002175       132 002201       133 002203       134 002212
    135 002217       137 002226       139 002240       140 002242       141 002243       142 002244       143 002245
    144 002253       147 002254       148 002255       150 002256       151 002264       152 002267       153 002271
    154 002302       156 002303       157 002331       158 002350       159 002352       160 002354       161 002356
    163 002360       164 002362       168 002364       170 002377       172 002405       173 002411       176 002412
    179 002417       180 002424       182 002431       183 002433       185 002434       186 002443       187 002450
    189 002452       190 002461       191 002466       193 002470       194 002472       195 002501       196 002506
    197 002510       198 002522       199 002534       201 002546       203 002571       205 002611       207 002634
    208 002654       209 002656       211 002661       212 002671       213 002673       214 002677       215 002711
    217 002721       219 002725       220 002727       221 002731       222 002744       223 002745       224 002746
    225 002754       227 002755       230 002757       232 003027       234 003065       235 003067       237 003073
    239 003116       241 003136       243 003161       245 003201       246 003220       248 003221       249 003225
    653 003226       252 003227       255 003230       256 003243       257 003246       258 003255       259 003256
    260 003260       261 003261       262 003262       267 003263       273 003265       274 003271       275 003272
    276 003306       279 003476       280 003505       281 003510       282 003513       284 003514       287 003604
    290 003662       291 003665       292 003667       293 003670       294 003671       296 003672       297 003675
    299 003676       300 003700       305 003701       315 003702       316 003705       317 003707       318 003710
    319 003711       320 003712       321 003714       322 003715       323 003716       324 003720       325 003723
    326 003730       327 003747       328 003761       329 003773       330 004005       331 004010       332 004042
    334 004051       338 004052       347 004053       348 004055       349 004057       350 004061       352 004107
    353 004123       355 004124       356 004152       358 004166       360 004167       361 004171       363 004217
    364 004233       366 004234       367 004262       370 004276       373 004277       374 004301       375 004327
    376 004353       378 004354       379 004402       383 004426       384 004430       385 004435       386 004442
    387 004447       388 004454       390 004455       391 004460       392 004466       393 004471       396 004477
    397 004555       398 004620       399 004677       401 004742       402 004746       403 004751       404 004753
    405 004754       408 004756       409 005010       410 005037       411 005066       412 005070       413 005145
    414 005220       416 005222       417 005304       418 005364       423 005366       432 005370       433 005371
    434 005373       435 005402       437 005421       438 005426       439 005456       440 005462       441 005500
    442 005504       443 005505       444 005506       445 005510       446 005513       447 005524       450 005601
    451 005611       452 005616       453 005620       454 005634       455 005641       456 005645       457 005651
    458 005652       462 005653       466 005666       467 005672       468 005701       469 005706       471 005707
    472 005715       474 005716       475 005720       476 005731       477 005740       480 005757       485 005760
    489 005761       490 005763       491 005764       492 006003       493 006005       494 006010       495 006016
    496 006020       497 006023       498 006026       500 006027       501 006035       502 006054       503 006065
    505 006104       506 006106       507 006110       508 006124       509 006130       510 006131       511 006132
    513 006146       514 006156       515 006161       516 006162       518 006175       519 006176       521 006205
    523 006211       525 006212       526 006214       527 006220       529 006232       530 006235       531 006240
    533 006250       535 006254       537 006255       538 006257       539 006260       540 006266       541 006301
    543 006311       544 006315       545 006320       546 006326       548 006330       552 006331       558 006332
    560 006336       561 006345       562 006354       565 006361       566 006371       567 006401       570 006420
    572 006451       574 006477       575 006502       576 006511       578 006526       580 006533       582 006537
    583 006541       585 006545       589 006550       590 006552       592 006620       595 006656       596 006660
    598 006677       603 006737       605 006740       610 006775       611 006777       612 007001       614 007003
    618 007004       619 007005       620 007026       621 007033       625 007034       626 007042       628 007060
    630 007074       632 007130       633 007133       634 007144       635 007147       637 007177       639 007201
    640 007203       641 007214       642 007217       644 007247       646 007251       649 007264       656 007267
    665 007270       667 007301       668 007302       669 007311       670 007326       672 007344       673 007354
    674 007364       676 007400       677 007410       678 007413       679 007423       680 007434       681 007435
    682 007447       683 007457       684 007462       685 007463       686 007465       687 007466       688 007476
    689 007477       690 007500       691 007501       692 007505       693 007510       694 007511       695 007521
    696 007523       697 007524       698 007534       699 007535       700 007536       701 007537       702 007552
    703 007564       704 007570       705 007622       706 007626       707 007627       708 007661       709 007663
    710 007664       713 007665       716 007666       717 007704       720 007737       721 007743       722 007744
    724 007752       725 007757       729 007760       734 007771       735 007772       736 010007       737 010022
    740 010023       748 010024       749 010036       750 010070       751 010073       752 010125       753 010130
    754 010162       755 010215       756 010221       757 010226       758 010233       763 010240       768 010241
    770 010247       771 010254       775 010255       777 010256       778 010261       780 010264       781 010266
    782 010267       783 010270       784 010271       785 010274       786 010300       788 010301       789 010307
    791 010317       792 010320       793 010331


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
