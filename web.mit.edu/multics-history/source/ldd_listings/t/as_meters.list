	COMPILATION LISTING OF SEGMENT as_meters
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Bull, Phx. Az., Sys-M 
	Compiled on: 08/04/87  1311.1 mst Tue
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Bull Inc., 1987                *
        4*        *                                                         *
        5*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        6*        *                                                         *
        7*        * Copyright (c) 1972 by Massachusetts Institute of        *
        8*        * Technology and Honeywell Information Systems, Inc.      *
        9*        *                                                         *
       10*        *********************************************************** */
       11 
       12 as_meters: proc;
       13 
       14 /* Command to print >sc1>as_meter_table.
       15*   Coded by Tom Casey, March 1980.
       16*   Modified May 1981 by T. Casey to print asmt meters in header.
       17*   Modified June 1981 by T. Casey for MR9.0 to print the ABS_TRYLOG meter.
       18*   Modified July 1981 by T. Casey to add -reset, -report_reset, &c.
       19**/
       20 
       21 
       22 /****^  HISTORY COMMENTS:
       23*  1) change(87-07-21,Herbst), approve(87-07-21,MCR7694),
       24*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1055):
       25*      A) Update for AS_METER_NAMES array declared in
       26*         as_meter_numbers.incl.pl1.
       27*                                                   END HISTORY COMMENTS */
       28 
       29 
       30 /* Ext. Entries */
       31 
       32 dcl  cu_$arg_count entry returns (fixed bin);
       33 dcl  cu_$arg_ptr entry (fixed bin, ptr, fixed bin, fixed bin (35));
       34 dcl (ioa_, ioa_$rsnnl, com_err_) entry options (variable);
       35 dcl  date_time_ entry (fixed bin (71), char (*));
       36 dcl  decode_clock_value_$date_time entry (fixed bin (71), fixed bin, fixed bin, fixed bin,
       37      fixed bin, fixed bin, fixed bin, fixed bin (71), fixed bin, char (3), fixed bin (35));
       38 dcl  get_temp_segment_ entry (char (*), ptr, fixed bin (35));
       39 dcl  hcs_$initiate entry (char (*), char (*), char (*), fixed bin (1), fixed bin (2), ptr, fixed bin (35));
       40 dcl  hcs_$terminate_noname entry (ptr, fixed bin (35));
       41 dcl  release_temp_segment_ entry (char (*), ptr, fixed bin (35));
       42 
       43 /* Automatic and Based */
       44 
       45 dcl  code fixed bin (35);
       46 dcl  ignore_code fixed bin (35);			/* crossref will show where we ignore return codes */
       47 dcl  i fixed bin;
       48 dcl (month, day, year, hour, minute, second, dow) fixed bin;
       49 dcl  usec fixed bin (71);
       50 dcl  zone char (3) init ("");
       51 dcl (asmtp, asmtep) ptr init (null);
       52 dcl  argp ptr, argl fixed bin, arg char (argl) based (argp);
       53 dcl  totalsw bit (1) aligned init (""b);
       54 dcl  namesw bit (1) aligned init ("1"b);
       55 dcl  shortnamesw bit (1) aligned init (""b);
       56 dcl  total_real_time fixed bin (71);
       57 dcl  sigma_vcpu fixed bin (71) init (0);
       58 dcl  sigma_pf fixed bin (34) init (0);
       59 
       60 dcl  dtstr char (16);
       61 dcl  now fixed bin (71);
       62 dcl  today char (8);
       63 dcl (reset_sw, report_reset_sw, un_reset_sw, temp_un_reset_sw, pct_sw,
       64      no_header_sw, meter_sw) bit (1) aligned init (""b);
       65 
       66 dcl  asmt_copy (asmt_length) fixed bin (35) aligned based;	/* overlay to copy asmt segment */
       67 dcl  asmt_length fixed bin;				/* length of overlay */
       68 
       69 dcl 1 rasmt like asmt aligned based (real_asmtp);		/* "rasmt" is easier to type than "real_asmtp -> asmt" */
       70 
       71 /* Static */
       72 
       73 dcl  real_asmtp ptr int static init (null);		/* ptr to real as_meter_table, in >sc1 (or test dir) */
       74 dcl  temp_ptr (2) ptr int static init ((2) null);		/* ptrs to two temp segs */
       75 dcl  prev_asmtp ptr defined (temp_ptr (1));		/* 1st one points to copy of as_meter_table made at reset time */
       76 dcl  diff_asmtp ptr defined (temp_ptr (2));		/* 2nd one points to difference between copy and current values */
       77 
       78 dcl  reset bit (1) int static init (""b);		/* on if we have saved a copy because user said -reset */
       79 dcl  reset_time fixed bin (71) int static;		/* time that reset was done */
       80 
       81 dcl  selected (36) bit (1) unaligned int static init ((36) (1)"1"b);
       82 dcl  sysdir char (168) int static init (">sc1");
       83 
       84 /* Constant */
       85 
       86 dcl  me char (9) int static options (constant) init ("as_meters");
       87 dcl  digits char (10) int static options (constant) init ("0123456789");
       88 
       89 dcl  UPPER char (26) int static options (constant) init ("ABCDEFGHIJKLMNOPQRSTUVWXYZ");
       90 dcl  LOWER char (26) int static options (constant) init ("abcdefghijklmnopqrstuvwxyz");
       91 
       92 /* Builtin */
       93 
       94 dcl (addr, clock, divide, float, hbound, length, ltrim, mod, null, size, substr, translate) builtin;
       95 
       96 	if real_asmtp = null then do;			/* get ptr to as_meter_table if we don't already have it */
       97 	     call hcs_$initiate (sysdir, "as_meter_table", "", (0), (1), real_asmtp, code);
       98 	     if real_asmtp = null then do;
       99 		call com_err_ (code, me, "^a>as_meter_table", sysdir);
      100 		return;
      101 	     end;
      102 	end;
      103 
      104 	now = clock ();
      105 	call date_time_ (now, dtstr);
      106 	today = substr (dtstr, 1, 8);
      107 
      108 	do i = 1 to cu_$arg_count ();
      109 	     call cu_$arg_ptr (i, argp, argl, ignore_code);
      110 	     if arg = "-tt" | arg = "-total" | arg = "-totals" then
      111 		totalsw = "1"b;
      112 	     else if arg = "-sh" | arg = "-short"
      113 	     | arg = "-short_name" | arg = "-shnm" then do;
      114 		shortnamesw = "1"b;
      115 		namesw = ""b;
      116 	     end;
      117 	     else if arg = "-rs" | arg = "-reset" then
      118 		reset_sw = "1"b;
      119 	     else if arg = "-rrs" | arg = "-report_reset" then
      120 		reset_sw, report_reset_sw = "1"b;
      121 	     else if arg = "-urs" | arg = "-unreset" then
      122 		un_reset_sw = "1"b;
      123 	     else if arg = "-turs" | arg = "-temp_unreset" then
      124 		temp_un_reset_sw = "1"b;
      125 	     else if arg = "-pct" | arg = "-percent" then
      126 		pct_sw = "1"b;
      127 	     else if arg = "-nhe" | arg = "-no_header" then
      128 		no_header_sw = "1"b;
      129 	     else if arg = "-mt" | arg = "-meter" then
      130 		call get_selected_meter_names;
      131 	     else do;
      132 		call com_err_ (0, "as_meters", "Unknown argument: ^a", arg);
      133 		return;
      134 	     end;
      135 	end;					/* end loop thru arglist */
      136 
      137 /* Decide what to do: report, reset, or some combination or variation of them */
      138 
      139 	if reset_sw then				/* if user wants to reset now */
      140 	     if ^report_reset_sw then			/* and he doesn't want a report first */
      141 		goto do_reset;			/* go do the reset */
      142 
      143 	asmtp = real_asmtp;				/* assume we'll print real asmt, until we discover otherwise */
      144 
      145 	if un_reset_sw then				/* if user wants to permanently cancel a previous reset */
      146 	     if reset then				/* and there was one */
      147 		do;				/* then cancel it */
      148 		reset = ""b;			/* forget it was done */
      149 		call release_temp_segment_ (me, prev_asmtp, code); /* release the seg it was in */
      150 		if code ^= 0 then goto temp_seg_error;
      151 	     end;
      152 
      153 	if reset then				/* if we did a reset previously */
      154 	     if ^temp_un_reset_sw then		/* and user doesn't want to temporarily ignore it */
      155 		do;				/* then subtract previous values from current ones */
      156 		call get_temp_segment_ (me, diff_asmtp, code); /* we always release this when done printing */
      157 		if code ^= 0 then goto temp_seg_error;
      158 		asmtp = diff_asmtp;			/* we'll print the seg containing the differences */
      159 		asmt =				/* if this works, I'll buy the compiler writers a beer */
      160 		     real_asmtp -> asmt - prev_asmtp -> asmt; /* subtract everything */
      161 	     end;
      162 
      163 /* Compute total real time. This does not include real time spent in un-metered code, so it is a little low. */
      164 
      165 	total_real_time = 0;
      166 	do i = 1 to hbound (asmt.entry, 1);		/* add up individual real times */
      167 	     total_real_time = total_real_time + asmt.entry (i).real_time; /* NOT tot_real_time */
      168 	end;					/* that would be double counting */
      169 
      170 /* Print header */
      171 
      172 	if no_header_sw then goto skip_header;
      173 
      174 	if ^totalsw then				/* print heading (different if reset or not) */
      175 	     if reset & ^temp_un_reset_sw then
      176 		call ioa_ ("Reset at ^a; metering time: ^a", dt (reset_time), ti (now - reset_time));
      177 	     else call ioa_ ("Startup at ^a, vcpu = ^.3f, pf = ^d; metering time: ^a", dt (asmt.startup_clock),
      178 		asmt.startup_vcpu/1.0e6, asmt.startup_pf, ti (now - asmt.startup_clock));
      179 	call ioa_ ("Latest update^[ (in progress)^] at ^a, rt = ^.3f, vcpu = ^.3f, pf = ^d",
      180 	     (rasmt.update_in_progress ^= 0), dt (rasmt.latest_clock),
      181 	     total_real_time/1.0e6, asmt.latest_vcpu/1.0e6, asmt.latest_pf);
      182 
      183 	if totalsw then goto do_reset;		/* no more output wanted; go reset (if wanted) & return */
      184 
      185 	if rasmt.global_entered > 0 then
      186 	     call ioa_ ("There ^[is^;are^] ^d call^[s^] in progress.",
      187 	     (rasmt.global_entered = 1), rasmt.global_entered, (rasmt.global_entered > 1));
      188 
      189 	call ioa_ ("Logins: ^d int, ^d abs, ^d dmn; logouts: ^d int, ^d abs, ^d dmn.", asmt.logins, asmt.logouts);
      190 
      191 	call ioa_ ("ASMT: ^d, RT: ^.3f, VCPU: ^.3f, PF: ^d^/",
      192 	     asmt.asmt_count, asmt.asmt_real_time/1.0e6, asmt.asmt_vcpu/1.0e6, asmt.asmt_pf);
      193 
      194 /* Print a line of column headings, and then one or more lines for each used (and selected) entry */
      195 
      196 	call ioa_ ("^5tUPD_TIME^14tCOUNT^20tTOTAL_REAL^31tTOTAL_VCPU^42tTOTALPF^50t^6xREAL^61t^6xVCPU^72t^5xPF");
      197 	if pct_sw then call ioa_;			/* blank line if printing 4-line group per entry */
      198 
      199 skip_header:
      200 
      201 	do i = 1 to hbound (asmt.entry, 1);
      202 	     asmtep = addr (asmt.entry (i));
      203 	     if asmte.entry_count > 0 & selected (i) then do;
      204 		call ioa_ (
      205 "^[^3a^s^;^s^2d)^]^[*^;^x^]^8a^14t^5d^[(^d)^;^s^]^20t^10.3f^31t^10.3f^42t^7d^50t^10.3f^61t^10.3f^72t^7d^[^x^a^]",
      206 		     shortnamesw, substr (AS_METER_NAMES (i), 1, 3), i, 
      207 		     asmte.entered > 0, tm (rasmt.entry (i).update_clock),
      208 		     asmte.entry_count, (asmte.recursive_entry_count ^= 0),
      209 		     asmte.recursive_entry_count,
      210 		     asmte.tot_real_time/1.0e6, asmte.tot_vcpu/1.0e6,
      211 		     asmte.tot_pf, 
      212 		     asmte.real_time/1.0e6, asmte.vcpu/1.0e6, asmte.pf,
      213 		     namesw, AS_METER_NAMES (i));
      214 		sigma_vcpu = sigma_vcpu + asmte.vcpu;
      215 		sigma_pf = sigma_pf + asmte.pf;
      216 
      217 /* If -pct arg given, print 3 more lines for this entry:
      218*     percent of total, per-call usage, pf per (real vcpu) sec */
      219 
      220 		if pct_sw then do;
      221 
      222 /* percent of total */
      223 		     if asmt.latest_pf > 0 then	/* avoid zerodivides */
      224 			call ioa_ ("^5t% of tot^20t^8.1f%^31t^8.1f%^42t^6.1f%^50t^8.1f%^61t^8.1f%^72t^6.1f%",
      225 			(1.0e2*asmte.tot_real_time)/total_real_time,
      226 			(1.0e2*asmte.tot_vcpu)/asmt.latest_vcpu,
      227 			(1.0e2*asmte.tot_pf)/asmt.latest_pf,
      228 			(1.0e2*asmte.real_time)/total_real_time,
      229 			(1.0e2*asmte.vcpu)/asmt.latest_vcpu,
      230 			(1.0e2*asmte.pf)/asmt.latest_pf);
      231 
      232 /* per-call usage */
      233 		     call ioa_ ("^5tper-call^20t^10.3f^31t^10.3f^42t^7.2f^50t^10.3f^61t^10.3f^72t^7.2f",
      234 			asmte.tot_real_time / (1.0e6*asmte.entry_count),
      235 			asmte.tot_vcpu/ (1.0e6*asmte.entry_count),
      236 			float (asmte.tot_pf)/asmte.entry_count,
      237 			asmte.real_time/ (1.0e6*asmte.entry_count),
      238 			asmte.vcpu/ (1.0e6*asmte.entry_count),
      239 			float (asmte.pf)/asmte.entry_count);
      240 
      241 /* page faults per real and vcpu second */
      242 		     if asmte.vcpu > 0 then		/* avoid zerodivides */
      243 			call ioa_ ("^5tpf/sec^20t^8.1f^31t^8.1f^50t^8.1f^61t^8.1f",
      244 			(1.0e6*asmte.tot_pf)/asmte.tot_real_time,
      245 			(1.0e6*asmte.tot_pf)/asmte.tot_vcpu,
      246 			(1.0e6*asmte.pf)/asmte.real_time,
      247 			(1.0e6*asmte.pf)/asmte.vcpu);
      248 		     call ioa_;			/* separate the 4-line per-entry groups with blank lines */
      249 		end;				/* end -pct given */
      250 	     end;					/* end this entry used and selected */
      251 	end;					/* end loop thru all entries */
      252 
      253 /* Compute and print the "Other" usage, i.e. that not included in any of the above meters */
      254 
      255 	if ^meter_sw then do;			/* only when printing all meters */
      256 	     sigma_vcpu = asmt.latest_vcpu - sigma_vcpu - asmt.startup_vcpu;
      257 	     sigma_pf = asmt.latest_pf - sigma_pf - asmt.startup_pf;
      258 	     call ioa_ ("^/Other (not metered) vcpu and pf:^61t^10.3f^72t^7d", sigma_vcpu/1.0e6, sigma_pf);
      259 	     if pct_sw
      260 	     & asmt.latest_pf > 0 then		/* avoid zerodivides */
      261 		call ioa_ ("^61t^8.1f%^72t^6.1f%", (1.0e2*sigma_vcpu)/asmt.latest_vcpu, (1.0e2*sigma_pf)/asmt.latest_pf);
      262 	     call ioa_;				/* blank line at end */
      263 	end;
      264 
      265 /* If we did a reset previously, release the temp seg containing the differences. */
      266 	if reset then do;
      267 	     call release_temp_segment_ (me, diff_asmtp, code);
      268 	     if code ^= 0 then goto temp_seg_error;
      269 	end;
      270 
      271 /* If user wants to do a reset now, save a copy of the live asmt */
      272 
      273 do_reset:	if reset_sw then do;			/* if user wants to reset now, save current values */
      274 	     if prev_asmtp = null then do;		/* if we don't have a temp seg to save them, get one */
      275 		call get_temp_segment_ (me, prev_asmtp, code);
      276 		if code ^= 0 then goto temp_seg_error;
      277 	     end;
      278 	     asmt_length = size (asmt);		/* size of stuff to copy */
      279 	     prev_asmtp -> asmt_copy = real_asmtp -> asmt_copy;
      280 	     reset_time = now;
      281 	     reset = "1"b;				/* remember that we have saved the values */
      282 	end;
      283 
      284 	return;
      285 
      286 temp_seg_error: call com_err_ (code, me, "(temp segment)");
      287 error_return:
      288 	return;
      289 
      290 /* ******************** */
      291 
      292 dt:	proc (clk) returns (char (17) varying);		/* to format and return the date (if not today) and time */
      293 
      294 dcl  clk fixed bin (71);
      295 dcl  c17 char (17) varying;
      296 dcl  c8 char (8);
      297 dcl  hhmmss char (8) init ("hh:mm:ss");
      298 dcl  dtsw bit (1) aligned;
      299 
      300 	     dtsw = "1"b;
      301 	     goto dt_common;
      302 
      303 tm:	     entry (clk) returns (char (8));		/* to format and return just the time */
      304 
      305 	     dtsw = ""b;
      306 
      307 dt_common:
      308 	     call date_time_ (clk, dtstr);
      309 	     call decode_clock_value_$date_time (clk, month, day, year, hour, minute, second, usec, dow, zone, code);
      310 	     substr (hhmmss, 1, 2) = substr (dtstr, 11, 2); /* whoever invented the tenths of a minute date time format */
      311 	     substr (hhmmss, 4, 2) = substr (dtstr, 13, 2); /* should be forced to use watches and clocks */
      312 	     if code = 0 then do;			/* whose faces are calibrated in tenths of a minute */
      313 		substr (hhmmss, 7, 1) = substr (digits, 1+divide (second, 10, 17, 0)); /* and whose second hands */
      314 		substr (hhmmss, 8, 1) = substr (digits, 1+mod (second, 10)); /* jump ahead every 6 seconds */
      315 	     end;
      316 	     else substr (hhmmss, 7, 2) = "??";		/* if code is nonzero, we don't know the seconds */
      317 
      318 	     if dtsw then do;			/* return date (if not today) as well as time */
      319 		if substr (dtstr, 1, 8) = today then
      320 		     c17 = hhmmss;			/* just return time, since date is today */
      321 		else do;
      322 		     c17 = substr (dtstr, 1, 8);
      323 		     c17 = c17 || " ";
      324 		     c17 = c17 || hhmmss;
      325 		end;
      326 		return (c17);
      327 	     end;
      328 	     else do;				/* we can only return 8 chars, so just return time */
      329 		c8 = hhmmss;
      330 		if substr (dtstr, 1, 8) ^= today then do; /* KLUDGE to flag time as not in current day */
      331 		     substr (c8, 3, 1) = "!";		/* I said it was a kludge ... */
      332 		     substr (c8, 6, 1) = "!";		/* but we only have 8 characters */
      333 		end;
      334 
      335 		return (c8);
      336 	     end;
      337 
      338 	end dt;
      339 
      340 /* ******************** */
      341 
      342 get_selected_meter_names: proc;			/* process args after -meter */
      343 
      344 dcl  ix fixed bin;
      345 dcl  name_arg char (8) varying;
      346 
      347 	     if ^meter_sw then do;			/* if this is first -meter arg on command line */
      348 		selected (*) = ""b;			/* clear all the switches */
      349 		meter_sw = "1"b;			/* remember that we did so */
      350 	     end;
      351 
      352 get_next_meter_arg:
      353 	     call cu_$arg_ptr (i+1, argp, argl, code);	/* look at next arg */
      354 	     if code ^= 0 then return;		/* if no more args */
      355 	     if substr (arg, 1, 1) = "-" then return;	/* if it is a control arg */
      356 
      357 	     i = i + 1;				/* we're going to use this arg; bump index to next one */
      358 
      359 	     if arg = "all" then do;
      360 		selected (*) = "1"b;
      361 		meter_sw = ""b;			/* we aren't printing a subset of the meters */
      362 		return;
      363 	     end;
      364 
      365 	     name_arg = translate (arg, UPPER, LOWER);	/* get it in all upper case */
      366 
      367 	     do ix = 1 to hbound (AS_METER_NAMES, 1)	/* look for exact match between arg and meter name */
      368 		while (AS_METER_NAMES (ix) ^= name_arg); end;
      369 
      370 	     if ix <= hbound (AS_METER_NAMES, 1) then do;
      371 		selected (ix) = "1"b;
      372 		goto get_next_meter_arg;
      373 	     end;
      374 
      375 	     do ix = 1 to hbound (AS_METER_NAMES, 1)	/* look for match between arg and first few chars of meter name */
      376 		while (substr (AS_METER_NAMES (ix), 1, length (name_arg)) ^= name_arg); end;
      377 
      378 	     if ix <= hbound (AS_METER_NAMES, 1) then do;
      379 		selected (ix) = "1"b;
      380 		goto get_next_meter_arg;
      381 	     end;
      382 
      383 	     call com_err_ (0, me, "Unknown meter name: ^a", arg);
      384 	     goto error_return;
      385 
      386 	end get_selected_meter_names;
      387 
      388 /* ******************** */
      389 
      390 ti:	proc (int) returns (char (9) varying);		/* format and return a time interval as HHH:MM:SS */
      391 
      392 dcl  int fixed bin (71);
      393 dcl  rs char (9) varying;
      394 dcl  int_pic pic "zzzzzzzz9";
      395 dcl  sum fixed bin;
      396 
      397 	     hour = divide (int, 3600*1000000, 71, 0);
      398 	     minute = divide (int, 60*1000000, 71, 0) - hour*60;
      399 	     second = divide (int, 1000000, 71, 0) - hour*3600 - minute*60;
      400 	     sum = second + minute*1000 + hour*1000000;	/* HHH0MM0SS */
      401 
      402 	     if sum > 999999999 then do;		/* avoid blowup in picture conversion */
      403 		if hour > 999999 then
      404 		     rs = "999999+hr";
      405 		else call ioa_$rsnnl ("^6d+hr", rs, (0), hour);
      406 	     end;
      407 	     else do;
      408 		int_pic = sum;
      409 		if substr (int_pic, 3, 1) ^= " " then substr (int_pic, 4, 1) = ":"; /* HHH:MM0SS */
      410 		if substr (int_pic, 6, 1) ^= " " then substr (int_pic, 7, 1) = ":"; /* HHH:MM:SS */
      411 		rs = ltrim (int_pic);
      412 	     end;
      413 
      414 	     return (rs);
      415 
      416 	end ti;
      417 
      418 /* ******************** */
      419 
      420 test:	entry (testdir);
      421 
      422 dcl  testdir char (*);
      423 
      424 	sysdir = testdir;				/* the arg better be there, or we'll take a fault */
      425 
      426 	if real_asmtp ^= null then			/* be sure to initiate new segs */
      427 	     call hcs_$terminate_noname (real_asmtp, ignore_code);
      428 
      429 	do i = 1 to 2;
      430 	     if temp_ptr (i) ^= null then
      431 		call release_temp_segment_ (me, temp_ptr (i), ignore_code);
      432 	end;
      433 	reset = ""b;				/* in case there was a reset in effect */
      434 
      435 	return;
      436  /* BEGIN INCLUDE FILE as_meter_numbers.incl.pl1 */
  1     2 
  1     3 /* These are the names and numbers of the slots in as_meter_table 
  1     4*   (see as_meter_table.incl.pl1).
  1     5*
  1     6*   Written March 1980 by Tom Casey
  1     7*   Modified June 1981 by T. Casey for MR9.0 to add ABS_TRYLOG_METER.
  1     8**/
  1     9 
  1    10 
  1    11 /****^  HISTORY COMMENTS:
  1    12*  1) change(86-01-31,Herbst), approve(87-07-21,MCR7694),
  1    13*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1056):
  1    14*      A) Add NETUP_METER.
  1    15*      B) Add AS_METER_NAMES array.
  1    16*                                                   END HISTORY COMMENTS */
  1    17 
  1    18 
  1    19 dcl  ASINIT_METER fixed bin int static options (constant) init (1); /* as_init_, parts 1 and 2 */
  1    20 dcl  DIALUP_METER fixed bin int static options (constant) init (2); /* dialup_ */
  1    21 dcl  DUM_METER fixed bin int static options (constant) init (3); /* daemon_user_manager_ */
  1    22 dcl  AUM_METER fixed bin int static options (constant) init (4); /* absentee_user_manager_ */
  1    23 dcl  AU_METER fixed bin int static options (constant) init (5); /* absentee_utility_ */
  1    24 dcl  CPG_METER fixed bin int static options (constant) init (6); /* cpg_ */
  1    25 dcl  DPG_METER fixed bin int static options (constant) init (7); /* dpg_ */
  1    26 dcl  ACCTUP_METER fixed bin int static options (constant) init (8); /* accounting updates */
  1    27 dcl  INSTALL_METER fixed bin int static options (constant) init (9); /* installs (up_sysctl_) */
  1    28 dcl  ABSQ_METER fixed bin int static options (constant) init (10); /* absentee queue reads and writes */
  1    29 dcl  MSGCORD_METER fixed bin int static options (constant) init (11); /* message coordinator */
  1    30 dcl  COMMAND_METER fixed bin int static options (constant) init (12); /* operator commands, other than admin */
  1    31 dcl  SAC_METER fixed bin int static options (constant) init (13); /* sac (send_admin_command handling) */
  1    32 dcl  ADMIN_METER fixed bin int static options (constant) init (14); /* admin mode */
  1    33 dcl  SSU_METER fixed bin int static options (constant) init (15); /* system_start_up.ec, parts 1, 2, and 3 */
  1    34 dcl  FIXPDT_METER fixed bin int static options (constant) init (16); /* cleanup of PDTs after crash (act_ctl_$init) */
  1    35 dcl  ABS_TRYLOG_METER fixed bin int static options (constant) init (17); /* attempts to login absentees via call lg_ctl_
  1    36*						   (the attempts might fail because of load control limits) */
  1    37 dcl  NETUP_METER fixed bin int static options (constant) init (18); /* a call to network_accounting_update_ */
  1    38 
  1    39 dcl  recursion_possible bit (18) int static options (constant) init ("000000000011000000"b); /* 11 & 12 (MSGCORD and COMMAND) */
  1    40 
  1    41 /* Bit length of recursion_possible equals highest slot number given above.  */
  1    42 
  1    43 dcl  AS_METER_NAMES (18) char (8) int static options (constant) init (
  1    44      "ASINIT",  "DIALUP",   "DUM",    "AUM",     "AU",
  1    45      "CPG",     "DPG",      "ACCTUP", "INSTALL", "ABSQ",
  1    46      "MSGCORD", "COMMAND",  "SAC",    "ADMIN",   "SSU",
  1    47      "FIXPDT",  "TRYABSLG", "NETUP");
  1    48 
  1    49 /* END INCLUDE FILE as_meter_numbers.incl.pl1 */
      436 
      437  /* BEGIN INCLUDE FILE as_meter_table.incl.pl1 */
  2     2 
  2     3 /* This include file describes the segment as_meter_table, normally found in >sc1.
  2     4*
  2     5*   This segment contains meters of the resources used by various subsystems of the
  2     6*   answering service. Real time, virtual cpu time, and page faults are metered.
  2     7*   In addition, there are counters of various events of interest, such as logins.
  2     8*   Care is taken to avoid double counting in cases of recursive entry to a subsystem,
  2     9*   or cases where one subsystem calls another and both are being metered.
  2    10*
  2    11*   Updates to this segment are made primarily by as_meter_, whose enter and exit
  2    12*   entry points are called by the subsystems just after entry and just before exit.
  2    13*   In addition, some procedures keep a pointer to this segment and update it directly.
  2    14*   This segment is printed by the as_meters command; this can be done by any
  2    15*   process that has read access to this segment.
  2    16*
  2    17*   The segment is truncated and reinitialized at each startup.
  2    18*   Each entry in the table is permanently assigned to a particular subsystem.
  2    19*   The assignments are defined in as_meter_numbers.incl.pl1.
  2    20*
  2    21*   Several variables are declared fixed bin (34). The intention is to avoid the
  2    22*   generation of code that does double word arithmetic when adding to these variables.
  2    23*
  2    24*   The two switches (asmt.update_in_progress and asmte.x) are declared fixed bin so that the as_meters command can
  2    25*   implement the -reset option by means of a structure subtraction statement (rather than individual subtraction
  2    26*   statements for all variables in the structure except the two switches), and be able to be compiled
  2    27*   with no warnings. For that reason, any new switches should be declared fixed bin.
  2    28*
  2    29*   Written March 1980 by Tom Casey
  2    30*   Modified May 1981 by T. Casey to add cells to meter cost of doing this metering.
  2    31*   Modified June 1981 by T. Casey for MR9.0 to add 17th entry for TRYLOG_ABS_METER.
  2    32*   Modified August 1981 by T. Casey for MR9.0 to change the switches from bit to fixed bin.
  2    33**/
  2    34 
  2    35 
  2    36 /****^  HISTORY COMMENTS:
  2    37*  1) change(86-11-13,Herbst), approve(87-07-21,MCR7694),
  2    38*     audit(87-07-21,GDixon), install(87-08-04,MR12.1-1056):
  2    39*     Changed to determine number of as_meter slots (entries) based upon the
  2    40*     variable hbound(AS_METER_NAMES,1) which is declared in
  2    41*     as_meter_numbers.incl.pl1.
  2    42*                                                   END HISTORY COMMENTS */
  2    43 
  2    44 
  2    45 dcl  ASMT_VERSION_1 fixed bin int static options (constant) init (1);
  2    46 
  2    47 dcl 1 asmt aligned based (asmtp),
  2    48     2 version fixed bin,
  2    49     2 update_in_progress fixed bin,			/* table is inconsistent when this word is ^=0 */
  2    50     2 startup_clock fixed bin (71),			/* time at startup */
  2    51     2 latest_clock fixed bin (71),			/* time at latest metering update */
  2    52     2 startup_vcpu fixed bin (71),			/* vcpu used prior to startup */
  2    53     2 latest_vcpu fixed bin (71),			/* current total vcpu usage of initializer process */
  2    54     2 startup_pf fixed bin (34),			/* page faults taken prior to startup */
  2    55     2 latest_pf fixed bin (34),			/* current total page faults taken by initializer process */
  2    56     2 global_entered fixed bin,			/* count of subsystems entered but not yet exited */
  2    57     2 logins (3) fixed bin,				/* count of interactive, absentee, and daemon logins */
  2    58     2 logouts (3) fixed bin,				/* count of interactive, absentee, and daemon logouts */
  2    59     2 asmt_count fixed bin (34),			/* count of calls to asmt entry points */
  2    60     2 asmt_real_time fixed bin (71),			/* real time spent in those entry points */
  2    61     2 asmt_vcpu fixed bin (71),			/* virtual cpu time spent in those entry points */
  2    62     2 asmt_pf fixed bin (34),				/* page faults taken while in those entry points */
  2    63     2 asmt_pad (7) fixed bin,				/* pad header to 32 words */
  2    64     2 entry (hbound(AS_METER_NAMES,1)) aligned like asmte;	/* 32 word entries */
  2    65 
  2    66 dcl 1 asmte aligned based (asmtep),
  2    67     2 entered fixed bin (34),				/* if nonzero, subsystem has been entered but not yet exited */
  2    68     2 entry_count fixed bin (34),			/* total entries to subsystem in this bootload */
  2    69     2 update_clock fixed bin (71),			/* time of entry or exit (whichever has happened last) */
  2    70     2 tot_real_time fixed bin (71),			/* total real time in subsystem, including called subsystems */
  2    71     2 real_time fixed bin (71),			/* real time in subsystem, excluding called subsystems */
  2    72     2 x_real_time fixed bin (71),			/* exclude this from tot_real to get real, at next exit */
  2    73     2 entry_vcpu fixed bin (71),			/* vcpu usage at entry to subsystem */
  2    74     2 tot_vcpu fixed bin (71),			/* total vcpu used in subsystem, including called subsystems */
  2    75     2 vcpu fixed bin (71),				/* vcpu used in subsystem, excluding called subsystems */
  2    76     2 x_vcpu fixed bin (71),				/* exclude this from tot_vcpu to get vcpu, at next exit */
  2    77     2 entry_pf fixed bin (34),			/* page faults at entry to subsystem */
  2    78     2 tot_pf fixed bin (34),				/* total page faults in subsystem, including called subsystems */
  2    79     2 pf fixed bin (34),				/* page faults in subsystem, excluding called subsystems */
  2    80     2 x_pf fixed bin (34),				/* exclude this from tot_pf to get pf, at next exit */
  2    81     2 x fixed bin,					/* ^=0 if subsystem has nonzero x values at the moment */
  2    82     2 recursive_entry_count fixed bin (34),		/* number of entries that were recursive */
  2    83     2 asmte_pad (8) fixed bin;			/* pad entry to 32 words */
  2    84 
  2    85 /* END INCLUDE FILE as_meter_table.incl.pl1 */
      437 
      438 
      439      end as_meters;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    08/04/87  1222.1  as_meters.pl1                     >special_ldd>install>MR12.1-1054>as_meters.pl1
436          1    08/04/87  1140.5  as_meter_numbers.incl.pl1         >spec>install>1056>as_meter_numbers.incl.pl1
437          2    08/04/87  1140.5  as_meter_table.incl.pl1           >spec>install>1056>as_meter_table.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
AS_METER_NAMES                  000000 constant        char(8)                  initial array unaligned dcl 1-43 set ref 159 159 159
                                                                                  166 199 204 204 204* 278 367 367 370 375 375 378
LOWER                           000044 constant        char(26)                 initial unaligned dcl 90 ref 365
UPPER                           000053 constant        char(26)                 initial unaligned dcl 89 ref 365
addr                                                   builtin function         dcl 94 ref 202
arg                                    based           char                     unaligned dcl 52 set ref 110 110 110 112 112 112 112
                                                                                  117 117 119 119 121 121 123 123 125 125 127 127
                                                                                  129 129 132* 355 359 365 383*
argl                            000124 automatic       fixed bin(17,0)          dcl 52 set ref 109* 110 110 110 112 112 112 112 117
                                                                                  117 119 119 121 121 123 123 125 125 127 127 129
                                                                                  129 132 132 352* 355 359 365 383 383
argp                            000122 automatic       pointer                  dcl 52 set ref 109* 110 110 110 112 112 112 112 117
                                                                                  117 119 119 121 121 123 123 125 125 127 127 129
                                                                                  129 132 352* 355 359 365 383
asmt                                   based           structure                level 1 dcl 2-47 set ref 159* 159 159 278
asmt_copy                              based           fixed bin(35,0)          array dcl 66 set ref 279* 279
asmt_count               23            based           fixed bin(34,0)          level 2 dcl 2-47 set ref 191*
asmt_length                     000155 automatic       fixed bin(17,0)          dcl 67 set ref 278* 279
asmt_pf                  30            based           fixed bin(34,0)          level 2 dcl 2-47 set ref 191*
asmt_real_time           24            based           fixed bin(71,0)          level 2 dcl 2-47 set ref 191
asmt_vcpu                26            based           fixed bin(71,0)          level 2 dcl 2-47 set ref 191
asmte                                  based           structure                level 1 dcl 2-66
asmtep                          000120 automatic       pointer                  initial dcl 51 set ref 51* 202* 203 204 204 204 204
                                                                                  204 204 204 204 204 204 214 215 223 223 223 223
                                                                                  223 223 233 233 233 233 233 233 233 233 233 233
                                                                                  233 233 242 242 242 242 242 242 242 242 242
asmtp                           000116 automatic       pointer                  initial dcl 51 set ref 51* 143* 158* 159 166 167 177
                                                                                  177 177 177 179 179 189 189 191 191 191 191 199
                                                                                  202 223 223 223 223 223 256 256 257 257 259 259
                                                                                  259 278
c17                             000170 automatic       varying char(17)         dcl 295 set ref 319* 322* 323* 323 324* 324 326
c8                              000176 automatic       char(8)                  unaligned dcl 296 set ref 329* 331* 332* 335
clk                                    parameter       fixed bin(71,0)          dcl 294 set ref 292 303 307* 309*
clock                                                  builtin function         dcl 94 ref 104
code                            000100 automatic       fixed bin(35,0)          dcl 45 set ref 97* 99* 149* 150 156* 157 267* 268
                                                                                  275* 276 286* 309* 312 352* 354
com_err_                        000106 constant        entry                    external dcl 34 ref 99 132 286 383
cu_$arg_count                   000076 constant        entry                    external dcl 32 ref 108
cu_$arg_ptr                     000100 constant        entry                    external dcl 33 ref 109 352
date_time_                      000110 constant        entry                    external dcl 35 ref 105 307
day                             000104 automatic       fixed bin(17,0)          dcl 48 set ref 309*
decode_clock_value_$date_time   000112 constant        entry                    external dcl 36 ref 309
diff_asmtp                             defined         pointer                  dcl 76 set ref 156* 158 267*
digits                          000062 constant        char(10)                 initial unaligned dcl 87 ref 313 314
divide                                                 builtin function         dcl 94 ref 313 397 398 399
dow                             000111 automatic       fixed bin(17,0)          dcl 48 set ref 309*
dtstr                           000135 automatic       char(16)                 unaligned dcl 60 set ref 105* 106 307* 310 311 319
                                                                                  322 330
dtsw                            000202 automatic       bit(1)                   dcl 298 set ref 300* 305* 318
entered                                based           fixed bin(34,0)          level 2 dcl 2-66 ref 204
entry                    40            based           structure                array level 2 in structure "rasmt" dcl 69
                                                                                  in procedure "as_meters"
entry                    40            based           structure                array level 2 in structure "asmt" dcl 2-47
                                                                                  in procedure "as_meters" set ref 166 199 202
entry_count               1            based           fixed bin(34,0)          level 2 dcl 2-66 set ref 203 204* 233 233 233 233
                                                                                  233 233
float                                                  builtin function         dcl 94 ref 233 233
get_temp_segment_               000114 constant        entry                    external dcl 38 ref 156 275
global_entered           14            based           fixed bin(17,0)          level 2 dcl 69 set ref 185 185 185* 185
hbound                                                 builtin function         dcl 94 ref 159 159 159 166 166 199 199 278 367 370
                                                                                  375 378
hcs_$initiate                   000116 constant        entry                    external dcl 39 ref 97
hcs_$terminate_noname           000120 constant        entry                    external dcl 40 ref 426
hhmmss                          000200 automatic       char(8)                  initial unaligned dcl 297 set ref 297* 310* 311*
                                                                                  313* 314* 316* 319 324 329
hour                            000106 automatic       fixed bin(17,0)          dcl 48 set ref 309* 397* 398 399 400 403 405*
i                               000102 automatic       fixed bin(17,0)          dcl 47 set ref 108* 109* 166* 167* 199* 202 203 204
                                                                                  204 204* 204 204 204* 352 357* 357 429* 430 430*
ignore_code                     000101 automatic       fixed bin(35,0)          dcl 46 set ref 109* 426* 430*
int                                    parameter       fixed bin(71,0)          dcl 392 ref 390 397 398 399
int_pic                         000232 automatic       picture(9)               unaligned dcl 394 set ref 408* 409 409* 410 410* 411
ioa_                            000102 constant        entry                    external dcl 34 ref 174 177 179 185 189 191 196 197
                                                                                  204 223 233 242 248 258 259 262
ioa_$rsnnl                      000104 constant        entry                    external dcl 34 ref 405
ix                              000212 automatic       fixed bin(17,0)          dcl 344 set ref 367* 367* 370 371 375* 375* 378 379
latest_clock              4            based           fixed bin(71,0)          level 2 dcl 69 set ref 179*
latest_pf                13            based           fixed bin(34,0)          level 2 dcl 2-47 set ref 179* 223 223 223 257 259
                                                                                  259
latest_vcpu              10            based           fixed bin(71,0)          level 2 dcl 2-47 set ref 179 223 223 256 259
length                                                 builtin function         dcl 94 ref 375
logins                   15            based           fixed bin(17,0)          array level 2 dcl 2-47 set ref 189*
logouts                  20            based           fixed bin(17,0)          array level 2 dcl 2-47 set ref 189*
ltrim                                                  builtin function         dcl 94 ref 411
me                              000065 constant        char(9)                  initial unaligned dcl 86 set ref 99* 149* 156* 267*
                                                                                  275* 286* 383* 430*
meter_sw                        000154 automatic       bit(1)                   initial dcl 63 set ref 63* 255 347 349* 361*
minute                          000107 automatic       fixed bin(17,0)          dcl 48 set ref 309* 398* 399 400
mod                                                    builtin function         dcl 94 ref 314
month                           000103 automatic       fixed bin(17,0)          dcl 48 set ref 309*
name_arg                        000213 automatic       varying char(8)          dcl 345 set ref 365* 367 375 375
namesw                          000126 automatic       bit(1)                   initial dcl 54 set ref 54* 115* 204*
no_header_sw                    000153 automatic       bit(1)                   initial dcl 63 set ref 63* 127* 172
now                             000142 automatic       fixed bin(71,0)          dcl 61 set ref 104* 105* 174 177 280
null                                                   builtin function         dcl 94 ref 51 51 96 98 274 426 430
pct_sw                          000152 automatic       bit(1)                   initial dcl 63 set ref 63* 125* 197 220 259
pf                       24            based           fixed bin(34,0)          level 2 dcl 2-66 set ref 204* 215 223 233 242 242
prev_asmtp                             defined         pointer                  dcl 75 set ref 149* 159 274 275* 279
rasmt                                  based           structure                level 1 dcl 69
real_asmtp                      000010 internal static pointer                  initial dcl 73 set ref 96 97* 98 143 159 179 179 185
                                                                                  185 185 185 204 204 279 426 426*
real_time                 6            based           fixed bin(71,0)          level 2 in structure "asmte" dcl 2-66 in procedure
                                                                                  "as_meters" ref 204 223 233 242
real_time                46            based           fixed bin(71,0)          array level 3 in structure "asmt" dcl 2-47
                                                                                  in procedure "as_meters" set ref 167
recursive_entry_count
                         27            based           fixed bin(34,0)          level 2 dcl 2-66 set ref 204 204*
release_temp_segment_           000122 constant        entry                    external dcl 41 ref 149 267 430
report_reset_sw                 000147 automatic       bit(1)                   initial dcl 63 set ref 63* 119* 139
reset                           000016 internal static bit(1)                   initial unaligned dcl 78 set ref 145 148* 153 174
                                                                                  266 281* 433*
reset_sw                        000146 automatic       bit(1)                   initial dcl 63 set ref 63* 117* 119* 139 273
reset_time                      000020 internal static fixed bin(71,0)          dcl 79 set ref 174* 174 280*
rs                              000226 automatic       varying char(9)          dcl 393 set ref 403* 405* 411* 414
second                          000110 automatic       fixed bin(17,0)          dcl 48 set ref 309* 313 314 399* 400
selected                        000022 internal static bit(1)                   initial array unaligned dcl 81 set ref 203 348* 360*
                                                                                  371* 379*
shortnamesw                     000127 automatic       bit(1)                   initial dcl 55 set ref 55* 114* 204*
sigma_pf                        000134 automatic       fixed bin(34,0)          initial dcl 58 set ref 58* 215* 215 257* 257 258*
                                                                                  259
sigma_vcpu                      000132 automatic       fixed bin(71,0)          initial dcl 57 set ref 57* 214* 214 256* 256 258 259
size                                                   builtin function         dcl 94 ref 278
startup_clock             2            based           fixed bin(71,0)          level 2 dcl 2-47 set ref 177* 177
startup_pf               12            based           fixed bin(34,0)          level 2 dcl 2-47 set ref 177* 257
startup_vcpu              6            based           fixed bin(71,0)          level 2 dcl 2-47 set ref 177 256
substr                                                 builtin function         dcl 94 set ref 106 204 204 310* 310 311* 311 313*
                                                                                  313 314* 314 316* 319 322 330 331* 332* 355 375
                                                                                  409 409* 410 410*
sum                             000235 automatic       fixed bin(17,0)          dcl 395 set ref 400* 402 408
sysdir                          000023 internal static char(168)                initial unaligned dcl 82 set ref 97* 99* 424*
temp_ptr                        000012 internal static pointer                  initial array dcl 74 set ref 149 149 156 156 158 158
                                                                                  159 159 267 267 274 274 275 275 279 279 430 430*
temp_un_reset_sw                000151 automatic       bit(1)                   initial dcl 63 set ref 63* 123* 153 174
testdir                                parameter       char                     unaligned dcl 422 ref 420 424
today                           000144 automatic       char(8)                  unaligned dcl 62 set ref 106* 319 330
tot_pf                   23            based           fixed bin(34,0)          level 2 dcl 2-66 set ref 204* 223 233 242 242
tot_real_time             4            based           fixed bin(71,0)          level 2 dcl 2-66 ref 204 223 233 242
tot_vcpu                 14            based           fixed bin(71,0)          level 2 dcl 2-66 ref 204 223 233 242
total_real_time                 000130 automatic       fixed bin(71,0)          dcl 56 set ref 165* 167* 167 179 223 223
totalsw                         000125 automatic       bit(1)                   initial dcl 53 set ref 53* 110* 174 183
translate                                              builtin function         dcl 94 ref 365
un_reset_sw                     000150 automatic       bit(1)                   initial dcl 63 set ref 63* 121* 145
update_clock             42            based           fixed bin(71,0)          array level 3 dcl 69 set ref 204* 204*
update_in_progress        1            based           fixed bin(17,0)          level 2 dcl 69 ref 179
usec                            000112 automatic       fixed bin(71,0)          dcl 49 set ref 309*
vcpu                     16            based           fixed bin(71,0)          level 2 dcl 2-66 ref 204 214 223 233 242 242
year                            000105 automatic       fixed bin(17,0)          dcl 48 set ref 309*
zone                            000114 automatic       char(3)                  initial unaligned dcl 50 set ref 50* 309*

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
ABSQ_METER                             internal static fixed bin(17,0)          initial dcl 1-28
ABS_TRYLOG_METER                       internal static fixed bin(17,0)          initial dcl 1-35
ACCTUP_METER                           internal static fixed bin(17,0)          initial dcl 1-26
ADMIN_METER                            internal static fixed bin(17,0)          initial dcl 1-32
ASINIT_METER                           internal static fixed bin(17,0)          initial dcl 1-19
ASMT_VERSION_1                         internal static fixed bin(17,0)          initial dcl 2-45
AUM_METER                              internal static fixed bin(17,0)          initial dcl 1-22
AU_METER                               internal static fixed bin(17,0)          initial dcl 1-23
COMMAND_METER                          internal static fixed bin(17,0)          initial dcl 1-30
CPG_METER                              internal static fixed bin(17,0)          initial dcl 1-24
DIALUP_METER                           internal static fixed bin(17,0)          initial dcl 1-20
DPG_METER                              internal static fixed bin(17,0)          initial dcl 1-25
DUM_METER                              internal static fixed bin(17,0)          initial dcl 1-21
FIXPDT_METER                           internal static fixed bin(17,0)          initial dcl 1-34
INSTALL_METER                          internal static fixed bin(17,0)          initial dcl 1-27
MSGCORD_METER                          internal static fixed bin(17,0)          initial dcl 1-29
NETUP_METER                            internal static fixed bin(17,0)          initial dcl 1-37
SAC_METER                              internal static fixed bin(17,0)          initial dcl 1-31
SSU_METER                              internal static fixed bin(17,0)          initial dcl 1-33
recursion_possible                     internal static bit(18)                  initial unaligned dcl 1-39

NAMES DECLARED BY EXPLICIT CONTEXT.
as_meters                       000635 constant        entry                    external dcl 12
do_reset                        003201 constant        label                    dcl 273 ref 139 183
dt                              003407 constant        entry                    internal dcl 292 ref 174 177 179
dt_common                       003424 constant        label                    dcl 307 ref 301
error_return                    003275 constant        label                    dcl 287 set ref 384
get_next_meter_arg              003675 constant        label                    dcl 352 ref 372 380
get_selected_meter_names        003655 constant        entry                    internal dcl 342 ref 129
skip_header                     002251 constant        label                    dcl 199 ref 172
temp_seg_error                  003250 constant        label                    dcl 286 ref 150 157 268 276
test                            003301 constant        entry                    external dcl 420
ti                              004101 constant        entry                    internal dcl 390 ref 174 177
tm                              003417 constant        entry                    internal dcl 303 ref 204 204

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4674        5020    4525        4704
Length      5310    4525       124         254     147          66

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
as_meters                           414 external procedure  is an external procedure.  
dt                                      internal procedure  shares stack frame of external procedure as_meters.  
get_selected_meter_names                internal procedure  shares stack frame of external procedure as_meters.  
ti                                      internal procedure  shares stack frame of external procedure as_meters.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 real_asmtp                  as_meters
000012 temp_ptr                    as_meters
000016 reset                       as_meters
000020 reset_time                  as_meters
000022 selected                    as_meters
000023 sysdir                      as_meters

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
as_meters                000100 code                        as_meters
                         000101 ignore_code                 as_meters
                         000102 i                           as_meters
                         000103 month                       as_meters
                         000104 day                         as_meters
                         000105 year                        as_meters
                         000106 hour                        as_meters
                         000107 minute                      as_meters
                         000110 second                      as_meters
                         000111 dow                         as_meters
                         000112 usec                        as_meters
                         000114 zone                        as_meters
                         000116 asmtp                       as_meters
                         000120 asmtep                      as_meters
                         000122 argp                        as_meters
                         000124 argl                        as_meters
                         000125 totalsw                     as_meters
                         000126 namesw                      as_meters
                         000127 shortnamesw                 as_meters
                         000130 total_real_time             as_meters
                         000132 sigma_vcpu                  as_meters
                         000134 sigma_pf                    as_meters
                         000135 dtstr                       as_meters
                         000142 now                         as_meters
                         000144 today                       as_meters
                         000146 reset_sw                    as_meters
                         000147 report_reset_sw             as_meters
                         000150 un_reset_sw                 as_meters
                         000151 temp_un_reset_sw            as_meters
                         000152 pct_sw                      as_meters
                         000153 no_header_sw                as_meters
                         000154 meter_sw                    as_meters
                         000155 asmt_length                 as_meters
                         000170 c17                         dt
                         000176 c8                          dt
                         000200 hhmmss                      dt
                         000202 dtsw                        dt
                         000212 ix                          get_selected_meter_names
                         000213 name_arg                    get_selected_meter_names
                         000226 rs                          ti
                         000232 int_pic                     ti
                         000235 sum                         ti

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
fx1_to_fl2          r_g_a               r_e_as              r_ne_as             alloc_char_temp     call_ext_out_desc
call_ext_out        return_mac          mdfx1               signal_op           shorten_stack       ext_entry
ext_entry_desc      divide_fx3          divide_fx4          clock_mac

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      cu_$arg_count                 cu_$arg_ptr                   date_time_
decode_clock_value_$date_time get_temp_segment_             hcs_$initiate                 hcs_$terminate_noname
ioa_                          ioa_$rsnnl                    release_temp_segment_

NO EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     50 000607        51 000611        53 000614        54 000615        55 000617        57 000620        58 000622
     63 000623        12 000634        96 000643        97 000650        98 000717        99 000724       100 000756
    104 000757       105 000761       106 000776       108 001001       109 001015       110 001032       112 001053
    114 001073       115 001075       116 001076       117 001077       119 001112       121 001126       123 001141
    125 001154       127 001167       129 001202       132 001214       133 001255       135 001256       139 001260
    143 001264       145 001267       148 001273       149 001274       150 001314       153 001316       156 001323
    157 001343       158 001345       159 001350       165 001613       166 001615       167 001625       168 001633
    172 001635       174 001637       177 001711       179 001774       183 002067       185 002071       189 002131
    191 002155       196 002226       197 002242       199 002251       202 002261       203 002264       204 002275
    214 002464       215 002470       220 002472       223 002474       233 002614       242 002716       248 003010
    251 003015       255 003017       256 003021       257 003026       258 003037       259 003073       262 003147
    266 003154       267 003157       268 003177       273 003201       274 003203       275 003210       276 003230
    278 003232       279 003234       280 003243       281 003245       284 003247       286 003250       287 003275
    420 003276       424 003315       426 003324       429 003340       430 003345       432 003375       433 003377
    435 003401       297 003403       292 003407       300 003414       301 003416       303 003417       305 003423
    307 003424       309 003442       310 003476       311 003501       312 003505       313 003507       314 003520
    315 003532       316 003533       318 003535       319 003537       322 003551       323 003555       324 003564
    326 003576       329 003617       330 003621       331 003625       332 003627       335 003631       338 003651
    342 003655       347 003656       348 003660       349 003673       352 003675       354 003715       355 003720
    357 003726       359 003727       360 003734       361 003747       362 003750       365 003751       367 003766
    368 004004       370 004006       371 004011       372 004015       375 004016       376 004032       378 004034
    379 004037       380 004043       383 004044       384 004100       390 004101       397 004103       398 004117
    399 004132       400 004152       402 004162       403 004164       405 004175       406 004225       408 004226
    409 004235       410 004244       411 004253       414 004274


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
