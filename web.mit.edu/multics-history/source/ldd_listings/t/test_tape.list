	COMPILATION LISTING OF SEGMENT test_tape
	Compiled by: Multics PL/I Compiler, Release 28e, of February 14, 1985
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 03/25/86  1057.2 mst Tue
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 /****^  HISTORY COMMENTS:
       12*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
       13*     audit(86-02-18,Coppola):
       14*     Support FIPS.
       15*                                                   END HISTORY COMMENTS */
       16 /* Modified 12/20/79 by R.L. Coppola and Paul Farley to add 6250 b.p.i. capability */
       17 /* Modified June 1980 by R.L. Coppola to clean up several bugs and provide detailed status
       18*   reporting and support of MTP610's */
       19 
       20 /* Modified Nov 1981 by Rich Coppola to fix bug in compatibility option */
       21 
       22 /* Modified Apr 14, 1982 by Rich Coppola to fix bug in test for recursive calls
       23*   probably caused by previous modification. */
       24 /* Modified 7/7/82 BIM to restore arg processing busted by above. */
       25 /* Modified September 1982 by C. Hornig to fix config processing. */
       26 /* Modified October 1982 By Rich Coppola for changes in call to
       27*   analyze_detail_stat_.
       28*   Also removed config processing as that is done in analyze_detail_stat_
       29*   and not needed here.
       30**/
       31 /* Modified July/Aug. 1983 by Paul Farley to correct the following:
       32*   Usage message (phx14639, phx15524) removed, none required.
       33*   Added the current time to error & info messages.
       34*   Added code to display current parameters after arg parsing (or to show dflt).
       35*   Removed "-retry" arg, made it the default, and removed all code
       36*   that was used when in "no retry" mode. Also if doing IO retry, the data
       37*   alert messages will be only recorded and not printed.
       38*   Fixed bug with data buffer loading when using -compare.
       39*   Also if first drive of -compare string cannot be attached
       40*   then the test will now terminate.
       41*   Added code in interp_xstats to summarize the status list.
       42*   Changed the ext_buffr to be a temp_seg, so that more errors could
       43*   be captured.
       44*   Modified Nov. 1984 by Paul Farley to write two EOFs at the end of a write
       45*   so that the read pass can use this to know when to stop reading.
       46*   Modified July 1985 by Paul Farley for FIPS tape.
       47**/
       48 
       49 /* format: style4,delnl,insnl,ifthenstmt,indnoniterend */
       50 test_tape:
       51      procedure options (variable);
       52 
       53 
       54 dcl  (vid, den8, den16, den6250) bit (1),
       55      program_interrupt condition,
       56      (write_error, read_error, irrec_write, irrec_read, rd_comp_err) fixed bin,
       57      cleanup condition,
       58      track7 bit (1) init ("0"b),
       59      retry_in_progress bit (1) init ("0"b),
       60      set_den_sw bit (1) init ("0"b),
       61      (comment_sw, sys_sw) bit (1) init ("0"b),
       62      ext_sw bit (1) init ("1"b),
       63      timer_manager_$sleep entry (fixed bin (71), bit (2)),
       64      (code, ecode) fixed bin (35) init (0),
       65      ipc_$create_ev_chn entry (fixed bin (71), fixed bin (35)),
       66      com_err_ entry options (variable),
       67      ipc_$block entry (ptr, ptr, fixed bin (35)),
       68      fail char (100) varying,
       69      mask bit (36),
       70      doing char (16) varying init ("mount"),
       71      dev_name char (32) init (""),
       72      comment char (55) init (""),
       73      reel_comment char (64),
       74      name char (32) init (""),
       75      (man_ptrn, rand_ptrn) bit (1) init ("0"b),
       76      (rec_wrt, rec_rd) fixed bin init (0),
       77      seed fixed bin (35) init (34546657),
       78      num_ret float bin (27),
       79      buf_init bit (1) init ("0"b),
       80      bufarray (1040) bit (36),
       81      buftemp bit (37440) based (addr (bufarray)),
       82      rek fixed bin (35) based (addr (bufarray)),
       83      read_buff bit (37440),
       84      err_buff (1040) bit (36) based (addr (read_buff)),
       85      ntimes fixed bin (25),
       86      det_valid bit (1) aligned,
       87      ioi_idx fixed bin,
       88      rsr_data bit (216) unal,
       89      (at_eot, detected_eof) bit (1) init ("0"b),
       90      (read_sw, write_sw, rew_sw, clean_up_sw) bit (1) init ("0"b),
       91      comp_sw bit (1) init ("0"b),
       92      dev_sw bit (1) init ("0"b),
       93      dev_array (16) char (32) init ((16) ("")),
       94      num_drives fixed bin int static init (0),
       95      comp_lp_ctr fixed bin int static init (0),
       96      (tdcm_attached, tape_mounted) bit (1) int static init ("0"b),
       97      nargs fixed bin,
       98      err_sum_sw bit (1) init ("0"b),
       99      (argptr, dstat_ptr) ptr,
      100      arglen fixed bin (21),
      101      arg_string char (arglen) based (argptr),
      102      blank_rd fixed bin init (0),
      103      yy fixed bin,
      104      temp fixed bin (35),				/* temp for compiler bug */
      105      (reelid, save_reel) char (9) init (""),
      106      wait_flag bit (1) init ("0"b),
      107      (wait, wait_cnt) fixed bin (35) init (0),
      108      density bit (36),
      109      att_bffr bit (208) init ("0"b),
      110      ext_bffr_ptr ptr init (null),
      111      1 ext_bffr (da_cnt) aligned based (ext_bffr_ptr),
      112        2 xrec_no fixed bin,
      113        2 xdoing fixed bin,
      114        2 iom_status bit (36) aligned,
      115        2 ext_data bit (208) unal,
      116      recursive_ fixed bin internal static,
      117      da_cnt fixed bin init (0),
      118      1 wait_list aligned,
      119        2 n fixed bin,
      120        2 chan (1) fixed bin (71),
      121      ndc_sw bit (1) init ("0"b),
      122      codex fixed bin init (0),
      123      dev_type fixed bin init (0),
      124      1 message aligned,
      125        2 chname fixed bin (71),
      126        2 message fixed bin (71),
      127        2 sender bit (36),
      128        2 origin,
      129          3 (devsignal, ring) bit (18) unaligned,
      130        2 channel_index fixed bin,
      131      stat_ptr ptr,
      132      1 stat_chk aligned based (stat_ptr),
      133        2 stat_pad1 bit (2) unaligned,
      134        2 stat_maj bit (4) unaligned,
      135        2 stat_min bit (6) unaligned,
      136        2 stat_pad2 bit (24) unaligned,
      137      i fixed bin (35) init (0),
      138      (k, l) fixed bin,
      139      (wrx, rdx) fixed bin init (0),
      140      (substr, index, addr, baseptr, bin, char, empty, fixed, rel, rtrim, unspec, null, length, string) builtin,
      141      ioa_ entry options (variable),
      142      get_temp_segment_ entry (char (*), ptr, fixed bin (35)),
      143      release_temp_segment_ entry (char (*), ptr, fixed bin (35)),
      144      error_table_$resource_attached ext fixed bin (35),
      145      error_table_$multiple_io_attachment fixed bin (35) ext static,
      146      error_table_$resource_assigned ext fixed bin (35),
      147      error_table_$resource_unavailable ext fixed bin (35),
      148      error_table_$inconsistent ext fixed bin (35),
      149      error_table_$bad_density external fixed bin (35),
      150      error_table_$noarg external fixed bin (35),
      151      error_table_$badopt external fixed bin (35),
      152      random_$uniform entry (fixed bin (35), float bin (27)),
      153      cu_$arg_count entry (fixed bin, fixed bin (35)),
      154      cu_$arg_ptr entry (fixed bin, ptr, fixed bin (21), fixed bin (35)),
      155      cv_oct_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35)),
      156      cv_dec_check_ entry (char (*), fixed bin (35)) returns (fixed bin (35)),
      157      tdcm_$tdcm_attach entry (ptr, fixed bin (35)),
      158      tdcm_$tdcm_set_signal entry (ptr, fixed bin (35)),
      159      tdcm_$tdcm_reset_signal entry (ptr, fixed bin (35)),
      160      tdcm_$tdcm_message entry (ptr, char (*), fixed bin (1), fixed bin (35)),
      161      tdcm_$tdcm_iocall entry (ptr, fixed bin (35)),
      162      tdcm_$tdcm_detach entry (ptr, fixed bin (35));
      163 
      164 dcl  rec_cap char (16) var,
      165      dev_spd char (8) var;
      166 
      167 
      168 dcl  rec_tbl (0:11) char (16) var static options (constant)
      169 	init ("1600", "200/556/800/1600", " ", " ", "200/556/800", "200/556", " ", " ", "800/1600", "556/800", "6250",
      170 	"1600/6250");
      171 
      172 dcl  spd_tbl (0:3) char (8) static options (constant) init (" 75 ips ", "        ", "125 ips ", "200 ips ");
      173 
      174 dcl  dens_ (4) fixed bin static options (constant) init (6250, 1600, 0, 800);
      175 
      176 dcl  ioi_$get_detailed_status entry (fixed bin, bit (1) aligned, bit (*), fixed bin (35));
      177 dcl  analyze_detail_stat_ entry (char (*), bit (36) aligned, bit (*) unal, ptr, fixed bin (35));
      178 dcl  analyze_detail_stat_$rsnnl entry (char (*), bit (36) aligned, bit (*) unal, char (*) var, bit (1), fixed bin (35));
      179 dcl  analyze_device_stat_$rsnnl entry (char (*) var, ptr, bit (72) aligned, bit (18) aligned);
      180 dcl  stat_tablep ptr;
      181 dcl  tape_status_table_$tape_status_table_ ext;
      182 
      183 /* Begin Here */
      184 
      185 get_args:
      186 	call cu_$arg_count (nargs, code);
      187 
      188 	if code ^= 0 then do;
      189 	     call com_err_ (code, "test_tape");
      190 	     return;
      191 	     end;
      192 
      193 	if recursive_ = -1 then do;
      194 	     code = error_table_$multiple_io_attachment;
      195 	     call com_err_ (code, "test_tape", "test_tape has been recursively invoked.");
      196 	     call com_err_ (0, "test_tape", "enter the release (rl) command and recall");
      197 	     return;
      198 	     end;
      199 
      200 	stat_tablep = addr (tape_status_table_$tape_status_table_);
      201 
      202 	read_sw = "1"b;
      203 	string (comment) = "";
      204 	string (reel_comment) = "";
      205 	sys_sw = "0"b;
      206 	ext_sw = "0"b;
      207 	write_sw = "1"b;
      208 	mask = (12)"010"b;
      209 	ntimes = 100000;
      210 	vid = "0"b;
      211 	den8 = "0"b;
      212 	den6250 = "0"b;
      213 	den16 = "1"b;
      214 	density = "000100000000000000000000000000000000"b;
      215 	k = 0;
      216 	write_error, read_error, irrec_write, irrec_read, rd_comp_err = 0;
      217 
      218 arg_loop:
      219 	do while (nargs - k > 0);
      220 
      221 /* -------------------------------------------------------------------------------------------------- */
      222 /*                                                                                                  */
      223 /*     Set up the indicators to read only.                                                          */
      224 /*                                                                                                  */
      225 /* -------------------------------------------------------------------------------------------------- */
      226 	     k = k + 1;
      227 	     call cu_$arg_ptr (k, argptr, arglen, code);
      228 
      229 	     if arg_string = "-r" | arg_string = "-read" then do;
      230 		read_sw = "1"b;
      231 		write_sw = "0"b;
      232 		go to next_arg;
      233 		end;
      234 
      235 
      236 
      237 /* -------------------------------------------------------------------------------------------------- */
      238 /*                                                                                                  */
      239 /*     Set up the indicators to write only.                                                         */
      240 /*                                                                                                  */
      241 /* -------------------------------------------------------------------------------------------------- */
      242 	     if arg_string = "-w" | arg_string = "-write" then do;
      243 		read_sw = "0"b;
      244 		write_sw = "1"b;
      245 		go to next_arg;
      246 		end;
      247 
      248 /* --------------------------------------------------------------------------------------------------- */
      249 /*                                                                                                   */
      250 /*     Both read and write have been specifically requested even though these are the default        */
      251 /*     no special processing is needed so proceed to the next argument                               */
      252 /*                                                                                                   */
      253 /* --------------------------------------------------------------------------------------------------- */
      254 
      255 
      256 	     if arg_string = "-wr" | arg_string = "-write_read" then do;
      257 		go to next_arg;
      258 		end;
      259 
      260 
      261 /* -------------------------------------------------------------------------------------------------- */
      262 /*                                                                                                  */
      263 /*     Pick up the pattern and check to be sure it is valid.                                        */
      264 /*                                                                                                  */
      265 /* -------------------------------------------------------------------------------------------------- */
      266 	     if arg_string = "-ptrn" | arg_string = "-pattern" then do;
      267 		if rand_ptrn then do;
      268 ptrn_err:
      269 		     call com_err_ (0, "test_tape", "Incompatible options, -ptrn and -random.");
      270 		     go to bad_arg;
      271 		     end;
      272 		k = k + 1;
      273 		if k > nargs then do;
      274 		     code = error_table_$noarg;
      275 		     call com_err_ (code, "test_tape", "Missing data pattern.");
      276 		     go to bad_arg;
      277 		     end;
      278 		call cu_$arg_ptr (k, argptr, arglen, code);
      279 		if index (arg_string, "-") ^= 0 then do;
      280 		     code = error_table_$noarg;
      281 		     call com_err_ (code, "test_tape", "Missing data pattern.");
      282 		     go to bad_arg;
      283 		     end;
      284 		temp = cv_oct_check_ (arg_string, code);
      285 		mask = unspec (temp);
      286 		if code ^= 0 then do;
      287 		     call com_err_ (code, "test_tape", "Character ^d of data pattern is invalid.");
      288 		     go to bad_arg;
      289 		     end;
      290 		man_ptrn = "1"b;
      291 		go to next_arg;
      292 		end;
      293 
      294 	     if arg_string = "-random" then do;
      295 		if man_ptrn then goto ptrn_err;
      296 		rand_ptrn = "1"b;
      297 		goto next_arg;
      298 		end;
      299 
      300 /* --------------------------------------------------------------------------------------------------- */
      301 /*                                                                                                   */
      302 /*     Pick up the number of records to write and/or read and make sure it is a valid decimal number. */
      303 /*                                                                                                   */
      304 /* --------------------------------------------------------------------------------------------------- */
      305 
      306 	     if arg_string = "-count" | arg_string = "-ct" then do;
      307 		k = k + 1;
      308 		if k > nargs then do;
      309 		     code = error_table_$noarg;
      310 		     call com_err_ (code, "test_tape", "Missing record count.");
      311 		     go to bad_arg;
      312 		     end;
      313 		call cu_$arg_ptr (k, argptr, arglen, code);
      314 		if index (arg_string, "-") ^= 0 then do;
      315 		     code = error_table_$noarg;
      316 		     call com_err_ (code, "test_tape", "Missing record count.");
      317 		     go to bad_arg;
      318 		     end;
      319 		ntimes = cv_dec_check_ (arg_string, code);
      320 		if code ^= 0 then do;
      321 		     call ioa_ ("Character ^d of the record count is invalid.", code);
      322 		     go to bad_arg;
      323 		     end;
      324 		go to next_arg;
      325 		end;
      326 
      327 /* -------------------------------------------------------------------------------------------------- */
      328 /*                                                                                                  */
      329 /*     Get the user designated volume id.                                                           */
      330 /*                                                                                                  */
      331 /* -------------------------------------------------------------------------------------------------- */
      332 	     if arg_string = "-volume" | arg_string = "-vol" then do;
      333 		k = k + 1;
      334 		if k > nargs then do;
      335 		     code = error_table_$noarg;
      336 		     call com_err_ (code, "test_tape", "Missing volume id.");
      337 		     go to bad_arg;
      338 		     end;
      339 		call cu_$arg_ptr (k, argptr, arglen, code);
      340 		if char (arg_string, 1) = "-" then do;
      341 		     code = error_table_$noarg;
      342 		     call com_err_ (code, "test_tape", "Missing volume id.");
      343 		     go to bad_arg;
      344 		     end;
      345 		reelid = arg_string;
      346 		save_reel = reelid;
      347 		vid = "1"b;
      348 		go to next_arg;
      349 
      350 		end;
      351 
      352 
      353 /* ***********************************************
      354*   *   Pick up any comments to reel information	  *
      355*   *********************************************** */
      356 
      357 	     if arg_string = "-comment" | arg_string = "-com" then do;
      358 		k = k + 1;
      359 		if k > nargs then do;
      360 		     code = error_table_$noarg;
      361 		     call com_err_ (code, "test_tape", "Missing Comment.");
      362 		     go to bad_arg;
      363 		     end;
      364 		call cu_$arg_ptr (k, argptr, arglen, code);
      365 		if index (arg_string, "-") ^= 0 then do;
      366 		     code = error_table_$noarg;
      367 		     call com_err_ (code, "test_tape", "Missing Comment.");
      368 		     go to bad_arg;
      369 		     end;
      370 
      371 		if length (arg_string) > 55 then do;
      372 		     code = error_table_$noarg;
      373 		     call com_err_ (code, "test_tape", "Comment String > 55 chars.");
      374 		     go to bad_arg;
      375 		     end;
      376 
      377 		comment = arg_string;
      378 		comment_sw = "1"b;
      379 		go to next_arg;
      380 		end;
      381 
      382 /* -------------------------------------------------------------------------------------------------- */
      383 
      384 /*                                                                                                  */
      385 /*     Pick up the specified density and set the indicator  accordingly.              */
      386 /*                                                                                                  */
      387 /* -------------------------------------------------------------------------------------------------- */
      388 	     if arg_string = "-density" | arg_string = "-den" then do;
      389 		k = k + 1;
      390 		if k > nargs then do;
      391 		     code = error_table_$noarg;
      392 		     call com_err_ (code, "test_tape", "Missing density.");
      393 		     go to bad_arg;
      394 		     end;
      395 		call cu_$arg_ptr (k, argptr, arglen, code);
      396 		if arg_string = "800" then do;
      397 		     den8 = "1"b;
      398 		     den16 = "0"b;
      399 		     den6250 = "0"b;
      400 		     density = "001000000000000000000000000000000000"b;
      401 		     end;
      402 
      403 		else if arg_string = "1600" then do;
      404 		     den8 = "0"b;
      405 		     den16 = "1"b;
      406 		     den6250 = "0"b;
      407 		     density = "000100000000000000000000000000000000"b;
      408 		     end;
      409 
      410 		else if arg_string = "6250" then do;
      411 		     den6250 = "1"b;
      412 		     den8 = "0"b;
      413 		     den16 = "0"b;
      414 		     density = "000010000000000000000000000000000000"b;
      415 		     end;
      416 
      417 
      418 		else do;
      419 		     code = error_table_$bad_density;
      420 		     call com_err_ (code, "test_tape", "Only 800, 1600 or 6250 bpi may be specified for test_tape.");
      421 		     go to bad_arg;
      422 		     end;
      423 		go to next_arg;
      424 		end;
      425 
      426 
      427 /* --------------------------------------------------------------------------------- */
      428 /*            pick up type handler (7 or 9 track).                                       */
      429 /*                        set track7 flag if requested                                    */
      430 /* --------------------------------------------------------------------------------- */
      431 
      432 	     if arg_string = "-track7" | arg_string = "-tk7" then do;
      433 		den8 = "1"b;
      434 		den16 = "0"b;
      435 		den6250 = "0"b;
      436 		track7 = "1"b;
      437 		density = "001000000000000000000000000000000000"b;
      438 		go to next_arg;
      439 		end;
      440 
      441 /* ------------------------------------------------------------------- */
      442 /*     See if user wants to turn on Detailed Status output      */
      443 
      444 /* ------------------------------------------------------------------- */
      445 
      446 	     if arg_string = "-raw" then do;
      447 		ext_sw = "1"b;
      448 		go to next_arg;
      449 		end;
      450 
      451 /* ------------------------------------------------------------------- */
      452 /*                                                                    */
      453 /*	           See if this is a no data compare read pass              */
      454 /*                                                                   */
      455 /* ----------------------------------------------------------------- */
      456 
      457 	     if arg_string = "-ndc" | arg_string = "no_data_compare" then do;
      458 		ndc_sw = "1"b;
      459 		go to next_arg;
      460 		end;
      461 
      462 /* **************************************
      463*   *    See if user wants wait option    *
      464*   ************************************** */
      465 
      466 	     if arg_string = "-wait" | arg_string = "-wt" then do;
      467 		wait_flag = "1"b;
      468 		k = k + 1;
      469 		if k > nargs then do;
      470 		     wait_cnt = 2;			/* default */
      471 		     goto done_args;
      472 		     end;
      473 		call cu_$arg_ptr (k, argptr, arglen, code);
      474 		if index (arg_string, "-") ^= 0 then do;
      475 		     wait_cnt = 2;			/* default */
      476 		     k = k - 1;
      477 		     goto next_arg;
      478 		     end;
      479 		wait_cnt = cv_dec_check_ (arg_string, code);
      480 		if code ^= 0 then do;
      481 		     call com_err_ (code, "test_tape", arg_string);
      482 		     go to bad_arg;
      483 		     end;
      484 		goto next_arg;
      485 		end;
      486 
      487 /* *******************************************
      488*   *    See if user wants a certain drive     *
      489*   ******************************************* */
      490 
      491 	     if arg_string = "-dv" | arg_string = "-device" then do;
      492 		if comp_sw then goto no_good;
      493 		k = k + 1;
      494 		if k > nargs then do;
      495 dv_error:
      496 		     code = error_table_$noarg;
      497 		     call com_err_ (code, "test_tape", "Missing device name");
      498 		     go to bad_arg;
      499 		     end;
      500 		call cu_$arg_ptr (k, argptr, arglen, code);
      501 		if index (arg_string, "-") ^= 0 then goto dv_error;
      502 		dev_name = arg_string;
      503 		dev_sw = "1"b;
      504 		goto next_arg;
      505 no_good:
      506 		code = error_table_$inconsistent;
      507 		call com_err_ (code, "test_tape", "Can't have both -device and -compare options at the same time!");
      508 		go to bad_arg;
      509 		end;
      510 
      511 /* **************************************************
      512*   *    See if user wants the compatability option   *
      513*   ************************************************** */
      514 
      515 	     if arg_string = "-comp" | arg_string = "-compare" then do;
      516 		if dev_sw then goto no_good;
      517 		num_drives = 0;
      518 		do l = 1 by 1;
      519 		     k = k + 1;
      520 		     if k > nargs then do;
      521 			if l < 3 then do;
      522 comp_error:
      523 			     code = error_table_$noarg;
      524 			     call com_err_ (code, "test_tape", "Must have at least 2 devices to run compatability!")
      525 				;
      526 			     go to bad_arg;
      527 			     end;
      528 			goto done_args;
      529 			end;
      530 		     call cu_$arg_ptr (k, argptr, arglen, code);
      531 		     if index (arg_string, "-") ^= 0 then do;
      532 			if l < 3 then goto comp_error;
      533 			k = k - 1;
      534 			goto next_arg;
      535 			end;
      536 		     if l > 16 then do;
      537 			call com_err_ (error_table_$badopt, "test_tape", "16 drives is the max.");
      538 			go to bad_arg;
      539 			end;
      540 		     dev_array (l) = arg_string;
      541 		     comp_sw = "1"b;
      542 		     num_drives = num_drives + 1;
      543 		end;
      544 		end;
      545 
      546 /* See if sys flag is wanted */
      547 
      548 	     if arg_string = "-system" | arg_string = "-sys" then do;
      549 		sys_sw = "1"b;
      550 		go to next_arg;
      551 		end;
      552 
      553 	     if arg_string = "-retry" then goto next_arg; /* Default (obsolete arg) */
      554 
      555 	     code = error_table_$badopt;
      556 	     call com_err_ (code, "test_tape", "Invalid or unrecognizable parameter in string (^a).", arg_string);
      557 
      558 bad_arg:
      559 	     call com_err_ (0, "test_tape", "For a list of valid control args type ""help test_tape -bf"".");
      560 	     return;
      561 next_arg:
      562 	end;
      563 
      564 done_args:
      565 	tsegp = null ();				/* so cleanup will work */
      566 	tdcm_attached = "0"b;
      567 	on cleanup call command_cleanup ("0"b);
      568 	rek = 0;
      569 
      570 /* Display current options to user. */
      571 
      572 	call com_err_ (0, name_stamp (),
      573 	     "Opt= tk-^[7^;9^],den-^[800^]^[1600^]^[6250^],mode-^[w^]^[r^],ct-^[entire^s^;^d^]^[,wt-^d^;^s^],ptrn-^[random^s^;^12.3b^]^[,ndc^]^[,raw^]^[,sys^]",
      574 	     track7, den8, den16, den6250, write_sw, read_sw, (ntimes >= 100000), ntimes, wait_flag, wait_cnt,
      575 	     rand_ptrn, mask, ndc_sw, ext_sw, sys_sw);
      576 
      577 
      578 /* init tape for write and get it mounted */
      579 
      580 
      581 /* -------------------------------------------------------------------------------------------------- */
      582 /*                                                                                                  */
      583 /*     Grab storage for the tseg structure.                                                         */
      584 /*                                                                                                  */
      585 /* -------------------------------------------------------------------------------------------------- */
      586 
      587 	comp_lp_ctr = 0;
      588 	if comp_sw then do;
      589 comp_loop:
      590 	     comp_lp_ctr = comp_lp_ctr + 1;
      591 	     dev_name = dev_array (comp_lp_ctr);
      592 	     if comp_lp_ctr > 1 then write_sw = "0"b;	/* turn off write */
      593 	     end;
      594 
      595 	call get_temp_segment_ (name_stamp (), ext_bffr_ptr, code);
      596 	if code ^= 0 then do;
      597 	     call com_err_ (code, name_stamp (), "Attempting to get a temporary segment!");
      598 	     return;
      599 	     end;
      600 	allocate tseg;
      601 
      602 	tseg.version_num = tseg_version_2;
      603 	tseg.areap = null;
      604 	call ipc_$create_ev_chn (tseg.ev_chan, code);
      605 	if code ^= 0 then do;
      606 	     call com_err_ (code, name_stamp (), "no event channel");
      607 	     go to done;
      608 	     end;
      609 
      610 	if track7
      611 	then tseg.tracks = 1;			/* We want a 7 track drive */
      612 
      613 
      614 	else tseg.tracks = 0;			/* we want a 9 track tape */
      615 sync:
      616 	tseg.sync = 1;				/* we want async operation */
      617 	tseg.get_size = 0;				/* no sizes returned */
      618 
      619 
      620 	tseg.bufferptr (1) = bin (rel (addr (tseg.buffer (1))), 18);
      621 	tseg.buffer_size (1) = 1040;
      622 	tseg.mode (1) = 0;				/* binary records */
      623 	tseg.density = density;
      624 
      625 
      626 /* ----------------------------------------------------------------------------------------------- */
      627 /*                                                                                               */
      628 /* Attach drive and do initial rewind and unload.  Prepare to wait for tape mounted signal.      */
      629 /*                                                                                               */
      630 /* ----------------------------------------------------------------------------------------------- */
      631 
      632 	if write_sw
      633 	then tseg.write_sw = 1;
      634 	else tseg.write_sw = 0;
      635 
      636 	call tdcm_$tdcm_attach (tsegp, code);
      637 	if code ^= 0 then do;
      638 	     call com_err_ (code, name_stamp (), "tdcm attach bad");
      639 	     go to done;
      640 	     end;
      641 	tdcm_attached = "1"b;
      642 
      643 	call tdcm_$tdcm_set_signal (tsegp, code);
      644 	if code ^= 0 then do;
      645 	     call com_err_ (code, name_stamp (), "mount tape set signal bad");
      646 	     go to done;
      647 	     end;
      648 
      649 
      650 /* ------------------------------------------------------------------------------------------------------- */
      651 /*                                                                                                       */
      652 /*     Set the volume id and issue the starting test message to the user.  Output a mount message        */
      653 /*     to the operator and hang around waiting for a response from him to indicate that the tape is      */
      654 /*     indeed mounted.                                                                                   */
      655 /*                                                                                                       */
      656 /* ------------------------------------------------------------------------------------------------------- */
      657 
      658 attach:
      659 	tape_mounted = "0"b;			/* No tape YET */
      660 	if dev_sw | comp_sw
      661 	then tseg.drive_name = dev_name;
      662 	else tseg.drive_name = "";
      663 
      664 	if vid
      665 	then reel_comment = rtrim (save_reel);
      666 
      667 	else do;
      668 	     reel_comment = "test-tape";
      669 	     save_reel = "test-tape";
      670 	     end;
      671 
      672 	if comment_sw then reel_comment = rtrim (reel_comment) || ",*" || rtrim (comment);
      673 
      674 	if sys_sw then reel_comment = rtrim (reel_comment) || ",sys";
      675 
      676 request_mount:
      677 	call com_err_ (0, name_stamp (), "Requesting mount of volume ""^a""^[ on ^a^].", save_reel, (dev_sw | comp_sw),
      678 	     tseg.drive_name);
      679 
      680 	call tdcm_$tdcm_message (tsegp, reel_comment, tseg.write_sw, code);
      681 	if code ^= 0 & code ^= error_table_$resource_attached & code ^= error_table_$resource_assigned then do;
      682 	     call com_err_ (code, name_stamp (), "Unable to attach ^a", tseg.drive_name);
      683 	     if wait_flag & (wait_cnt > wait) & code = error_table_$resource_unavailable then do;
      684 		call com_err_ (0, name_stamp (), "I will wait 1 minute and then try again!");
      685 		call timer_manager_$sleep (60, "11"b);
      686 		wait = wait + 1;
      687 		goto request_mount;
      688 		end;
      689 	     wait = 0;
      690 	     if comp_sw then do;
      691 		if comp_lp_ctr = 1 then do;
      692 		     call com_err_ (0, name_stamp (), "Unable to continue test.");
      693 		     call command_cleanup ("1"b);
      694 		     return;
      695 		     end;
      696 		call com_err_ (0, name_stamp (), "Bypassing device ^a.", tseg.drive_name);
      697 		goto done;
      698 		end;
      699 	     call command_cleanup ("1"b);
      700 	     return;
      701 	     end;
      702 
      703 	else if code ^= 0 then do;
      704 	     call com_err_ (code, name_stamp (), "Attaching tape.");
      705 	     go to done;
      706 	     end;
      707 
      708 	wait = 0;
      709 	call wait_io;				/* wait for drive ext signal */
      710 
      711 /* ------------------------------------------------------------------------------------------------------- */
      712 /*                                                                                                       */
      713 /*     When the tape is officially mounted set the density if requested to do so.                        */
      714 /*                                                                                                       */
      715 /* ------------------------------------------------------------------------------------------------------- */
      716 
      717 	tape_mounted = "1"b;			/* now official */
      718 
      719 	if den8 | den16 | den6250 then do;
      720 	     set_den_sw = "1"b;
      721 	     doing = "set density";
      722 	     if den8 then tseg.command_queue (1) = bin ("110000"b, 6);
      723 	     if den16 then tseg.command_queue (1) = bin ("110101"b, 6);
      724 	     if den6250 then tseg.command_queue (1) = bin ("100001"b, 6);
      725 	     tseg.sync = 1;
      726 	     tseg.buffer_count = 0;
      727 	     tseg.command_count = 1;
      728 	     call tdcm_$tdcm_iocall (tsegp, code);
      729 
      730 	     if code ^= 0 then do;
      731 		call com_err_ (code, name_stamp (), "Set density iocall failed.");
      732 		go to done;
      733 		end;
      734 
      735 
      736 	     if tseg.completion_status = 1
      737 	     then tseg.sync = 1;
      738 
      739 	     else do;
      740 		call ck_io (code, "0"b);
      741 		call com_err_ (0, name_stamp (), "Set density io failed, terminating test.");
      742 		go to done;
      743 		end;
      744 	     end;
      745 
      746 	set_den_sw = "0"b;
      747 
      748 	if ^buf_init then do;
      749 	     if rand_ptrn then do;
      750 		do i = 1 to 1040;
      751 		     call random_$uniform (seed, num_ret);
      752 		     bufarray (i) = unspec (num_ret);
      753 		end;
      754 		end;
      755 	     else do i = 1 to 1040;
      756 		bufarray (i) = mask;
      757 	     end;
      758 
      759 	     tseg.buffer (1) = buftemp;
      760 
      761 	     buf_init = "1"b;
      762 	     end;
      763 
      764 	ws_ptr = baseptr (tseg.ws_segno);
      765 	ioi_idx = ws.info.ioix;
      766 
      767 
      768 	tseg.command_count = 2;
      769 	tseg.command_queue (2) = bin ("100000"b, 6);	/* reset dev status */
      770 	tseg.command_queue (1) = bin ("101001"b, 6);	/* reset device extended status */
      771 	call tdcm_$tdcm_iocall (tsegp, code);
      772 	recursive_ = -1;				/* prevent recursive calls */
      773 	name = tseg.drive_name;
      774 
      775 	on program_interrupt
      776 	     call com_err_ (0, name_stamp (), "^a pass on ^a, processing record ^d", rtrim (doing),
      777 		rtrim (tseg.drive_name), rek);
      778 
      779 
      780 
      781 
      782 /* here we write test tape if requested, else go to read */
      783 
      784 	if write_sw = "0"b then go to read_part;
      785 	doing = "write";
      786 	call com_err_ (0, name_stamp (), "Begin write pass on ^a^[ vol=^a^].", tseg.drive_name, vid, save_reel);
      787 
      788 /*     Do this loop either till end of tape or until we reach the number of records specified  by the user in the -nrec parameter.        */
      789 
      790 
      791 	rek, rec_wrt = 0;
      792 
      793 	do i = 1 to ntimes;
      794 	     rek = rek + 1;
      795 	     wrx = i;
      796 	     rec_wrt = rec_wrt + 1;
      797 
      798 reissue_wr:
      799 	     tseg.buffer (1) = buftemp;
      800 	     call issue_rw;
      801 
      802 	     if tseg.completion_status = 1 then go to write_ok;
      803 						/* Completion Status was good */
      804 
      805 	     stat_ptr = addr (tseg.hardware_status);
      806 
      807 	     if stat_maj = "0001"b then go to reissue_wr;
      808 
      809 
      810 	     call ck_io (code, "0"b);
      811 	     if code = 1 then go to done;
      812 	     if code = 3 then go to reissue_wr;
      813 	     if code = 4 then go to eot_m;
      814 	     if (code = 5) | (code = 9) then go to done;
      815 	     if code = 6 then go to eot_m;
      816 
      817 
      818 write_ok:
      819 done_write:
      820 	end;
      821 
      822 
      823 eot_m:
      824 	if code = 4
      825 	then at_eot = "1"b;
      826 	else at_eot = "0"b;
      827 	doing = "write EOF";
      828 
      829 	do i = 1 to 10;
      830 	     tseg.buffer_count = 0;
      831 	     tseg.command_count = 1;
      832 	     tseg.command_queue (1) = bin ("101101"b, 6);
      833 	     call tdcm_$tdcm_iocall (tsegp, code);
      834 
      835 	     if code ^= 0 then do;
      836 		call com_err_ (code, name_stamp (), "Write EOF^[ at EOT^;^] iocall failed.", at_eot);
      837 		go to done;
      838 		end;
      839 
      840 
      841 	     if tseg.completion_status = 1
      842 	     then go to write_second_eof;
      843 
      844 	     else do;
      845 		call ck_io (code, "0"b);
      846 		if code = 4 then go to write_second_eof;
      847 		call backspace (1);
      848 		end;
      849 
      850 	end;
      851 
      852 	call com_err_ (0, name_stamp (), "Unable to write EOF^[ at EOT^;^], terminating test.", at_eot);
      853 	go to done;
      854 
      855 
      856 write_second_eof:
      857 	doing = "write second EOF";
      858 
      859 	do i = 1 to 10;
      860 	     tseg.buffer_count = 0;
      861 	     tseg.command_count = 1;
      862 	     tseg.command_queue (1) = bin ("101101"b, 6);
      863 	     call tdcm_$tdcm_iocall (tsegp, code);
      864 
      865 	     if code ^= 0 then do;
      866 		call com_err_ (code, name_stamp (), "Write second EOF^[ at EOT^;^] iocall failed.", at_eot);
      867 		go to done;
      868 		end;
      869 
      870 
      871 	     if tseg.completion_status = 1
      872 	     then go to rew;
      873 
      874 	     else do;
      875 		call ck_io (code, "0"b);
      876 		if code = 4 then go to rew;
      877 		call backspace (1);
      878 		end;
      879 
      880 	end;
      881 
      882 	call com_err_ (0, name_stamp (), "Unable to write second EOF^[ at EOT^;^], terminating test.", at_eot);
      883 	go to done;
      884 
      885 
      886 rew:
      887 	doing = "rewind";
      888 	at_eot = "0"b;
      889 	write_sw = "0"b;
      890 	rew_sw = "1"b;
      891 
      892 	do i = 1 to 5;
      893 	     tseg.buffer_count = 0;
      894 	     tseg.command_count = 1;
      895 	     tseg.command_queue (1) = bin ("111000"b, 6);
      896 
      897 	     call tdcm_$tdcm_iocall (tsegp, code);
      898 
      899 	     if code ^= 0 then do;
      900 		call com_err_ (code, name_stamp (), "rewind iocall failed");
      901 		go to done;
      902 		end;
      903 
      904 	     if tseg.completion_status = 1 then go to wait_rew;
      905 
      906 	     call ck_io (code, "0"b);			/*  got bad io stat */
      907 	end;
      908 
      909 	call com_err_ (0, name_stamp (), "Unable to issue rewind io, terminating test.");
      910 	go to done;
      911 
      912 
      913 
      914 wait_rew:
      915 	do i = 1 to 120 while (rew_sw = "1"b);		/* Max = 10 minutes */
      916 
      917 	     call timer_manager_$sleep (5, "11"b);	/* 5 relative seconds */
      918 	     tseg.buffer_count = 0;
      919 	     tseg.command_count = 1;
      920 	     tseg.command_queue (1) = bin ("000000"b, 6);
      921 	     call tdcm_$tdcm_iocall (tsegp, code);
      922 
      923 	     if code ^= 0 then do;
      924 		call com_err_ (code, name_stamp (), "check status iocall failed.");
      925 		go to done;
      926 		end;
      927 
      928 	     if tseg.completion_status = 1 then do;
      929 		rew_sw = "0"b;
      930 		go to read_part;
      931 		end;
      932 
      933 	     if (addr (tseg.hardware_status) -> stat_chk.stat_maj = "0001"b)
      934 		& (addr (tseg.hardware_status) -> stat_chk.stat_min = "000001"b)
      935 	     then go to end_wait;
      936 
      937 
      938 	     if tseg.completion_status = 2 then call ck_io (code, "0"b);
      939 
      940 end_wait:
      941 	end;
      942 
      943 	call com_err_ (code, name_stamp (), "unable to perform rewind on device");
      944 	go to done;
      945 
      946 
      947 
      948 /* here to read tape and check how we did */
      949 
      950 read_part:
      951 	if read_sw = "0"b then go to done;
      952 
      953 
      954 	detected_eof = "0"b;
      955 	write_sw = "0"b;
      956 	doing = "read";
      957 	call com_err_ (0, name_stamp (), "Begin read pass on ^a^[ vol=^a^].", tseg.drive_name, vid, save_reel);
      958 	tseg.write_sw = 0;				/* lets setup to do a read */
      959 
      960 	rec_rd = 0;
      961 	rek = 0;					/* record number for s/b data */
      962 
      963 	do i = 1 to ntimes;
      964 	     rek = rek + 1;
      965 	     rdx = i;
      966 	     rec_rd = rec_rd + 1;
      967 
      968 
      969 reissue_rd:
      970 	     call issue_rw;
      971 
      972 	     if tseg.completion_status = 1 then do;
      973 		detected_eof = "0"b;
      974 		if ^ndc_sw
      975 		then call ck_data;
      976 		else go to end_read;
      977 		end;
      978 
      979 	     stat_ptr = addr (tseg.hardware_status);
      980 
      981 	     if stat_maj = "0001"b then go to reissue_rd;
      982 
      983 	     if tseg.completion_status = 2 then do;
      984 
      985 		if stat_maj = "0100"b then do;
      986 		     if stat_min = "001111"b | stat_min = "010011"b then do;
      987 						/* 7 or 9 track eof signal */
      988 			rek = rek - 1;
      989 			rdx = rdx - 1;
      990 			rec_rd = rec_rd - 1;
      991 
      992 			if detected_eof then goto done;
      993 						/* this makes two in a row! */
      994 			detected_eof = "1"b;	/* one seen */
      995 			goto end_read;
      996 			end;
      997 		     rew_sw = "1"b;			/* set so no retries */
      998 		     call ck_io (code, "1"b);		/* got a parity err */
      999 		     go to done;
     1000 		     end;
     1001 
     1002 		call ck_io (code, "1"b);		/* how was it */
     1003 		if code = 1 then go to done;
     1004 		if code = 4 then do;
     1005 		     call com_err_ (code, name_stamp (), "EOT detected during read");
     1006 		     go to done;
     1007 		     end;
     1008 
     1009 		if (code = 5) | (code = 9) then do;
     1010 		     call com_err_ (code, name_stamp (), "Unrecoverable Attention condition, Quit.");
     1011 		     codex = 9;
     1012 		     go to done;
     1013 		     end;
     1014 		end;
     1015 	     go to end_read;
     1016 
     1017 end_read:
     1018 	     blank_rd = 0;
     1019 	end;
     1020 
     1021 done:
     1022 	call summarize;				/* display results */
     1023 
     1024 	call command_cleanup ("1"b);
     1025 
     1026 	if (comp_sw) & (comp_lp_ctr < num_drives) then do;
     1027 	     read_error, write_error, rd_comp_err = 0;
     1028 	     irrec_write, irrec_read = 0;
     1029 	     blank_rd, rec_wrt, rec_rd = 0;
     1030 	     da_cnt = 0;
     1031 	     goto comp_loop;
     1032 	     end;
     1033 
     1034 	return;
     1035 
     1036 error:
     1037      proc (efail, ecode);
     1038 dcl  efail char (*) varying,
     1039      ecode fixed bin (35),
     1040      more_sw bit (1),
     1041      recn fixed bin;
     1042 dcl  t_maj bit (6) init ("000000"b);
     1043 dcl  is_interesting bit (1);
     1044 dcl  detailed_stat bit (208) unal based (dstat_ptr);
     1045 dcl  1 ext based (dstat_ptr),
     1046        2 data (26) bit (8) unal;
     1047 
     1048 
     1049 	if retry_in_progress &			/* bypass if in retry */
     1050 	     ^(code = 9 | code = 5)
     1051 	then return;
     1052 	if read_sw then recn = rdx;
     1053 
     1054 	if write_sw then recn = wrx;
     1055 
     1056 	if (rew_sw | set_den_sw)
     1057 	then more_sw = "1"b;
     1058 	else more_sw = "0"b;
     1059 
     1060 
     1061 	call com_err_ (0, name_stamp (), "^a error^[ @ record ^9d^].", doing, ^more_sw, recn);
     1062 	call ioa_ ("^-^3x^a (^2o/^2o)", efail, stat_maj, stat_min);
     1063 
     1064 
     1065 	dstat_ptr = addr (ext_bffr (da_cnt).ext_data);
     1066 
     1067 	if code = 9 | code = 5 then do;		/* if its an att. cond. */
     1068 	     call analyze_detail_stat_$rsnnl (name, (tseg.hardware_status), detailed_stat, efail, is_interesting, ecode)
     1069 		;
     1070 	     if is_interesting then call ioa_ ("^-^3xDetailed status: ^a", efail);
     1071 	     end;
     1072 
     1073 
     1074 	if ext_sw then do;
     1075 	     call ioa_ ("^/Detailed Status: ^( ^2.4b^) (hex)", ext.data (1), ext.data (2), ext.data (3), ext.data (4),
     1076 		ext.data (5), ext.data (6), ext.data (7), ext.data (8), ext.data (9), ext.data (10), ext.data (11),
     1077 		ext.data (12), ext.data (13), ext.data (14), ext.data (15), ext.data (16));
     1078 	     call ioa_ ("^10xByte => 00 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15^/");
     1079 	     call ioa_ ("^17x^( ^2.4b^) (hex)", ext.data (17), ext.data (18), ext.data (19), ext.data (20),
     1080 		ext.data (21), ext.data (22), ext.data (23), ext.data (24), ext.data (25), ext.data (26));
     1081 	     call ioa_ ("^10xByte => 16 17 18 19 20 21 22 23 24 25^/");
     1082 	     end;
     1083 
     1084 	return;
     1085      end error;
     1086 
     1087 
     1088 /* internal proc to determine type of error */
     1089 
     1090 ck_io:
     1091      proc (xcode, who_sw);
     1092 
     1093 dcl  xcode fixed bin (35),
     1094      stat_pad bit (36) aligned init ("0"b),
     1095      who_sw bit (1);
     1096 
     1097 
     1098 	if tseg.completion_status ^= 2
     1099 	then					/* should not be here otherwise */
     1100 	     return;
     1101 
     1102 	code = 0;					/* resett error status */
     1103 
     1104 
     1105 	if stat_maj = "0011"b & substr (stat_min, 1, 1) = "1"b then do;
     1106 						/* EOT Detected */
     1107 	     code = 4;
     1108 	     if stat_min ^= "100000"b then do;
     1109 		call analyze_device_stat_$rsnnl (fail, stat_tablep, (tseg.hardware_status || stat_pad), ("0"b));
     1110 		call error (fail, code);
     1111 		code = 2;
     1112 		end;
     1113 	     return;
     1114 	     end;
     1115 
     1116 	if stat_maj = "0011"b & stat_min = "000010"b then do;
     1117 	     blank_rd = blank_rd + 1;
     1118 	     if blank_rd = 3 then do;
     1119 		call com_err_ (0, name_stamp (), "quitting test due to BLANK TAPE on READ statuses.");
     1120 		go to done;
     1121 		end;
     1122 	     end;
     1123 
     1124 	call ioi_$get_detailed_status (ioi_idx, det_valid, rsr_data, code);
     1125 	if ^det_valid then rsr_data = "0"b;
     1126 
     1127 	if tseg.write_sw = 1
     1128 	then					/* if we're  writing update the write errors */
     1129 	     write_error = write_error + 1;
     1130 
     1131 	else read_error = read_error + 1;
     1132 
     1133 	call analyze_device_stat_$rsnnl (fail, stat_tablep, (tseg.hardware_status || stat_pad), ("0"b));
     1134 
     1135 	da_cnt = da_cnt + 1;			/* update error ctr */
     1136 	if da_cnt > 1000 then do;			/* too many errors */
     1137 	     call com_err_ (0, name_stamp (), "Too many errors encountered! ^/Fix tape drive and re-run!");
     1138 	     da_cnt = da_cnt - 1;			/* forget about this one */
     1139 	     call error (fail, code);
     1140 	     go to done;
     1141 	     end;
     1142 
     1143 
     1144 	ext_bffr (da_cnt).iom_status = tseg.hardware_status;
     1145 	ext_bffr (da_cnt).ext_data = substr (rsr_data, 1, 208);
     1146 
     1147 	if tseg.write_sw = 1			/* if writing */
     1148 	then ext_bffr (da_cnt).xrec_no = wrx;
     1149 
     1150 	else ext_bffr (da_cnt).xrec_no = rdx;
     1151 
     1152 	ext_bffr (da_cnt).xdoing = tseg.write_sw;
     1153 
     1154 check_stat:
     1155 	if stat_maj = "0011"b | stat_maj = "0010"b | stat_maj = "1011"b | stat_maj = "1010"b
     1156 	then go to err_stat (fixed (stat_maj, 4));
     1157 
     1158 	else go to err_stat (9);
     1159 
     1160 
     1161 err_stat (3):					/* MTH Data Alert */
     1162 	code, codex = 2;
     1163 	call error (fail, code);
     1164 	if ^retry_in_progress then call retry_;
     1165 	return;
     1166 
     1167 err_stat (11):					/* MPC Data Alert */
     1168 	if stat_min = "100000"b
     1169 	then code, codex = 9;			/* Marginal Condition */
     1170 
     1171 	else code, codex = 2;
     1172 	call error (fail, code);
     1173 	if ^retry_in_progress then call retry_;
     1174 	return;
     1175 
     1176 
     1177 err_stat (10):					/* MPC Attention */
     1178 	code, codex = 9;
     1179 
     1180 	if substr (stat_min, 3, 2) = "11"b then do;
     1181 	     code = 2;
     1182 	     call error (fail, code);
     1183 	     if ^retry_in_progress then call retry_;
     1184 	     return;
     1185 	     end;
     1186 
     1187 	else if substr (stat_min, 3, 2) ^= "11"b then do;
     1188 	     code, codex = 9;
     1189 	     ext_sw = "1"b;
     1190 	     call error (fail, code);
     1191 	     ext_sw = "0"b;
     1192 	     go to done;
     1193 	     end;
     1194 
     1195 err_stat (2):					/* MTH Attention */
     1196 	code, codex = 9;
     1197 	ext_sw = "1"b;
     1198 	call error (fail, code);
     1199 	ext_sw = "0"b;
     1200 	go to done;
     1201 
     1202 /* should never get here. if we do report it and quit test */
     1203 
     1204 err_stat (9):
     1205 	codex = 9;
     1206 	call com_err_ (0, name_stamp (), "Cannot process returned status, aborting test.");
     1207 	ext_sw = "1"b;
     1208 	call error (fail, code);
     1209 	ext_sw = "0"b;
     1210 	go to done;
     1211 
     1212      end ck_io;
     1213 
     1214 
     1215 retry_:
     1216      proc;
     1217 dcl  (kntt, knt, gotit) fixed bin init (0);
     1218 
     1219 	if index (doing, "EOT") ^= 0 then return;
     1220 
     1221 
     1222 	if rew_sw then return;
     1223 
     1224 	retry_in_progress = "1"b;
     1225 
     1226 	if doing = "write" then do;
     1227 
     1228 	     do knt = 1 to 10;			/* allow  for 10 retries of a record */
     1229 		call backspace (1);
     1230 
     1231 		call issue_rw;			/*  do the io */
     1232 
     1233 		if tseg.completion_status = 1 then do;
     1234 		     code = 0;
     1235 		     retry_in_progress = "0"b;
     1236 		     return;
     1237 		     end;
     1238 
     1239 		if tseg.completion_status = 2 then call ck_io (code, "0"b);
     1240 
     1241 	     end;
     1242 
     1243 	     irrec_write = irrec_write + 1;
     1244 
     1245 /*  do a bksp/erase */
     1246 
     1247 	     call com_err_ (0, name_stamp (), "10 unsuccessful attempts to write record ^d.", wrx);
     1248 	     call com_err_ (0, "", "^2-backspace/erase operation will be performed.");
     1249 
     1250 	     tseg.command_count = 2;
     1251 	     tseg.command_queue (1) = bin ("100110"b, 6);
     1252 	     tseg.command_queue (2) = bin ("101100"b, 6);
     1253 
     1254 	     call tdcm_$tdcm_iocall (tsegp, code);
     1255 
     1256 	     if code ^= 0 then do;
     1257 		call com_err_ (code, name_stamp (), "backspace/erase  iocall failed, QUIT");
     1258 		go to done;
     1259 		end;
     1260 
     1261 	     if tseg.completion_status = 1 then do;	/* good term */
     1262 		retry_in_progress = "0"b;
     1263 		code = 3;
     1264 		return;
     1265 		end;
     1266 
     1267 	     else do;				/* abnormal term */
     1268 
     1269 		call ck_io (code, "0"b);
     1270 		call com_err_ (0, name_stamp (), "backspace/erase failed, QUIT.");
     1271 		go to done;
     1272 		end;
     1273 
     1274 	     retry_in_progress = "0"b;
     1275 	     end;					/* end of write retry */
     1276 
     1277 
     1278 	else do;					/* retry reads */
     1279 
     1280 	     do knt = 1 to 3;			/* allow for 3 retries */
     1281 		call backspace (1);
     1282 		call issue_rw;
     1283 
     1284 		if tseg.completion_status = 1 then do;	/* read ok */
     1285 		     call ck_data;			/* verify the data */
     1286 		     return;
     1287 		     end;
     1288 
     1289 		else call ck_io (code, "1"b);
     1290 	     end;
     1291 
     1292 	     call com_err_ (0, name_stamp (), "Unable to read record ^d.", rdx);
     1293 	     irrec_read = irrec_read + 1;
     1294 	     retry_in_progress = "0"b;
     1295 	     end;					/* end of read retry */
     1296 	retry_in_progress = "0"b;
     1297 
     1298 	return;
     1299      end retry_;
     1300 
     1301 
     1302 
     1303 
     1304 /* routine to issue read and write calls to tdcm */
     1305 
     1306 issue_rw:
     1307      proc;
     1308 
     1309 	tseg.buffer_offset = 0;
     1310 	tseg.buffer_count = 1;
     1311 	tseg.command_count = 0;
     1312 
     1313 	call tdcm_$tdcm_iocall (tsegp, code);
     1314 
     1315 
     1316 	if code ^= 0 then do;
     1317 	     call com_err_ (code, name_stamp (), "^a iocall failed", doing);
     1318 	     go to done;
     1319 	     end;
     1320 
     1321 	return;
     1322      end issue_rw;
     1323 
     1324 backspace:
     1325      proc (n);
     1326 
     1327 dcl  (i, n) fixed bin;
     1328 
     1329 	tseg.command_count = n;
     1330 
     1331 	do i = 1 to n;
     1332 	     tseg.command_queue (i) = bin ("100110"b, 6); /* backspace cmd */
     1333 	end;
     1334 
     1335 	call tdcm_$tdcm_iocall (tsegp, code);
     1336 
     1337 	if code ^= 0 then do;
     1338 	     call com_err_ (code, name_stamp (), "backspace iocall failed.");
     1339 	     go to done;
     1340 	     end;
     1341 
     1342 	tseg.command_count, code = 0;
     1343 
     1344 	return;
     1345 
     1346      end backspace;
     1347 
     1348 ck_data:
     1349      proc;
     1350 dcl  kk fixed bin;
     1351 
     1352 	if tseg.buffer (1) = buftemp
     1353 	then					/* if data compares */
     1354 	     return;				/*  all's well */
     1355 
     1356 	rd_comp_err = rd_comp_err + 1;
     1357 	call com_err_ (0, name_stamp (), "data compare error at record  ^9d.", rdx);
     1358 	read_buff = tseg.buffer (1);
     1359 	do k = 1 to 1040;
     1360 	     if err_buff (k) ^= bufarray (k) then do;
     1361 
     1362 		if k > 2
     1363 		then kk = k - 2;
     1364 		else kk = k;
     1365 
     1366 		call ioa_ ("^/Data Word^9d^3x^9d^3x^9d^3x^9d", kk, kk + 1, kk + 2, kk + 3);
     1367 		call ioa_ ("Data Was:^4( ^.3b^)", err_buff (kk), err_buff (kk + 1), err_buff (kk + 2),
     1368 		     err_buff (kk + 3));
     1369 		call ioa_ ("Data S/B:^4( ^.3b^)^/", bufarray (kk), bufarray (kk + 1), bufarray (kk + 2),
     1370 		     bufarray (kk + 3));
     1371 		end;
     1372 	     return;
     1373 	end;
     1374 
     1375 	return;
     1376      end ck_data;
     1377 
     1378 /* routine to wait for external signal form tape drine */
     1379 
     1380 wait_io:
     1381      proc;
     1382 
     1383 	wait_list.n = 1;
     1384 	wait_list.chan (1) = tseg.ev_chan;
     1385 	call ipc_$block (addr (wait_list), addr (message), code);
     1386 
     1387 	if code ^= 0 then do;
     1388 	     call com_err_ (code, name_stamp (), "ipc_$block failed");
     1389 	     go to done;
     1390 	     end;
     1391 
     1392 	doing = "wait io";
     1393 ck_ready:
     1394 	tseg.buffer_count = 0;
     1395 	tseg.command_count = 1;
     1396 	tseg.command_queue (1) = bin ("100000"b, 6);
     1397 	call tdcm_$tdcm_iocall (tsegp, code);
     1398 	if code ^= 0 then do;
     1399 	     call com_err_ (code, name_stamp (), "status  check iocall bad");
     1400 	     go to done;
     1401 	     end;
     1402 
     1403 	tseg.command_count = 0;			/* back to async */
     1404 	stat_ptr = addr (tseg.hardware_status);
     1405 
     1406 	if stat_maj ^= "0000"b
     1407 	then if stat_min ^= "000010"b | stat_min ^= "000110"b then go to ck_ready;
     1408 	call tdcm_$tdcm_reset_signal (tsegp, code);
     1409 	if code ^= 0 then do;
     1410 	     call com_err_ (code, name_stamp (), "reset signal bad");
     1411 	     go to done;
     1412 	     end;
     1413 
     1414 
     1415 	return;
     1416 
     1417      end wait_io;					/* end wait_io of wait_io  */
     1418 
     1419 interp_xstats:
     1420      proc;
     1421 
     1422 dcl  tks fixed bin init (0);
     1423 dcl  valid bit (1) init ("0"b);
     1424 dcl  (i, j, k) fixed bin;
     1425 dcl  (xx, num_in_list) fixed bin init (0);
     1426 dcl  curr_dens fixed bin init (0);			/* current density */
     1427 dcl  ret_chars fixed bin (21);
     1428 dcl  analysis_string char (120);
     1429 dcl  message_hold char (1016) varying;
     1430 dcl  1 analysis_list (num_in_list) aligned based (a_list_ptr),
     1431        2 mess_count fixed bin,
     1432        2 message char (1016) varying;
     1433 dcl  (ext_ptr, a_list_ptr) ptr;
     1434 dcl  rec_mode (0:1) char (1) internal static options (constant) init ("R", "W");
     1435 dcl  (tracks_v, cmts) bit (1) init ("0"b);
     1436 dcl  my_analp ptr init (null ());
     1437 dcl  code fixed bin (35);
     1438 dcl  (
     1439      ioa_$rs,
     1440      ioa_$nnl
     1441      ) entry () options (variable);
     1442 
     1443 	if da_cnt < 1 then return;
     1444 	curr_dens = dens_ (fixed (substr (density, 3, 3), 3));
     1445 	att_bffr = ext_bffr (1).ext_data;
     1446 	call analyze_detail_stat_ (name, ext_bffr (1).iom_status, ext_bffr (1).ext_data, my_analp, code);
     1447 	if code ^= 0 then return;
     1448 	if my_analp = null () then return;
     1449 	tape_analp = my_analp;
     1450 	if ^tape_analysis.fips_controller then do;
     1451 	     i = fixed (substr (att_bffr, 21, 4), 4);
     1452 	     rec_cap = rec_tbl (i);
     1453 
     1454 	     i = fixed (substr (att_bffr, 30, 2), 2);
     1455 	     dev_spd = spd_tbl (i);
     1456 	     end;
     1457 	else do;
     1458 	     if substr (att_bffr, 53, 1)
     1459 	     then rec_cap = "1600/6250";
     1460 	     else rec_cap = "800/1600/6250";
     1461 	     if substr (att_bffr, 54, 3) = "011"b then dev_spd = " 75 ips ";
     1462 	     else if substr (att_bffr, 54, 3) = "100"b then dev_spd = "125 ips ";
     1463 	     else if substr (att_bffr, 54, 3) = "101"b then dev_spd = "200 ips ";
     1464 	     else dev_spd = "??? ips ";
     1465 	     end;
     1466 
     1467 	call ioa_ (
     1468 	     "^/Device is an ^a,^2x^d track;^2xCurrent Recording Mode:^x^4dbpi^/Recording Capability:^2x^abpi;^5xDevice Speed:^2x^a.^/",
     1469 	     tape_analysis.mth_model, tape_analysis.num_tracks, curr_dens, rec_cap, dev_spd);
     1470 
     1471 
     1472 	call ioa_ ("^xCount^4xRecd #^2xR/W^2xData Bit(s) in Error^2xOther Detail Status Bit Decodes");
     1473 	call ioa_ ("========^2x======^2x===^2x====================^2x===============================");
     1474 
     1475 	call get_temp_segment_ ("test_tape", a_list_ptr, code);
     1476 	if code ^= 0 then do;
     1477 	     call com_err_ (code, name_stamp (), "Attempting to get a temporary segment!");
     1478 	     return;
     1479 	     end;
     1480 
     1481 	do i = 1 to da_cnt;
     1482 	     call analyze_detail_stat_ (name, ext_bffr (i).iom_status, ext_bffr (i).ext_data, my_analp, code);
     1483 
     1484 	     if code ^= 0 then return;
     1485 	     if my_analp = null () then return;
     1486 	     tape_analp = my_analp;
     1487 
     1488 	     if tape_analysis.num_analyzed > 0 then cmts = "1"b;
     1489 
     1490 	     call ioa_$rs ("^6d^3x^1a^4x^18a^[^37t^a^]", analysis_string, ret_chars, ext_bffr (i).xrec_no,
     1491 		rec_mode (ext_bffr (i).xdoing), tape_analysis.tracks_in_error, cmts,
     1492 		rtrim (tape_analysis.analyses (1)));
     1493 	     message_hold = substr (analysis_string, 1, ret_chars);
     1494 
     1495 	     do j = 2 to tape_analysis.num_analyzed;
     1496 		call ioa_$rs ("^47t^a", analysis_string, ret_chars, rtrim (tape_analysis.analyses (j)));
     1497 		message_hold = message_hold || substr (analysis_string, 1, ret_chars);
     1498 	     end;
     1499 
     1500 	     do k = 1 to num_in_list;
     1501 		if analysis_list (k).message = message_hold then do;
     1502 		     analysis_list (k).mess_count = analysis_list (k).mess_count + 1;
     1503 		     goto next_xstats;
     1504 		     end;
     1505 	     end;
     1506 	     num_in_list = k;
     1507 	     analysis_list (k).mess_count = 1;
     1508 	     analysis_list (k).message = message_hold;
     1509 next_xstats:
     1510 	end;
     1511 
     1512 	do k = 1 to num_in_list;
     1513 	     call ioa_$nnl ("^7d^3x^a", analysis_list (k).mess_count, analysis_list (k).message);
     1514 	end;
     1515 
     1516 	call release_temp_segment_ (name_stamp (), a_list_ptr, code);
     1517 end_xstat:
     1518 	return;
     1519      end interp_xstats;
     1520 
     1521 
     1522 
     1523 command_cleanup:
     1524      proc (term_condition);
     1525 dcl  term_condition bit (1);				/* 1 = just cleanup */
     1526 						/* 0 = display results and clean */
     1527 
     1528 	if tsegp ^= null () then do;
     1529 	     if tape_mounted then do;
     1530 		tseg.command_count = 1;
     1531 		tseg.buffer_count = 0;
     1532 		tseg.command_queue (1) = bin ("111000"b, 6);
     1533 						/* rewind */
     1534 		call tdcm_$tdcm_iocall (tsegp, code);
     1535 		if ^term_condition then call summarize;
     1536 		tape_mounted = "0"b;		/* really still is! */
     1537 		end;
     1538 	     if tdcm_attached then do;
     1539 		call tdcm_$tdcm_detach (tsegp, code);
     1540 		tdcm_attached = "0"b;
     1541 		end;
     1542 	     free tseg;
     1543 	     end;
     1544 	if ext_bffr_ptr ^= null () then call release_temp_segment_ ("test_tape", ext_bffr_ptr, code);
     1545 	recursive_ = 0;
     1546 
     1547 	return;
     1548 
     1549      end command_cleanup;
     1550 
     1551 summarize:
     1552      proc;
     1553 	if ^tape_mounted then return;			/* never got off the ground */
     1554 	call com_err_ (0, name_stamp (), "Test Complete on ^a^2xvol=^a (^4dbpi)", rtrim (name), rtrim (save_reel),
     1555 	     dens_ (fixed (substr (density, 3, 3), 3)));
     1556 	call ioa_ ("^/^/Records Written  ^9d", rec_wrt);
     1557 	call ioa_ ("Records Read     ^9d", rec_rd);
     1558 
     1559 	yy = read_error + write_error + rd_comp_err;
     1560 
     1561 	if yy = 0 then do;
     1562 	     call ioa_ ("^/No read/write errors encountered in test.^/");
     1563 	     return;
     1564 	     end;
     1565 
     1566 
     1567 	call ioa_ ("^14tRecoverable  Non-Recoverable");
     1568 	call ioa_ ("Write Errors^5x^7d^6x^11d", write_error, irrec_write);
     1569 	call ioa_ ("Read  Errors^5x^7d^6x^11d", read_error, irrec_read);
     1570 	call ioa_ ("Data Compare Errs^7d^/", rd_comp_err);
     1571 	call interp_xstats;
     1572 	call ioa_ ("^2/");
     1573 
     1574      end summarize;
     1575 
     1576 name_stamp:
     1577      proc () returns (char (17));
     1578 dcl  1 the_time unaligned int static,
     1579        2 hour pic "99",
     1580        2 minute pic "99",
     1581        2 dot char (1) init ("."),
     1582        2 tenth pic "9";
     1583 
     1584 dcl  (clock, string, divide) builtin;
     1585 dcl  ec fixed bin (35);				/* use this, not "code" */
     1586 dcl  (hour_bin, minute_bin, second) fixed bin;
     1587 dcl  micro_second fixed bin (71);
     1588 dcl  decode_clock_value_$time
     1589 	entry (fixed bin (71), fixed bin, fixed bin, fixed bin, fixed bin (71), char (3), fixed bin (35));
     1590 
     1591 	call decode_clock_value_$time (clock (), hour_bin, minute_bin, second, micro_second, "", ec);
     1592 	the_time.hour = hour_bin;
     1593 	the_time.minute = minute_bin;
     1594 	the_time.tenth = divide (second, 6, 17, 0);
     1595 	return ("test_tape: " || string (the_time));
     1596      end name_stamp;
     1597 
  1     1 /*	Begin  include file ... tdcm_info.incl.pl1
  1     2*   *
  1     3*   *	Created on 02/20/75 by Bill Silver.
  1     4*   *	Modified 5/20/77 by Noel I. Morris for DCC.
  1     5*   *	Modified 3/19/82 by J. A. Bush for Marker interrupt processing
  1     6*   *	This include file defines the IOI workspace used by tdcm_.
  1     7**/
  1     8 dcl  ws_ptr ptr;					/* Pointer to base of tdcm_ IOI workspace. */
  1     9 
  1    10 dcl 1 ws based (ws_ptr) aligned,			/* Starts at base of ioi_ workspace. */
  1    11     2 info like ws_info,				/* See ws_info structure below. */
  1    12     2 ndt_list (10),				/* List of non-data transfer IDCWs. */
  1    13       3 idcw bit (36),				/* IDCWs. */
  1    14     2 rw_list (12),					/* DCW list for reads and writes. */
  1    15       3 idcw bit (36),				/* IDCW. */
  1    16       3 dcw bit (36),				/* DCW.  */
  1    17     2 mark_tdcw bit (36),				/* TDCW to chain the DCW list when processing Markers */
  1    18     2 statq (4) like istat,				/* A queue of IOI status entries. */
  1    19     2 pad_ev ptr,					/* to force buffer to even location */
  1    20     2 buffer (0 refer (ws.info.buf_size)) bit (36) aligned,
  1    21     2 buf_end bit (36);				/* Marks end of data buffer. */
  1    22 
  1    23 dcl 1 ws_info based aligned,				/* Control information. */
  1    24     2 flags,					/* All flags in one word. */
  1    25      (3 attached bit (1),				/* ON => tape drive has been attached. */
  1    26       3 connected bit (1),				/* ON => there is a connect in progress. */
  1    27       3 get_size bit (1),				/* ON => return actual read count. */
  1    28       3 ndtrans bit (1),				/* ON => non-data transfer type connect. */
  1    29       3 reading bit (1),				/* ON => connect issued for reading. */
  1    30       3 large_rec bit (1),				/* ON => transmitting record longer than 4096 words */
  1    31       3 allow_marker bit (1),				/* ON => Set up DCW list for marker interrupt processing */
  1    32       3 good_ws bit (1)) unaligned,			/* ON => can get a workspace big enough to satisfy user. */
  1    33     2 buf_size fixed bin,				/* Current size of tdcm_ I/O buffer. */
  1    34     2 rcp_id bit (36) aligned,			/* ID used to communicate with rcp_. */
  1    35     2 ioix fixed bin,				/* Index used to communicate with ioi_. */
  1    36     2 statqx fixed bin,				/* Index of current status queue entry. */
  1    37     2 process_id bit (36) aligned,			/* User's process ID. */
  1    38     2 tracks fixed bin,				/* Temporary place to save track type. */
  1    39     2 wait_list,					/* Used to block. */
  1    40       3 num_ev_chans fixed bin,			/* Number of channels in list. */
  1    41       3 wait_echan fixed bin (71),			/* Used to wait when blocked. */
  1    42     2 fast_echan fixed bin (71),			/* Fast event channel used to wait. */
  1    43     2 special_echan fixed bin (71),			/* Event call channel for special interrupts. */
  1    44     2 user_echan fixed bin (71),			/* Event channel set up by user in tseg. */
  1    45     2 init_echan fixed bin (71),			/* Event channel to use after drive attached. */
  1    46     2 meters,					/* temporary meters */
  1    47       3 last_io_time fixed bin (71),			/* clock time of last data xfer I/O */
  1    48       3 io_delta fixed bin (71),			/* total delta times */
  1    49       3 low_delta fixed bin (71),			/* lowest time between data xfer i/os */
  1    50       3 high_delta fixed bin (71),			/* longest time between data xfer i/os */
  1    51       3 number_ios fixed bin (35),			/* number of data xfer i/os */
  1    52       3 block fixed bin (35),				/* # of times we went blocked awaiting I/O to complete */
  1    53       3 no_block fixed bin (35),			/* # of times status queue precessed w/o going blocked */
  1    54       3 mark_st fixed bin (35),			/* # of marker interrupts received */
  1    55       3 term_st fixed bin (35),			/* # of term interrupts received */
  1    56       3 term_ne fixed bin (35),			/* # of term interrupts received with no error status */
  1    57       3 most_consec_mark fixed bin (35),		/* longest burst of marker interrupts processed */
  1    58       3 consec_mark fixed bin (35),			/* counter for keeping track of consecutive markers */
  1    59       3 block_count fixed bin,			/* highest number of blocks per I/O call */
  1    60     2 subset_size fixed bin,				/* max block size of data xfer I/O */
  1    61     2 detachx fixed bin,				/* Index that tells what has been set up. */
  1    62     2 disposition bit (1),				/* RCP assignment disposition. */
  1    63     2 read_start fixed bin,				/* First tseg buffer we are reading into. */
  1    64     2 buffer_size (12) fixed bin,			/* Data size in each workspace buffer. */
  1    65     2 ndt_offsetx fixed bin,				/* Offset of non-data transfer DCW list. */
  1    66     2 rw_offsetx fixed bin,				/* Offset of read/write DCW list. */
  1    67     2 mark_offset fixed bin,				/* buffer offset of last marker interrupt */
  1    68     2 error_count fixed bin,				/* Count of errors during attachment. */
  1    69     2 read_idcws (0:5) bit (36) aligned,		/* An array of read and write IDCW's. */
  1    70     2 write_idcws (0:5) bit (36) aligned;		/* One for each possible buffer in 1 connect. */
  1    71 
  1    72 /*	End of include file ... tdcm_info.incl.pl1	*/
     1598 
     1599 
  2     1 
  2     2 /* Begin include file ...... ioi_stat.incl.pl1 */
  2     3 /* Last modified 3/24/75 by Noel I. Morris */
  2     4 
  2     5 dcl  isp ptr;					/* pointer to status structure */
  2     6 
  2     7 dcl 1 istat based (isp) aligned,			/* I/O Interfacer status structure */
  2     8     2 completion,					/* completion flags */
  2     9      (3 st bit (1),					/* "1"b if status returned */
  2    10       3 er bit (1),					/* "1"b if status indicates error condition */
  2    11       3 run bit (1),				/* "1"b if channel still running */
  2    12       3 time_out bit (1)) unal,			/* "1"b if time-out occurred */
  2    13     2 level fixed bin (3),				/* IOM interrupt level */
  2    14     2 offset fixed bin (18),				/* DCW list offset */
  2    15     2 absaddr fixed bin (24),				/* absolute address of workspace */
  2    16     2 iom_stat bit (72),				/* IOM status */
  2    17     2 lpw bit (72);					/* LPW residue */
  2    18 
  2    19 dcl  imp ptr;					/* pointer to message structure */
  2    20 
  2    21 dcl 1 imess based (imp) aligned,			/* I/O Interfacer event message structure */
  2    22    (2 completion like istat.completion,			/* completion flags */
  2    23     2 pad bit (11),
  2    24     2 level bit (3),				/* interrupt level */
  2    25     2 offset bit (18),				/* DCW list offset */
  2    26     2 status bit (36)) unal;				/* first 36 bits of status */
  2    27 
  2    28 /* End of include file ...... ioi_stat.incl.pl1 */
  2    29 
     1600 
     1601 
  3     1 /* Include segment tseg.incl.pl1 --- declaration for Tape DSM-DCM Interface Segment */
  3     2 /*   Modified 10 July 1973 by MJ Grady */
  3     3 /*   Modified 7/79 by R.J.C. Kissel to add a version number, tracks, density, and drive_name, and get rid of drive_number. */
  3     4 /*   Modified 5 August 1981 by Chris Jones to add speed specification */
  3     5 
  3     6 /* NB:  tape_ansi_cseg.incl.pl1 has a parallel version of this tseg declared in it.  Any changes made here MUST
  3     7*   be made there too. */
  3     8 
  3     9 /* format: style4,delnl,insnl,indattr,ifthen,dclind9 */
  3    10 dcl      (
  3    11          nbuffs		  init (12),		/* # of buffers in structure */
  3    12          max_rec_size	  init (2080)
  3    13          )		  fixed bin (17) int static;	/* Max # of words that may be transmitted (2 * 1040) */
  3    14 
  3    15 dcl      tsegp		  ptr;			/* Used to access Ring-0/Ring-4 shared structure */
  3    16 dcl      tseg_version_2	  fixed bin internal static options (constant) init (2);
  3    17 
  3    18 declare  1 tseg		  based (tsegp) aligned,
  3    19 	 2 version_num	  fixed bin,
  3    20 	 2 areap		  ptr,			/* pointer to DSM area */
  3    21 	 2 ev_chan	  fixed bin (71),		/* event channel number */
  3    22 	 2 write_sw	  fixed bin (1),		/* 0 = read, 1 = write */
  3    23 	 2 sync		  fixed bin (1),		/* non-zero for synchronous i/o */
  3    24 	 2 get_size	  fixed bin (1),		/* ON for record sizes to be returned */
  3    25 	 2 ws_segno	  bit (18),		/* segment number of IOI workspace */
  3    26 	 2 drive_name	  char (32),		/* physical drive name. */
  3    27 	 2 tracks		  fixed bin,		/* 0 = 9-track, 1 = 7-track. */
  3    28 	 2 density	  bit (36),		/* bits are 200, 556, 800 1600, 6250 respectively. */
  3    29 	 2 speed		  bit (36),		/* bits are 75, 125, 200 ips respectively */
  3    30 	 2 pad99 bit (36),				/* so that buffers start on an evenword boundary */
  3    31 	 2 buffer_offset	  fixed bin (12),		/* offset (from 1) of first buffer to be processed */
  3    32 	 2 buffer_count	  fixed bin (12),		/* number of buffers to be processed */
  3    33 	 2 completion_status  fixed bin (2),		/* 0 = no pending i/o or no status */
  3    34 						/* 1 = normal termination of i/o */
  3    35 						/* 2 = non-zero major status from previous i/o */
  3    36 	 2 hardware_status	  bit (36) aligned,		/* major and sub-status */
  3    37 	 2 error_buffer	  fixed bin (12),		/* buffer in which i/o error occurred */
  3    38 	 2 command_count	  fixed bin (12),		/* number of non-data commands to execute */
  3    39 	 2 command_queue	  (10) fixed bin (6) aligned, /* non-data-transfer commands */
  3    40 	 2 bufferptr	  (12) fixed bin (18) aligned,/* relative ptrs to buffers */
  3    41 	 2 buffer_size	  (12) fixed bin (18) aligned,/* size of buffer */
  3    42 	 2 mode		  (12) fixed bin (2) aligned, /* 0 = bin, 1 = bcd, 2 = 9 track */
  3    43 	 2 buffer		  (12) bit (37440) aligned,	/* data buffers - 1040 words */
  3    44 	 2 dsm_area	  area ((100 /* strictly nominal */));
  3    45 						/* DSM workspace */
  3    46 
  3    47 /* End include segment tseg.incl.pl1 */
     1602 
     1603 
  4     1 /* Begin include file ..... analyze_det_stat_info.incl.pl1 */
  4     2 
  4     3 
  4     4 /****^  HISTORY COMMENTS:
  4     5*  1) change(85-09-09,Farley), approve(85-09-09,MCR6979),
  4     6*     audit(86-03-05,Coppola), install(86-03-21,MR12.0-1033):
  4     7*     Add support of FIPS
  4     8*     disk and tape.
  4     9*                                                   END HISTORY COMMENTS */
  4    10 
  4    11 /*  Describes format of structures returned by analyze_detail_stat_ */
  4    12 /*  Prepared Jan 29, 1981 by Rich Coppola */
  4    13 /*  Modified July 1985 by Paul Farley for FIPS disk/tape.. */
  4    14 
  4    15 dcl  analyze_det_stat_info_version_1 fixed bin static init (1) options (constant);
  4    16 dcl  analyze_det_stat_info_version_2 fixed bin static init (2) options (constant);
  4    17 
  4    18 dcl  tape_analp ptr;		/* ptr to analyzed tape detail stats */
  4    19 dcl  prt_analp ptr;			/* ptr to printer analysis */
  4    20 dcl  disk_analp ptr;		/* ptr to disk analysis */
  4    21 dcl  rdr_pun_analp ptr;		/* ptr to rdr/pun analysis */
  4    22 
  4    23 
  4    24 dcl 1 tape_analysis based (tape_analp),
  4    25     2 tape_analysis_version fixed bin,   /* Version Number 2 */
  4    26     2 num_analyzed fixed bin,
  4    27     2 is_interesting_tape bit (1) unal,
  4    28     2 fips_controller bit (1) unal,
  4    29     2 pad bit (34) unal,
  4    30     2 mth_model char (8),		/* MTH Model Number */
  4    31     2 num_tracks fixed bin,
  4    32     2 tracks_in_error char (18),	/* defines the data bit in error
  4    33*				   for data alert stati */
  4    34     2 dbie_array (9) fixed bin,	/* array to denote data bit in error cnt */
  4    35     2 modes,
  4    36       3 density fixed bin,		/* 800, 1600, 6250 bpi */
  4    37       3 operation char (7) var,	/* reading/writing/rewinding */
  4    38     2 analyses (number_analyzed refer (tape_analysis.num_analyzed)) char (65) var;
  4    39 
  4    40 
  4    41 dcl 1 disk_analysis based (disk_analp),
  4    42     2 disk_analysis_version fixed bin,   /* Version Number 2 */
  4    43     2 num_analyzed fixed bin,
  4    44     2 is_interesting_disk bit (1) unal,
  4    45     2 fips_controller bit (1) unal,
  4    46     2 pad bit (34) unal,
  4    47     2 dsk_model char (7) var,
  4    48     2 CA fixed bin,
  4    49     2 PORT fixed bin,
  4    50     2 analyses (number_analyzed refer (disk_analysis.num_analyzed)) char (50) var;
  4    51 
  4    52 dcl 1 prt_analysis based (prt_analp),
  4    53     2 prt_analysis_version fixed bin,   /* Version Number 1 */
  4    54     2 num_analyzed fixed bin,
  4    55     2 is_interesting_prt bit (1),
  4    56     2 prt_model char (7) var,
  4    57     2 density char (6),		/* 6 or 8 lpi */
  4    58     2 analyses (number_analyzed refer (prt_analysis.num_analyzed)) char (40) var;
  4    59 
  4    60 dcl 1 rdr_pun_analysis based (rdr_pun_analp),
  4    61     2 rdr_pun_analysis_version fixed bin,   /* Version Number 1 */
  4    62     2 num_analyzed fixed bin,
  4    63     2 is_interesting_rdr_pun bit (1),
  4    64     2 rdr_pun_model char (6),
  4    65     2 analyses (number_analyzed refer (rdr_pun_analysis.num_analyzed)) char (40) var;
  4    66 
  4    67 
  4    68 /* End include file analyze_det_stat_info.incl.pl1 */
     1604 
     1605 
     1606      end test_tape;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    03/25/86  1055.7  test_tape.pl1                     >spec>install>1033>test_tape.pl1
1598         1    06/09/82  2051.4  tdcm_info.incl.pl1                >ldd>include>tdcm_info.incl.pl1
1600         2    08/17/79  2215.0  ioi_stat.incl.pl1                 >ldd>include>ioi_stat.incl.pl1
1602         3    06/10/82  1045.4  tseg.incl.pl1                     >ldd>include>tseg.incl.pl1
1604         4    03/21/86  1306.7  analyze_det_stat_info.incl.pl1    >spec>install>1033>analyze_det_stat_info.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_list_ptr                      000554 automatic       pointer                  dcl 1433 set ref 1475* 1501 1502 1502 1507 1508 1513
                                                                                  1513 1516*
addr                                                   builtin function         dcl 54 ref 200 568 620 759 775 791 794 794 798 805
                                                                                  933 933 961 964 964 979 988 988 1065 1352 1360
                                                                                  1367 1367 1367 1367 1385 1385 1385 1385 1404
analyses                 30            based           varying char(65)         array level 2 dcl 4-24 ref 1490 1490 1496 1496
analysis_list                          based           structure                array level 1 dcl 1430
analysis_string                 000117 automatic       char(120)                unaligned dcl 1428 set ref 1490* 1493 1496* 1497
analyze_detail_stat_            000106 constant        entry                    external dcl 177 ref 1446 1482
analyze_detail_stat_$rsnnl      000110 constant        entry                    external dcl 178 ref 1068
analyze_device_stat_$rsnnl      000112 constant        entry                    external dcl 179 ref 1109 1133
areap                     2            based           pointer                  level 2 dcl 3-18 set ref 603*
arg_string                             based           char                     unaligned dcl 54 set ref 229 229 242 242 256 256 266
                                                                                  266 279 284* 294 306 306 314 319* 332 332 340 345
                                                                                  357 357 365 371 377 388 388 396 403 410 432 432
                                                                                  446 457 457 466 466 474 479* 481* 491 491 501 502
                                                                                  515 515 531 540 548 548 553 556*
arglen                          004552 automatic       fixed bin(21,0)          dcl 54 set ref 227* 229 229 242 242 256 256 266 266
                                                                                  278* 279 284 284 294 306 306 313* 314 319 319 332
                                                                                  332 339* 340 345 357 357 364* 365 371 377 388 388
                                                                                  395* 396 403 410 432 432 446 457 457 466 466 473*
                                                                                  474 479 479 481 481 491 491 500* 501 502 515 515
                                                                                  530* 531 540 548 548 553 556 556
argptr                          004546 automatic       pointer                  dcl 54 set ref 227* 229 229 242 242 256 256 266 266
                                                                                  278* 279 284 294 306 306 313* 314 319 332 332 339*
                                                                                  340 345 357 357 364* 365 371 377 388 388 395* 396
                                                                                  403 410 432 432 446 457 457 466 466 473* 474 479
                                                                                  481 491 491 500* 501 502 515 515 530* 531 540 548
                                                                                  548 553 556
at_eot                          004334 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 823* 826* 836*
                                                                                  852* 866* 882* 888*
att_bffr                        004570 automatic       bit(208)                 initial unaligned dcl 54 set ref 54* 1445* 1451 1454
                                                                                  1458 1461 1462 1463
baseptr                                                builtin function         dcl 54 ref 764
bin                                                    builtin function         dcl 54 ref 620 722 723 724 769 770 832 862 895 920
                                                                                  1251 1252 1332 1396 1532
blank_rd                        004553 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 1017* 1029* 1117* 1117
                                                                                  1118
buf_init                        000262 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 748 761*
bufarray                        000263 automatic       bit(36)                  array unaligned dcl 54 set ref 568 752* 756* 759 775
                                                                                  791 794 794 798 961 964 964 988 988 1352 1360
                                                                                  1369* 1369* 1369* 1369*
buffer                  112            based           bit(37440)               array level 2 dcl 3-18 set ref 620 759* 798* 1352
                                                                                  1358
buffer_count             27            based           fixed bin(12,0)          level 2 dcl 3-18 set ref 726* 830* 860* 893* 918*
                                                                                  1310* 1393* 1531*
buffer_offset            26            based           fixed bin(12,0)          level 2 dcl 3-18 set ref 1309*
buffer_size              62            based           fixed bin(18,0)          array level 2 dcl 3-18 set ref 621*
bufferptr                46            based           fixed bin(18,0)          array level 2 dcl 3-18 set ref 620*
buftemp                                based           bit(37440)               unaligned dcl 54 ref 759 798 1352
chan                      2     004602 automatic       fixed bin(71,0)          array level 2 dcl 54 set ref 1384*
char                                                   builtin function         dcl 54 ref 340
clean_up_sw                     004341 automatic       bit(1)                   initial unaligned dcl 54 set ref 54*
cleanup                         000120 stack reference condition                dcl 54 ref 567
clock                                                  builtin function         dcl 1584 ref 1591 1591
cmts                            000557 automatic       bit(1)                   initial unaligned dcl 1435 set ref 1435* 1488* 1490*
code                            000134 automatic       fixed bin(35,0)          initial dcl 54 in procedure "test_tape" set ref 54*
                                                                                  185* 188 189* 194* 195* 227* 274* 275* 278* 280*
                                                                                  281* 284* 286 287* 309* 310* 313* 315* 316* 319*
                                                                                  320 321* 335* 336* 339* 341* 342* 360* 361* 364*
                                                                                  366* 367* 372* 373* 391* 392* 395* 419* 420* 473*
                                                                                  479* 480 481* 495* 497* 500* 505* 507* 522* 524*
                                                                                  530* 555* 556* 595* 596 597* 604* 605 606* 636*
                                                                                  637 638* 643* 644 645* 680* 681 681 681 682* 683
                                                                                  703 704* 728* 730 731* 740* 771* 810* 811 812 813
                                                                                  814 814 815 823 833* 835 836* 845* 846 863* 865
                                                                                  866* 875* 876 897* 899 900* 906* 921* 923 924*
                                                                                  938* 943* 998* 1002* 1003 1004 1005* 1009 1009
                                                                                  1010* 1049 1049 1067 1067 1102* 1107* 1110* 1111*
                                                                                  1124* 1139* 1161* 1163* 1167* 1171* 1172* 1177*
                                                                                  1181* 1182* 1188* 1190* 1195* 1198* 1208* 1234*
                                                                                  1239* 1254* 1256 1257* 1263* 1269* 1289* 1313*
                                                                                  1316 1317* 1335* 1337 1338* 1342* 1385* 1387 1388*
                                                                                  1397* 1398 1399* 1408* 1409 1410* 1534* 1539*
                                                                                  1544*
code                            000562 automatic       fixed bin(35,0)          dcl 1437 in procedure "interp_xstats" set ref 1446*
                                                                                  1447 1475* 1476 1477* 1482* 1484 1516*
codex                           004607 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 1011* 1161* 1167* 1171*
                                                                                  1177* 1188* 1195* 1204*
com_err_                        000024 constant        entry                    external dcl 54 ref 189 195 196 268 275 281 287 310
                                                                                  316 336 342 361 367 373 392 420 481 497 507 524
                                                                                  537 556 558 572 597 606 638 645 676 682 684 692
                                                                                  696 704 731 741 775 786 836 852 866 882 900 909
                                                                                  924 943 957 1005 1010 1061 1119 1137 1206 1247
                                                                                  1248 1257 1270 1292 1317 1338 1357 1388 1399 1410
                                                                                  1477 1554
command_count            33            based           fixed bin(12,0)          level 2 dcl 3-18 set ref 727* 768* 831* 861* 894*
                                                                                  919* 1250* 1311* 1329* 1342* 1395* 1403* 1530*
command_queue            34            based           fixed bin(6,0)           array level 2 dcl 3-18 set ref 722* 723* 724* 769*
                                                                                  770* 832* 862* 895* 920* 1251* 1252* 1332* 1396*
                                                                                  1532*
comment                         000206 automatic       char(55)                 initial unaligned dcl 54 set ref 54* 203* 377* 672
comment_sw                      000131 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 378* 672
comp_lp_ctr                     000011 internal static fixed bin(17,0)          initial dcl 54 set ref 587* 589* 589 591 592 691
                                                                                  1026
comp_sw                         004342 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 492 541* 588
                                                                                  660 676 690 1026
completion                             based           structure                level 2 in structure "istat" dcl 2-7 in procedure
                                                                                  "test_tape"
completion              150            based           structure                array level 3 in structure "ws" dcl 1-10
                                                                                  in procedure "test_tape"
completion_status        30            based           fixed bin(2,0)           level 2 dcl 3-18 ref 736 802 841 871 904 928 938 972
                                                                                  983 1098 1233 1239 1261 1284
cu_$arg_count                   000060 constant        entry                    external dcl 54 ref 185
cu_$arg_ptr                     000062 constant        entry                    external dcl 54 ref 227 278 313 339 364 395 473 500
                                                                                  530
curr_dens                       000115 automatic       fixed bin(17,0)          initial dcl 1426 set ref 1426* 1444* 1467*
cv_dec_check_                   000066 constant        entry                    external dcl 54 ref 319 479
cv_oct_check_                   000064 constant        entry                    external dcl 54 ref 284
da_cnt                          004600 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 1030* 1065 1135* 1135
                                                                                  1136 1138* 1138 1144 1145 1147 1150 1152 1443 1481
data                                   based           bit(8)                   array level 2 packed unaligned dcl 1045 set ref
                                                                                  1075* 1075* 1075* 1075* 1075* 1075* 1075* 1075*
                                                                                  1075* 1075* 1075* 1075* 1075* 1075* 1075* 1075*
                                                                                  1079* 1079* 1079* 1079* 1079* 1079* 1079* 1079*
                                                                                  1079* 1079*
decode_clock_value_$time        000122 constant        entry                    external dcl 1588 ref 1591
den16                           000102 automatic       bit(1)                   unaligned dcl 54 set ref 213* 398* 405* 413* 434*
                                                                                  572* 719 723
den6250                         000103 automatic       bit(1)                   unaligned dcl 54 set ref 212* 399* 406* 411* 435*
                                                                                  572* 719 724
den8                            000101 automatic       bit(1)                   unaligned dcl 54 set ref 211* 397* 404* 412* 433*
                                                                                  572* 719 722
dens_                           000013 constant        fixed bin(17,0)          initial array dcl 174 set ref 1444 1554*
density                  23            based           bit(36)                  level 2 in structure "tseg" dcl 3-18 in procedure
                                                                                  "test_tape" set ref 623*
density                         004567 automatic       bit(36)                  unaligned dcl 54 in procedure "test_tape" set ref
                                                                                  214* 400* 407* 414* 437* 623 1444 1554
det_valid                       004324 automatic       bit(1)                   dcl 54 set ref 1124* 1125
detailed_stat                          based           bit(208)                 unaligned dcl 1044 set ref 1068*
detected_eof                    004335 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 954* 973* 992
                                                                                  994*
dev_array                       004344 automatic       char(32)                 initial array unaligned dcl 54 set ref 54* 540* 591
dev_name                        000176 automatic       char(32)                 initial unaligned dcl 54 set ref 54* 502* 591* 660
dev_spd                         004636 automatic       varying char(8)          dcl 164 set ref 1455* 1461* 1462* 1463* 1464* 1467*
dev_sw                          004343 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 503* 516 660
                                                                                  676
dev_type                        004610 automatic       fixed bin(17,0)          initial dcl 54 set ref 54*
divide                                                 builtin function         dcl 1584 ref 1594
doing                           000171 automatic       varying char(16)         initial dcl 54 set ref 54* 721* 775 775 785* 827*
                                                                                  856* 886* 956* 1061* 1219 1226 1317* 1392*
drive_name               12            based           char(32)                 level 2 dcl 3-18 set ref 660* 662* 676* 682* 696*
                                                                                  773 775 775 786* 957*
dsm_area              30412            based           area(100)                level 2 dcl 3-18 set ref 600*
dstat_ptr                       004550 automatic       pointer                  dcl 54 set ref 1065* 1068 1075 1075 1075 1075 1075
                                                                                  1075 1075 1075 1075 1075 1075 1075 1075 1075 1075
                                                                                  1075 1079 1079 1079 1079 1079 1079 1079 1079 1079
                                                                                  1079
ec                              000100 automatic       fixed bin(35,0)          dcl 1585 set ref 1591*
ecode                                  parameter       fixed bin(35,0)          dcl 1038 in procedure "error" set ref 1036 1068*
ecode                           000135 automatic       fixed bin(35,0)          initial dcl 54 in procedure "test_tape" set ref 54*
efail                                  parameter       varying char             dcl 1038 set ref 1036 1062* 1068* 1070*
empty                                                  builtin function         dcl 54 ref 600
err_buff                               based           bit(36)                  array unaligned dcl 54 set ref 1360 1367* 1367*
                                                                                  1367* 1367*
err_sum_sw                      004545 automatic       bit(1)                   initial unaligned dcl 54 set ref 54*
error_table_$bad_density        000050 external static fixed bin(35,0)          dcl 54 ref 419
error_table_$badopt             000054 external static fixed bin(35,0)          dcl 54 set ref 537* 555
error_table_$inconsistent       000046 external static fixed bin(35,0)          dcl 54 ref 505
error_table_$multiple_io_attachment
                                000040 external static fixed bin(35,0)          dcl 54 ref 194
error_table_$noarg              000052 external static fixed bin(35,0)          dcl 54 ref 274 280 309 315 335 341 360 366 372 391
                                                                                  495 522
error_table_$resource_assigned  000042 external static fixed bin(35,0)          dcl 54 ref 681
error_table_$resource_attached  000036 external static fixed bin(35,0)          dcl 54 ref 681
error_table_$resource_unavailable
                                000044 external static fixed bin(35,0)          dcl 54 ref 683
ev_chan                   4            based           fixed bin(71,0)          level 2 dcl 3-18 set ref 604* 1384
ext                                    based           structure                level 1 packed unaligned dcl 1045
ext_bffr                               based           structure                array level 1 dcl 54
ext_bffr_ptr                    004576 automatic       pointer                  initial dcl 54 set ref 54* 595* 1065 1144 1145 1147
                                                                                  1150 1152 1445 1446 1446 1482 1482 1490 1490 1544
                                                                                  1544*
ext_data                  3            based           bit(208)                 array level 2 packed unaligned dcl 54 set ref 1065
                                                                                  1145* 1445 1446* 1482*
ext_sw                          000133 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 206* 447* 572*
                                                                                  1074 1189* 1191* 1197* 1199* 1207* 1209*
fail                            000136 automatic       varying char(100)        dcl 54 set ref 1109* 1110* 1133* 1139* 1163* 1172*
                                                                                  1182* 1190* 1198* 1208*
fips_controller           2(01)        based           bit(1)                   level 2 packed unaligned dcl 4-24 ref 1450
fixed                                                  builtin function         dcl 54 ref 1154 1444 1451 1454 1554
get_size                 10            based           fixed bin(1,0)           level 2 dcl 3-18 set ref 617*
get_temp_segment_               000032 constant        entry                    external dcl 54 ref 595 1475
gotit                           000124 automatic       fixed bin(17,0)          initial dcl 1217 set ref 1217*
hardware_status          31            based           bit(36)                  level 2 dcl 3-18 set ref 805 933 933 979 1068 1109
                                                                                  1133 1144 1404
hour                            000016 internal static picture(2)               level 2 packed unaligned dcl 1578 set ref 1592*
hour_bin                        000101 automatic       fixed bin(17,0)          dcl 1586 set ref 1591* 1592
i                               000110 automatic       fixed bin(17,0)          dcl 1424 in procedure "interp_xstats" set ref 1451*
                                                                                  1452 1454* 1455 1481* 1482 1482 1490 1490*
i                               000100 automatic       fixed bin(17,0)          dcl 1327 in procedure "backspace" set ref 1331*
                                                                                  1332*
i                               004624 automatic       fixed bin(35,0)          initial dcl 54 in procedure "test_tape" set ref 54*
                                                                                  750* 752* 755* 756* 793* 795* 829* 859* 892* 914*
                                                                                  963* 965*
index                                                  builtin function         dcl 54 ref 279 314 365 474 501 531 1219
info                                   based           structure                level 2 dcl 1-10
ioa_                            000030 constant        entry                    external dcl 54 ref 321 1062 1070 1075 1078 1079
                                                                                  1081 1366 1367 1369 1467 1472 1473 1556 1557 1562
                                                                                  1567 1568 1569 1570 1572
ioa_$nnl                        000120 constant        entry                    external dcl 1438 ref 1513
ioa_$rs                         000116 constant        entry                    external dcl 1438 ref 1490 1496
ioi_$get_detailed_status        000104 constant        entry                    external dcl 176 ref 1124
ioi_idx                         004325 automatic       fixed bin(17,0)          dcl 54 set ref 765* 1124*
ioix                      3            based           fixed bin(17,0)          level 3 dcl 1-10 ref 765
iom_status                2            based           bit(36)                  array level 2 dcl 54 set ref 1144* 1446* 1482*
ipc_$block                      000026 constant        entry                    external dcl 54 ref 1385
ipc_$create_ev_chn              000022 constant        entry                    external dcl 54 ref 604
irrec_read                      000115 automatic       fixed bin(17,0)          dcl 54 set ref 216* 1028* 1293* 1293 1569*
irrec_write                     000114 automatic       fixed bin(17,0)          dcl 54 set ref 216* 1028* 1243* 1243 1568*
is_interesting                  000111 automatic       bit(1)                   unaligned dcl 1043 set ref 1068* 1070
istat                                  based           structure                level 1 dcl 2-7
j                               000111 automatic       fixed bin(17,0)          dcl 1424 set ref 1495* 1496 1496*
k                               004625 automatic       fixed bin(17,0)          dcl 54 in procedure "test_tape" set ref 215* 218
                                                                                  226* 226 227* 272* 272 273 278* 307* 307 308 313*
                                                                                  333* 333 334 339* 358* 358 359 364* 389* 389 390
                                                                                  395* 468* 468 469 473* 476* 476 493* 493 494 500*
                                                                                  519* 519 520 530* 533* 533 1359* 1360 1360 1362
                                                                                  1362 1364*
k                               000112 automatic       fixed bin(17,0)          dcl 1424 in procedure "interp_xstats" set ref 1500*
                                                                                  1501 1502 1502* 1506 1507 1508 1512* 1513 1513*
kk                              000100 automatic       fixed bin(17,0)          dcl 1350 set ref 1362* 1364* 1366* 1366 1366 1366
                                                                                  1367 1367 1367 1367 1369 1369 1369 1369
knt                             000123 automatic       fixed bin(17,0)          initial dcl 1217 set ref 1217* 1228* 1280*
kntt                            000122 automatic       fixed bin(17,0)          initial dcl 1217 set ref 1217*
l                               004626 automatic       fixed bin(17,0)          dcl 54 set ref 518* 521 532 536 540*
length                                                 builtin function         dcl 54 ref 371
man_ptrn                        000254 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 290* 295
mask                            000170 automatic       bit(36)                  unaligned dcl 54 set ref 208* 285* 572* 756
mess_count                             based           fixed bin(17,0)          array level 2 dcl 1430 set ref 1502* 1502 1507*
                                                                                  1513*
message                         004612 automatic       structure                level 1 dcl 54 in procedure "test_tape" set ref 1385
                                                                                  1385
message                   1            based           varying char(1016)       array level 2 in structure "analysis_list" dcl 1430
                                                                                  in procedure "interp_xstats" set ref 1501 1508*
                                                                                  1513*
message_hold                    000155 automatic       varying char(1016)       dcl 1429 set ref 1493* 1497* 1497 1501 1508
micro_second                    000104 automatic       fixed bin(71,0)          dcl 1587 set ref 1591*
minute                    0(18) 000016 internal static picture(2)               level 2 packed unaligned dcl 1578 set ref 1593*
minute_bin                      000102 automatic       fixed bin(17,0)          dcl 1586 set ref 1591* 1593
mode                     76            based           fixed bin(2,0)           array level 2 dcl 3-18 set ref 622*
more_sw                         000106 automatic       bit(1)                   unaligned dcl 1038 set ref 1056* 1058* 1061
mth_model                 3            based           char(8)                  level 2 packed unaligned dcl 4-24 set ref 1467*
my_analp                        000560 automatic       pointer                  initial dcl 1436 set ref 1436* 1446* 1448 1449 1482*
                                                                                  1485 1486
n                                      parameter       fixed bin(17,0)          dcl 1327 in procedure "backspace" ref 1324 1329 1331
n                               004602 automatic       fixed bin(17,0)          level 2 in structure "wait_list" dcl 54 in procedure
                                                                                  "test_tape" set ref 1383*
name                            000244 automatic       char(32)                 initial unaligned dcl 54 set ref 54* 773* 1068*
                                                                                  1446* 1482* 1554 1554
nargs                           004544 automatic       fixed bin(17,0)          dcl 54 set ref 185* 218 273 308 334 359 390 469 494
                                                                                  520
ndc_sw                          004606 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 458* 572* 974
ntimes                          004323 automatic       fixed bin(25,0)          dcl 54 set ref 209* 319* 572 572* 793 963
null                                                   builtin function         dcl 54 ref 54 564 603 1436 1448 1485 1528 1544
num_analyzed              1            based           fixed bin(17,0)          level 2 dcl 4-24 ref 1488 1495
num_drives                      000010 internal static fixed bin(17,0)          initial dcl 54 set ref 517* 542* 542 1026
num_in_list                     000114 automatic       fixed bin(17,0)          initial dcl 1425 set ref 1425* 1500 1506* 1512
num_ret                         000261 automatic       float bin(27)            dcl 54 set ref 751* 752
num_tracks                5            based           fixed bin(17,0)          level 2 dcl 4-24 set ref 1467*
program_interrupt               000104 stack reference condition                dcl 54 ref 775
rand_ptrn                       000255 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 267 296* 572*
                                                                                  749
random_$uniform                 000056 constant        entry                    external dcl 54 ref 751
rd_comp_err                     000116 automatic       fixed bin(17,0)          dcl 54 set ref 216* 1027* 1356* 1356 1559 1570*
rdx                             004630 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 965* 989* 989 1052 1150
                                                                                  1292* 1357*
read_buff                       002303 automatic       bit(37440)               unaligned dcl 54 set ref 1358* 1360 1367 1367 1367
                                                                                  1367
read_error                      000113 automatic       fixed bin(17,0)          dcl 54 set ref 216* 1027* 1131* 1131 1559 1569*
read_sw                         004336 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 202* 230* 243*
                                                                                  572* 950 1052
rec_cap                         004631 automatic       varying char(16)         dcl 164 set ref 1452* 1458* 1460* 1467*
rec_mode                        000012 constant        char(1)                  initial array unaligned dcl 1434 set ref 1490*
rec_rd                          000257 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 960* 966* 966 990* 990
                                                                                  1029* 1557*
rec_tbl                         000027 constant        varying char(16)         initial array dcl 168 ref 1452
rec_wrt                         000256 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 791* 796* 796 1029* 1556*
recn                            000107 automatic       fixed bin(17,0)          dcl 1038 set ref 1052* 1054* 1061*
recursive_                      000014 internal static fixed bin(17,0)          dcl 54 set ref 193 772* 1545*
reel_comment                    000224 automatic       char(64)                 unaligned dcl 54 set ref 204* 664* 668* 672* 672
                                                                                  674* 674 680*
reelid                          004556 automatic       char(9)                  initial unaligned dcl 54 set ref 54* 345* 346
rek                                    based           fixed bin(35,0)          dcl 54 set ref 568* 775* 791* 794* 794 961* 964* 964
                                                                                  988* 988
rel                                                    builtin function         dcl 54 ref 620
release_temp_segment_           000034 constant        entry                    external dcl 54 ref 1516 1544
ret_chars                       000116 automatic       fixed bin(21,0)          dcl 1427 set ref 1490* 1493 1496* 1497
retry_in_progress               000127 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 1049 1164 1173
                                                                                  1183 1224* 1235* 1262* 1274* 1294* 1296*
rew_sw                          004340 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 890* 914 929*
                                                                                  997* 1056 1222
rsr_data                        004326 automatic       bit(216)                 unaligned dcl 54 set ref 1124* 1125* 1145
rtrim                                                  builtin function         dcl 54 ref 664 672 672 674 775 775 775 775 1490 1490
                                                                                  1496 1496 1554 1554 1554 1554
save_reel                       004561 automatic       char(9)                  initial unaligned dcl 54 set ref 54* 346* 664 669*
                                                                                  676* 786* 957* 1554 1554
second                          000103 automatic       fixed bin(17,0)          dcl 1586 set ref 1591* 1594
seed                            000260 automatic       fixed bin(35,0)          initial dcl 54 set ref 54* 751*
set_den_sw                      000130 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 720* 746* 1056
spd_tbl                         000017 constant        char(8)                  initial array unaligned dcl 172 ref 1455
stat_chk                               based           structure                level 1 dcl 54
stat_maj                  0(02)        based           bit(4)                   level 2 packed unaligned dcl 54 set ref 807 933 981
                                                                                  985 1062* 1105 1116 1154 1154 1154 1154 1154 1406
stat_min                  0(06)        based           bit(6)                   level 2 packed unaligned dcl 54 set ref 933 986 986
                                                                                  1062* 1105 1108 1116 1167 1180 1187 1406 1406
stat_pad                        000112 automatic       bit(36)                  initial dcl 1093 set ref 1093* 1109 1133
stat_ptr                        004622 automatic       pointer                  dcl 54 set ref 805* 807 979* 981 985 986 986 1062
                                                                                  1062 1105 1105 1108 1116 1116 1154 1154 1154 1154
                                                                                  1154 1167 1180 1187 1404* 1406 1406 1406
stat_tablep                     004642 automatic       pointer                  dcl 180 set ref 200* 1109* 1133*
string                                                 builtin function         dcl 54 in procedure "test_tape" set ref 203* 204*
string                                                 builtin function         dcl 1584 in procedure "name_stamp" ref 1595
substr                                                 builtin function         dcl 54 ref 1105 1145 1180 1187 1444 1451 1454 1458
                                                                                  1461 1462 1463 1493 1497 1554
sync                      7            based           fixed bin(1,0)           level 2 dcl 3-18 set ref 615* 725* 736*
sys_sw                          000132 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 205* 549* 572*
                                                                                  674
t_maj                           000110 automatic       bit(6)                   initial unaligned dcl 1042 set ref 1042*
tape_analp                      004650 automatic       pointer                  dcl 4-18 set ref 1449* 1450 1467 1467 1486* 1488
                                                                                  1490 1490 1490 1495 1496 1496
tape_analysis                          based           structure                level 1 unaligned dcl 4-24
tape_mounted                    000013 internal static bit(1)                   initial unaligned dcl 54 set ref 658* 717* 1529
                                                                                  1536* 1553
tape_status_table_$tape_status_table_
                                000114 external static fixed bin(17,0)          dcl 181 set ref 200
tdcm_$tdcm_attach               000070 constant        entry                    external dcl 54 ref 636
tdcm_$tdcm_detach               000102 constant        entry                    external dcl 54 ref 1539
tdcm_$tdcm_iocall               000100 constant        entry                    external dcl 54 ref 728 771 833 863 897 921 1254
                                                                                  1313 1335 1397 1534
tdcm_$tdcm_message              000076 constant        entry                    external dcl 54 ref 680
tdcm_$tdcm_reset_signal         000074 constant        entry                    external dcl 54 ref 1408
tdcm_$tdcm_set_signal           000072 constant        entry                    external dcl 54 ref 643
tdcm_attached                   000012 internal static bit(1)                   initial unaligned dcl 54 set ref 566* 641* 1538
                                                                                  1540*
temp                            004555 automatic       fixed bin(35,0)          dcl 54 set ref 284* 285
tenth                     1(09) 000016 internal static picture(1)               level 2 packed unaligned dcl 1578 set ref 1594*
term_condition                         parameter       bit(1)                   unaligned dcl 1525 ref 1523 1535
the_time                        000016 internal static structure                level 1 packed unaligned dcl 1578 set ref 1595
timer_manager_$sleep            000020 constant        entry                    external dcl 54 ref 685 917
tks                             000106 automatic       fixed bin(17,0)          initial dcl 1422 set ref 1422*
track7                          000126 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 436* 572* 610
tracks                   22            based           fixed bin(17,0)          level 2 dcl 3-18 set ref 610* 614*
tracks_in_error           6            based           char(18)                 level 2 packed unaligned dcl 4-24 set ref 1490*
tracks_v                        000556 automatic       bit(1)                   initial unaligned dcl 1435 set ref 1435*
tseg                                   based           structure                level 1 dcl 3-18 set ref 600 1542
tseg_version_2                         constant        fixed bin(17,0)          initial dcl 3-16 ref 602
tsegp                           004646 automatic       pointer                  dcl 3-15 set ref 564* 600* 602 603 604 610 614 615
                                                                                  617 620 620 621 622 623 632 634 636* 643* 660 662
                                                                                  676 680* 680 682 696 722 723 724 725 726 727 728*
                                                                                  736 736 759 764 768 769 770 771* 773 775 775 786
                                                                                  798 802 805 830 831 832 833* 841 860 861 862 863*
                                                                                  871 893 894 895 897* 904 918 919 920 921* 928 933
                                                                                  933 938 957 958 972 979 983 1068 1098 1109 1127
                                                                                  1133 1144 1147 1152 1233 1239 1250 1251 1252 1254*
                                                                                  1261 1284 1309 1310 1311 1313* 1329 1332 1335*
                                                                                  1342 1352 1358 1384 1393 1395 1396 1397* 1403 1404
                                                                                  1408* 1528 1530 1531 1532 1534* 1539* 1542
unspec                                                 builtin function         dcl 54 ref 285 752
valid                           000107 automatic       bit(1)                   initial unaligned dcl 1423 set ref 1423*
version_num                            based           fixed bin(17,0)          level 2 dcl 3-18 set ref 602*
vid                             000100 automatic       bit(1)                   unaligned dcl 54 set ref 210* 347* 664 786* 957*
wait                            004565 automatic       fixed bin(35,0)          initial dcl 54 set ref 54* 683 686* 686 689* 708*
wait_cnt                        004566 automatic       fixed bin(35,0)          initial dcl 54 set ref 54* 470* 475* 479* 572* 683
wait_flag                       004564 automatic       bit(1)                   initial unaligned dcl 54 set ref 54* 467* 572* 683
wait_list                       004602 automatic       structure                level 1 dcl 54 set ref 1385 1385
who_sw                                 parameter       bit(1)                   unaligned dcl 1093 ref 1090
write_error                     000112 automatic       fixed bin(17,0)          dcl 54 set ref 216* 1027* 1127* 1127 1559 1568*
write_sw                  6            based           fixed bin(1,0)           level 2 in structure "tseg" dcl 3-18 in procedure
                                                                                  "test_tape" set ref 632* 634* 680* 958* 1127 1147
                                                                                  1152
write_sw                        004337 automatic       bit(1)                   initial unaligned dcl 54 in procedure "test_tape"
                                                                                  set ref 54* 207* 231* 244* 572* 592* 632 784 889*
                                                                                  955* 1054
wrx                             004627 automatic       fixed bin(17,0)          initial dcl 54 set ref 54* 795* 1054 1147 1247*
ws                                     based           structure                level 1 dcl 1-10
ws_info                                based           structure                level 1 dcl 1-23
ws_ptr                          004644 automatic       pointer                  dcl 1-8 set ref 764* 765
ws_segno                 11            based           bit(18)                  level 2 dcl 3-18 ref 764
xcode                                  parameter       fixed bin(35,0)          dcl 1093 ref 1090
xdoing                    1            based           fixed bin(17,0)          array level 2 dcl 54 set ref 1152* 1490
xrec_no                                based           fixed bin(17,0)          array level 2 dcl 54 set ref 1147* 1150* 1490*
xx                              000113 automatic       fixed bin(17,0)          initial dcl 1425 set ref 1425*
yy                              004554 automatic       fixed bin(17,0)          dcl 54 set ref 1559* 1561

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
analyze_det_stat_info_version_1        internal static fixed bin(17,0)          initial dcl 4-15
analyze_det_stat_info_version_2        internal static fixed bin(17,0)          initial dcl 4-16
disk_analp                             automatic       pointer                  dcl 4-20
disk_analysis                          based           structure                level 1 unaligned dcl 4-41
ext_ptr                                automatic       pointer                  dcl 1433
imess                                  based           structure                level 1 dcl 2-21
imp                                    automatic       pointer                  dcl 2-19
isp                                    automatic       pointer                  dcl 2-5
max_rec_size                           internal static fixed bin(17,0)          initial dcl 3-10
nbuffs                                 internal static fixed bin(17,0)          initial dcl 3-10
prt_analp                              automatic       pointer                  dcl 4-19
prt_analysis                           based           structure                level 1 unaligned dcl 4-52
rdr_pun_analp                          automatic       pointer                  dcl 4-21
rdr_pun_analysis                       based           structure                level 1 unaligned dcl 4-60

NAMES DECLARED BY EXPLICIT CONTEXT.
arg_loop                        002306 constant        label                    dcl 218
attach                          005242 constant        label                    dcl 658
backspace                       012455 constant        entry                    internal dcl 1324 ref 847 877 1229 1281
bad_arg                         004464 constant        label                    dcl 558 ref 270 276 282 288 311 317 322 337 343 362
                                                                                  368 374 393 421 482 498 508 526 538
check_stat                      011375 constant        label                    dcl 1154
ck_data                         012570 constant        entry                    internal dcl 1348 ref 974 1285
ck_io                           011005 constant        entry                    internal dcl 1090 ref 740 810 845 875 906 938 998
                                                                                  1002 1239 1269 1289
ck_ready                        013124 constant        label                    dcl 1393 ref 1406
command_cleanup                 014335 constant        entry                    internal dcl 1523 ref 567 693 699 1024
comp_error                      004235 constant        label                    dcl 522 ref 532
comp_loop                       004676 constant        label                    dcl 589 ref 1031
done                            010176 constant        label                    dcl 1021 ref 607 639 646 697 705 732 742 811 814 837
                                                                                  853 867 883 901 910 925 944 950 992 999 1003 1006
                                                                                  1012 1120 1140 1192 1200 1210 1258 1271 1318 1339
                                                                                  1389 1400 1411
done_args                       004516 constant        label                    dcl 564 ref 471 528
done_write                      006671 constant        label                    dcl 818
dv_error                        004063 constant        label                    dcl 495 ref 501
end_read                        010170 constant        label                    dcl 1017 ref 974 995 1015
end_wait                        007603 constant        label                    dcl 940 ref 933
end_xstat                       014333 constant        label                    dcl 1517
eot_m                           006676 constant        label                    dcl 823 ref 813 815
err_stat                        000000 constant        label                    array(2:11) dcl 1161 ref 1154 1158
error                           010233 constant        entry                    internal dcl 1036 ref 1110 1139 1163 1172 1182 1190
                                                                                  1198 1208
get_args                        002122 constant        label                    dcl 185
interp_xstats                   013273 constant        entry                    internal dcl 1419 ref 1571
issue_rw                        012357 constant        entry                    internal dcl 1306 ref 800 969 1231 1282
name_stamp                      015025 constant        entry                    internal dcl 1576 ref 572 572 595 595 597 597 606
                                                                                  606 638 638 645 645 676 676 682 682 684 684 692
                                                                                  692 696 696 704 704 731 731 741 741 775 775 786
                                                                                  786 836 836 852 852 866 866 882 882 900 900 909
                                                                                  909 924 924 943 943 957 957 1005 1005 1010 1010
                                                                                  1061 1061 1119 1119 1137 1137 1206 1206 1247 1247
                                                                                  1257 1257 1270 1270 1292 1292 1317 1317 1338 1338
                                                                                  1357 1357 1388 1388 1399 1399 1410 1410 1477 1477
                                                                                  1516 1516 1554 1554
next_arg                        004516 constant        label                    dcl 561 ref 232 245 257 291 297 324 348 379 423 438
                                                                                  448 459 477 484 504 534 550 553
next_xstats                     014236 constant        label                    dcl 1509 ref 1503
no_good                         004154 constant        label                    dcl 505 set ref 492 516
ptrn_err                        002407 constant        label                    dcl 268 ref 295
read_part                       007643 constant        label                    dcl 950 ref 784 930
reissue_rd                      007750 constant        label                    dcl 969 ref 981
reissue_wr                      006616 constant        label                    dcl 798 set ref 807 812
request_mount                   005415 constant        label                    dcl 676 ref 687
retry_                          011675 constant        entry                    internal dcl 1215 ref 1164 1173 1183
rew                             007267 constant        label                    dcl 886 ref 871 876
summarize                       014462 constant        entry                    internal dcl 1551 ref 1021 1535
sync                            005075 constant        label                    dcl 615
test_tape                       002002 constant        entry                    external dcl 50
wait_io                         013034 constant        entry                    internal dcl 1380 ref 709
wait_rew                        007443 constant        label                    dcl 914 ref 904
write_ok                        006671 constant        label                    dcl 818 ref 802
write_second_eof                007077 constant        label                    dcl 856 ref 841 846

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0     15640       15764   15137       15650
Length     16432   15137       124         431     501          10

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
test_tape                          2726 external procedure  is an external procedure.  
on unit on line 567                  72 on unit               
on unit on line 775                 122 on unit               
error                                   internal procedure  shares stack frame of internal procedure ck_io.  
ck_io                               320 internal procedure  calls itself recursively.  
retry_                                  internal procedure  shares stack frame of internal procedure ck_io.  
issue_rw                             94 internal procedure  is called by several nonquick procedures.  
backspace                            92 internal procedure  is called by several nonquick procedures.  
ck_data                             128 internal procedure  is called by several nonquick procedures.  
wait_io                                 internal procedure  shares stack frame of external procedure test_tape.  
interp_xstats                           internal procedure  shares stack frame of internal procedure summarize.  
command_cleanup                      84 internal procedure  is called by several nonquick procedures.  
summarize                           554 internal procedure  is called by several nonquick procedures.  
name_stamp                           90 internal procedure  is called by several nonquick procedures.  

STORAGE FOR INTERNAL STATIC VARIABLES.

   LOC IDENTIFIER                  BLOCK NAME
000010 num_drives                  test_tape
000011 comp_lp_ctr                 test_tape
000012 tdcm_attached               test_tape
000013 tape_mounted                test_tape
000014 recursive_                  test_tape
000016 the_time                    name_stamp

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
backspace                000100 i                           backspace
ck_data                  000100 kk                          ck_data
ck_io                    000106 more_sw                     error
                         000107 recn                        error
                         000110 t_maj                       error
                         000111 is_interesting              error
                         000112 stat_pad                    ck_io
                         000122 kntt                        retry_
                         000123 knt                         retry_
                         000124 gotit                       retry_
name_stamp               000100 ec                          name_stamp
                         000101 hour_bin                    name_stamp
                         000102 minute_bin                  name_stamp
                         000103 second                      name_stamp
                         000104 micro_second                name_stamp
summarize                000106 tks                         interp_xstats
                         000107 valid                       interp_xstats
                         000110 i                           interp_xstats
                         000111 j                           interp_xstats
                         000112 k                           interp_xstats
                         000113 xx                          interp_xstats
                         000114 num_in_list                 interp_xstats
                         000115 curr_dens                   interp_xstats
                         000116 ret_chars                   interp_xstats
                         000117 analysis_string             interp_xstats
                         000155 message_hold                interp_xstats
                         000554 a_list_ptr                  interp_xstats
                         000556 tracks_v                    interp_xstats
                         000557 cmts                        interp_xstats
                         000560 my_analp                    interp_xstats
                         000562 code                        interp_xstats
test_tape                000100 vid                         test_tape
                         000101 den8                        test_tape
                         000102 den16                       test_tape
                         000103 den6250                     test_tape
                         000112 write_error                 test_tape
                         000113 read_error                  test_tape
                         000114 irrec_write                 test_tape
                         000115 irrec_read                  test_tape
                         000116 rd_comp_err                 test_tape
                         000126 track7                      test_tape
                         000127 retry_in_progress           test_tape
                         000130 set_den_sw                  test_tape
                         000131 comment_sw                  test_tape
                         000132 sys_sw                      test_tape
                         000133 ext_sw                      test_tape
                         000134 code                        test_tape
                         000135 ecode                       test_tape
                         000136 fail                        test_tape
                         000170 mask                        test_tape
                         000171 doing                       test_tape
                         000176 dev_name                    test_tape
                         000206 comment                     test_tape
                         000224 reel_comment                test_tape
                         000244 name                        test_tape
                         000254 man_ptrn                    test_tape
                         000255 rand_ptrn                   test_tape
                         000256 rec_wrt                     test_tape
                         000257 rec_rd                      test_tape
                         000260 seed                        test_tape
                         000261 num_ret                     test_tape
                         000262 buf_init                    test_tape
                         000263 bufarray                    test_tape
                         002303 read_buff                   test_tape
                         004323 ntimes                      test_tape
                         004324 det_valid                   test_tape
                         004325 ioi_idx                     test_tape
                         004326 rsr_data                    test_tape
                         004334 at_eot                      test_tape
                         004335 detected_eof                test_tape
                         004336 read_sw                     test_tape
                         004337 write_sw                    test_tape
                         004340 rew_sw                      test_tape
                         004341 clean_up_sw                 test_tape
                         004342 comp_sw                     test_tape
                         004343 dev_sw                      test_tape
                         004344 dev_array                   test_tape
                         004544 nargs                       test_tape
                         004545 err_sum_sw                  test_tape
                         004546 argptr                      test_tape
                         004550 dstat_ptr                   test_tape
                         004552 arglen                      test_tape
                         004553 blank_rd                    test_tape
                         004554 yy                          test_tape
                         004555 temp                        test_tape
                         004556 reelid                      test_tape
                         004561 save_reel                   test_tape
                         004564 wait_flag                   test_tape
                         004565 wait                        test_tape
                         004566 wait_cnt                    test_tape
                         004567 density                     test_tape
                         004570 att_bffr                    test_tape
                         004576 ext_bffr_ptr                test_tape
                         004600 da_cnt                      test_tape
                         004602 wait_list                   test_tape
                         004606 ndc_sw                      test_tape
                         004607 codex                       test_tape
                         004610 dev_type                    test_tape
                         004612 message                     test_tape
                         004622 stat_ptr                    test_tape
                         004624 i                           test_tape
                         004625 k                           test_tape
                         004626 l                           test_tape
                         004627 wrx                         test_tape
                         004630 rdx                         test_tape
                         004631 rec_cap                     test_tape
                         004636 dev_spd                     test_tape
                         004642 stat_tablep                 test_tape
                         004644 ws_ptr                      test_tape
                         004646 tsegp                       test_tape
                         004650 tape_analp                  test_tape

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
r_e_as              r_ge_a              alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out
call_int_this       call_int_other      return              tra_ext             enable              shorten_stack
ext_entry           int_entry           set_cs_eis          index_cs_eis        alloc_based_storage free_based
empty               clock

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
analyze_detail_stat_          analyze_detail_stat_$rsnnl    analyze_device_stat_$rsnnl    com_err_
cu_$arg_count                 cu_$arg_ptr                   cv_dec_check_                 cv_oct_check_
decode_clock_value_$time      get_temp_segment_             ioa_                          ioa_$nnl
ioa_$rs                       ioi_$get_detailed_status      ipc_$block                    ipc_$create_ev_chn
random_$uniform               release_temp_segment_         tdcm_$tdcm_attach             tdcm_$tdcm_detach
tdcm_$tdcm_iocall             tdcm_$tdcm_message            tdcm_$tdcm_reset_signal       tdcm_$tdcm_set_signal
timer_manager_$sleep

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$bad_density      error_table_$badopt           error_table_$inconsistent
error_table_$multiple_io_attachment                         error_table_$noarg
error_table_$resource_assigned                              error_table_$resource_attached
error_table_$resource_unavailable                           tape_status_table_$tape_status_table_




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     50 002001        54 002007       185 002122       188 002133       189 002135       190 002156       193 002157
    194 002163       195 002165       196 002214       197 002245       200 002246       202 002250       203 002252
    204 002255       205 002260       206 002262       207 002263       208 002265       209 002267       210 002271
    211 002272       212 002273       213 002274       214 002276       215 002300       216 002301       218 002306
    226 002311       227 002312       229 002327       230 002341       231 002343       232 002345       242 002346
    243 002356       244 002360       245 002362       256 002363       257 002373       266 002374       267 002404
    268 002407       270 002440       272 002441       273 002442       274 002445       275 002450       276 002502
    278 002503       279 002520       280 002533       281 002536       282 002570       284 002571       285 002614
    286 002616       287 002620       288 002650       290 002651       291 002653       294 002654       295 002660
    296 002662       297 002664       306 002665       307 002675       308 002676       309 002701       310 002704
    311 002736       313 002737       314 002754       315 002767       316 002772       317 003024       319 003025
    320 003052       321 003054       322 003074       324 003075       332 003076       333 003106       334 003107
    335 003112       336 003115       337 003147       339 003150       340 003165       341 003176       342 003201
    343 003233       345 003234       346 003240       347 003243       348 003245       357 003246       358 003256
    359 003257       360 003262       361 003265       362 003317       364 003320       365 003335       366 003350
    367 003353       368 003405       371 003406       372 003411       373 003414       374 003443       377 003444
    378 003447       379 003451       388 003452       389 003462       390 003463       391 003466       392 003471
    393 003523       395 003524       396 003541       397 003547       398 003551       399 003553       400 003554
    401 003556       403 003557       404 003563       405 003565       406 003567       407 003571       408 003573
    410 003574       411 003600       412 003602       413 003604       414 003605       415 003607       419 003610
    420 003613       421 003642       423 003643       432 003644       433 003654       434 003656       435 003660
    436 003661       437 003663       438 003665       446 003666       447 003672       448 003674       457 003675
    458 003705       459 003707       466 003710       467 003720       468 003722       469 003723       470 003726
    471 003730       473 003731       474 003746       475 003761       476 003763       477 003765       479 003766
    480 004011       481 004013       482 004043       484 004044       491 004045       492 004055       493 004057
    494 004060       495 004063       497 004066       498 004115       500 004116       501 004133       502 004146
    503 004151       504 004153       505 004154       507 004157       508 004206       515 004207       516 004217
    517 004221       518 004223       519 004226       520 004227       521 004232       522 004235       524 004240
    526 004267       528 004270       530 004271       531 004306       532 004321       533 004324       534 004326
    536 004327       537 004332       538 004365       540 004366       541 004374       542 004376       543 004400
    548 004402       549 004414       550 004416       553 004417       555 004423       556 004426       558 004464
    560 004515       564 004516       566 004520       567 004522       568 004550       572 004551       587 004672
    588 004674       589 004676       591 004700       592 004706       595 004713       596 004742       597 004744
    598 004776       600 004777       602 005006       603 005010       604 005013       605 005024       606 005026
    607 005063       610 005064       614 005073       615 005075       617 005077       620 005100       621 005104
    622 005106       623 005107       632 005111       634 005117       636 005120       637 005132       638 005134
    639 005171       641 005172       643 005175       644 005205       645 005207       646 005241       658 005242
    660 005244       662 005255       664 005261       668 005301       669 005304       672 005307       674 005363
    676 005415       680 005471       681 005517       682 005526       683 005570       684 005602       685 005635
    686 005652       687 005656       689 005657       690 005660       691 005662       692 005666       693 005724
    694 005734       696 005735       697 005775       699 005776       700 006006       703 006007       704 006011
    705 006046       708 006047       709 006050       717 006051       719 006054       720 006065       721 006067
    722 006074       723 006102       724 006110       725 006116       726 006121       727 006122       728 006124
    730 006134       731 006136       732 006170       736 006171       740 006200       741 006212       742 006245
    746 006246       748 006247       749 006251       750 006254       751 006261       752 006272       753 006275
    754 006302       755 006303       756 006311       757 006313       759 006320       761 006325       764 006327
    765 006334       768 006336       769 006340       770 006342       771 006344       772 006355       773 006360
    775 006364       784 006516       785 006521       786 006525       791 006575       793 006577       794 006607
    795 006613       796 006615       798 006616       800 006623       802 006627       805 006633       807 006635
    810 006642       811 006654       812 006657       813 006661       814 006663       815 006667       818 006671
    823 006676       826 006704       827 006706       829 006713       830 006721       831 006723       832 006725
    833 006727       835 006740       836 006742       837 007000       841 007001       845 007005       846 007017
    847 007022       850 007032       852 007037       853 007076       856 007077       859 007104       860 007111
    861 007113       862 007115       863 007117       865 007130       866 007132       867 007170       871 007171
    875 007175       876 007207       877 007212       880 007222       882 007227       883 007266       886 007267
    888 007273       889 007275       890 007276       892 007300       893 007305       894 007307       895 007311
    897 007313       899 007324       900 007326       901 007363       904 007364       906 007370       907 007402
    909 007407       910 007442       914 007443       917 007454       918 007471       919 007473       920 007475
    921 007476       923 007507       924 007511       925 007543       928 007544       929 007550       930 007551
    933 007552       938 007566       940 007603       943 007610       944 007642       950 007643       954 007646
    955 007647       956 007651       957 007655       958 007725       960 007727       961 007730       963 007731
    964 007741       965 007745       966 007747       969 007750       972 007754       973 007760       974 007761
    979 007770       981 007773       983 010000       985 010004       986 010006       988 010016       989 010024
    990 010026       992 010030       994 010032       995 010034       997 010035       998 010037       999 010050
   1002 010051      1003 010063      1004 010066      1005 010070      1006 010125      1009 010126      1010 010132
   1011 010164      1012 010166      1015 010167      1017 010170      1019 010171      1021 010176      1024 010202
   1026 010212      1027 010220      1028 010223      1029 010225      1030 010230      1031 010231      1034 010232
   1036 010233      1042 010244      1049 010245      1052 010256      1054 010263      1056 010270      1058 010277
   1061 010300      1062 010354      1065 010413      1067 010421      1068 010426      1070 010470      1074 010520
   1075 010524      1078 010652      1079 010666      1081 010767      1084 011003      1090 011004      1093 011012
   1098 011013      1102 011020      1105 011021      1107 011035      1108 011037      1109 011044      1110 011075
   1111 011112      1113 011115      1116 011116      1117 011125      1118 011126      1119 011131      1120 011165
   1124 011170      1125 011214      1127 011223      1131 011231      1133 011232      1135 011264      1136 011266
   1137 011271      1138 011325      1139 011330      1140 011344      1144 011347      1145 011354      1147 011360
   1150 011370      1152 011373      1154 011375      1158 011413      1161 011414      1163 011420      1164 011434
   1165 011440      1167 011441      1171 011453      1172 011457      1173 011473      1174 011477      1177 011500
   1180 011504      1181 011512      1182 011514      1183 011530      1184 011534      1187 011535      1189 011536
   1190 011540      1191 011554      1192 011557      1195 011562      1197 011566      1198 011570      1199 011604
   1200 011607      1204 011612      1206 011614      1207 011650      1208 011653      1209 011667      1210 011672
   1215 011675      1217 011676      1219 011701      1222 011712      1224 011715      1226 011717      1228 011724
   1229 011731      1231 011742      1233 011747      1234 011754      1235 011755      1236 011756      1239 011757
   1241 011774      1243 011776      1247 012000      1248 012041      1250 012066      1251 012072      1252 012074
   1254 012076      1256 012107      1257 012112      1258 012146      1261 012151      1262 012155      1263 012156
   1264 012160      1269 012161      1270 012174      1271 012230      1280 012233      1281 012241      1282 012252
   1284 012257      1285 012264      1286 012271      1289 012272      1290 012305      1292 012307      1293 012350
   1294 012352      1296 012353      1298 012355      1306 012356      1309 012364      1310 012367      1311 012371
   1313 012372      1316 012402      1317 012405      1318 012450      1321 012453      1324 012454      1329 012462
   1331 012467      1332 012475      1333 012502      1335 012504      1337 012516      1338 012521      1339 012560
   1342 012563      1344 012566      1348 012567      1352 012575      1356 012604      1357 012605      1358 012646
   1359 012654      1360 012662      1362 012670      1364 012675      1366 012676      1367 012740      1369 012773
   1372 013032      1375 013033      1380 013034      1383 013035      1384 013037      1385 013042      1387 013061
   1388 013063      1389 013117      1392 013120      1393 013124      1395 013126      1396 013130      1397 013132
   1398 013143      1399 013145      1400 013202      1403 013203      1404 013205      1406 013207      1408 013221
   1409 013232      1410 013234      1411 013271      1415 013272      1419 013273      1422 013274      1423 013275
   1425 013276      1426 013300      1435 013301      1436 013303      1443 013305      1444 013312      1445 013317
   1446 013323      1447 013360      1448 013363      1449 013370      1450 013373      1451 013377      1452 013403
   1454 013413      1455 013417      1456 013426      1458 013427      1460 013440      1461 013445      1462 013461
   1463 013471      1464 013501      1467 013506      1472 013545      1473 013561      1475 013575      1476 013622
   1477 013624      1478 013657      1481 013660      1482 013671      1484 013733      1485 013736      1486 013743
   1488 013746      1490 013753      1493 014052      1495 014063      1496 014075      1497 014157      1498 014172
   1500 014174      1501 014203      1502 014215      1503 014217      1505 014220      1506 014222      1507 014223
   1508 014230      1509 014236      1512 014240      1513 014247      1514 014301      1516 014303      1517 014333
   1523 014334      1528 014342      1529 014347      1530 014351      1531 014354      1532 014355      1534 014357
   1535 014367      1536 014402      1538 014404      1539 014406      1540 014417      1542 014421      1544 014424
   1545 014456      1547 014460      1551 014461      1553 014467      1554 014471      1556 014606      1557 014633
   1559 014654      1561 014661      1562 014662      1563 014676      1567 014677      1568 014713      1569 014737
   1570 014763      1571 015007      1572 015010      1574 015023      1576 015024      1591 015032      1592 015061
   1593 015071      1594 015100      1595 015112


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
