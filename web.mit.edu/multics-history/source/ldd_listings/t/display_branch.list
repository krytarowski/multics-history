	COMPILATION LISTING OF SEGMENT display_branch
	Compiled by: Multics PL/I Compiler, Release 28d, of October 4, 1983
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 11/23/84  1257.8 mst Fri
	    Options: optimize map

        1 /* ***********************************************************
        2*   *                                                         *
        3*   * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*   *                                                         *
        5*   * Copyright (c) 1972 by Massachusetts Institute of        *
        6*   * Technology and Honeywell Information Systems, Inc.      *
        7*   *                                                         *
        8*   *********************************************************** */
        9 
       10 
       11 display_branch: procedure options (variable);
       12 
       13 /* DISPLAY_BRANCH  A hardcore debugging tool by Bernard Greenberg 05/21/76 */
       14 /*		Modified 10/76 by S. Barr for new hash table format */
       15 /* Modified 1984-07-24 BIM to really, truly, not copy out the entire dir. */
       16 
       17 
       18 
       19 /* usage: display_branch branchpathname */
       20 /*  OR    display_branch segno-of-seg-whose-branch-is-to-be-displayed */
       21 /*  OR    display_branch dirsegno|offset (location of branch) */
       22 /*  OR    display_branch -name branchpathname   if it looks like octal # or ptr */
       23 
       24 	dcl     (adir, pdir)	 char (168);
       25 	dcl     (ent, pent)		 char (32);
       26 	dcl     (verify, null, addr, ptr, baseptr, baseno, fixed, size, divide, index, length, rel, reverse, substr, unspec) builtin;
       27 	dcl     q			 (1) ptr;
       28 	dcl     (error_table_$root, error_table_$noentry) fixed bin (35) ext;
       29 	dcl     ring0_get_$segptr	 entry (char (*), char (*), ptr, fixed bin (35));
       30 	dcl     hcs_$fs_get_path_name	 entry (ptr, char (*), fixed bin,
       31 				 char (*), fixed bin (35));
       32 	dcl     (dsn, dnl, ero, esn)	 fixed bin;
       33 	dcl     ofgotten		 bit (1) init ("0"b);
       34 	dcl     cv_oct_check_	 entry (char (*), fixed bin (35)) returns (fixed bin);
       35 	dcl     vs		 char (80) varying;
       36 	dcl     (rzdp, rzdsp)	 ptr;
       37 	dcl     1 tsdw		 like sdw aligned;
       38 	dcl     (lvname, pvname)	 char (32);
       39 	dcl     ppname		 char (168);
       40 	dcl     sname		 char (32);
       41 	dcl     epname		 char (168);
       42 	dcl     mdc_$find_volname	 entry (bit (36) aligned, char (*), char (*), fixed bin (35));
       43 	dcl     mdc_$find_lvname	 entry (bit (36) aligned, char (*), fixed bin (35));
       44 	dcl     date_time_		 entry (fixed bin (71), char (*));
       45 	dcl     (dirsegno, failct)	 fixed bin;
       46 	dcl     hash_index_		 entry (ptr, fixed bin, fixed bin, fixed bin) returns (fixed bin);
       47 	dcl     dirlen		 fixed bin (17);
       48 	dcl     hsi		 fixed bin;
       49 	dcl     phcs_$initiate	 entry (char (*), char (*), char (*), fixed bin, fixed bin, ptr, fixed bin (35));
       50 	dcl     phcs_$terminate_noname entry (ptr, fixed bin (35));
       51 	dcl     phcs_$ring_0_peek	 entry (ptr, ptr, fixed bin);
       52 	dcl     expand_pathname_	 entry (char (*), char (*), char (*), fixed bin (35));
       53 	dcl     (get_temp_segments_, release_temp_segments_) entry (char (*), (*) ptr, fixed bin (35));
       54 	dcl     (cleanup, out_of_bounds) condition;
       55 	dcl     (ioa_, com_err_)	 entry options (variable);
       56 	dcl     cu_$arg_ptr		 entry (fixed bin, ptr, fixed bin, fixed bin (35));
       57 	dcl     arg		 char (argl) based (argp);
       58 	dcl     argp		 ptr, argl fixed bin;
       59 	dcl     myname		 char (19) init ("display_branch") static options (constant);
       60 
       61 	dcl     code		 fixed bin (35);
       62 
  1     1 /* BEGIN INCLUDE FILE ... sdw.incl.pl1 ... last modified 12 May 1976 */
  1     2 
  1     3 dcl  sdwp ptr;
  1     4 
  1     5 dcl 1 sdw based (sdwp) aligned,			/* Segment Descriptor Word */
  1     6 
  1     7    (2 add bit (24),					/* main memory address of page table */
  1     8     2 (r1, r2, r3) bit (3),				/* ring brackets for the segment */
  1     9     2 df bit (1),					/* directed fault bit (0 => fault) */
  1    10     2 df_no bit (2),				/* directed fault number */
  1    11 
  1    12     2 pad1 bit (1),
  1    13     2 bound bit (14),				/* boundary field (in 16 word blocks) */
  1    14     2 access,					/* access bits */
  1    15       3 read bit (1),				/* read permission bit */
  1    16       3 execute bit (1),				/* execute permission bit */
  1    17       3 write bit (1),				/* write permission bit */
  1    18       3 privileged bit (1),				/* privileged bit */
  1    19     2 unpaged bit (1),				/* segment is unpaged if this is 1 */
  1    20     2 entry_bound_sw bit (1),				/* if this is 0 the entry bound is checked by hardware */
  1    21     2 cache bit (1),				/* cache enable bit */
  1    22     2 entry_bound bit (14)) unaligned;			/* entry bound */
  1    23 
  1    24 dcl 1 sdwa (0: 1) based (sdwp) aligned like sdw;		/* SDW array (descriptor segment) */
  1    25 
  1    26 /* END INCLUDE FILE  sdw.incl.pl1 */
       63 
  2     1 /*	BEGIN INCLUDE FILE ... dir_header.incl.pl1 */
  2     2 /* Modified 8/74 for NSS */
  2     3 /* Modified 8/76 to add version number and hash table rel pointer for variable hash table sizes */
  2     4 /* Modified 3/82 BIM for change pclock */
  2     5 /* format: style3 */
  2     6 
  2     7 /* Template for the directory header. Length = 64 words. */
  2     8 
  2     9 dcl  dp ptr;
  2    10 
  2    11 dcl 1 dir based (dp) aligned,
  2    12 
  2    13    2 modify bit (36),				/* Process ID of last modifier */
  2    14    2 type bit (18) unaligned,			/* type of object = dir header */
  2    15    2 size fixed bin (17) unaligned,			/* size of header in words */
  2    16     2 dtc (3),					/* date-time checked by salvager array */
  2    17       3 date bit (36),				/* the date */
  2    18       3 error bit (36),				/* what errors were discovered */
  2    19 
  2    20     2 uid bit (36),					/* uid of the directory           - copied from branch */
  2    21 
  2    22     2 pvid bit (36),				/* phys vol id of the dir         - copied from branch */
  2    23 
  2    24     2 sons_lvid bit (36),				/* log vol id for inf non dir seg - copied from branch */
  2    25 
  2    26     2 access_class bit (72),				/* security attributes of dir     - copied from branch */
  2    27 
  2    28     (2 vtocx fixed bin (17),				/* vtoc entry index of the dir    - copied from branch */
  2    29     2 version_number fixed bin (17),			/* version number of header */
  2    30 
  2    31     2 entryfrp bit (18),				/* rel ptr to beginning of entry list */
  2    32     2 pad2 bit (18),
  2    33 
  2    34     2 entrybrp bit (18),				/* rel ptr to end of entry list */
  2    35     2 pad3 bit (18),
  2    36 
  2    37     2 pers_frp bit (18),				/* rel ptr to start of person name list */
  2    38     2 proj_frp bit (18),				/* rel ptr to start of project name list */
  2    39 
  2    40     2 pers_brp bit (18),				/* rel ptr to end of person name list */
  2    41     2 proj_brp bit (18),				/* rel ptr to end of project name list */
  2    42 
  2    43     2 seg_count fixed bin (17),			/* number of non-directory branches */
  2    44     2 dir_count fixed bin (17),			/* number of directory branches */
  2    45 
  2    46     2 lcount fixed bin (17),				/* number of links */
  2    47     2 acle_total fixed bin (17),			/* total number of ACL entries in directory */
  2    48 
  2    49     2 arearp bit (18),				/* relative pointer to beginning of allocation area */
  2    50     2 per_process_sw bit (1),				/* indicates dir contains per process segments */
  2    51     2 master_dir bit (1),				/* TRUE if this is a master dir */
  2    52     2 force_rpv bit (1),				/* TRUE if segs must be on RPV */
  2    53     2 rehashing bit (1),				/* TRUE if hash table is being constructed */
  2    54     2 pad4 bit (14),
  2    55 
  2    56     2 iacl_count (0:7),
  2    57       3 seg fixed bin (17),				/* number of initial acl entries for segs */
  2    58       3 dir fixed bin (17),				/* number of initial acl entries for dir */
  2    59 
  2    60     2 iacl (0:7),					/* pointer to initial ACLs for each ring */
  2    61       3 seg_frp bit (18),				/* rel ptr to start of initial ACL for segs */
  2    62       3 seg_brp bit (18),				/* rel ptr to end of initial ACL for segs */
  2    63 
  2    64       3 dir_frp bit (18),				/* rel ptr to start of initial for dirs */
  2    65       3 dir_brp bit (18),				/* rel ptr to end of initial ACL for dirs */
  2    66 
  2    67     2 htsize fixed bin (17),				/* size of hash table */
  2    68     2 hash_table_rp bit (18),				/* rel ptr to start of hash table */
  2    69 
  2    70     2 htused fixed bin (17),				/* no. of used places in hash table */
  2    71     2 pad6 fixed bin (17),
  2    72 
  2    73     2 tree_depth fixed bin (17),			/* number of levels from root of this dir */
  2    74     2 pad7 bit (18)) unaligned,
  2    75 
  2    76     2 dts bit (36),					/* date-time directory last salvaged */
  2    77 
  2    78     2 master_dir_uid bit (36),			/* uid of superior master dir */
  2    79     2 change_pclock fixed bin (35),			/* up one each call to sum$dirmod */
  2    80     2 pad8 (11) bit (36),				/* pad to make it a 64 word header */
  2    81     2 checksum bit (36),				/* checksummed from uid on */
  2    82     2 owner bit (36);				/* uid of parent dir */
  2    83 
  2    84 dcl version_number_2 fixed bin int static options (constant) init (2);
  2    85 
  2    86 /*	END INCLUDE FILE ... dir_header.incl.pl1 */
       64 
  3     1 /*     BEGIN INCLUDE FILE ... dir_ht.incl.pl1 */
  3     2 
  3     3 
  3     4 dcl htp ptr;
  3     5 
  3     6 dcl 1 hash_table based (htp) aligned,			/* htp = ptr(dp,active_hardcore_data$htrp) */
  3     7     2 modify bit (36) unal,
  3     8     2 type bit (18) unal,				/* type = dir hash table */
  3     9     2 size fixed bin (17) unal,			/* size of current dir hash table entry */
  3    10     2 name_rp (0:1) bit(18) unal,			/* rel ptr of name entry  */
  3    11     2 checksum bit (36) unal,
  3    12     2 owner bit (36) unal;
  3    13 						/* otherwise rel ptr to name */
  3    14 
  3    15 /*     END INCLUDE FILE ... dir_ht.incl.pl1 */
       65 
  4     1 /*	BEGIN INCLUDE FILE ... dir_entry.incl.pl1 ...last modified August 1974 for nss */
  4     2 
  4     3 
  4     4 /* Template for an entry. Length = 38 words */
  4     5 
  4     6 dcl  ep ptr;
  4     7 
  4     8 dcl 1 entry based (ep) aligned,
  4     9 
  4    10     (2 efrp bit (18),				/* forward rel ptr to next entry */
  4    11     2 ebrp bit (18)) unaligned,			/* backward rel ptr to previous entry */
  4    12 
  4    13     2 type bit (18) unaligned,			/* type of object = dir entry  */
  4    14     2 size fixed bin (17) unaligned,			/* size of dir entry */
  4    15 
  4    16     2 uid bit (36),					/* unique id of entry */
  4    17 
  4    18     2 dtem bit (36),				/* date-time entry modified */
  4    19 
  4    20     (2 bs bit (1),					/* branch switch = 1 if branch */
  4    21     2 pad0 bit (17),
  4    22     2 nnames fixed bin (17),				/* number of names for this entry */
  4    23 
  4    24     2 name_frp bit (18),				/* rel pointer to start of name list */
  4    25     2 name_brp bit (18),				/* rel pointer to end of name list */
  4    26 
  4    27     2 author,					/* user who created branch */
  4    28       3 pers_rp bit (18),				/* name of user who created branch */
  4    29       3 proj_rp bit (18),				/* project of user who created branch */
  4    30 
  4    31       3 tag char (1),				/* tag of user who created branch */
  4    32       3 pad1 char (3),
  4    33 
  4    34     2 primary_name bit (504),				/* first name on name list */
  4    35 
  4    36     2 dtd bit (36),					/* date time dumped */
  4    37 
  4    38     2 pad2 bit (36),
  4    39 
  4    40 
  4    41 /* the declarations below are for branch only */
  4    42 
  4    43 
  4    44     2 pvid bit (36),				/* physical volume id */
  4    45 
  4    46     2 vtocx fixed bin (17),				/* vtoc entry index */
  4    47     2 pad3 bit (18),
  4    48 
  4    49     2 dirsw bit (1),				/* = 1 if this is a directory branch */
  4    50     2 oosw bit (1),					/* out of service switch  on = 1 */
  4    51     2 per_process_sw bit (1),				/* indicates segment is per process */
  4    52     2 copysw bit (1),				/* = 1 make copy of segment whenever initiated */
  4    53     2 safety_sw bit (1),				/* if 1 then entry cannot be deleted */
  4    54     2 multiple_class bit (1),				/* segment has multiple security classes */
  4    55     2 audit_flag bit (1),				/* segment must be audited for security */
  4    56     2 security_oosw bit (1),				/* security out of service switch */
  4    57     2 entrypt_sw bit (1),				/* 1 if call limiter is to be enabled */
  4    58     2 master_dir bit (1),				/* TRUE for master directory */
  4    59     2 tpd bit (1),					/* TRUE if this segment is never to go on the PD */
  4    60     2 pad4 bit (11),
  4    61     2 entrypt_bound bit (14)) unaligned,		/* call limiter */
  4    62 
  4    63     2 access_class bit (72) aligned,			/* security attributes : level and category */
  4    64 
  4    65     (2 ring_brackets (3) bit (3),			/* ring brackets on segment */
  4    66     2 ex_ring_brackets (3) bit (3),			/* extended ring brackets */
  4    67     2 acle_count fixed bin (17),			/* number of entries on ACL */
  4    68 
  4    69     2 acl_frp bit (18),				/* rel ptr to start of ACL */
  4    70     2 acl_brp bit (18),				/* rel ptr to end of ACL */
  4    71 
  4    72     2 bc_author,					/* user who last set the bit count */
  4    73       3 pers_rp bit (18),				/* name of user who set the bit count */
  4    74       3 proj_rp bit (18),				/* project of user who set the bit count */
  4    75 
  4    76       3 tag char (1),				/* tag of user who set the bit count */
  4    77       3 pad5 bit (2),
  4    78     2 bc fixed bin (24)) unaligned,			/* bit count for segs, msf indicator for dirs */
  4    79 
  4    80     2 sons_lvid bit (36),				/* logical volume id for immediat inf non dir seg */
  4    81 
  4    82     2 pad6 bit (36),
  4    83 
  4    84     2 checksum bit (36),				/* checksum from dtd */
  4    85 
  4    86     2 owner bit (36);				/* uid of containing directory */
  4    87 
  4    88 /*	END INCLUDE FILE ... dir_entry.incl.pl1 ... */
       66 
  5     1 /*     BEGIN INCLUDE FILE ... dir_link.incl.pl1 ... last modified August 1974 for nss */
  5     2 
  5     3 /* Template for link. Note that it is identical to entry for first 24 words. */
  5     4 
  5     5 
  5     6 dcl 1 link based (ep) aligned,
  5     7 
  5     8     (2 efrp bit (18),				/* forward rel ptr to next entry */
  5     9     2 ebrp bit (18),				/* backward rel ptr to previous entry */
  5    10 
  5    11     2 type bit (18),				/* type = dir link */
  5    12     2 size fixed bin (17),				/* size of link in words */
  5    13 
  5    14     2 uid bit (36),					/* unique id of entry */
  5    15 
  5    16     2 dtem bit (36),				/* date-time entry modified */
  5    17 
  5    18     2 bs bit (1),					/* entry switch = 1 if entry */
  5    19     2 pad0 bit (17),
  5    20     2 nnames fixed bin (17),				/* number of names for this entry */
  5    21 
  5    22     2 name_frp bit (18),				/* rel pointer to start of name list */
  5    23     2 name_brp bit (18),				/* rel pointer to end of name list */
  5    24 
  5    25     2 author,					/* user who created entry */
  5    26       3 pers_rp bit (18),				/* name of user who created entry */
  5    27       3 proj_rp bit (18),				/* project of user who created entry */
  5    28 
  5    29       3 tag char (1),				/* tag of user who created entry */
  5    30       3 pad1 char (3),
  5    31 
  5    32     2 primary_name bit (504),				/* first name on name list */
  5    33 
  5    34     2 dtd bit (36),					/* date time dumped */
  5    35 
  5    36     2 pad2 bit (36),
  5    37 
  5    38 
  5    39 /* the declarations below are only applicable to links */
  5    40 
  5    41     2 pad3 bit (18),
  5    42     2 pathname_size fixed bin (17),			/* number of characters in pathname */
  5    43 
  5    44     2 pathname char (168 refer (pathname_size))) unaligned, /* pathname of link */
  5    45 
  5    46     2 checksum bit (36),				/* checksum from uid */
  5    47 
  5    48     2 owner bit (36);				/* uid of containing directory */
  5    49 
  5    50 /*     END INCLUDE FILE ... dir_link.incl.pl1 */
       67 
  6     1 /*     BEGIN INCLUDE FILE ... dir_name.incl.pl1 ... last modified Nov 1975 for nss */
  6     2 
  6     3 /* Template for names of branches or links. Length = 14 words. */
  6     4 
  6     5 dcl np ptr;
  6     6 
  6     7 dcl 1 names based aligned,				/* based on ptr(dp,ep->entry.name_frp) */
  6     8     2 fp bit(18) unaligned,				/* rel ptr to next name */
  6     9     2 bp bit(18) unaligned,				/* rel ptr to prev name */
  6    10 
  6    11     2 type bit (18) unaligned,			/* type = dir name */
  6    12     2 size fixed bin (17) unaligned,			/* size of dir name */
  6    13 
  6    14     2 entry_rp bit(18) unaligned,			/* rel ptr to entry */
  6    15     2 ht_index fixed bin(17) unaligned,			/* index of hash table entry */
  6    16 
  6    17     2 hash_thread bit (18) unal,			/* relative ptr to next hash  entry */
  6    18     2 pad3 bit (18) unal,
  6    19 
  6    20     2 name char(32) aligned,
  6    21 
  6    22     2 checksum bit (36),				/* checksum from entry_rp */
  6    23 
  6    24     2 owner bit (36);				/* uid of entry */
  6    25 
  6    26 
  6    27 /*     END INCLUDE FILE ... dir_name.incl.pl1 */
       68 
       69 
       70 
       71 	call ring0_get_$segptr ("", "dseg", rzdsp, code);
       72 	if code ^= 0 then do;
       73 		call com_err_ (0, myname, "Cannot get dseg ptr");
       74 		return;
       75 	     end;
       76 
       77 	call cu_$arg_ptr (1, argp, argl, code);
       78 	if code ^= 0 then do;
       79 noarg:		call com_err_ (code, myname);
       80 		return;
       81 	     end;
       82 
       83 	if arg = "-name" | arg = "-nm" | arg = "-path" | arg = "-pn" then do;
       84 		call cu_$arg_ptr (2, argp, argl, code);
       85 		if code ^= 0 then go to noarg;
       86 		go to nooct;
       87 	     end;
       88 
       89 	esn = cv_oct_check_ (arg, code);
       90 	if code = 0 then do;			/* legit octal */
       91 		call hcs_$fs_get_path_name (baseptr (esn), adir, dnl, ent, code);
       92 		if code ^= 0 then do;
       93 			call com_err_ (code, myname, "^o", esn);
       94 			return;
       95 		     end;
       96 		if dnl = 0 then adir = ">";		/* Multix cant even act consist. */
       97 		go to got_adir_ent;
       98 	     end;
       99 
      100 /* try for x|y */
      101 
      102 	dnl = index (arg, "|");
      103 	if dnl = 0 then go to nooct;
      104 	if dnl = 1 | dnl = length (arg) then go to nooct;
      105 	ero = cv_oct_check_ (substr (arg, dnl + 1), code);
      106 	if code = 0 then dsn = cv_oct_check_ (substr (arg, 1, dnl - 1), code);
      107 	if code = 0 then do;			/* Got a branch ptr */
      108 		rzdp = baseptr (dsn);
      109 		call hcs_$fs_get_path_name (rzdp, pdir, dnl, pent, code);
      110 		if code ^= 0 then do;
      111 			call com_err_ (code, myname, "^o", dsn);
      112 			return;
      113 		     end;
      114 		ofgotten = "1"b;
      115 		if dnl = 0 then pdir = ">";
      116 		if pdir = ">" then ppname = ">" || pent;
      117 		else ppname = substr (pdir, 1, trim (pdir)) || ">" || pent;
      118 		go to ext;
      119 	     end;
      120 nooct:
      121 	call expand_pathname_ (arg, adir, ent, code);
      122 	if code ^= 0 then do;
      123 		call com_err_ (code, myname, arg);
      124 		return;
      125 	     end;
      126 got_adir_ent:
      127 
      128 	if adir = ">" then if ent = "" then do;
      129 		     call com_err_ (error_table_$root, myname);
      130 		     return;
      131 		end;
      132 
      133 	call expand_pathname_ (adir, pdir, pent, (0));
      134 						/* Cannot fail */
      135 	if pdir = ">" then ppname = ">" || pent;
      136 	else ppname = substr (pdir, 1, trim (pdir)) || ">" || pent;
      137 
      138 	if pent = "" then epname = ">" || ent;
      139 	else epname = substr (adir, 1, trim (adir)) || ">" || ent;
      140 
      141 
      142 ext:	on cleanup call release_temp_segments_ (myname, q, (0));
      143 	call get_temp_segments_ (myname, q, code);
      144 	if code ^= 0 then do;
      145 		call com_err_ (code, myname, "Getting temp segment.");
      146 		return;
      147 	     end;
      148 
      149 	dp = q (1);
      150 
      151 
      152 	call phcs_$initiate (pdir, pent, "", 0, 0, rzdp, code);
      153 	if rzdp = null then do;
      154 		call com_err_ (code, myname, ppname);
      155 		call release_temp_segments_ (myname, q, (0));
      156 		return;
      157 	     end;
      158 
      159 	if ofgotten then do;
      160 		ep = ptr (dp, ero);
      161 		call m_a (ep, size (entry));
      162 		go to dsplay;
      163 	     end;
      164 	dirsegno = fixed (baseno (rzdp), 18);
      165 	call phcs_$ring_0_peek (rzdp, dp, 1);		/* Cause fault */
      166 	failct = 0;
      167 ftsdw:
      168 	call phcs_$ring_0_peek (addr (rzdsp -> sdwa (dirsegno)), addr (tsdw), 2);
      169 	if tsdw.bound = "0"b then go to ftsdw;
      170 	dirlen = fixed (tsdw.bound, 15) * 16 + 16;
      171 
      172 	on out_of_bounds go to refetch_dir;
      173 refetch_dir:
      174 	failct = failct + 1;
      175 	if failct > 10 then do;
      176 		call com_err_ (0, myname, "Cannot get consistent copy of ^a after 10 tries", ppname);
      177 		call phcs_$terminate_noname (rzdp, (0));
      178 		call release_temp_segments_ (myname, q, (0));
      179 		return;
      180 	     end;
      181 	call m_a (dp, size (dir));
      182 	hsi = hash_index_ (addr (ent), trim (ent), 0, (dir.htsize));
      183 	htp = ptr (dp, dp -> dir.hash_table_rp);
      184 	call m_a (htp, (dir.htsize));
      185 
      186 	do np = ptr (dp, htp -> hash_table.name_rp (hsi))
      187 	     repeat ptr (dp, np -> names.hash_thread)
      188 	     while (rel (np));
      189 	     call m_a (np, size (names));
      190 	     if fixed (rel (np), 18) >= dirlen then go to refetch_dir;
      191 	     if np -> names.ht_index ^= hsi then go to refetch_dir;
      192 	     if ent = np -> names.name then do;
      193 		     ep = ptr (dp, np -> names.entry_rp);
      194 		     call m_a (ep, size (entry));
      195 		     go to dsplay;
      196 		end;
      197 	end;
      198 
      199 /* Name not found.  Cleanup and return. */
      200 	call com_err_ (error_table_$noentry, myname, epname);
      201 	call release_temp_segments_ (myname, q, (0));
      202 	call phcs_$terminate_noname (rzdp, (0));
      203 	return;
      204 
      205 dsplay:
      206 	sname = addr (entry.primary_name) -> names.name;
      207 	call ioa_ ("^/^-Branch for ^a in ^a at ^p^/", sname,
      208 	     ppname, ptr (rzdp, rel (ep)));
      209 	if ^entry.bs then do;
      210 		call m_a (ep, divide (length (unspec (link)), 36, 17, 0));
      211 		call ioa_ ("^a (uid ^w) is a link to ^a", sname, link.uid, link.pathname);
      212 	     end;
      213 	else do;
      214 
      215 		call mdc_$find_volname ((entry.pvid), pvname, lvname, code);
      216 		if code ^= 0 then do;
      217 			call com_err_ (code, myname, "^/ Cannot determine vol name for pvid ^w", entry.pvid);
      218 			lvname, pvname = "-NOT-CLEAR-";
      219 		     end;
      220 
      221 		call ioa_ ("UID ^w, is vtocx ^o on ^a (of log vol. ^a)", entry.uid, entry.vtocx, pvname, lvname);
      222 		if entry.dirsw then call ioa_ ("^a is a directory.", sname);
      223 		if entry.master_dir then do;
      224 			call mdc_$find_lvname (entry.sons_lvid, lvname, code);
      225 			if code ^= 0 then do;
      226 				lvname = "-NOT-CLEAR-";
      227 				call com_err_ (code, myname, "Cannot get LV name for lvid ^w", entry.sons_lvid);
      228 			     end;
      229 			call ioa_ ("^a is a master dir for LV ^a", sname, lvname);
      230 		     end;
      231 		vs = "";
      232 		if entry.oosw then call putsw (" oosw");
      233 		if entry.per_process_sw then call putsw (" per-process");
      234 		if entry.copysw then call putsw (" copysw");
      235 		if entry.multiple_class then call putsw (" multi-class");
      236 		if entry.safety_sw then call putsw (" safety_sw");
      237 		if entry.audit_flag then call putsw (" audit");
      238 		if entry.security_oosw then call putsw (" sec-oosw");
      239 		if entry.tpd then call putsw (" tpd");
      240 		call putsw ("OOP");
      241 		if entry.entrypt_sw then call ioa_
      242 			("Call limiter at ^o .", fixed (entry.entrypt_bound, 14));
      243 		call ioa_ ("Ring brackets (^o ^o ^o)", fixed (entry.ring_brackets
      244 		     (1), 3), fixed (entry.ring_brackets (2), 3), fixed
      245 		     (entry.ring_brackets (3), 3));
      246 	     end;
      247 	if entry.dtem then call ioa_ ("Entry modified ^a", dtc (entry.dtem));
      248 	else call ioa_ ("DTEM not set.");
      249 	if entry.dtd then call ioa_ ("Dumped ^a", dtc ((entry.dtd)));
      250 	else call ioa_ ("Never dumped.");
      251 	if entry.nnames > 1 then call ioa_ ("^d names.", entry.nnames);
      252 	if entry.bs then do;
      253 		call get_access_class (entry.access_class, code);
      254 		if code ^= 0 then call ioa_ ("Unable to convert access class information.");
      255 	     end;
      256 	call release_temp_segments_ (myname, q, (0));
      257 	call phcs_$terminate_noname (rzdp, (0));
      258 	return;
      259 
      260 trim: proc (ch) returns (fixed bin);
      261 	dcl     ch		 char (*);
      262 	dcl     x			 fixed bin;
      263 	x = verify (reverse (ch), " ");
      264 	if x ^= 0 then x = length (ch) - x + 1;
      265 	return (x);
      266      end;
      267 
      268 m_a: proc (cp, sz);
      269 						/* This proc is needed to avoid copying a whole directory out,
      270*						   which can, and did one May morning in Phoenix, withdraw a large number
      271*						   of pages against the RLV. Writers of similar programs beware. */
      272 	dcl     (cp, rgp)		 ptr, sz fixed bin;
      273 	rgp = ptr (rzdp, rel (cp));
      274 	call phcs_$ring_0_peek (rgp, cp, sz);
      275      end;
      276 
      277 dtc: proc (d) returns (char (24));			/* Proc to convert date_times */
      278 
      279 	dcl     fbuf		 fixed bin (71);
      280 	dcl     d			 bit (36) aligned, cd char (24);
      281 
      282 	fbuf = 0;
      283 	substr (unspec (fbuf), 21) = d;
      284 	call date_time_ (fbuf, cd);
      285 	return (cd);
      286      end dtc;
      287 
      288 putsw: proc (swn);
      289 
      290 	dcl     swn		 char (*);
      291 	if length (vs) + length (swn) > 70 | swn = "OOP" then do;
      292 		if vs = "" then ;
      293 		else call ioa_ ("Switches:^a", vs);
      294 		vs = "";
      295 	     end;
      296 	vs = vs || swn;
      297      end putsw;
      298 
      299 
      300 get_access_class:
      301      proc (access_class, code);
      302 
      303 	dcl     access_class	 bit (72) aligned,
      304 	        (class, temp_string)	 char (336),
      305 	        (class_len, k, kk)	 fixed bin,
      306 	        first		 bit (1),
      307 	        code		 fixed bin (35);
      308 	dcl     convert_authorization_$to_string_short
      309 				 entry (bit (72) aligned, char (*), fixed bin (35));
      310 
      311 	code = 0;
      312 
      313 	call convert_authorization_$to_string_short (access_class, class, code);
      314 	if code ^= 0 then return;
      315 	if class = "" then call ioa_ ("Access Class:  system_low");
      316 	else do;
      317 						/* format access class in lines of 50 chars */
      318 		class_len = index (class, " ") - 1;
      319 		if class_len = -1 then class_len = 336;
      320 		k = 1;
      321 		first = "1"b;
      322 		do while ((class_len - k + 1) > 50);
      323 		     temp_string = substr (class, k, 50);
      324 		     kk = length (temp_string) + 1 - index (reverse (temp_string), ",");
      325 		     call ioa_ ("^[Access Class:^;             ^]  ^a", (first), substr (class, k, kk));
      326 		     first = "0"b;
      327 		     k = k + kk;
      328 		end;
      329 		call ioa_ ("^[Access Class:  ^;               ^]^a", (first), substr (class, k));
      330 	     end;
      331      end get_access_class;
      332      end;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    11/23/84  1245.0  display_branch.pl1                >special_ldd>online>6717-11/23/84>display_branch.pl1
63           1    09/14/76  0759.8  sdw.incl.pl1                      >ldd>include>sdw.incl.pl1
64           2    05/24/82  1005.0  dir_header.incl.pl1               >ldd>include>dir_header.incl.pl1
65           3    11/02/76  1414.6  dir_ht.incl.pl1                   >ldd>include>dir_ht.incl.pl1
66           4    04/29/76  1100.6  dir_entry.incl.pl1                >ldd>include>dir_entry.incl.pl1
67           5    04/29/76  1049.2  dir_link.incl.pl1                 >ldd>include>dir_link.incl.pl1
68           6    11/02/76  1414.7  dir_name.incl.pl1                 >ldd>include>dir_name.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
access_class                           parameter       bit(72)                  dcl 303 in procedure "get_access_class" set ref 300
                                                                                  313*
access_class             33            based           bit(72)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "display_branch" set ref 253*
addr                                                   builtin function         dcl 26 ref 167 167 167 167 182 182 205
adir                            000100 automatic       char(168)                unaligned dcl 24 set ref 91* 96* 120* 126 133* 139
                                                                                  139*
arg                                    based           char                     unaligned dcl 57 set ref 83 83 83 83 89* 102 104 105
                                                                                  105 106 106 120* 123*
argl                            000504 automatic       fixed bin(17,0)          dcl 58 set ref 77* 83 83 83 83 84* 89 89 102 104 105
                                                                                  105 106 106 120 120 123 123
argp                            000502 automatic       pointer                  dcl 58 set ref 77* 83 83 83 83 84* 89 102 104 105
                                                                                  105 106 106 120 123
audit_flag               32(06)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 237
baseno                                                 builtin function         dcl 26 ref 164
baseptr                                                builtin function         dcl 26 ref 91 91 108
bound                     1(01) 000304 automatic       bit(14)                  level 2 packed unaligned dcl 37 set ref 169 170
bs                        4            based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 209 252
cd                              000546 automatic       char(24)                 unaligned dcl 280 set ref 284* 285
ch                                     parameter       char                     unaligned dcl 261 ref 260 263 264
class                           000570 automatic       char(336)                unaligned dcl 303 set ref 313* 315 318 323 325 325
                                                                                  329 329
class_len                       001040 automatic       fixed bin(17,0)          dcl 303 set ref 318* 319 319* 322
cleanup                         000466 stack reference condition                dcl 54 ref 142
code                                   parameter       fixed bin(35,0)          dcl 303 in procedure "get_access_class" set ref 300
                                                                                  311* 313* 314
code                            000505 automatic       fixed bin(35,0)          dcl 61 in procedure "display_branch" set ref 71* 72
                                                                                  77* 78 79* 84* 85 89* 90 91* 92 93* 105* 106 106*
                                                                                  107 109* 110 111* 120* 122 123* 143* 144 145* 152*
                                                                                  154* 215* 216 217* 224* 225 227* 253* 254
com_err_                        000050 constant        entry                    external dcl 55 ref 73 79 93 111 123 129 145 154 176
                                                                                  200 217 227
convert_authorization_$to_string_short
                                000054 constant        entry                    external dcl 308 ref 313
copysw                   32(03)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 234
cp                                     parameter       pointer                  dcl 272 set ref 268 273 274*
cu_$arg_ptr                     000052 constant        entry                    external dcl 56 ref 77 84
cv_oct_check_                   000020 constant        entry                    external dcl 34 ref 89 105 106
d                                      parameter       bit(36)                  dcl 280 ref 277 283
date_time_                      000026 constant        entry                    external dcl 44 ref 284
dir                                    based           structure                level 1 dcl 2-11 ref 181 181
dirlen                          000464 automatic       fixed bin(17,0)          dcl 47 set ref 170* 190
dirsegno                        000462 automatic       fixed bin(17,0)          dcl 45 set ref 164* 167 167
dirsw                    32            based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 222
divide                                                 builtin function         dcl 26 ref 210 210
dnl                             000247 automatic       fixed bin(17,0)          dcl 32 set ref 91* 96 102* 103 104 104 105 105 106
                                                                                  106 109* 115
dp                              000506 automatic       pointer                  dcl 2-9 set ref 149* 160 165* 181* 181 181 182 183
                                                                                  183 184 186 193 197
dsn                             000246 automatic       fixed bin(17,0)          dcl 32 set ref 106* 108 111*
dtd                      26            based           bit(36)                  level 2 packed unaligned dcl 4-8 ref 249 249 249
dtem                      3            based           bit(36)                  level 2 dcl 4-8 set ref 247 247* 247*
ent                             000224 automatic       char(32)                 unaligned dcl 25 set ref 91* 120* 126 138 139 182
                                                                                  182 182* 182* 192
entry                                  based           structure                level 1 dcl 4-8 set ref 161 161 194 194
entry_rp                  2            based           bit(18)                  level 2 packed unaligned dcl 6-7 ref 193
entrypt_bound            32(22)        based           bit(14)                  level 2 packed unaligned dcl 4-8 ref 241 241
entrypt_sw               32(08)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 241
ep                              000512 automatic       pointer                  dcl 4-6 set ref 160* 161* 161 161 193* 194* 194 194
                                                                                  205 207 207 209 210* 210 210 211 211 215 217 221
                                                                                  221 222 223 224 227 232 233 234 235 236 237 238
                                                                                  239 241 241 241 243 243 243 243 243 243 247 247
                                                                                  247 249 249 249 251 251 252 253
epname                          000410 automatic       char(168)                unaligned dcl 41 set ref 138* 139* 200*
ero                             000250 automatic       fixed bin(17,0)          dcl 32 set ref 105* 160
error_table_$noentry            000012 external static fixed bin(35,0)          dcl 28 set ref 200*
error_table_$root               000010 external static fixed bin(35,0)          dcl 28 set ref 129*
esn                             000251 automatic       fixed bin(17,0)          dcl 32 set ref 89* 91 91 93*
expand_pathname_                000040 constant        entry                    external dcl 52 ref 120 133
failct                          000463 automatic       fixed bin(17,0)          dcl 45 set ref 166* 173* 173 175
fbuf                            000544 automatic       fixed bin(71,0)          dcl 279 set ref 282* 283 284*
first                           001043 automatic       bit(1)                   unaligned dcl 303 set ref 321* 325 326* 329
fixed                                                  builtin function         dcl 26 ref 164 170 190 241 241 243 243 243 243 243
                                                                                  243
get_temp_segments_              000042 constant        entry                    external dcl 53 ref 143
hash_index_                     000030 constant        entry                    external dcl 46 ref 182
hash_table                             based           structure                level 1 dcl 3-6
hash_table_rp            55(18)        based           bit(18)                  level 2 packed unaligned dcl 2-11 ref 183
hash_thread               3            based           bit(18)                  level 2 packed unaligned dcl 6-7 ref 197
hcs_$fs_get_path_name           000016 constant        entry                    external dcl 30 ref 91 109
hsi                             000465 automatic       fixed bin(17,0)          dcl 48 set ref 182* 186 191
ht_index                  2(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 6-7 ref 191
htp                             000510 automatic       pointer                  dcl 3-4 set ref 183* 184* 186
htsize                   55            based           fixed bin(17,0)          level 2 packed unaligned dcl 2-11 ref 182 184
index                                                  builtin function         dcl 26 ref 102 318 324
ioa_                            000046 constant        entry                    external dcl 55 ref 207 211 221 222 229 241 243 247
                                                                                  248 249 250 251 254 293 315 325 329
k                               001041 automatic       fixed bin(17,0)          dcl 303 set ref 320* 322 323 325 325 327* 327 329
                                                                                  329
kk                              001042 automatic       fixed bin(17,0)          dcl 303 set ref 324* 325 325 327
length                                                 builtin function         dcl 26 ref 104 210 210 264 291 291 324
link                                   based           structure                level 1 dcl 5-6 set ref 210 210
lvname                          000306 automatic       char(32)                 unaligned dcl 38 set ref 215* 218* 221* 224* 226*
                                                                                  229*
master_dir               32(09)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 223
mdc_$find_lvname                000024 constant        entry                    external dcl 43 ref 224
mdc_$find_volname               000022 constant        entry                    external dcl 42 ref 215
multiple_class           32(05)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 235
myname                          000000 constant        char(19)                 initial unaligned dcl 59 set ref 73* 79* 93* 111*
                                                                                  123* 129* 142* 143* 145* 154* 155* 176* 178* 200*
                                                                                  201* 217* 227* 256*
name                      4            based           char(32)                 level 2 dcl 6-7 ref 192 205
name_rp                   2            based           bit(18)                  array level 2 packed unaligned dcl 3-6 ref 186
names                                  based           structure                level 1 dcl 6-7 ref 189 189
nnames                    4(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 4-8 set ref 251 251*
np                              000514 automatic       pointer                  dcl 6-5 set ref 186* 186* 189* 190 191 192 193* 197
null                                                   builtin function         dcl 26 ref 153
ofgotten                        000252 automatic       bit(1)                   initial unaligned dcl 33 set ref 33* 114* 159
oosw                     32(01)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 232
out_of_bounds                   000474 stack reference condition                dcl 54 ref 172
pathname                 31            based           char                     level 2 packed unaligned dcl 5-6 set ref 211*
pathname_size            30(18)        based           fixed bin(17,0)          level 2 packed unaligned dcl 5-6 ref 210 210 211 211
pdir                            000152 automatic       char(168)                unaligned dcl 24 set ref 109* 115* 116 117 117* 133*
                                                                                  135 136 136* 152*
pent                            000234 automatic       char(32)                 unaligned dcl 25 set ref 109* 116 117 133* 135 136
                                                                                  138 152*
per_process_sw           32(02)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 233
phcs_$initiate                  000032 constant        entry                    external dcl 49 ref 152
phcs_$ring_0_peek               000036 constant        entry                    external dcl 51 ref 165 167 274
phcs_$terminate_noname          000034 constant        entry                    external dcl 50 ref 177 202 257
ppname                          000326 automatic       char(168)                unaligned dcl 39 set ref 116* 117* 135* 136* 154*
                                                                                  176* 207*
primary_name             10            based           bit(504)                 level 2 packed unaligned dcl 4-8 set ref 205
ptr                                                    builtin function         dcl 26 ref 160 183 186 193 197 207 207 273
pvid                     30            based           bit(36)                  level 2 packed unaligned dcl 4-8 set ref 215 217*
pvname                          000316 automatic       char(32)                 unaligned dcl 38 set ref 215* 218* 221*
q                               000244 automatic       pointer                  array dcl 27 set ref 142* 143* 149 155* 178* 201*
                                                                                  256*
rel                                                    builtin function         dcl 26 ref 186 190 207 207 273
release_temp_segments_          000044 constant        entry                    external dcl 53 ref 142 155 178 201 256
reverse                                                builtin function         dcl 26 ref 263 324
rgp                             000534 automatic       pointer                  dcl 272 set ref 273* 274*
ring0_get_$segptr               000014 constant        entry                    external dcl 29 ref 71
ring_brackets            35            based           bit(3)                   array level 2 packed unaligned dcl 4-8 ref 243 243
                                                                                  243 243 243 243
rzdp                            000300 automatic       pointer                  dcl 36 set ref 108* 109* 152* 153 164 165* 177* 202*
                                                                                  207 207 257* 273
rzdsp                           000302 automatic       pointer                  dcl 36 set ref 71* 167 167
safety_sw                32(04)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 236
sdw                                    based           structure                level 1 dcl 1-5
sdwa                                   based           structure                array level 1 dcl 1-24 set ref 167 167
security_oosw            32(07)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 238
size                                                   builtin function         dcl 26 ref 161 161 181 181 189 189 194 194
sname                           000400 automatic       char(32)                 unaligned dcl 40 set ref 205* 207* 211* 222* 229*
sons_lvid                41            based           bit(36)                  level 2 dcl 4-8 set ref 224* 227*
substr                                                 builtin function         dcl 26 set ref 105 105 106 106 117 136 139 283* 323
                                                                                  325 325 329 329
swn                                    parameter       char                     unaligned dcl 290 ref 288 291 291 296
sz                                     parameter       fixed bin(17,0)          dcl 272 set ref 268 274*
temp_string                     000714 automatic       char(336)                unaligned dcl 303 set ref 323* 324 324
tpd                      32(10)        based           bit(1)                   level 2 packed unaligned dcl 4-8 ref 239
tsdw                            000304 automatic       structure                level 1 dcl 37 set ref 167 167
uid                       2            based           bit(36)                  level 2 in structure "link" packed unaligned dcl 5-6
                                                                                  in procedure "display_branch" set ref 211*
uid                       2            based           bit(36)                  level 2 in structure "entry" dcl 4-8 in procedure
                                                                                  "display_branch" set ref 221*
unspec                                                 builtin function         dcl 26 ref 210 210 283
verify                                                 builtin function         dcl 26 ref 263
vs                              000253 automatic       varying char(80)         dcl 35 set ref 231* 291 292 293* 294* 296* 296
vtocx                    31            based           fixed bin(17,0)          level 2 packed unaligned dcl 4-8 set ref 221*
x                               000524 automatic       fixed bin(17,0)          dcl 262 set ref 263* 264 264* 264 265

NAMES DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
sdwp                                   automatic       pointer                  dcl 1-3
version_number_2                       internal static fixed bin(17,0)          initial dcl 2-84

NAMES DECLARED BY EXPLICIT CONTEXT.
display_branch                  000371 constant        entry                    external dcl 11
dsplay                          002304 constant        label                    dcl 205 set ref 162 195
dtc                             003454 constant        entry                    internal dcl 277 ref 247 247 249 249
ext                             001450 constant        label                    dcl 142 ref 118
ftsdw                           001734 constant        label                    dcl 167 ref 169
get_access_class                003602 constant        entry                    internal dcl 300 ref 253
got_adir_ent                    001250 constant        label                    dcl 126 ref 97
m_a                             003427 constant        entry                    internal dcl 268 ref 161 181 184 189 194 210
noarg                           000476 constant        label                    dcl 79 ref 85
nooct                           001171 constant        label                    dcl 120 ref 86 103 104
putsw                           003512 constant        entry                    internal dcl 288 ref 232 233 234 235 236 237 238 239
                                                                                  240
refetch_dir                     002006 constant        label                    dcl 173 ref 172 190 191
trim                            003373 constant        entry                    internal dcl 260 ref 117 136 139 182 182

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      4510        4566    4226        4520
Length      5136    4226        56         334     261           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
display_branch                      715 external procedure  is an external procedure.  
on unit on line 142                  80 on unit               
on unit on line 172                  64 on unit               
trim                                    internal procedure  shares stack frame of external procedure display_branch.  
m_a                                     internal procedure  shares stack frame of external procedure display_branch.  
dtc                                     internal procedure  shares stack frame of external procedure display_branch.  
putsw                                   internal procedure  shares stack frame of external procedure display_branch.  
get_access_class                        internal procedure  shares stack frame of external procedure display_branch.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
display_branch           000100 adir                        display_branch
                         000152 pdir                        display_branch
                         000224 ent                         display_branch
                         000234 pent                        display_branch
                         000244 q                           display_branch
                         000246 dsn                         display_branch
                         000247 dnl                         display_branch
                         000250 ero                         display_branch
                         000251 esn                         display_branch
                         000252 ofgotten                    display_branch
                         000253 vs                          display_branch
                         000300 rzdp                        display_branch
                         000302 rzdsp                       display_branch
                         000304 tsdw                        display_branch
                         000306 lvname                      display_branch
                         000316 pvname                      display_branch
                         000326 ppname                      display_branch
                         000400 sname                       display_branch
                         000410 epname                      display_branch
                         000462 dirsegno                    display_branch
                         000463 failct                      display_branch
                         000464 dirlen                      display_branch
                         000465 hsi                         display_branch
                         000502 argp                        display_branch
                         000504 argl                        display_branch
                         000505 code                        display_branch
                         000506 dp                          display_branch
                         000510 htp                         display_branch
                         000512 ep                          display_branch
                         000514 np                          display_branch
                         000524 x                           trim
                         000534 rgp                         m_a
                         000544 fbuf                        dtc
                         000546 cd                          dtc
                         000570 class                       get_access_class
                         000714 temp_string                 get_access_class
                         001040 class_len                   get_access_class
                         001041 k                           get_access_class
                         001042 kk                          get_access_class
                         001043 first                       get_access_class

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_cs            cat_realloc_cs      call_ext_out_desc   call_ext_out        return              tra_ext
enable              shorten_stack       ext_entry           int_entry

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
com_err_                      convert_authorization_$to_string_short                      cu_$arg_ptr
cv_oct_check_                 date_time_                    expand_pathname_              get_temp_segments_
hash_index_                   hcs_$fs_get_path_name         ioa_                          mdc_$find_lvname
mdc_$find_volname             phcs_$initiate                phcs_$ring_0_peek             phcs_$terminate_noname
release_temp_segments_        ring0_get_$segptr

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$noentry          error_table_$root




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     11 000370        33 000376        71 000377        72 000425        73 000427        74 000454        77 000455
     78 000474        79 000476        80 000513        83 000514        84 000536        85 000555        86 000557
     89 000560        90 000604        91 000606        92 000643        93 000645        94 000674        96 000675
     97 000702       102 000703       103 000716       104 000717       105 000723       106 000756       107 001014
    108 001017       109 001023       110 001054       111 001056       112 001105       114 001106       115 001110
    116 001115       117 001135       118 001167       120 001171       122 001221       123 001223       124 001247
    126 001250       129 001260       130 001275       133 001276       135 001323       136 001343       138 001375
    139 001416       142 001450       143 001510       144 001531       145 001533       146 001562       149 001563
    152 001565       153 001627       154 001633       155 001654       156 001676       159 001677       160 001701
    161 001705       162 001711       164 001712       165 001716       166 001733       167 001734       169 001757
    170 001763       172 001767       173 002006       175 002007       176 002012       177 002043       178 002055
    179 002077       181 002100       182 002104       183 002135       184 002143       186 002150       189 002164
    190 002170       191 002174       192 002202       193 002206       194 002213       195 002217       197 002220
    200 002226       201 002247       202 002271       203 002303       205 002304       207 002310       209 002344
    210 002350       211 002364       212 002423       215 002424       216 002452       217 002454       218 002505
    221 002513       222 002547       223 002576       224 002602       225 002623       226 002625       227 002630
    229 002661       231 002704       232 002705       233 002716       234 002731       235 002742       236 002756
    237 002771       238 003002       239 003016       240 003027       241 003034       243 003063       247 003130
    248 003167       249 003204       250 003235       251 003252       252 003304       253 003310       254 003320
    256 003336       257 003360       258 003372       260 003373       263 003404       264 003420       265 003425
    268 003427       273 003431       274 003437       275 003453       277 003454       282 003456       283 003460
    284 003467       285 003504       288 003512       291 003523       292 003535       293 003543       294 003564
    296 003565       297 003601       300 003602       311 003604       313 003605       314 003627       315 003633
    318 003654       319 003664       320 003670       321 003672       322 003674       323 003701       324 003705
    325 003721       326 003755       327 003757       328 003761       329 003762       330 004025       331 004026


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
