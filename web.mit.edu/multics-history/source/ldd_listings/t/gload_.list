	COMPILATION LISTING OF SEGMENT gload_
	Compiled by: Multics PL/I Compiler, Release 29, of July 28, 1986
	Compiled at: Honeywell Multics Op. - System M
	Compiled on: 12/01/86  1258.0 mst Mon
	    Options: optimize map

        1 /****^  ***********************************************************
        2*        *                                                         *
        3*        * Copyright, (C) Honeywell Information Systems Inc., 1982 *
        4*        *                                                         *
        5*        * Copyright (c) 1972 by Massachusetts Institute of        *
        6*        * Technology and Honeywell Information Systems, Inc.      *
        7*        *                                                         *
        8*        *********************************************************** */
        9 
       10 
       11 /* Initially coded March 1978 by J. A. Bush
       12*   Modified July 1978 by J. A. Bush to add checksum capability
       13*   Modified March 1979 by J. A. Bush to process octal and hex patch cards
       14*   Modified August 1981 by J. A. Bush to load object decks produced by 355map
       15*   Modified June 1983 by G. C. Dixon to add $allow_zero_checksums entrypoint. */
       16 
       17 
       18 /****^  HISTORY COMMENTS:
       19*  1) change(86-10-13,Fakoury), approve(86-10-29,MCR7565),
       20*     audit(86-11-24,Parisek), install(86-12-01,MR12.0-1229):
       21*     Modified to correct errors in patch code.
       22*                                                   END HISTORY COMMENTS */
       23 
       24 
       25 
       26 /* format: style4,ifthenstmt,ifthen,ind3,ll125,lineconind1 */
       27 gload_: proc (deck_ptr, a_load_ptr, a_ld_offset, info_ptr, code);
       28 
       29 dcl  caller char (*);				/* naming of calling program used in warnings. */
       30 dcl  dir char (*);					/* dir/ent of firmware file being loaded. */
       31 dcl  ent char (*);
       32 dcl  deck_ptr ptr;					/* pointer to gcos ssf object deck */
       33 dcl  a_load_ptr ptr;				/* pointer to segment in which to load core image */
       34 dcl  a_ld_offset fixed bin (18);			/* relocation offset */
       35 dcl  info_ptr ptr;					/* ptr to load_data structure */
       36 dcl  code fixed bin (35);				/* standard status code */
       37 
       38 dcl  core_ptr ptr;					/* pointer to core image during loading */
       39 dcl  (ldp, load_ptr) ptr;
       40 dcl  accum bit (36);				/* checksum accumulator */
       41 dcl  allow_zero_checksums bit (1);			/* "1"b => zero checksums are allowed in decks. */
       42 						/* The 0 is replaced by computed checksum. */
       43 dcl  fnp_sw bit (1);				/* "1"b => the fnp entry was called */
       44 dcl  (load_len, ld_offset, dlen) fixed bin (18);		/* words loaded by loader */
       45 dcl  (preface, obj_flag, eof, first_reloc, first_abs, tmr, two_wd) bit (1); /* flags */
       46 dcl  (i, j, k, l, m, n) fixed bin;			/* do loop counters */
       47 dcl  blk_len fixed bin;				/* physical block length counter */
       48 dcl  cbsn fixed bin;				/* current block serial number */
       49 dcl  lst_ld_entry fixed bin;				/* last entry in load table */
       50 dcl  lx fixed bin;					/* load_table index */
       51 dcl  vcb fixed bin;					/* v count bit index */
       52 dcl  last_seq fixed bin;				/* last sequence number */
       53 dcl  last_assigned fixed bin (18);			/* last assigned address in relocatable deck */
       54 dcl  final fixed bin (18);				/* final address for relocation */
       55 dcl  symref_vec fixed bin (18);			/* symref vector location */
       56 dcl  blank_common fixed bin (18);			/* address of blank common, if present */
       57 dcl  blank_common_len fixed bin (18);			/* length of blank common */
       58 dcl  lcwp ptr;					/* pointer to loader control word */
       59 dcl  cptr ptr;					/* pointer to card image */
       60 dcl  idbp ptr;					/* pointer to mpc deck id block */
       61 dcl  p_ptr ptr;					/* patch card ptr */
       62 dcl  obj_buf char (80);				/* char buffer for $ object card */
       63 dcl  card_buf char (80);				/* char buffer for patch card */
       64 dcl  mpc_checksum bit (16);
       65 dcl  dk_rev char (6);
       66 dcl  (pa, tp, mpcp (2)) bit (36);
       67 dcl  (fw_low, fw_high, ovl, a_cnt) fixed bin;
       68 dcl  mem_name char (14);
       69 dcl  data_move char (l) unaligned based;		/* to move data as a character string */
       70 dcl  fnp_seg (0:262143) bit (18) unaligned based (load_ptr);
       71 dcl  ld_wd bit (36) based (core_ptr);
       72 dcl  halfs (2) fixed bin (18) unsigned unaligned based (ldp);
       73 dcl  p_word (2) fixed bin (18) unsigned unaligned based (p_ptr);
       74 dcl  error_table_$fatal_error fixed bin (35) ext;
       75 dcl  (addr, addrel, bin, bit, char, currentsize, fixed, index, length,
       76      ltrim, mod, ptr, rel, rtrim, search, substr, unspec) builtin;
       77 
       78 dcl  1 spec_halfs (2) unaligned based (ldp),
       79        2 sign bit (1),				/* relocation sign bit */
       80        2 rindex bit (vcb),				/* relocation index in load table */
       81        2 addend bit (17 - vcb);			/* relative addend */
       82 
       83 dcl  1 ld_table aligned,				/* load table */
       84          (2 ld_entry (256),				/* array of entries */
       85          3 ld_offset fixed bin (18),			/* program offset */
       86          3 pad1 bit (13),
       87          3 ld_type fixed bin (3)) unaligned;		/* symbol type */
       88 
       89 dcl  bcd_to_ascii_ entry (bit (*), char (*));
       90 dcl  ioa_ entry () options (variable);
       91 dcl  ioa_$rsnnl entry options (variable);
       92 dcl  gload_cksum_ entry (ptr, fixed bin (18), bit (36));
       93 
       94 dcl  1 preface_card based (cptr) aligned,		/* relocatable preface card format */
       95          (2 cw like lcw,				/* close enough to use */
       96        2 checksum bit (36),				/* checksum of columns 1-3 and 7-72 */
       97        2 blk_cmn_len fixed bin (18) unsigned,		/* length of blank common */
       98        2 mb8 bit (1),				/* if on, program should be loaded mod 8 */
       99        2 cob_68 bit (1),				/* if on, program is a cobol 68 deck */
      100        2 reserved bit (1),				/* reserved for future use */
      101        2 sym_x2 bit (15),				/* 2 times the number of symbols */
      102        2 sym_pair (10),				/* symbol definitions */
      103          3 bcd_sym bit (36),				/* 6 char bcd symbol name */
      104          3 sym_pos fixed bin (18) unsigned,		/* relative position of sym within sub pgm */
      105          3 mod8 bit (1),				/* if set, blk comn is set to next mod8 loc */
      106          3 sym_ref_ptr bit (14),			/* ptr to card  and block for symref */
      107          3 sym_type fixed bin (3) unsigned) unaligned;	/* symbol type */
      108 
      109 dcl  1 reloc_card based (cptr) aligned,			/* relocatable binary card format */
      110        2 cw like lcw unaligned,			/* loader control word goes here */
      111        2 checksum bit (36),				/* checksum of columns 1-3 and 7-72 */
      112        2 reloc_data (3) unaligned,			/* relocation data */
      113          3 rloc (7),				/* relocation identifiers */
      114 	 4 reserved bit (1),
      115 	 4 hwds (2) fixed bin (2) unsigned,		/* relocation for each half word */
      116          3 mbz bit (1),
      117        2 data (0:18) bit (36);			/* data words */
      118 
      119 dcl  1 abs_card based (cptr) aligned,			/* absolute binary card format */
      120        2 cw like lcw unaligned,			/* loader control word goes here */
      121        2 checksum bit (36),				/* checksum of columns 1-3 and 7-72 */
      122        2 data (0:22) bit (36);			/* data words */
      123 
      124 dcl  1 bin_card based (cptr) aligned,			/* any binary card */
      125        (2 data (rcw.rsize - 3) bit (36),		/* all words but seq number */
      126        2 edit_name (4) bit (12),			/* bcd data read in binary mode */
      127        2 sn (4),					/* 4 sequence numbers */
      128          3 pad1 bit (2),
      129          3 seq_num bit (10),				/* bcd seq number  read in bin mode */
      130        2 pad2 bit (12)) unaligned;
      131 
      132 dcl  1 fnp_card based (cptr) unaligned,			/* FNP binary card format */
      133        2 cw like lcw,				/* loader control word goes here */
      134        2 checksum bit (36),				/* checksum of columns 1-3 and 7-72 */
      135        2 data (0:44) bit (18);			/* data words */
      136 
      137 dcl  1 lcw unaligned based (lcwp),			/* template for loader control word */
      138        (2 type fixed bin (3),				/* 1 = abs, 2 = reloc, 0 = xfer, 4 = preface */
      139        2 rel_sym fixed bin (6),			/* if reloc, symbol to which card to be loaded */
      140        2 mb5 fixed bin (3),				/* must be 5 for binary card */
      141        2 count fixed bin (6),				/* count of data words on this card */
      142        2 l_addr fixed bin (18)) unsigned;		/* load address */
      143 
      144 dcl  1 o_card based (addr (obj_buf)) aligned,		/* template for an object card */
      145        (2 pad1 char (15),
      146        2 library char (6),				/* col 16 - either "hmpcj1" or "htnd  " */
      147        2 ld_type char (1),				/* col 22, module type */
      148        2 ss_type char (1),				/* col 23, subsystem type */
      149        2 pad2 char (3),
      150        2 m_applic char (1),				/* Multics applicability, non blank means not applicable */
      151        2 pad3 char (15),
      152        2 model char (6),				/* for hmpcj1 decks, controller model # */
      153        2 version char (6),				/* for hmpcj1 decks, model version # */
      154        2 pad4 char (5),
      155        2 assem char (1),				/* "m" for mpc assembler, "g" for gmap */
      156        2 call_name char (6),				/* module call name, or gecall name */
      157        2 ttl_date char (6),				/* date module assembled */
      158        2 edit_name char (4)) unaligned;			/* module edit name */
      159 
      160 dcl  1 o_patch based (addr (card_buf)) aligned,		/* template for octal patch card */
      161        (2 add char (6),				/* patch address */
      162        2 blk1 char (1),
      163        2 octal char (5),				/* either "octal" or "mask " */
      164        2 blk2 char (3),
      165        2 p_fld char (57),				/* variable filed (patch data) */
      166        2 lbl char (4)) unaligned;			/* edit name */
      167 
      168 
      169 dcl  1 h_patch based (addr (card_buf)) aligned,		/* template for hex patch card */
      170        (2 h_add char (6),				/* (c1) hex patch address */
      171        2 cr char (1),				/* (c7) = "c" for cs, "r" for r/w mem */
      172        2 hex char (3),				/* (c8) = "hex" for hex patch */
      173        2 pad1 char (5),
      174        2 inst (2) char (4),				/* (c16) 2 - 4 hex digit instructions */
      175        2 pad2 char (23),
      176        2 rev char (6),				/* (c48) should equal word 2 of deck id block */
      177        2 pad3 char (20),
      178        2 lbl char (4)) unaligned;			/* (c75) = deck edit name */
      179 
      180 dcl  1 id_blk based (idbp) aligned,			/* template for ident block */
      181        (2 ident bit (36),				/* module identification */
      182        2 revision,
      183          3 rev_dot bit (24),				/* char string "rev." */
      184          3 rev bit (12),				/* alpa-numeric revision */
      185        2 type_code bit (18),				/* module type (itr, mdr or firmware) */
      186        2 pad1 bit (18),
      187        2 dk_purpose bit (24),
      188        2 pad2 bit (12),
      189        2 rw_start fixed bin (18) unsigned,		/* offset of read/write overlay */
      190        2 pad3 bit (18),
      191        2 hx_cs_st fixed bin (18) unsigned,		/* rel. start of control store in hex words */
      192        2 hx_rw_st fixed bin (18) unsigned,		/* rel. start of read/write overlay in hex words */
      193        2 pad4 bit (108),
      194        2 mpcbot bit (36)) unaligned;			/* = "MPCBOT" */
      195 
      196 dcl  1 p_array aligned,				/* storage for parsed patch cards */
      197        2 patches (20),				/* 20 patches possible */
      198          (3 rloc (2) bit (1),				/* relocation for both halfs */
      199          3 ppad bit (34),
      200          3 ul (2) bit (18)) unaligned;			/* upper and lower half */
      201 
      202 dcl  1 fw based (load_ptr),				/* A memory overlay */
      203        2 fw_word (fw_low:fw_high) unal,
      204          3 fill1 bit (1) unal,
      205          3 byte1 bit (8) unal,
      206          3 fill2 bit (1) unal,
      207          3 byte2 bit (8) unal;
      208 
      209 dcl  btp (2) bit (18) unaligned based (addr (tp));
      210 dcl  1 load_data based (info_ptr) like gload_data aligned;	/* pertinent info  generated from loader */
      211 
      212 dcl  bcd_obj bit (78) int static options (constant) init
      213       ("53202020202020462241252363"b3);			/* "$      object" in bcd */
      214 dcl  bcd_dkend bit (72) int static options (constant) init
      215       ("532020202020202442254524"b3);			/* "$      dkend" in bcd */
      216 dcl  (max_abs_wds init (22),
      217      max_reloc_wds init (19),
      218      max_fnp_wds init (44)) fixed bin int static options (constant);
      219 
      220       allow_zero_checksums = "0"b;
      221       go to COMMON;
      222 
      223 allow_zero_checksums:
      224    entry (caller, dir, ent, deck_ptr, a_load_ptr, a_ld_offset, info_ptr, code);
      225 
      226       allow_zero_checksums = "1"b;
      227 
      228 COMMON: ld_offset = a_ld_offset;			/* copy load offset */
      229       load_ptr = a_load_ptr;				/* copy load ptr */
      230       preface, obj_flag, eof, first_reloc, first_abs = "0"b;/* initialize some things */
      231       load_data.deck_name, load_data.diagnostic = "";
      232       load_data.sym_cnt = 0;
      233       load_data.deck_type, load_data.text_len = "0"b;
      234       code, load_len, symref_vec, last_seq = 0;
      235       prptr = deck_ptr;				/* set first block pointer */
      236       cbsn = bcw.bsn;				/* load block serial number counter */
      237 
      238       do while (^eof);				/* iterate through entire deck */
      239          lrptr = addr (gc_phy_rec.gc_phy_rec_data (1));	/* get pointer to first logical record */
      240          blk_len = 0;				/* initialize block length counter */
      241          do while (blk_len < bcw.blk_size);
      242 	  if rcw.media_code = 2 then do;		/* bcd card image */
      243 	     if substr (gc_log_rec_bits, 1, 78) = bcd_obj then do; /* object card */
      244 	        call bcd_to_ascii_ (gc_log_rec_bits, obj_buf); /* convert to ascii */
      245 	        obj_flag = "1"b;
      246 	        load_data.deck_name = o_card.edit_name;	/* set name for user */
      247 	        call CK_TD_LOAD;			/* go add in relocation (if required) */
      248 	     end;
      249 	     else if substr (gc_log_rec_bits, 1, 72) = bcd_dkend then /* dkend card */
      250 	        eof = "1"b;				/* set flag to get out */
      251 	     else do;				/* must be patch card or bad bcd card */
      252 	        call CK_PATCH;			/* go check if valid patch */
      253 	        if code ^= 0 then return;		/* not valid patch, quit now */
      254 	     end;
      255 	  end;
      256 	  else if rcw.media_code = 1 then do;		/* bin card image */
      257 	     cptr = addr (gc_log_rec.gc_log_rec_data);	/* set card pointer */
      258 	     if ^obj_flag then do;			/* we must have object card first */
      259 	        code = error_table_$fatal_error;	/* cards out of sequence */
      260 	        call ioa_$rsnnl ("Binary card at ^p, appears before $ object card",
      261 	         load_data.diagnostic, i, cptr);
      262 	        return;
      263 	     end;
      264 	     if reloc_card.mb5 ^= 5 then do;		/* not column binary card */
      265 	        code = error_table_$fatal_error;
      266 	        call ioa_$rsnnl ("Card type - ^12.3b at ^p, is not a column binary card",
      267 	         load_data.diagnostic, i, cptr -> ld_wd, cptr);
      268 	        return;
      269 	     end;
      270 	     if reloc_card.type > 4 then do;		/* illegal card type */
      271 	        code = error_table_$fatal_error;
      272 	        call ioa_$rsnnl ("Card type - ^12.3b at ^p, is not a loadable binary card",
      273 	         load_data.diagnostic, i, cptr -> ld_wd, cptr);
      274 	        return;
      275 	     end;
      276 	     j = 0;
      277 	     do i = 1 to 4;				/* 4 digits of seq number */
      278 	        j = j * 10 + (index (bin_card.seq_num (i), "1"b) - 1);
      279 	     end;
      280 	     if j ^= last_seq + 1 then do;		/* seq num error */
      281 	        code = error_table_$fatal_error;
      282 	        call ioa_$rsnnl ("Binary card sequence error at ^p. Sequence number is ^d; S/B ^d",
      283 	         load_data.diagnostic, i, cptr, j, last_seq + 1);
      284 	        return;
      285 	     end;
      286 	     last_seq = j;
      287 	     if abs_card.type ^= 0 then		/* if not absolute xfer card */
      288 	        if CKSUM_CARD () then return;		/* if checksum error return with error */
      289 	     if fnp_sw then
      290 	        call DO_FNP;			/* go load fnp deck */
      291 	     else if preface_card.type = 4 then		/* preface card */
      292 	        call DO_PREFACE;
      293 	     else if abs_card.type < 2 then		/* absolute card */
      294 	        call DO_ABS;
      295 	     else if reloc_card.type < 4 then		/* relocatable card */
      296 	        call DO_RELOC;
      297 
      298 	     else do;
      299 	        code = error_table_$fatal_error;	/* unrecognizeable card type */
      300 	        call ioa_$rsnnl ("Card type - ^12.3b at ^p, is not recognizable by loader",
      301 	         load_data.diagnostic, i, cptr -> ld_wd, cptr);
      302 	     end;
      303 	     if code ^= 0 then return;		/* must have had error */
      304 	  end;
      305 	  else if rcw.media_code = 0 & rcw.file_mark = 15 then eof = "1"b; /* if eof */
      306 	  else do;				/* card type we do not process */
      307 	     code = error_table_$fatal_error;		/* illegal type */
      308 	     call ioa_$rsnnl ("Logical record media code - ^o at ^p, is not processed by loader",
      309 	      load_data.diagnostic, i, rcw.media_code, lrptr);
      310 	     return;
      311 	  end;
      312 	  blk_len = blk_len + rcw.rsize + 1;		/* increment running block length */
      313 	  lrptr = addrel (lrptr, currentsize (gc_log_rec)); /* set next logical record */
      314          end;
      315          if ^eof then do;				/* if we haven't reached last block */
      316 	  prptr = addrel (prptr, bcw.blk_size + 1);	/* set phy rcd ptr to nxt word */
      317 	  if bcw.bsn = 0 then			/* if nxt blk not appended... */
      318 	     prptr = ptr (prptr, bin (rel (prptr)) + (320 - mod (bin (rel (prptr)), 320)));
      319 	  if bcw.bsn ^= cbsn + 1 then do;		/* block serial number error */
      320 	     code = error_table_$fatal_error;
      321 	     call ioa_$rsnnl ("Block serial number error at ^p. Block serial number is ^o; S/B ^o",
      322 	      load_data.diagnostic, i, prptr, bcw.bsn, cbsn + 1);
      323 	     return;
      324 	  end;
      325 	  cbsn = cbsn + 1;				/* increment current block serial number */
      326          end;
      327       end;
      328       dlen = load_len;				/* save loaded length */
      329       if preface then				/* if relocatable */
      330          load_len = last_assigned;			/* offset already added in */
      331       else load_len = load_len + ld_offset;
      332       load_data.text_len = bit (load_len);		/* set length for user */
      333       accum = "0"b;					/* initialize checksum accumulator */
      334       call gload_cksum_ (load_ptr, dlen, accum);		/* calculate deck checksum */
      335       load_data.checksum = accum;			/* and save for user */
      336 
      337 
      338 
      339 /* DO_RELOC - internal procedure to process relocatable binary cards */
      340 
      341 DO_RELOC: proc;
      342 
      343       if ^first_reloc then do;
      344          first_reloc = "1"b;
      345          if ^preface then do;				/* must have preface card first */
      346 	  code = error_table_$fatal_error;		/* no preface card */
      347 	  call ioa_$rsnnl ("Relocatable text card at ^p, appears before preface card",
      348 	   load_data.diagnostic, i, cptr);
      349 	  return;
      350          end;
      351          if blank_common_len ^= 0 then do;		/* we have blank common to assign */
      352 	  blank_common = last_assigned;		/* set address of blank common */
      353 	  last_assigned = last_assigned + blank_common_len; /* set last address */
      354          end;
      355          lst_ld_entry = lx;				/* set last load table entry */
      356       end;
      357       lcwp = addr (reloc_card.cw);			/* set initial control word ptr */
      358       a_cnt = lcw.count;				/* load control word count */
      359       l, m, n = 0;					/* start at first data word */
      360       tmr, two_wd = "0"b;				/* reset flags */
      361       if lcw.rel_sym ^= 0 | lcw.type = 3 then do;		/* do we have an addend? */
      362          call ADD_COMMON;				/* yes */
      363          if code ^= 0 then return;			/* return if some problem */
      364       end;
      365       else core_ptr = addrel (load_ptr, lcw.l_addr);
      366       ldp = addr (reloc_card.data (m));			/* set address of first data word */
      367       do i = 1 to 3 while (^tmr);			/* relocate each word */
      368          do j = 1 to 7 while (^tmr);
      369 	  if unspec (reloc_data (i).rloc (j)) = "0"b then /* if no relocation this word */
      370 	     ld_wd = ldp -> ld_wd;			/* move the whole thing as is */
      371 	  else do k = 1 to 2;			/* relocate each half */
      372 	     go to reloc (reloc_data (i).rloc (j).hwds (k));
      373 reloc (0):					/* absolute, copy as is */
      374 	     core_ptr -> halfs (k) = halfs (k);
      375 	     go to reloc_end;
      376 reloc (1):					/* relocate relative to load address */
      377 	     core_ptr -> halfs (k) = halfs (k) + ld_offset;
      378 	     go to reloc_end;
      379 reloc (2):					/* relocate relative to beginning of blank common */
      380 	     core_ptr -> halfs (k) = halfs (k) + blank_common;
      381 	     go to reloc_end;
      382 reloc (3):					/* special relocation */
      383 	     lx = fixed (rindex (k), 7);		/* form load table index */
      384 	     if ld_entry (lx).ld_type ^= 5 then do;	/* if not symref */
      385 	        if fixed (addend (k), 12) ^= -1 then	/* if we do not have to use next word */
      386 		 if ^sign (k) then			/* and not minus */
      387 		    final = ld_entry (lx).ld_offset + fixed (addend (k), 12);
      388 		 else final = ld_entry (lx).ld_offset - fixed (addend (k), 12);
      389 	        else do;				/* Must use the nxt word */
      390 		 two_wd = "1"b;
      391 		 if ^sign (k) then			/* if positive number */
      392 		    final = ld_entry (lx).ld_offset + addrel (ldp, 1) -> halfs (k);
      393 		 else final = ld_entry (lx).ld_offset - addrel (ldp, 1) -> halfs (k);
      394 	        end;
      395 	        core_ptr -> halfs (k) = final;		/* set in load area */
      396 	     end;
      397 	     else do;				/* sym ref, set up mme gebort */
      398 	        if symref_vec = 0 then do;		/* if we havn't set up vector yet */
      399 		 symref_vec = last_assigned;		/* set it now */
      400 		 last_assigned = last_assigned + 2;	/* add vector to total length */
      401 		 ptr (load_ptr, symref_vec) -> ld_wd =	/* set first word in vector */
      402 		  "004301236007"b3;			/* to ldq =hol1,dl */
      403 		 ptr (load_ptr, symref_vec + 1) -> ld_wd = /* set up second word */
      404 		  "000010001000"b3;			/* to mme gebort */
      405 	        end;
      406 	        if k = 1 then do;			/* if upper half reloc */
      407 		 core_ptr -> halfs (1) = symref_vec;	/* set up a tsx7 to */
      408 		 core_ptr -> halfs (2) = bin ("707000"b3, 18); /* symref_vector */
      409 		 k = 2;				/* set k so we don't come back */
      410 	        end;
      411 	        else core_ptr -> halfs (k) = symref_vec;	/* if lower set address of vector */
      412 	        if fixed (addend (k), 12) = -1 then	/* if two word entry */
      413 		 two_wd = "1"b;			/* skip second word */
      414 	     end;
      415 reloc_end:
      416 	  end;
      417 	  core_ptr = addrel (core_ptr, 1);
      418 	  ldp = addrel (ldp, 1);			/* increment deck ptr */
      419 	  m = m + 1;
      420 	  if two_wd then do;			/* if two word addend */
      421 	     two_wd = "0"b;				/* reset flag */
      422 	     ldp = addrel (ldp, 1);			/* skip next word */
      423 	     m = m + 1;
      424 	  end;
      425 	  if m = a_cnt then do;			/* control word exhausted? */
      426 	     l = l + lcw.count + n;			/* increment total load count */
      427 	     if l = max_reloc_wds then tmr = "1"b;	/* if max length card */
      428 	     else if (l < max_reloc_wds & reloc_card.data (l) = "0"b) then
      429 	        tmr = "1"b;				/* if no more control words */
      430 	     else do;				/* more control words + data */
      431 	        lcwp = addr (reloc_card.data (l));	/* set control word ptr */
      432 	        a_cnt = lcw.count;			/* load control word count */
      433 	        m = 0;				/* reset load index */
      434 	        n = 1;				/* set control word skip */
      435 	        if lcw.rel_sym ^= 0 | lcw.type = 3 then do; /* do we have an addend? */
      436 		 call ADD_COMMON;			/* yes */
      437 		 if code ^= 0 then return;		/* return if some problem */
      438 	        end;
      439 	        else core_ptr = addrel (load_ptr, lcw.l_addr);
      440 	        ldp = addrel (ldp, 1);		/* increment load ptr past control word */
      441 	     end;
      442 	  end;
      443 
      444          end;
      445       end;
      446 
      447    end DO_RELOC;
      448 
      449 
      450 
      451 /* DO_PREFACE - internal procedure to process binary preface cards */
      452 
      453 DO_PREFACE: proc;
      454 
      455       if ^preface then do;				/* if we haven't been here already */
      456          vcb = preface_card.rel_sym;			/* set vcb index */
      457          if preface_card.mb8 then			/* if pgm to be loaded mod 8 */
      458 	  if mod (ld_offset, 8) ^= 0 then		/* and if not already mod 8 */
      459 	     ld_offset = ld_offset + (8 - mod (ld_offset, 8));
      460          load_len = preface_card.l_addr;
      461          last_assigned = load_len + ld_offset;		/* set initial value */
      462          lx = 0;					/* initialize load table index */
      463          blank_common_len = preface_card.blk_cmn_len;	/* save blank common length */
      464          load_data.deck_type = "1"b;			/* relocatable deck */
      465          preface = "1"b;
      466       end;
      467       do i = 1 to (preface_card.count - 1) / 2 while (bcd_sym (i) ^= "0"b);
      468          call bcd_to_ascii_ (bcd_sym (i), load_data.definition (i + load_data.sym_cnt).symbol);
      469          j, load_data.definition (i + load_data.sym_cnt).sym_type = sym_pair (i).sym_type; /* set symbol type */
      470          if j = 0 | j = 1 then do;			/* symdefs */
      471 	  final = sym_pair (i).sym_pos + ld_offset;	/* add in offset */
      472 	  load_data.definition (i + load_data.sym_cnt).offset = bit (final);
      473          end;
      474          else if j = 3 then
      475 	  load_data.definition (i + load_data.sym_cnt).offset = bit (sym_pair (i).sym_pos, 18);
      476          else if j ^= 2 then do;			/* Must be common or symref, if not cobol seg  */
      477 	  lx = lx + 1;				/* increment load table index */
      478 	  ld_entry (lx).ld_type = j;			/* set symbol type in load table */
      479 	  if j ^= 5 then do;			/* if not symref */
      480 	     if sym_pair (i).mod8 then		/* if mod 8 required */
      481 	        if mod (last_assigned, 8) ^= 0 then	/* set it mod 8 if necessary */
      482 		 last_assigned = last_assigned + (8 - mod (last_assigned, 8));
      483 	     ld_entry (lx).ld_offset = last_assigned;	/* set address in load table */
      484 	     load_data.definition (i + load_data.sym_cnt).offset = bit (ld_entry (lx).ld_offset);
      485 	     last_assigned = last_assigned + sym_pair (i).sym_pos;
      486 	  end;
      487 	  else load_data.definition (i + load_data.sym_cnt).offset = "0"b;
      488          end;
      489       end;
      490       load_data.sym_cnt = load_data.sym_cnt + (i - 1);	/* set new load_data.sym_cnt */
      491 
      492    end DO_PREFACE;
      493 
      494 
      495 
      496 /* DO_ABS - internal procedure to process absolute binary cards */
      497 
      498 DO_ABS: proc;
      499 
      500       lcwp = addr (abs_card.cw);			/* set initial control word ptr */
      501       go to absc (lcw.type);				/* process proper card type */
      502 
      503 absc (0):						/* absolute binary xfer card */
      504 
      505       load_data.definition (1).symbol = "xfer  ";		/* set symbol and xfer */
      506       load_data.definition (1).offset = bit (lcw.l_addr, 18); /* address for user */
      507       load_data.sym_cnt = 1;				/* set symbol count for user */
      508       return;
      509 
      510 absc (1):						/* absolute binary text card */
      511       if ^first_abs then do;				/* if first time through */
      512          first_abs = "1"b;
      513          ld_offset = lcw.l_addr;			/* set offset from zero */
      514       end;
      515       m = 0;					/* start with first data word */
      516       tmr = "0"b;
      517       do while (^tmr);				/* do while there is more data */
      518          ldp = addr (abs_card.data (m));		/* set load address */
      519          core_ptr = addrel (load_ptr, lcw.l_addr);	/* set core address */
      520          l = lcw.count * 4;				/* generate character count */
      521          core_ptr -> data_move = ldp -> data_move;	/* move the data */
      522          load_len = load_len + lcw.count;		/* increment loaded length */
      523          m = m + lcw.count;				/* increment total count, this card */
      524          if m = max_abs_wds then tmr = "1"b;		/* if max length card */
      525          else if (m < max_abs_wds & abs_card.data (m) = "0"b) then
      526 	  tmr = "1"b;				/* if no more control wds */
      527          else do;					/* more control wds + data */
      528 	  lcwp = addr (abs_card.data (m));		/* set control word ptr */
      529 	  m = m + 1;				/* increment data word index */
      530          end;
      531       end;
      532       return;
      533 
      534    end DO_ABS;
      535 
      536 
      537 /* DO_FNP - internal subroutine to load object decks generated by the 355map assembler */
      538 
      539 DO_FNP: proc;
      540 
      541       lcwp = addr (fnp_card.cw);			/* set initial control word ptr */
      542       go to fnpc (lcw.type);				/* process proper card type */
      543 
      544 fnpc (0):						/* absolute binary xfer card */
      545       load_data.definition (1).symbol = "xfer  ";		/* set symbol and xfer */
      546       load_data.definition (1).offset = bit (lcw.l_addr, 18); /* address for user */
      547       load_data.sym_cnt = 1;				/* set symbol count for user */
      548       return;
      549 
      550 fnpc (1):						/* absolute binary text card */
      551       m = 0;					/* set word index */
      552       core_ptr = addr (fnp_seg (lcw.l_addr));		/* set ptr to move */
      553       if ^first_abs | fnp_seg (lcw.l_addr) = "000000"b3 then do;
      554          l = 4;
      555          if ^first_abs then
      556 	  core_ptr -> data_move = o_card.edit_name;	/* move the data */
      557          first_abs = "1"b;
      558       end;
      559       core_ptr = addrel (core_ptr, 1);			/* set ptr to move */
      560       go to fnp_com;				/* and go to common code */
      561 
      562 fnpc (2):						/* relocatable binary text card */
      563       m = 5;					/* set word index to ignore relocation */
      564       core_ptr = addr (fnp_seg (lcw.l_addr + ld_offset));	/* set ptr to move */
      565 
      566 fnp_com:						/* common to type 1 and 2 text cards */
      567       tmr = "0"b;
      568       do while (^tmr);				/* do while there is more data */
      569          ldp = addr (fnp_card.data (m));		/* move ptr to nxt data field */
      570          l = lcw.count * 2;				/* generate character count */
      571          load_len = load_len + lcw.count;		/* increment loaded length */
      572          core_ptr -> data_move = ldp -> data_move;	/* move the data */
      573          m = m + lcw.count;				/* increment total count, this card */
      574          if m = max_fnp_wds then tmr = "1"b;		/* if max length card */
      575          else if (m < max_fnp_wds & fnp_card.data (m) = "0"b) then
      576 	  tmr = "1"b;				/* if no more control wds */
      577          else do;
      578 	  lcwp = addr (fnp_card.data (m));		/* set new control word ptr */
      579 	  m = m + 2;				/* adjust index for control word */
      580          end;
      581       end;
      582       return;
      583 
      584 
      585 fnpc (4):						/*  preface card */
      586       preface, load_data.deck_type = "1"b;		/* relocatable deck */
      587       last_assigned = preface_card.l_addr + ld_offset;	/* set length */
      588       return;					/* thats all for now */
      589 
      590    end DO_FNP;
      591 
      592 
      593 /* ADD_COMMON - internal subroutine to add in common symbol reference from preface card */
      594 
      595 ADD_COMMON: proc;
      596 
      597       lx = lcw.rel_sym;
      598       if lcw.type = 3 then				/* if we must */
      599          lx = lx + 64;
      600       if lx > lst_ld_entry then do;			/* OH OH */
      601          code = error_table_$fatal_error;		/* more symbols than we have */
      602          call ioa_$rsnnl ("Card type ^12.3b at ^p refs. symbol # ^d, but only ^d symbols are defined",
      603 	load_data.diagnostic, i, lcwp -> ld_wd, lcwp, lx, lst_ld_entry);
      604       end;
      605       else core_ptr = addrel (load_ptr, ld_entry (lx).ld_offset + lcw.l_addr); /* set core ptr */
      606 
      607    end ADD_COMMON;
      608 
      609 /* CKSUM_CARD - internal procedure to compute and check checksum on a binary card */
      610 
      611 CKSUM_CARD: proc returns (bit (1));
      612 
      613       accum = bin_card.data (1);			/* add in first word */
      614       call gload_cksum_ (addrel (cptr, 2), 22, accum);	/* add in rest of card - cksum word and last word */
      615       if accum ^= reloc_card.checksum then do;
      616          if allow_zero_checksums & reloc_card.checksum = "0"b then do;
      617 	  call ioa_ ("^a: ZERO checksum at ^p; Checksum S/B ^12.3b.
      618 Loading ^a>^a.  Checksum will be adjusted.",
      619 	   caller, cptr, accum, dir, ent);
      620 	  reloc_card.checksum = accum;
      621 	  return ("0"b);
      622          end;
      623          else do;
      624 	  code = error_table_$fatal_error;		/* if checksum error */
      625 	  call ioa_$rsnnl ("Checksum error at ^p. Checksum is ^12.3b; S/B ^12.3b.",
      626 	   load_data.diagnostic, i, cptr, reloc_card.checksum, accum);
      627 	  return ("1"b);				/* return error */
      628          end;
      629       end;
      630       else return ("0"b);				/* checksum ok */
      631 
      632    end CKSUM_CARD;
      633 
      634 
      635 
      636 /* CK_TD_LOAD - internal procedure to special case "hmpcj1" and "htnd" library decks */
      637 
      638 CK_TD_LOAD: proc;
      639 
      640       if o_card.assem = " " then do;			/* if this is true, it is a 355map deck */
      641          fnp_sw = "1"b;				/* set indicator switch */
      642          return;					/* thats all we need here */
      643       end;
      644       else fnp_sw = "0"b;
      645       if o_card.library = "hmpcj1" | o_card.library = "htnd  " then do;
      646          if o_card.ld_type = "d" then			/* if data deck */
      647 	  ld_offset = 0;				/* no relocation, load in place */
      648          else if o_card.ld_type = "p" then do;		/* if program deck */
      649 	  ld_offset = 72;				/* offset 110 oct */
      650 	  load_ptr = addrel (load_ptr, 72);		/* load at offset 110 */
      651          end;
      652          else if o_card.ld_type = "r" then do;		/* if relocatable deck */
      653 	  load_ptr = addrel (load_ptr, 72);		/* add 110 offset */
      654 	  ld_offset = fixed (rel (load_ptr), 18) - ld_offset; /* and subtract base */
      655          end;
      656       end;
      657       else load_ptr = addrel (load_ptr, ld_offset);	/* if not special case, addin  ld offset */
      658 
      659    end CK_TD_LOAD;
      660 
      661 
      662 /* CK_PATCH - internal procedure to check a bcd card image for a ligit patch card */
      663 
      664 CK_PATCH: proc;
      665 
      666       call bcd_to_ascii_ (gc_log_rec_bits, card_buf);	/* convert to ascii */
      667       if o_patch.octal = "octal" | o_patch.octal = "mask " then /* if octal patch card */
      668          call O_PATCH;				/* go process it */
      669       else if h_patch.hex = "hex" then			/* if hex patch card */
      670          call H_PATCH;				/* go process it */
      671       else do;					/* unrecognized bcd card image */
      672          code = error_table_$fatal_error;		/* Illegal bcd card */
      673          call ioa_$rsnnl ("Bcd card at ^p, is not $ object, $ dkend, or valid patch - ""^a""",
      674 	load_data.diagnostic, i, addrel (lrptr, 1), card_buf);
      675       end;
      676 
      677    end CK_PATCH;
      678 
      679 
      680 
      681 /* O_PATCH - internal procedure to process octal and mask octal patch cards */
      682 
      683 O_PATCH: proc;
      684 
      685       if o_patch.lbl ^= o_card.edit_name then		/* edit names don't agree */
      686          call PATCH_ERR ("octal", "edit name does not agree with edit name from $ object card");
      687       else if ^CV_AB (8, o_patch.add, pa) then		/* if error in address */
      688          call PATCH_ERR ("octal", "error converting octal address");
      689       if code ^= 0 then return;			/* if error already */
      690       p_ptr = addrel (load_ptr, bin (pa, 18));		/* set patch address */
      691       l = 1;					/* set scan position to 1 */
      692       tmr = "0"b;					/* reset terminate condition */
      693       do i = 1 to 20 while (^tmr);			/* get patches into patch array */
      694          patches (i).rloc (1), patches (i).rloc (2) = "0"b;
      695          if substr (o_patch.p_fld, l, 1) = "r" then do;	/* if left half relocation */
      696 	  patches (i).rloc (1) = "1"b;		/* set relocation indicator */
      697 	  l = l + 1;				/* update field position */
      698          end;
      699          else if index ("01234567", substr (o_patch.p_fld, l, 1)) = 0 then do;
      700 	  call PATCH_ERR ("octal", "illegal relocation indicator in octal patch " || char (i));
      701 	  return;
      702          end;
      703          j = search (substr (o_patch.p_fld, l), ", ");	/* search for comma or blank */
      704          k = j - 1;					/* set  to field length */
      705          if substr (o_patch.p_fld, l + k, 1) = " " | l + j >= length (o_patch.p_fld) then
      706 	  tmr = "1"b;				/* if at end of patch field */
      707          if substr (o_patch.p_fld, l + k - 1, 1) = "r" then do; /* if right half relocation */
      708 	  patches (i).rloc (2) = "1"b;		/* set relocation indicator */
      709 	  k = k - 1;				/* subtract 1 from fild length */
      710          end;
      711          else if index ("01234567", substr (o_patch.p_fld, l + k - 1, 1)) = 0 then do;
      712 	  call PATCH_ERR ("octal", "illegal relocation indicator in octal patch " || char (i));
      713 	  return;
      714          end;
      715          if ^CV_AB (8, substr (o_patch.p_fld, l, k), tp) then do;
      716 	  call PATCH_ERR ("octal", "error converting octal patch " || char (i));
      717 	  return;
      718          end;
      719          patches (i).ul (*) = btp;			/* copy patch data */
      720          l = l + k + 1;				/* update string start */
      721       end;
      722       do j = 1 to i - 1;				/* now do the patching */
      723          do k = 1 to 2;				/* apply patch to each half word */
      724 	  if patches (j).rloc (k) then		/* if relocation this half... */
      725 	     p_word (k) = bin (patches (j).ul (k), 18) + ld_offset; /* add in relocation */
      726 	  else p_word (k) = bin (patches (j).ul (k), 18); /* otherwise just use value as is */
      727          end;
      728          p_ptr = addrel (p_ptr, 1);			/* increment to next word */
      729       end;
      730 
      731    end O_PATCH;
      732 
      733 
      734 
      735 /* H_PATCH - internal procedure to process hexadecimal patch cards for mpc decks */
      736 
      737 H_PATCH: proc;
      738 
      739       idbp = ptr (load_ptr, last_assigned - 10);		/* set ptr to id blk */
      740       call bcd_to_ascii_ (bit (id_blk.revision.rev), dk_rev); /* convert rev to ascii */
      741 
      742 /* do some consistancy checks on the hex patch card */
      743 
      744       if h_patch.cr ^= "c" & h_patch.cr ^= "r" then	/* if not for control store of r/w mem */
      745          call PATCH_ERR ("hex", "collum 7 must be ""c"" or ""r""");
      746       else if o_card.assem ^= "m" then			/* if not assembled by mpc assembler */
      747          call PATCH_ERR ("hex", "object deck to be patched not produced with mpc assembler");
      748       else if h_patch.lbl ^= o_card.edit_name then	/* edit names don't agree */
      749          call PATCH_ERR ("hex", "edit name does not agree with edit name from $ object card");
      750       else if h_patch.rev ^= dk_rev then		/* revisions don't agree */
      751          call PATCH_ERR ("hex", "revision does not agree with revision from ident block");
      752       else if h_patch.cr = "r" & id_blk.rw_start = 0 then	/* no r/w memory overlay */
      753          call PATCH_ERR ("hex", "r/w memory overlay non existant");
      754       else if ^CV_AB (16, h_patch.h_add, pa) then		/* error converting address */
      755          call PATCH_ERR ("hex", "error converting hex address");
      756       else if substr (unspec (pa), 36, 1) & h_patch.inst (2) ^= "" then /* odd add and 2 patches */
      757          call PATCH_ERR ("hex", "only one patch allowed for odd address");
      758       else if ^CV_AB (16, h_patch.inst (1), mpcp (1)) then
      759          call PATCH_ERR ("hex", "error converting first hex patch");
      760       else if h_patch.inst (2) ^= "" then		/* if 2nd inst exists */
      761          if ^CV_AB (16, h_patch.inst (2), mpcp (2)) then	/* error converting 2nd inst */
      762 	  call PATCH_ERR ("hex", "error converting second hex patch");
      763       if code ^= 0 then return;			/* if error already return */
      764       if h_patch.cr = "r" then do;			/* if patching r/w memory */
      765          fw_low = id_blk.hx_rw_st;			/* set diminsion limits */
      766          ovl = last_assigned - id_blk.rw_start - 10;
      767          mem_name = "read/write";
      768       end;
      769       else do;					/* patching control store */
      770          fw_low = id_blk.hx_cs_st;			/* set diminsion limits */
      771          if id_blk.rw_start = 0 then			/* if no r/w mem overlay */
      772 	  ovl = last_assigned - 10;
      773          else ovl = id_blk.rw_start;
      774          mem_name = "control store";
      775       end;
      776       fw_high = fw_low + 2 * ovl - 1;			/* compute high range in 16 bit words */
      777       if bin (pa, 18) < fw_low | bin (pa, 18) > fw_high - 2 | /* check patch card range */
      778        (h_patch.inst (2) ^= "" & bin (pa, 18) + 1 > fw_high - 2) then do;
      779          code = error_table_$fatal_error;		/* set error code */
      780          call ioa_$rsnnl ("Hex patch address(s) not within ^a memory range of ^.4b to ^.4b^/""^a""",
      781 	load_data.diagnostic, i, mem_name, bit (bin (fw_low, 16), 16),
      782 	bit (bin (fw_high - 2, 16), 16), card_buf);
      783          return;
      784       end;
      785       call MPC_CHECKSUM;				/* compute initial checksum */
      786       if GET_WORD (fw_high - 1) ^= mpc_checksum then do;	/* error in initial mpc_checksum */
      787          code = error_table_$fatal_error;
      788          call ioa_$rsnnl ("Checksum error detected in ^a memory before hex patch at ^p applied",
      789 	load_data.diagnostic, i, mem_name, addrel (lrptr, 1));
      790          return;
      791       end;
      792 
      793 /* now apply the patches */
      794 
      795       do i = 1 to 2 while (h_patch.inst (i) ^= "");
      796          j = bin (pa, 18) - 1 + i;
      797          call PUT_WORD (j, bit (bin (mpcp (i), 16), 16));
      798       end;
      799       call MPC_CHECKSUM;				/* compute new mpc_checksum */
      800       call PUT_WORD (fw_high - 1, mpc_checksum);		/* and store */
      801 
      802    end H_PATCH;
      803 
      804 
      805 
      806 /* PATCH_ERR - subroutine to set diagnostic for patch card error */
      807 
      808 PATCH_ERR: proc (type, mess);
      809 
      810 dcl  (type, mess) char (*);
      811 
      812       code = error_table_$fatal_error;			/* set error code */
      813       call ioa_$rsnnl ("Error in ^a patch card at ^p: ^a.^/""^a""", load_data.diagnostic, i,
      814        type, addrel (lrptr, 1), mess, card_buf);
      815 
      816    end PATCH_ERR;
      817 
      818 /* CV_AB - function to convert ascii characters to binary */
      819 
      820 CV_AB: proc (base, ain, cv) returns (bit (1));
      821 
      822 dcl  ain char (*);
      823 dcl  cv bit (36);
      824 dcl  v fixed bin (36);
      825 dcl  (base, i, j) fixed bin;
      826 dcl  aw char (32);
      827 
      828       v = 0;					/* initialize bin number */
      829       aw = "";					/* initialize working storage */
      830       aw = ltrim (ain);				/* strip off leading white space */
      831       do i = 1 to length (rtrim (aw));
      832          j = index (substr ("0123456789abcdef", 1, base), substr (aw, i, 1)); /* convert char to bin */
      833          if j = 0 then return ("0"b);			/* return error */
      834          v = base * v + j - 1;			/* add in current value */
      835          if base = 16 then				/* if converting hex */
      836 	  if v > 1111111111111111b then		/* if number not in range 0-FFFF */
      837 	     return ("0"b);
      838       end;
      839       cv = bit (v, 36);				/* return converted number */
      840       return ("1"b);				/* return good */
      841 
      842    end CV_AB;
      843 
      844 
      845 
      846 /* Procedure that can reconstruct a firmware word */
      847 
      848 GET_WORD: proc (i) returns (bit (16));
      849 
      850 
      851 dcl  i fixed bin;
      852 
      853       return (fw.byte1 (i) || fw.byte2 (i));
      854 
      855    end GET_WORD;
      856 
      857 /* Procedure which can store a firmware word */
      858 
      859 PUT_WORD: proc (i, new_word);
      860 
      861 dcl  i fixed bin;
      862 dcl  new_word bit (16);
      863 
      864       fw.byte1 (i) = substr (new_word, 1, 8);
      865       fw.byte2 (i) = substr (new_word, 9, 8);
      866       return;
      867 
      868    end PUT_WORD;
      869 
      870 /* Procedure that can compute a mpc_checksum from a mpc memory image */
      871 
      872 MPC_CHECKSUM: proc;
      873 
      874 dcl  sum fixed bin (35);
      875 dcl  i fixed bin;
      876 
      877       sum = 0;
      878       do i = fw_low to fw_high - 2;
      879          sum = sum + bin (GET_WORD (i), 16);
      880          do while (sum > 1111111111111111b);
      881 	  sum = sum - 10000000000000000b;
      882 	  sum = sum + 1;
      883          end;
      884       end;
      885       sum = -sum;
      886       mpc_checksum = substr (unspec (sum), 21);		/* Get last 16 bits */
      887       return;
      888 
      889    end MPC_CHECKSUM;
      890 
  1     1 
  1     2 /* BEGIN INCLUDE FILE gload_data.incl.pl1 */
  1     3 /* created 9/29/78 by James A. Bush */
  1     4 
  1     5 dcl 1 gload_data aligned,				/* pertinent info  generated from gload_ */
  1     6    (2 deck_name char (4),				/* name from columns 73-76 of $ object card */
  1     7     2 deck_type bit (1),				/* "0"b = absolute, "1"b = relocatable */
  1     8     2 sym_cnt fixed bin (16),				/* count of valid symbols */
  1     9     2 text_len bit (18),				/* length in words including load offset */
  1    10     2 checksum bit (36),				/* checksum of loaded deck */
  1    11     2 diagnostic char (200),				/* loader diagnostic */
  1    12     2 definition (128),				/* array of definitions */
  1    13       3 symbol char (6),				/* symbol name */
  1    14       3 pad1 bit (18),
  1    15       3 offset bit (18),				/* symbol offset in text */
  1    16       3 pad2 bit (14),
  1    17       3 sym_type fixed bin (3)) unaligned;		/* type of symbol (0 - 7) */
  1    18 
  1    19 /* END INCLUDE FILE gload_data.incl.pl1 */
  1    20 
      891 
  2     1 
  2     2 /* BEGIN INCLUDE FILE: gcos_ssf_records.incl.pl1 */
  2     3 
  2     4 /* Created by J. A. Bush 05/07/80 */
  2     5 
  2     6 dcl  prptr ptr;					/* GCOS physical record pointer */
  2     7 dcl  lrptr ptr;					/* GCOS logical record pointer */
  2     8 
  2     9 dcl 1 gc_phy_rec based (prptr) aligned,			/* GCOS ssf format (physical record) */
  2    10     2 bcw unaligned,				/* block control word */
  2    11      (3 bsn fixed bin (18),				/* block serial number */
  2    12       3 blk_size fixed bin (18)) unsigned,		/* block size (-bcw) */
  2    13     2 gc_phy_rec_data (0 refer (gc_phy_rec.bcw.blk_size)) bit (36);
  2    14 
  2    15 dcl 1 gc_log_rec based (lrptr) aligned,			/* GCOS ssf logical record format */
  2    16     2 rcw unaligned,				/* record control word */
  2    17      (3 rsize fixed bin (18),				/* size of rcd (-rcw) */
  2    18       3 nchar_used fixed bin (2),			/* characters used in last word */
  2    19       3 file_mark fixed bin (4),			/* file mark if rsize = 0 */
  2    20       3 mbz1 fixed bin (2),
  2    21       3 media_code fixed bin (4),			/* file media code */
  2    22       3 report_code fixed bin (6)) unsigned,		/* report code */
  2    23     2 gc_log_rec_data (0 refer (gc_log_rec.rcw.rsize)) bit (36); /* logical record data */
  2    24 
  2    25 dcl  gc_phy_rec_bits bit (gc_phy_rec.bcw.blk_size * 36) based (addr (gc_phy_rec.gc_phy_rec_data));
  2    26 dcl  gc_log_rec_bits bit (gc_log_rec.rcw.rsize * 36) based (addr (gc_log_rec.gc_log_rec_data));
  2    27 
  2    28 /* END INCLUDE FILE: gcos_ssf_records.incl.pl1 */
      892 
      893 
      894    end gload_;
	SOURCE FILES USED IN THIS COMPILATION.

LINE      NUMBER  DATE MODIFIED     NAME			PATHNAME
             0    12/01/86  1258.0  gload_.pl1                        >spec>install>1229>gload_.pl1
891          1    05/23/79  1612.1  gload_data.incl.pl1               >ldd>include>gload_data.incl.pl1
892          2    03/27/82  0437.1  gcos_ssf_records.incl.pl1         >ldd>include>gcos_ssf_records.incl.pl1
	NAMES DECLARED IN THIS COMPILATION.

IDENTIFIER	     OFFSET    LOC STORAGE CLASS   DATA TYPE		ATTRIBUTES AND REFERENCES
								(* indicates a set context)

NAMES DECLARED BY DECLARE STATEMENT.
a_cnt                           000237 automatic       fixed bin(17,0)          dcl 67 set ref 358* 425 432*
a_ld_offset                            parameter       fixed bin(18,0)          dcl 34 ref 27 223 228
a_load_ptr                             parameter       pointer                  dcl 33 ref 27 223 229
abs_card                               based           structure                level 1 dcl 119
accum                           000106 automatic       bit(36)                  unaligned dcl 40 set ref 333* 334* 335 613* 614* 615
                                                                                  617* 620 625*
add                                    based           char(6)                  level 2 packed unaligned dcl 160 set ref 687*
addend                                 based           bit                      array level 2 packed unaligned dcl 78 ref 385 385
                                                                                  388 412
addr                                                   builtin function         dcl 75 ref 239 243 244 246 249 257 357 366 431 500
                                                                                  518 528 541 552 555 564 569 578 640 645 645 646
                                                                                  648 652 666 667 667 669 685 685 687 695 699 703
                                                                                  705 705 707 711 715 715 719 744 744 746 748 748
                                                                                  750 752 754 756 758 760 760 764 777 795
addrel                                                 builtin function         dcl 75 ref 313 316 365 391 393 417 418 422 439 440
                                                                                  519 559 605 614 614 650 653 657 673 673 690 728
                                                                                  788 788 813 813
ain                                    parameter       char                     unaligned dcl 822 ref 820 830
allow_zero_checksums            000107 automatic       bit(1)                   unaligned dcl 41 set ref 220* 226* 616
assem                    16(27)        based           char(1)                  level 2 packed unaligned dcl 144 ref 640 746
aw                              000104 automatic       char(32)                 unaligned dcl 826 set ref 829* 830* 831 832
base                                   parameter       fixed bin(17,0)          dcl 825 ref 820 832 834 835
bcd_dkend                       000014 constant        bit(72)                  initial unaligned dcl 214 ref 249
bcd_obj                         000016 constant        bit(78)                  initial unaligned dcl 212 ref 243
bcd_sym                   3            based           bit(36)                  array level 3 packed unaligned dcl 94 set ref 467
                                                                                  468*
bcd_to_ascii_                   000012 constant        entry                    external dcl 89 ref 244 468 666 740
bcw                                    based           structure                level 2 packed unaligned dcl 2-9
bin                                                    builtin function         dcl 75 ref 317 317 408 690 724 726 777 777 777 780
                                                                                  780 780 780 796 797 797 879
bin_card                               based           structure                level 1 dcl 124
bit                                                    builtin function         dcl 75 ref 332 472 474 484 506 546 740 740 780 780
                                                                                  780 780 797 797 839
blank_common                    000142 automatic       fixed bin(18,0)          dcl 56 set ref 352* 379
blank_common_len                000143 automatic       fixed bin(18,0)          dcl 57 set ref 351 353 463*
blk_cmn_len               2            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 94 ref 463
blk_len                         000131 automatic       fixed bin(17,0)          dcl 47 set ref 240* 241 312* 312
blk_size                  0(18)        based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 2-9 ref 241
                                                                                  316
bsn                                    based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 2-9 set ref
                                                                                  236 317 319 321*
btp                                    based           bit(18)                  array unaligned dcl 209 ref 719
byte1                     0(01)        based           bit(8)                   array level 3 packed unaligned dcl 202 set ref 853
                                                                                  864*
byte2                     0(10)        based           bit(8)                   array level 3 packed unaligned dcl 202 set ref 853
                                                                                  865*
caller                                 parameter       char                     unaligned dcl 29 set ref 223 617*
card_buf                        000200 automatic       char(80)                 unaligned dcl 63 set ref 666* 667 667 669 673* 685
                                                                                  687 695 699 703 705 705 707 711 715 715 744 744
                                                                                  748 750 752 754 756 758 760 760 764 777 780* 795
                                                                                  813*
cbsn                            000132 automatic       fixed bin(17,0)          dcl 48 set ref 236* 319 321 325* 325
char                                                   builtin function         dcl 75 ref 700 712 716
checksum                  2            based           bit(36)                  level 2 in structure "load_data" packed unaligned
                                                                                  dcl 210 in procedure "gload_" set ref 335*
checksum                  1            based           bit(36)                  level 2 in structure "reloc_card" dcl 109
                                                                                  in procedure "gload_" set ref 615 616 620* 625*
code                                   parameter       fixed bin(35,0)          dcl 36 set ref 27 223 234* 253 259* 265* 271* 281*
                                                                                  299* 303 307* 320* 346* 363 437 601* 624* 672* 689
                                                                                  763 779* 787* 812*
core_ptr                        000100 automatic       pointer                  dcl 38 set ref 365* 369 373 376 379 395 407 408 411
                                                                                  417* 417 439* 519* 521 552* 555 559* 559 564* 572
                                                                                  605*
count                     0(12)        based           fixed bin(6,0)           level 2 in structure "lcw" packed unsigned unaligned
                                                                                  dcl 137 in procedure "gload_" ref 358 426 432 520
                                                                                  522 523 570 571 573
count                     0(12)        based           fixed bin(6,0)           level 3 in structure "preface_card" packed unsigned
                                                                                  unaligned dcl 94 in procedure "gload_" ref 467
cptr                            000146 automatic       pointer                  dcl 59 set ref 257* 260* 264 266 266* 270 272 272*
                                                                                  278 282* 287 291 293 295 300 300* 347* 357 366 369
                                                                                  372 428 431 456 457 460 463 467 467 468 469 471
                                                                                  474 480 485 500 518 525 528 541 569 575 578 587
                                                                                  613 614 614 615 616 617* 620 625* 625
cr                        1(18)        based           char(1)                  level 2 packed unaligned dcl 169 ref 744 744 752 764
currentsize                                            builtin function         dcl 75 ref 313
cv                                     parameter       bit(36)                  unaligned dcl 823 set ref 820 839*
cw                                     based           structure                level 2 in structure "reloc_card" packed unaligned
                                                                                  dcl 109 in procedure "gload_" set ref 357
cw                                     based           structure                level 2 in structure "abs_card" packed unaligned
                                                                                  dcl 119 in procedure "gload_" set ref 500
cw                                     based           structure                level 2 in structure "preface_card" packed unaligned
                                                                                  dcl 94 in procedure "gload_"
cw                                     based           structure                level 2 in structure "fnp_card" packed unaligned
                                                                                  dcl 132 in procedure "gload_" set ref 541
data                      2            based           bit(36)                  array level 2 in structure "abs_card" dcl 119
                                                                                  in procedure "gload_" set ref 518 525 528
data                      5            based           bit(36)                  array level 2 in structure "reloc_card" dcl 109
                                                                                  in procedure "gload_" set ref 366 428 431
data                      2            based           bit(18)                  array level 2 in structure "fnp_card" packed
                                                                                  unaligned dcl 132 in procedure "gload_" set ref
                                                                                  569 575 578
data                                   based           bit(36)                  array level 2 in structure "bin_card" packed
                                                                                  unaligned dcl 124 in procedure "gload_" ref 613
data_move                              based           char                     unaligned dcl 69 set ref 521* 521 555* 572* 572
deck_name                              based           char(4)                  level 2 packed unaligned dcl 210 set ref 231* 246*
deck_ptr                               parameter       pointer                  dcl 32 ref 27 223 235
deck_type                 1            based           bit(1)                   level 2 packed unaligned dcl 210 set ref 233* 464*
                                                                                  585*
definition               65            based           structure                array level 2 packed unaligned dcl 210
diagnostic                3            based           char(200)                level 2 packed unaligned dcl 210 set ref 231* 260*
                                                                                  266* 272* 282* 300* 308* 321* 347* 602* 625* 673*
                                                                                  780* 788* 813*
dir                                    parameter       char                     unaligned dcl 30 set ref 223 617*
dk_rev                          000226 automatic       char(6)                  unaligned dcl 65 set ref 740* 750
dlen                            000113 automatic       fixed bin(18,0)          dcl 44 set ref 328* 334*
edit_name                22            based           char(4)                  level 2 packed unaligned dcl 144 ref 246 555 685 748
ent                                    parameter       char                     unaligned dcl 31 set ref 223 617*
eof                             000116 automatic       bit(1)                   unaligned dcl 45 set ref 230* 238 249* 305* 315
error_table_$fatal_error        000010 external static fixed bin(35,0)          dcl 74 ref 259 265 271 281 299 307 320 346 601 624
                                                                                  672 779 787 812
file_mark                 0(20)        based           fixed bin(4,0)           level 3 packed unsigned unaligned dcl 2-15 ref 305
final                           000140 automatic       fixed bin(18,0)          dcl 54 set ref 385* 388* 391* 393* 395 471* 472
first_abs                       000120 automatic       bit(1)                   unaligned dcl 45 set ref 230* 510 512* 553 555 557*
first_reloc                     000117 automatic       bit(1)                   unaligned dcl 45 set ref 230* 343 344*
fixed                                                  builtin function         dcl 75 ref 382 385 385 388 412 654
fnp_card                               based           structure                level 1 packed unaligned dcl 132
fnp_seg                                based           bit(18)                  array unaligned dcl 70 set ref 552 553 564
fnp_sw                          000110 automatic       bit(1)                   unaligned dcl 43 set ref 289 641* 644*
fw                                     based           structure                level 1 packed unaligned dcl 202
fw_high                         000235 automatic       fixed bin(17,0)          dcl 67 set ref 776* 777 777 780 780 786 800 878
fw_low                          000234 automatic       fixed bin(17,0)          dcl 67 set ref 765* 770* 776 777 780 780 853 853 864
                                                                                  865 878
fw_word                                based           structure                array level 2 packed unaligned dcl 202
gc_log_rec                             based           structure                level 1 dcl 2-15 set ref 313
gc_log_rec_bits                        based           bit                      unaligned dcl 2-26 set ref 243 244* 249 666*
gc_log_rec_data           1            based           bit(36)                  array level 2 dcl 2-15 set ref 243 244 249 257 666
gc_phy_rec                             based           structure                level 1 dcl 2-9
gc_phy_rec_data           1            based           bit(36)                  array level 2 dcl 2-9 set ref 239
gload_cksum_                    000020 constant        entry                    external dcl 92 ref 334 614
gload_data                      000714 automatic       structure                level 1 dcl 1-5
h_add                                  based           char(6)                  level 2 packed unaligned dcl 169 set ref 754*
h_patch                                based           structure                level 1 dcl 169
halfs                                  based           fixed bin(18,0)          array unsigned unaligned dcl 72 set ref 373* 373
                                                                                  376* 376 379* 379 391 393 395* 407* 408* 411*
hex                       1(27)        based           char(3)                  level 2 packed unaligned dcl 169 ref 669
hwds                      2(01)        based           fixed bin(2,0)           array level 4 packed unsigned unaligned dcl 109 ref
                                                                                  372
hx_cs_st                  5            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 180 ref 770
hx_rw_st                  5(18)        based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 180 ref 765
i                               000123 automatic       fixed bin(17,0)          dcl 46 in procedure "gload_" set ref 260* 266* 272*
                                                                                  277* 278* 282* 300* 308* 321* 347* 367* 369 372*
                                                                                  467* 467* 468 468 469 469 471 472 474 474 480 484
                                                                                  485 487* 490 602* 625* 673* 693* 694 694 696 700
                                                                                  708 712 716 719* 722 780* 788* 795* 795* 796 797
                                                                                  797* 813*
i                               001751 automatic       fixed bin(17,0)          dcl 875 in procedure "MPC_CHECKSUM" set ref 878*
                                                                                  879*
i                                      parameter       fixed bin(17,0)          dcl 851 in procedure "GET_WORD" ref 848 853 853
i                                      parameter       fixed bin(17,0)          dcl 861 in procedure "PUT_WORD" ref 859 864 865
i                               000102 automatic       fixed bin(17,0)          dcl 825 in procedure "CV_AB" set ref 831* 832*
id_blk                                 based           structure                level 1 dcl 180
idbp                            000150 automatic       pointer                  dcl 60 set ref 739* 740 740 752 765 766 770 771 773
index                                                  builtin function         dcl 75 ref 278 699 711 832
info_ptr                               parameter       pointer                  dcl 35 ref 27 223 231 231 232 233 233 246 260 266
                                                                                  272 282 300 308 321 332 335 347 464 468 468 469
                                                                                  469 472 472 474 474 484 484 487 487 490 490 503
                                                                                  506 507 544 546 547 585 602 625 673 780 788 813
inst                      3(27)        based           char(4)                  array level 2 packed unaligned dcl 169 set ref 756
                                                                                  758* 760 760* 777 795
ioa_                            000014 constant        entry                    external dcl 90 ref 617
ioa_$rsnnl                      000016 constant        entry                    external dcl 91 ref 260 266 272 282 300 308 321 347
                                                                                  602 625 673 780 788 813
j                               000124 automatic       fixed bin(17,0)          dcl 46 in procedure "gload_" set ref 276* 278* 278
                                                                                  280 282* 286 368* 369 372* 469* 470 470 474 476
                                                                                  478 479 703* 704 705 722* 724 724 726* 796* 797*
j                               000103 automatic       fixed bin(17,0)          dcl 825 in procedure "CV_AB" set ref 832* 833 834
k                               000125 automatic       fixed bin(17,0)          dcl 46 set ref 371* 372 373 373 376 376 379 379 382
                                                                                  385 385 385 388 391 391 393 395 406 409* 411 412*
                                                                                  704* 705 707 709* 709 711 715 715 720 723* 724 724
                                                                                  724 726 726*
l                               000126 automatic       fixed bin(17,0)          dcl 46 set ref 359* 426* 426 427 428 428 431 520*
                                                                                  521 521 554* 555 570* 572 572 691* 695 697* 697
                                                                                  699 703 705 705 707 711 715 715 720* 720
l_addr                    0(18)        based           fixed bin(18,0)          level 3 in structure "preface_card" packed unsigned
                                                                                  unaligned dcl 94 in procedure "gload_" ref 460 587
l_addr                    0(18)        based           fixed bin(18,0)          level 2 in structure "lcw" packed unsigned unaligned
                                                                                  dcl 137 in procedure "gload_" ref 365 439 506 513
                                                                                  519 546 552 553 564 605
last_assigned                   000137 automatic       fixed bin(18,0)          dcl 53 set ref 329 352 353* 353 399 400* 400 461*
                                                                                  480 480* 480 480 483 485* 485 587* 739 766 771
last_seq                        000136 automatic       fixed bin(17,0)          dcl 52 set ref 234* 280 282 286*
lbl                      22            based           char(4)                  level 2 in structure "o_patch" packed unaligned
                                                                                  dcl 160 in procedure "gload_" ref 685
lbl                      22            based           char(4)                  level 2 in structure "h_patch" packed unaligned
                                                                                  dcl 169 in procedure "gload_" ref 748
lcw                                    based           structure                level 1 packed unaligned dcl 137
lcwp                            000144 automatic       pointer                  dcl 58 set ref 357* 358 361 361 365 426 431* 432 435
                                                                                  435 439 500* 501 506 513 519 520 522 523 528* 541*
                                                                                  542 546 552 553 564 570 571 573 578* 597 598 602
                                                                                  602* 605
ld_entry                        000244 automatic       structure                array level 2 packed unaligned dcl 83
ld_offset                       000112 automatic       fixed bin(18,0)          dcl 44 in procedure "gload_" set ref 228* 331 376
                                                                                  457 457* 457 457 461 471 513* 564 587 646* 649*
                                                                                  654* 654 657 724
ld_offset                       000244 automatic       fixed bin(18,0)          array level 3 in structure "ld_table" packed
                                                                                  unaligned dcl 83 in procedure "gload_" set ref 385
                                                                                  388 391 393 483* 484 605
ld_table                        000244 automatic       structure                level 1 dcl 83
ld_type                   0(32) 000244 automatic       fixed bin(3,0)           array level 3 in structure "ld_table" packed
                                                                                  unaligned dcl 83 in procedure "gload_" set ref 384
                                                                                  478*
ld_type                   5(09)        based           char(1)                  level 2 in structure "o_card" packed unaligned
                                                                                  dcl 144 in procedure "gload_" ref 646 648 652
ld_wd                                  based           bit(36)                  unaligned dcl 71 set ref 266* 272* 300* 369* 369
                                                                                  401* 403* 602*
ldp                             000102 automatic       pointer                  dcl 39 set ref 366* 369 373 376 379 382 385 385 385
                                                                                  388 391 391 393 412 418* 418 422* 422 440* 440
                                                                                  518* 521 569* 572
length                                                 builtin function         dcl 75 ref 705 831
library                   3(27)        based           char(6)                  level 2 packed unaligned dcl 144 ref 645 645
load_data                              based           structure                level 1 dcl 210
load_len                        000111 automatic       fixed bin(18,0)          dcl 44 set ref 234* 328 329* 331* 331 332 460* 461
                                                                                  522* 522 571* 571
load_ptr                        000104 automatic       pointer                  dcl 39 set ref 229* 334* 365 401 403 439 519 552 553
                                                                                  564 605 650* 650 653* 653 654 657* 657 690 739 853
                                                                                  853 864 865
lrptr                           001604 automatic       pointer                  dcl 2-7 set ref 239* 242 243 243 244 244 244 249 249
                                                                                  256 257 278 305 305 308 308* 312 313* 313 313 666
                                                                                  666 666 673 673 788 788 813 813
lst_ld_entry                    000133 automatic       fixed bin(17,0)          dcl 49 set ref 355* 600 602*
ltrim                                                  builtin function         dcl 75 ref 830
lx                              000134 automatic       fixed bin(17,0)          dcl 50 set ref 355 382* 384 385 388 391 393 462*
                                                                                  477* 477 478 483 484 597* 598* 598 600 602* 605
m                               000127 automatic       fixed bin(17,0)          dcl 46 set ref 359* 366 419* 419 423* 423 425 433*
                                                                                  515* 518 523* 523 524 525 525 528 529* 529 550*
                                                                                  562* 569 573* 573 574 575 575 578 579* 579
max_abs_wds                            constant        fixed bin(17,0)          initial dcl 216 ref 524 525
max_fnp_wds                            constant        fixed bin(17,0)          initial dcl 216 ref 574 575
max_reloc_wds                          constant        fixed bin(17,0)          initial dcl 216 ref 427 428
mb5                       0(09)        based           fixed bin(3,0)           level 3 packed unsigned unaligned dcl 109 set ref
                                                                                  264
mb8                       2(18)        based           bit(1)                   level 2 packed unaligned dcl 94 ref 457
media_code                0(26)        based           fixed bin(4,0)           level 3 packed unsigned unaligned dcl 2-15 set ref
                                                                                  242 256 305 308*
mem_name                        000240 automatic       char(14)                 unaligned dcl 68 set ref 767* 774* 780* 788*
mess                                   parameter       char                     unaligned dcl 810 set ref 808 813*
mod                                                    builtin function         dcl 75 ref 317 457 457 480 480
mod8                      4(18)        based           bit(1)                   array level 3 packed unaligned dcl 94 ref 480
mpc_checksum                    000224 automatic       bit(16)                  unaligned dcl 64 set ref 786 800* 886*
mpcp                            000232 automatic       bit(36)                  array unaligned dcl 66 set ref 758* 760* 797 797
n                               000130 automatic       fixed bin(17,0)          dcl 46 set ref 359* 426 434*
new_word                               parameter       bit(16)                  unaligned dcl 862 ref 859 864 865
o_card                                 based           structure                level 1 dcl 144
o_patch                                based           structure                level 1 dcl 160
obj_buf                         000154 automatic       char(80)                 unaligned dcl 62 set ref 244* 246 555 640 645 645
                                                                                  646 648 652 685 746 748
obj_flag                        000115 automatic       bit(1)                   unaligned dcl 45 set ref 230* 245* 258
octal                     1(27)        based           char(5)                  level 2 packed unaligned dcl 160 ref 667 667
offset                   67            based           bit(18)                  array level 3 packed unaligned dcl 210 set ref 472*
                                                                                  474* 484* 487* 506* 546*
ovl                             000236 automatic       fixed bin(17,0)          dcl 67 set ref 766* 771* 773* 776
p_array                         000644 automatic       structure                level 1 dcl 196
p_fld                     3(27)        based           char(57)                 level 2 packed unaligned dcl 160 ref 695 699 703 705
                                                                                  705 707 711 715 715
p_ptr                           000152 automatic       pointer                  dcl 61 set ref 690* 724 726 728* 728
p_word                                 based           fixed bin(18,0)          array unsigned unaligned dcl 73 set ref 724* 726*
pa                              000230 automatic       bit(36)                  unaligned dcl 66 set ref 687* 690 754* 756 777 777
                                                                                  777 796
patches                         000644 automatic       structure                array level 2 dcl 196
preface                         000114 automatic       bit(1)                   unaligned dcl 45 set ref 230* 329 345 455 465* 585*
preface_card                           based           structure                level 1 dcl 94
prptr                           001602 automatic       pointer                  dcl 2-6 set ref 235* 236 239 241 316* 316 316 317
                                                                                  317* 317 317 317 319 321* 321
ptr                                                    builtin function         dcl 75 ref 317 401 403 739
rcw                                    based           structure                level 2 packed unaligned dcl 2-15
rel                                                    builtin function         dcl 75 ref 317 317 654
rel_sym                   0(03)        based           fixed bin(6,0)           level 3 in structure "preface_card" packed unsigned
                                                                                  unaligned dcl 94 in procedure "gload_" ref 456
rel_sym                   0(03)        based           fixed bin(6,0)           level 2 in structure "lcw" packed unsigned unaligned
                                                                                  dcl 137 in procedure "gload_" ref 361 435 597
reloc_card                             based           structure                level 1 dcl 109
reloc_data                2            based           structure                array level 2 packed unaligned dcl 109
rev                       1(24)        based           bit(12)                  level 3 in structure "id_blk" packed unaligned
                                                                                  dcl 180 in procedure "gload_" ref 740 740
rev                      13(18)        based           char(6)                  level 2 in structure "h_patch" packed unaligned
                                                                                  dcl 169 in procedure "gload_" ref 750
revision                  1            based           structure                level 2 packed unaligned dcl 180
rindex                    0(01)        based           bit                      array level 2 packed unaligned dcl 78 ref 382
rloc                            000644 automatic       bit(1)                   array level 3 in structure "p_array" packed
                                                                                  unaligned dcl 196 in procedure "gload_" set ref
                                                                                  694* 694* 696* 708* 724
rloc                      2            based           structure                array level 3 in structure "reloc_card" packed
                                                                                  unaligned dcl 109 in procedure "gload_" ref 369
rsize                                  based           fixed bin(18,0)          level 3 packed unsigned unaligned dcl 2-15 ref 243
                                                                                  244 244 249 278 312 313 666 666
rtrim                                                  builtin function         dcl 75 ref 831
rw_start                  4            based           fixed bin(18,0)          level 2 packed unsigned unaligned dcl 180 ref 752
                                                                                  766 771 773
search                                                 builtin function         dcl 75 ref 703
seq_num                                based           bit(10)                  array level 3 packed unaligned dcl 124 ref 278
sign                                   based           bit(1)                   array level 2 packed unaligned dcl 78 ref 385 391
sn                                     based           structure                array level 2 packed unaligned dcl 124
spec_halfs                             based           structure                array level 1 packed unaligned dcl 78
substr                                                 builtin function         dcl 75 ref 243 249 695 699 703 705 707 711 715 715
                                                                                  756 832 832 864 865 886
sum                             001750 automatic       fixed bin(35,0)          dcl 874 set ref 877* 879* 879 880 881* 881 882* 882
                                                                                  885* 885 886
sym_cnt                   1(01)        based           fixed bin(16,0)          level 2 packed unaligned dcl 210 set ref 232* 468
                                                                                  469 472 474 484 487 490* 490 507* 547*
sym_pair                  3            based           structure                array level 2 packed unaligned dcl 94
sym_pos                   4            based           fixed bin(18,0)          array level 3 packed unsigned unaligned dcl 94 ref
                                                                                  471 474 485
sym_type                 67(32)        based           fixed bin(3,0)           array level 3 in structure "load_data" packed
                                                                                  unaligned dcl 210 in procedure "gload_" set ref
                                                                                  469*
sym_type                  4(33)        based           fixed bin(3,0)           array level 3 in structure "preface_card" packed
                                                                                  unsigned unaligned dcl 94 in procedure "gload_"
                                                                                  ref 469
symbol                   65            based           char(6)                  array level 3 packed unaligned dcl 210 set ref 468*
                                                                                  503* 544*
symref_vec                      000141 automatic       fixed bin(18,0)          dcl 55 set ref 234* 398 399* 401 403 407 411
text_len                  1(18)        based           bit(18)                  level 2 packed unaligned dcl 210 set ref 233* 332*
tmr                             000121 automatic       bit(1)                   unaligned dcl 45 set ref 360* 367 368 427* 428* 516*
                                                                                  517 524* 525* 566* 568 574* 575* 692* 693 705*
tp                              000231 automatic       bit(36)                  unaligned dcl 66 set ref 715* 719
two_wd                          000122 automatic       bit(1)                   unaligned dcl 45 set ref 360* 390* 412* 420 421*
type                                   based           fixed bin(3,0)           level 3 in structure "abs_card" packed unsigned
                                                                                  unaligned dcl 119 in procedure "gload_" set ref
                                                                                  287 293
type                                   based           fixed bin(3,0)           level 3 in structure "preface_card" packed unsigned
                                                                                  unaligned dcl 94 in procedure "gload_" ref 291
type                                   based           fixed bin(3,0)           level 3 in structure "reloc_card" packed unsigned
                                                                                  unaligned dcl 109 in procedure "gload_" set ref
                                                                                  270 295
type                                   parameter       char                     unaligned dcl 810 in procedure "PATCH_ERR" set ref
                                                                                  808 813*
type                                   based           fixed bin(3,0)           level 2 in structure "lcw" packed unsigned unaligned
                                                                                  dcl 137 in procedure "gload_" ref 361 435 501 542
                                                                                  598
ul                        1     000644 automatic       bit(18)                  array level 3 packed unaligned dcl 196 set ref 719*
                                                                                  724 726
unspec                                                 builtin function         dcl 75 ref 369 756 886
v                               000100 automatic       fixed bin(36,0)          dcl 824 set ref 828* 834* 834 835 839
vcb                             000135 automatic       fixed bin(17,0)          dcl 51 set ref 382 382 382 382 382 385 385 385 385
                                                                                  385 385 385 385 385 385 385 385 385 385 385 385
                                                                                  388 388 388 388 388 388 391 391 391 391 412 412
                                                                                  412 412 412 412 456*

NAME DECLARED BY DECLARE STATEMENT AND NEVER REFERENCED.
gc_phy_rec_bits                        based           bit                      unaligned dcl 2-25

NAMES DECLARED BY EXPLICIT CONTEXT.
ADD_COMMON                      003517 constant        entry                    internal dcl 595 ref 362 436
CKSUM_CARD                      003630 constant        entry                    internal dcl 611 ref 287
CK_PATCH                        004104 constant        entry                    internal dcl 664 ref 252
CK_TD_LOAD                      004023 constant        entry                    internal dcl 638 ref 247
COMMON                          001002 constant        label                    dcl 228 ref 221
CV_AB                           005712 constant        entry                    internal dcl 820 ref 687 715 754 758 760
DO_ABS                          003162 constant        entry                    internal dcl 498 ref 293
DO_FNP                          003310 constant        entry                    internal dcl 539 ref 289
DO_PREFACE                      002664 constant        entry                    internal dcl 453 ref 291
DO_RELOC                        002001 constant        entry                    internal dcl 341 ref 295
GET_WORD                        006057 constant        entry                    internal dcl 848 ref 786 879
H_PATCH                         004725 constant        entry                    internal dcl 737 ref 669
MPC_CHECKSUM                    006130 constant        entry                    internal dcl 872 ref 785 799
O_PATCH                         004221 constant        entry                    internal dcl 683 ref 667
PATCH_ERR                       005615 constant        entry                    internal dcl 808 ref 685 687 700 712 716 744 746 748
                                                                                  750 752 754 756 758 760
PUT_WORD                        006107 constant        entry                    internal dcl 859 ref 797 800
absc                            000004 constant        label                    array(0:1) dcl 503 ref 501
allow_zero_checksums            000740 constant        entry                    external dcl 223
fnp_com                         003416 constant        label                    dcl 566 ref 560
fnpc                            000006 constant        label                    array(0:4) dcl 544 ref 542
gload_                          000707 constant        entry                    external dcl 27
reloc                           000000 constant        label                    array(0:3) dcl 373 set ref 372
reloc_end                       002537 constant        label                    dcl 415 ref 375 378 381

THERE WERE NO NAMES DECLARED BY CONTEXT OR IMPLICATION.

STORAGE REQUIREMENTS FOR THIS PROGRAM.

	Object	Text	Link	Symbol	Defs	Static
Start          0       0      6760        7002    6654        6770
Length      7244    6654        22         225     103           0

BLOCK NAME	         STACK SIZE     TYPE		WHY NONQUICK/WHO SHARES STACK FRAME
gload_                             1497 external procedure  is an external procedure.  
DO_RELOC                                internal procedure  shares stack frame of external procedure gload_.  
DO_PREFACE                              internal procedure  shares stack frame of external procedure gload_.  
DO_ABS                                  internal procedure  shares stack frame of external procedure gload_.  
DO_FNP                                  internal procedure  shares stack frame of external procedure gload_.  
ADD_COMMON                              internal procedure  shares stack frame of external procedure gload_.  
CKSUM_CARD                              internal procedure  shares stack frame of external procedure gload_.  
CK_TD_LOAD                              internal procedure  shares stack frame of external procedure gload_.  
CK_PATCH                                internal procedure  shares stack frame of external procedure gload_.  
O_PATCH                                 internal procedure  shares stack frame of external procedure gload_.  
H_PATCH                                 internal procedure  shares stack frame of external procedure gload_.  
PATCH_ERR                               internal procedure  shares stack frame of external procedure gload_.  
CV_AB                                79 internal procedure  is called during a stack extension.  
GET_WORD                                internal procedure  shares stack frame of external procedure gload_.  
PUT_WORD                                internal procedure  shares stack frame of external procedure gload_.  
MPC_CHECKSUM                            internal procedure  shares stack frame of external procedure gload_.  

STORAGE FOR AUTOMATIC VARIABLES.

STACK FRAME                 LOC IDENTIFIER                  BLOCK NAME
CV_AB                    000100 v                           CV_AB
                         000102 i                           CV_AB
                         000103 j                           CV_AB
                         000104 aw                          CV_AB
gload_                   000100 core_ptr                    gload_
                         000102 ldp                         gload_
                         000104 load_ptr                    gload_
                         000106 accum                       gload_
                         000107 allow_zero_checksums        gload_
                         000110 fnp_sw                      gload_
                         000111 load_len                    gload_
                         000112 ld_offset                   gload_
                         000113 dlen                        gload_
                         000114 preface                     gload_
                         000115 obj_flag                    gload_
                         000116 eof                         gload_
                         000117 first_reloc                 gload_
                         000120 first_abs                   gload_
                         000121 tmr                         gload_
                         000122 two_wd                      gload_
                         000123 i                           gload_
                         000124 j                           gload_
                         000125 k                           gload_
                         000126 l                           gload_
                         000127 m                           gload_
                         000130 n                           gload_
                         000131 blk_len                     gload_
                         000132 cbsn                        gload_
                         000133 lst_ld_entry                gload_
                         000134 lx                          gload_
                         000135 vcb                         gload_
                         000136 last_seq                    gload_
                         000137 last_assigned               gload_
                         000140 final                       gload_
                         000141 symref_vec                  gload_
                         000142 blank_common                gload_
                         000143 blank_common_len            gload_
                         000144 lcwp                        gload_
                         000146 cptr                        gload_
                         000150 idbp                        gload_
                         000152 p_ptr                       gload_
                         000154 obj_buf                     gload_
                         000200 card_buf                    gload_
                         000224 mpc_checksum                gload_
                         000226 dk_rev                      gload_
                         000230 pa                          gload_
                         000231 tp                          gload_
                         000232 mpcp                        gload_
                         000234 fw_low                      gload_
                         000235 fw_high                     gload_
                         000236 ovl                         gload_
                         000237 a_cnt                       gload_
                         000240 mem_name                    gload_
                         000244 ld_table                    gload_
                         000644 p_array                     gload_
                         000714 gload_data                  gload_
                         001602 prptr                       gload_
                         001604 lrptr                       gload_
                         001750 sum                         MPC_CHECKSUM
                         001751 i                           MPC_CHECKSUM

THE FOLLOWING EXTERNAL OPERATORS ARE USED BY THIS PROGRAM.
alloc_char_temp     call_ext_out_desc   call_ext_out        call_int_this_desc  return_mac          longbs_to_fx2
mpfx2               mdfx1               mdfx3               signal_op           shorten_stack       ext_entry
ext_entry_desc      int_entry_desc      set_bits_eis        index_bs_1_eis      divide_fx1

THE FOLLOWING EXTERNAL ENTRIES ARE CALLED BY THIS PROGRAM.
bcd_to_ascii_                 gload_cksum_                  ioa_                          ioa_$rsnnl

THE FOLLOWING EXTERNAL VARIABLES ARE USED BY THIS PROGRAM.
error_table_$fatal_error




   LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC      LINE    LOC   
     27 000702       220 000727       221 000730       223 000731       226 001000       228 001002       229 001004
    230 001007       231 001014       232 001023       233 001027       234 001033       235 001037       236 001042
    238 001045       239 001050       240 001053       241 001054       242 001061       243 001067       244 001076
    245 001121       246 001123       247 001126       248 001127       249 001130       252 001137       253 001140
    255 001142       256 001143       257 001145       258 001150       259 001152       260 001155       262 001206
    264 001207       265 001214       266 001217       268 001254       270 001255       271 001261       272 001264
    274 001321       276 001322       277 001323       278 001331       279 001357       280 001361       281 001365
    282 001370       284 001433       286 001434       287 001436       289 001446       291 001452       293 001460
    295 001466       299 001474       300 001477       303 001534       304 001536       305 001537       307 001551
    308 001554       310 001613       312 001614       313 001622       314 001627       315 001630       316 001632
    317 001636       319 001657       320 001666       321 001671       323 001735       325 001736       327 001737
    328 001740       329 001742       331 001747       332 001751       333 001760       334 001761       335 001774
    894 002000       341 002001       343 002002       344 002004       345 002006       346 002010       347 002013
    349 002044       351 002045       352 002047       353 002051       355 002053       357 002055       358 002057
    359 002065       360 002070       361 002072       362 002107       363 002110       364 002113       365 002114
    366 002124       367 002130       368 002137       369 002147       371 002170       372 002175       373 002216
    375 002225       376 002226       378 002246       379 002247       381 002267       382 002270       384 002314
    385 002321       388 002353       390 002361       391 002363       393 002411       395 002430       396 002442
    398 002443       399 002445       400 002447       401 002451       403 002457       406 002465       407 002470
    408 002477       409 002504       410 002506       411 002507       412 002520       415 002537       417 002541
    418 002544       419 002547       420 002550       421 002552       422 002553       423 002555       425 002556
    426 002561       427 002572       428 002577       431 002606       432 002611       433 002617       434 002620
    435 002622       436 002637       437 002640       438 002643       439 002644       440 002654       444 002657
    445 002661       447 002663       453 002664       455 002665       456 002667       457 002673       460 002707
    461 002712       462 002714       463 002715       464 002720       465 002724       467 002726       468 002751
    469 002776       470 003022       471 003027       472 003035       473 003043       474 003044       476 003056
    477 003060       478 003061       479 003066       480 003071       483 003107       484 003114       485 003130
    486 003134       487 003135       489 003142       490 003144       492 003161       498 003162       500 003163
    501 003165       503 003173       506 003200       507 003207       508 003213       510 003214       512 003216
    513 003220       515 003226       516 003227       517 003230       518 003232       519 003236       520 003247
    521 003257       522 003262       523 003264       524 003265       525 003273       528 003302       529 003305
    531 003306       532 003307       539 003310       541 003311       542 003313       544 003321       546 003326
    547 003335       548 003341       550 003342       552 003343       553 003354       554 003366       555 003370
    557 003375       559 003377       560 003401       562 003402       564 003404       566 003416       568 003417
    569 003422       570 003430       571 003441       572 003443       573 003450       574 003451       575 003457
    578 003474       579 003500       581 003502       582 003503       585 003504       587 003512       588 003516
    595 003517       597 003520       598 003527       600 003540       601 003543       602 003546       604 003611
    605 003612       607 003627       611 003630       613 003632       614 003634       615 003654       616 003660
    617 003664       620 003726       621 003731       624 003737       625 003742       627 004003       630 004011
    632 004017       638 004023       640 004024       641 004032       642 004034       644 004035       645 004036
    646 004046       648 004056       649 004060       650 004062       651 004065       652 004066       653 004070
    654 004073       656 004076       657 004077       659 004103       664 004104       666 004105       667 004131
    669 004145       672 004155       673 004160       677 004220       683 004221       685 004222       687 004240
    689 004301       690 004304       691 004311       692 004313       693 004314       694 004323       695 004332
    696 004344       697 004347       698 004350       699 004351       700 004362       701 004404       703 004405
    704 004425       705 004427       707 004443       708 004452       709 004457       710 004461       711 004462
    712 004473       713 004515       715 004516       716 004556       717 004601       719 004602       720 004622
    721 004626       722 004630       723 004637       724 004645       726 004676       727 004715       728 004717
    729 004722       731 004724       737 004725       739 004726       740 004733       744 004753       746 004776
    748 005015       750 005031       752 005052       754 005072       756 005134       758 005163       760 005227
    763 005302       764 005305       765 005312       766 005316       767 005325       768 005330       770 005331
    771 005335       773 005345       774 005346       776 005351       777 005355       779 005402       780 005405
    783 005463       785 005464       786 005465       787 005501       788 005504       790 005544       795 005545
    796 005564       797 005571       798 005604       799 005606       800 005607       802 005614       808 005615
    812 005633       813 005636       816 005710       820 005711       828 005725       829 005727       830 005732
    831 005752       832 005771       833 006004       834 006012       835 006022       838 006036       839 006040
    840 006052       848 006057       853 006061       859 006107       864 006111       865 006124       866 006127
    872 006130       877 006131       878 006132       879 006143       880 006153       881 006157       882 006165
    883 006171       884 006172       885 006174       886 006176       887 006203


                                          -----------------------------------------------------------


Historical Background

This edition of the Multics software materials and documentation is provided and donated
to Massachusetts Institute of Technology by Group BULL including BULL HN Information Systems Inc. 
as a contribution to computer science knowledge.  
This donation is made also to give evidence of the common contributions of Massachusetts Institute of Technology,
Bell Laboratories, General Electric, Honeywell Information Systems Inc., Honeywell BULL Inc., Groupe BULL
and BULL HN Information Systems Inc. to the development of this operating system. 
Multics development was initiated by Massachusetts Institute of Technology Project MAC (1963-1970),
renamed the MIT Laboratory for Computer Science and Artificial Intelligence in the mid 1970s, under the leadership
of Professor Fernando Jose Corbato. Users consider that Multics provided the best software architecture 
for managing computer hardware properly and for executing programs. Many subsequent operating systems 
incorporated Multics principles.
Multics was distributed in 1975 to 2000 by Group Bull in Europe , and in the U.S. by Bull HN Information Systems Inc., 
as successor in interest by change in name only to Honeywell Bull Inc. and Honeywell Information Systems Inc. .

                                          -----------------------------------------------------------

Permission to use, copy, modify, and distribute these programs and their documentation for any purpose and without
fee is hereby granted,provided that the below copyright notice and historical background appear in all copies
and that both the copyright notice and historical background and this permission notice appear in supporting
documentation, and that the names of MIT, HIS, BULL or BULL HN not be used in advertising or publicity pertaining
to distribution of the programs without specific prior written permission.
    Copyright 1972 by Massachusetts Institute of Technology and Honeywell Information Systems Inc.
    Copyright 2006 by BULL HN Information Systems Inc.
    Copyright 2006 by Bull SAS
    All Rights Reserved
